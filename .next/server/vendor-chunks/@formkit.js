"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@formkit";
exports.ids = ["vendor-chunks/@formkit"];
exports.modules = {

/***/ "(ssr)/./node_modules/@formkit/auto-animate/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@formkit/auto-animate/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ autoAnimate),\n/* harmony export */   getTransitionSizes: () => (/* binding */ getTransitionSizes),\n/* harmony export */   vAutoAnimate: () => (/* binding */ vAutoAnimate)\n/* harmony export */ });\n/**\n * A set of all the parents currently being observe. This is the only non weak\n * registry.\n */ const parents = new Set();\n/**\n * Element coordinates that is constantly kept up to date.\n */ const coords = new WeakMap();\n/**\n * Siblings of elements that have been removed from the dom.\n */ const siblings = new WeakMap();\n/**\n * Animations that are currently running.\n */ const animations = new WeakMap();\n/**\n * A map of existing intersection observers used to track element movements.\n */ const intersections = new WeakMap();\n/**\n * Intervals for automatically checking the position of elements occasionally.\n */ const intervals = new WeakMap();\n/**\n * The configuration options for each group of elements.\n */ const options = new WeakMap();\n/**\n * Debounce counters by id, used to debounce calls to update positions.\n */ const debounces = new WeakMap();\n/**\n * All parents that are currently enabled are tracked here.\n */ const enabled = new WeakSet();\n/**\n * The document used to calculate transitions.\n */ let root;\n/**\n * The rootâ€™s XY scroll positions.\n */ let scrollX = 0;\nlet scrollY = 0;\n/**\n * Used to sign an element as the target.\n */ const TGT = \"__aa_tgt\";\n/**\n * Used to sign an element as being part of a removal.\n */ const DEL = \"__aa_del\";\n/**\n * Used to sign an element as being \"new\". When an element is removed from the\n * dom, but may cycle back in we can sign it with new to ensure the next time\n * it is recognized we consider it new.\n */ const NEW = \"__aa_new\";\n/**\n * Callback for handling all mutations.\n * @param mutations - A mutation list\n */ const handleMutations = (mutations)=>{\n    const elements = getElements(mutations);\n    // If elements is \"false\" that means this mutation that should be ignored.\n    if (elements) {\n        elements.forEach((el)=>animate(el));\n    }\n};\n/**\n *\n * @param entries - Elements that have been resized.\n */ const handleResizes = (entries)=>{\n    entries.forEach((entry)=>{\n        if (entry.target === root) updateAllPos();\n        if (coords.has(entry.target)) updatePos(entry.target);\n    });\n};\n/**\n * Observe this elements position.\n * @param el - The element to observe the position of.\n */ function observePosition(el) {\n    const oldObserver = intersections.get(el);\n    oldObserver === null || oldObserver === void 0 ? void 0 : oldObserver.disconnect();\n    let rect = coords.get(el);\n    let invocations = 0;\n    const buffer = 5;\n    if (!rect) {\n        rect = getCoords(el);\n        coords.set(el, rect);\n    }\n    const { offsetWidth, offsetHeight } = root;\n    const rootMargins = [\n        rect.top - buffer,\n        offsetWidth - (rect.left + buffer + rect.width),\n        offsetHeight - (rect.top + buffer + rect.height),\n        rect.left - buffer\n    ];\n    const rootMargin = rootMargins.map((px)=>`${-1 * Math.floor(px)}px`).join(\" \");\n    const observer = new IntersectionObserver(()=>{\n        ++invocations > 1 && updatePos(el);\n    }, {\n        root,\n        threshold: 1,\n        rootMargin\n    });\n    observer.observe(el);\n    intersections.set(el, observer);\n}\n/**\n * Update the exact position of a given element.\n * @param el - An element to update the position of.\n */ function updatePos(el) {\n    clearTimeout(debounces.get(el));\n    const optionsOrPlugin = getOptions(el);\n    const delay = isPlugin(optionsOrPlugin) ? 500 : optionsOrPlugin.duration;\n    debounces.set(el, setTimeout(async ()=>{\n        const currentAnimation = animations.get(el);\n        try {\n            await (currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.finished);\n            coords.set(el, getCoords(el));\n            observePosition(el);\n        } catch  {\n        // ignore errors as the `.finished` promise is rejected when animations were cancelled\n        }\n    }, delay));\n}\n/**\n * Updates all positions that are currently being tracked.\n */ function updateAllPos() {\n    clearTimeout(debounces.get(root));\n    debounces.set(root, setTimeout(()=>{\n        parents.forEach((parent)=>forEach(parent, (el)=>lowPriority(()=>updatePos(el))));\n    }, 100));\n}\n/**\n * Its possible for a quick scroll or other fast events to get past the\n * intersection observer, so occasionally we need want \"cold-poll\" for the\n * latests and greatest position. We try to do this in the most non-disruptive\n * fashion possible. First we only do this ever couple seconds, staggard by a\n * random offset.\n * @param el - Element\n */ function poll(el) {\n    setTimeout(()=>{\n        intervals.set(el, setInterval(()=>lowPriority(updatePos.bind(null, el)), 2000));\n    }, Math.round(2000 * Math.random()));\n}\n/**\n * Perform some operation that is non critical at some point.\n * @param callback\n */ function lowPriority(callback) {\n    if (typeof requestIdleCallback === \"function\") {\n        requestIdleCallback(()=>callback());\n    } else {\n        requestAnimationFrame(()=>callback());\n    }\n}\n/**\n * The mutation observer responsible for watching each root element.\n */ let mutations;\n/**\n * A resize observer, responsible for recalculating elements on resize.\n */ let resize;\n/**\n * Ensure the browser is supported.\n */ const supportedBrowser =  false && 0;\n/**\n * If this is in a browser, initialize our Web APIs\n */ if (supportedBrowser) {\n    root = document.documentElement;\n    mutations = new MutationObserver(handleMutations);\n    resize = new ResizeObserver(handleResizes);\n    window.addEventListener(\"scroll\", ()=>{\n        scrollY = window.scrollY;\n        scrollX = window.scrollX;\n    });\n    resize.observe(root);\n}\n/**\n * Retrieves all the elements that may have been affected by the last mutation\n * including ones that have been removed and are no longer in the DOM.\n * @param mutations - A mutation list.\n * @returns\n */ function getElements(mutations) {\n    const observedNodes = mutations.reduce((nodes, mutation)=>{\n        return [\n            ...nodes,\n            ...Array.from(mutation.addedNodes),\n            ...Array.from(mutation.removedNodes)\n        ];\n    }, []);\n    // Short circuit if _only_ comment nodes are observed\n    const onlyCommentNodesObserved = observedNodes.every((node)=>node.nodeName === \"#comment\");\n    if (onlyCommentNodesObserved) return false;\n    return mutations.reduce((elements, mutation)=>{\n        // Short circuit if we find a purposefully deleted node.\n        if (elements === false) return false;\n        if (mutation.target instanceof Element) {\n            target(mutation.target);\n            if (!elements.has(mutation.target)) {\n                elements.add(mutation.target);\n                for(let i = 0; i < mutation.target.children.length; i++){\n                    const child = mutation.target.children.item(i);\n                    if (!child) continue;\n                    if (DEL in child) {\n                        return false;\n                    }\n                    target(mutation.target, child);\n                    elements.add(child);\n                }\n            }\n            if (mutation.removedNodes.length) {\n                for(let i = 0; i < mutation.removedNodes.length; i++){\n                    const child = mutation.removedNodes[i];\n                    if (DEL in child) {\n                        return false;\n                    }\n                    if (child instanceof Element) {\n                        elements.add(child);\n                        target(mutation.target, child);\n                        siblings.set(child, [\n                            mutation.previousSibling,\n                            mutation.nextSibling\n                        ]);\n                    }\n                }\n            }\n        }\n        return elements;\n    }, new Set());\n}\n/**\n * Assign the target to an element.\n * @param el - The root element\n * @param child\n */ function target(el, child) {\n    if (!child && !(TGT in el)) Object.defineProperty(el, TGT, {\n        value: el\n    });\n    else if (child && !(TGT in child)) Object.defineProperty(child, TGT, {\n        value: el\n    });\n}\n/**\n * Determines what kind of change took place on the given element and then\n * performs the proper animation based on that.\n * @param el - The specific element to animate.\n */ function animate(el) {\n    var _a;\n    const isMounted = el.isConnected;\n    const preExisting = coords.has(el);\n    if (isMounted && siblings.has(el)) siblings.delete(el);\n    if (animations.has(el)) {\n        (_a = animations.get(el)) === null || _a === void 0 ? void 0 : _a.cancel();\n    }\n    if (NEW in el) {\n        add(el);\n    } else if (preExisting && isMounted) {\n        remain(el);\n    } else if (preExisting && !isMounted) {\n        remove(el);\n    } else {\n        add(el);\n    }\n}\n/**\n * Removes all non-digits from a string and casts to a number.\n * @param str - A string containing a pixel value.\n * @returns\n */ function raw(str) {\n    return Number(str.replace(/[^0-9.\\-]/g, \"\"));\n}\n/**\n * Get the scroll offset of elements\n * @param el - Element\n * @returns\n */ function getScrollOffset(el) {\n    let p = el.parentElement;\n    while(p){\n        if (p.scrollLeft || p.scrollTop) {\n            return {\n                x: p.scrollLeft,\n                y: p.scrollTop\n            };\n        }\n        p = p.parentElement;\n    }\n    return {\n        x: 0,\n        y: 0\n    };\n}\n/**\n * Get the coordinates of elements adjusted for scroll position.\n * @param el - Element\n * @returns\n */ function getCoords(el) {\n    const rect = el.getBoundingClientRect();\n    const { x, y } = getScrollOffset(el);\n    return {\n        top: rect.top + y,\n        left: rect.left + x,\n        width: rect.width,\n        height: rect.height\n    };\n}\n/**\n * Returns the width/height that the element should be transitioned between.\n * This takes into account box-sizing.\n * @param el - Element being animated\n * @param oldCoords - Old set of Coordinates coordinates\n * @param newCoords - New set of Coordinates coordinates\n * @returns\n */ function getTransitionSizes(el, oldCoords, newCoords) {\n    let widthFrom = oldCoords.width;\n    let heightFrom = oldCoords.height;\n    let widthTo = newCoords.width;\n    let heightTo = newCoords.height;\n    const styles = getComputedStyle(el);\n    const sizing = styles.getPropertyValue(\"box-sizing\");\n    if (sizing === \"content-box\") {\n        const paddingY = raw(styles.paddingTop) + raw(styles.paddingBottom) + raw(styles.borderTopWidth) + raw(styles.borderBottomWidth);\n        const paddingX = raw(styles.paddingLeft) + raw(styles.paddingRight) + raw(styles.borderRightWidth) + raw(styles.borderLeftWidth);\n        widthFrom -= paddingX;\n        widthTo -= paddingX;\n        heightFrom -= paddingY;\n        heightTo -= paddingY;\n    }\n    return [\n        widthFrom,\n        widthTo,\n        heightFrom,\n        heightTo\n    ].map(Math.round);\n}\n/**\n * Retrieves animation options for the current element.\n * @param el - Element to retrieve options for.\n * @returns\n */ function getOptions(el) {\n    return TGT in el && options.has(el[TGT]) ? options.get(el[TGT]) : {\n        duration: 250,\n        easing: \"ease-in-out\"\n    };\n}\n/**\n * Returns the target of a given animation (generally the parent).\n * @param el - An element to check for a target\n * @returns\n */ function getTarget(el) {\n    if (TGT in el) return el[TGT];\n    return undefined;\n}\n/**\n * Checks if animations are enabled or disabled for a given element.\n * @param el - Any element\n * @returns\n */ function isEnabled(el) {\n    const target = getTarget(el);\n    return target ? enabled.has(target) : false;\n}\n/**\n * Iterate over the children of a given parent.\n * @param parent - A parent element\n * @param callback - A callback\n */ function forEach(parent, ...callbacks) {\n    callbacks.forEach((callback)=>callback(parent, options.has(parent)));\n    for(let i = 0; i < parent.children.length; i++){\n        const child = parent.children.item(i);\n        if (child) {\n            callbacks.forEach((callback)=>callback(child, options.has(child)));\n        }\n    }\n}\n/**\n * Always return tuple to provide consistent interface\n */ function getPluginTuple(pluginReturn) {\n    if (Array.isArray(pluginReturn)) return pluginReturn;\n    return [\n        pluginReturn\n    ];\n}\n/**\n * Determine if config is plugin\n */ function isPlugin(config) {\n    return typeof config === \"function\";\n}\n/**\n * The element in question is remaining in the DOM.\n * @param el - Element to flip\n * @returns\n */ function remain(el) {\n    const oldCoords = coords.get(el);\n    const newCoords = getCoords(el);\n    if (!isEnabled(el)) return coords.set(el, newCoords);\n    let animation;\n    if (!oldCoords) return;\n    const pluginOrOptions = getOptions(el);\n    if (typeof pluginOrOptions !== \"function\") {\n        const deltaX = oldCoords.left - newCoords.left;\n        const deltaY = oldCoords.top - newCoords.top;\n        const [widthFrom, widthTo, heightFrom, heightTo] = getTransitionSizes(el, oldCoords, newCoords);\n        const start = {\n            transform: `translate(${deltaX}px, ${deltaY}px)`\n        };\n        const end = {\n            transform: `translate(0, 0)`\n        };\n        if (widthFrom !== widthTo) {\n            start.width = `${widthFrom}px`;\n            end.width = `${widthTo}px`;\n        }\n        if (heightFrom !== heightTo) {\n            start.height = `${heightFrom}px`;\n            end.height = `${heightTo}px`;\n        }\n        animation = el.animate([\n            start,\n            end\n        ], {\n            duration: pluginOrOptions.duration,\n            easing: pluginOrOptions.easing\n        });\n    } else {\n        const [keyframes] = getPluginTuple(pluginOrOptions(el, \"remain\", oldCoords, newCoords));\n        animation = new Animation(keyframes);\n        animation.play();\n    }\n    animations.set(el, animation);\n    coords.set(el, newCoords);\n    animation.addEventListener(\"finish\", updatePos.bind(null, el));\n}\n/**\n * Adds the element with a transition.\n * @param el - Animates the element being added.\n */ function add(el) {\n    if (NEW in el) delete el[NEW];\n    const newCoords = getCoords(el);\n    coords.set(el, newCoords);\n    const pluginOrOptions = getOptions(el);\n    if (!isEnabled(el)) return;\n    let animation;\n    if (typeof pluginOrOptions !== \"function\") {\n        animation = el.animate([\n            {\n                transform: \"scale(.98)\",\n                opacity: 0\n            },\n            {\n                transform: \"scale(0.98)\",\n                opacity: 0,\n                offset: 0.5\n            },\n            {\n                transform: \"scale(1)\",\n                opacity: 1\n            }\n        ], {\n            duration: pluginOrOptions.duration * 1.5,\n            easing: \"ease-in\"\n        });\n    } else {\n        const [keyframes] = getPluginTuple(pluginOrOptions(el, \"add\", newCoords));\n        animation = new Animation(keyframes);\n        animation.play();\n    }\n    animations.set(el, animation);\n    animation.addEventListener(\"finish\", updatePos.bind(null, el));\n}\n/**\n * Clean up after removing an element from the dom.\n * @param el - Element being removed\n * @param styles - Optional styles that should be removed from the element.\n */ function cleanUp(el, styles) {\n    var _a;\n    el.remove();\n    coords.delete(el);\n    siblings.delete(el);\n    animations.delete(el);\n    (_a = intersections.get(el)) === null || _a === void 0 ? void 0 : _a.disconnect();\n    setTimeout(()=>{\n        if (DEL in el) delete el[DEL];\n        Object.defineProperty(el, NEW, {\n            value: true,\n            configurable: true\n        });\n        if (styles && el instanceof HTMLElement) {\n            for(const style in styles){\n                el.style[style] = \"\";\n            }\n        }\n    }, 0);\n}\n/**\n * Animates the removal of an element.\n * @param el - Element to remove\n */ function remove(el) {\n    var _a;\n    if (!siblings.has(el) || !coords.has(el)) return;\n    const [prev, next] = siblings.get(el);\n    Object.defineProperty(el, DEL, {\n        value: true,\n        configurable: true\n    });\n    const finalX = window.scrollX;\n    const finalY = window.scrollY;\n    if (next && next.parentNode && next.parentNode instanceof Element) {\n        next.parentNode.insertBefore(el, next);\n    } else if (prev && prev.parentNode) {\n        prev.parentNode.appendChild(el);\n    } else {\n        (_a = getTarget(el)) === null || _a === void 0 ? void 0 : _a.appendChild(el);\n    }\n    if (!isEnabled(el)) return cleanUp(el);\n    const [top, left, width, height] = deletePosition(el);\n    const optionsOrPlugin = getOptions(el);\n    const oldCoords = coords.get(el);\n    if (finalX !== scrollX || finalY !== scrollY) {\n        adjustScroll(el, finalX, finalY, optionsOrPlugin);\n    }\n    let animation;\n    let styleReset = {\n        position: \"absolute\",\n        top: `${top}px`,\n        left: `${left}px`,\n        width: `${width}px`,\n        height: `${height}px`,\n        margin: \"0\",\n        pointerEvents: \"none\",\n        transformOrigin: \"center\",\n        zIndex: \"100\"\n    };\n    if (!isPlugin(optionsOrPlugin)) {\n        Object.assign(el.style, styleReset);\n        animation = el.animate([\n            {\n                transform: \"scale(1)\",\n                opacity: 1\n            },\n            {\n                transform: \"scale(.98)\",\n                opacity: 0\n            }\n        ], {\n            duration: optionsOrPlugin.duration,\n            easing: \"ease-out\"\n        });\n    } else {\n        const [keyframes, options] = getPluginTuple(optionsOrPlugin(el, \"remove\", oldCoords));\n        if ((options === null || options === void 0 ? void 0 : options.styleReset) !== false) {\n            styleReset = (options === null || options === void 0 ? void 0 : options.styleReset) || styleReset;\n            Object.assign(el.style, styleReset);\n        }\n        animation = new Animation(keyframes);\n        animation.play();\n    }\n    animations.set(el, animation);\n    animation.addEventListener(\"finish\", cleanUp.bind(null, el, styleReset));\n}\n/**\n * If the element being removed is at the very bottom of the page, and the\n * the page was scrolled into a space being \"made available\" by the element\n * that was removed, the page scroll will have jumped up some amount. We need\n * to offset the jump by the amount that the page was \"automatically\" scrolled\n * up. We can do this by comparing the scroll position before and after the\n * element was removed, and then offsetting by that amount.\n *\n * @param el - The element being deleted\n * @param finalX - The final X scroll position\n * @param finalY - The final Y scroll position\n * @param optionsOrPlugin - The options or plugin\n * @returns\n */ function adjustScroll(el, finalX, finalY, optionsOrPlugin) {\n    const scrollDeltaX = scrollX - finalX;\n    const scrollDeltaY = scrollY - finalY;\n    const scrollBefore = document.documentElement.style.scrollBehavior;\n    const scrollBehavior = getComputedStyle(root).scrollBehavior;\n    if (scrollBehavior === \"smooth\") {\n        document.documentElement.style.scrollBehavior = \"auto\";\n    }\n    window.scrollTo(window.scrollX + scrollDeltaX, window.scrollY + scrollDeltaY);\n    if (!el.parentElement) return;\n    const parent = el.parentElement;\n    let lastHeight = parent.clientHeight;\n    let lastWidth = parent.clientWidth;\n    const startScroll = performance.now();\n    // Here we use a manual scroll animation to keep the element using the same\n    // easing and timing as the parentâ€™s scroll animation.\n    function smoothScroll() {\n        requestAnimationFrame(()=>{\n            if (!isPlugin(optionsOrPlugin)) {\n                const deltaY = lastHeight - parent.clientHeight;\n                const deltaX = lastWidth - parent.clientWidth;\n                if (startScroll + optionsOrPlugin.duration > performance.now()) {\n                    window.scrollTo({\n                        left: window.scrollX - deltaX,\n                        top: window.scrollY - deltaY\n                    });\n                    lastHeight = parent.clientHeight;\n                    lastWidth = parent.clientWidth;\n                    smoothScroll();\n                } else {\n                    document.documentElement.style.scrollBehavior = scrollBefore;\n                }\n            }\n        });\n    }\n    smoothScroll();\n}\n/**\n * Determines the position of the element being removed.\n * @param el - The element being deleted\n * @returns\n */ function deletePosition(el) {\n    const oldCoords = coords.get(el);\n    const [width, , height] = getTransitionSizes(el, oldCoords, getCoords(el));\n    let offsetParent = el.parentElement;\n    while(offsetParent && (getComputedStyle(offsetParent).position === \"static\" || offsetParent instanceof HTMLBodyElement)){\n        offsetParent = offsetParent.parentElement;\n    }\n    if (!offsetParent) offsetParent = document.body;\n    const parentStyles = getComputedStyle(offsetParent);\n    const parentCoords = coords.get(offsetParent) || getCoords(offsetParent);\n    const top = Math.round(oldCoords.top - parentCoords.top) - raw(parentStyles.borderTopWidth);\n    const left = Math.round(oldCoords.left - parentCoords.left) - raw(parentStyles.borderLeftWidth);\n    return [\n        top,\n        left,\n        width,\n        height\n    ];\n}\n/**\n * A function that automatically adds animation effects to itself and its\n * immediate children. Specifically it adds effects for adding, moving, and\n * removing DOM elements.\n * @param el - A parent element to add animations to.\n * @param options - An optional object of options.\n */ function autoAnimate(el, config = {}) {\n    if (mutations && resize) {\n        const mediaQuery = window.matchMedia(\"(prefers-reduced-motion: reduce)\");\n        const isDisabledDueToReduceMotion = mediaQuery.matches && !isPlugin(config) && !config.disrespectUserMotionPreference;\n        if (!isDisabledDueToReduceMotion) {\n            enabled.add(el);\n            if (getComputedStyle(el).position === \"static\") {\n                Object.assign(el.style, {\n                    position: \"relative\"\n                });\n            }\n            forEach(el, updatePos, poll, (element)=>resize === null || resize === void 0 ? void 0 : resize.observe(element));\n            if (isPlugin(config)) {\n                options.set(el, config);\n            } else {\n                options.set(el, {\n                    duration: 250,\n                    easing: \"ease-in-out\",\n                    ...config\n                });\n            }\n            mutations.observe(el, {\n                childList: true\n            });\n            parents.add(el);\n        }\n    }\n    return Object.freeze({\n        parent: el,\n        enable: ()=>{\n            enabled.add(el);\n        },\n        disable: ()=>{\n            enabled.delete(el);\n        },\n        isEnabled: ()=>enabled.has(el)\n    });\n}\n/**\n * The vue directive.\n */ const vAutoAnimate = {\n    mounted: (el, binding)=>{\n        autoAnimate(el, binding.value || {});\n    },\n    // ignore ssr see #96:\n    getSSRProps: ()=>({})\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvYXV0by1hbmltYXRlL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7O0NBR0MsR0FDRCxNQUFNQSxVQUFVLElBQUlDO0FBQ3BCOztDQUVDLEdBQ0QsTUFBTUMsU0FBUyxJQUFJQztBQUNuQjs7Q0FFQyxHQUNELE1BQU1DLFdBQVcsSUFBSUQ7QUFDckI7O0NBRUMsR0FDRCxNQUFNRSxhQUFhLElBQUlGO0FBQ3ZCOztDQUVDLEdBQ0QsTUFBTUcsZ0JBQWdCLElBQUlIO0FBQzFCOztDQUVDLEdBQ0QsTUFBTUksWUFBWSxJQUFJSjtBQUN0Qjs7Q0FFQyxHQUNELE1BQU1LLFVBQVUsSUFBSUw7QUFDcEI7O0NBRUMsR0FDRCxNQUFNTSxZQUFZLElBQUlOO0FBQ3RCOztDQUVDLEdBQ0QsTUFBTU8sVUFBVSxJQUFJQztBQUNwQjs7Q0FFQyxHQUNELElBQUlDO0FBQ0o7O0NBRUMsR0FDRCxJQUFJQyxVQUFVO0FBQ2QsSUFBSUMsVUFBVTtBQUNkOztDQUVDLEdBQ0QsTUFBTUMsTUFBTTtBQUNaOztDQUVDLEdBQ0QsTUFBTUMsTUFBTTtBQUNaOzs7O0NBSUMsR0FDRCxNQUFNQyxNQUFNO0FBQ1o7OztDQUdDLEdBQ0QsTUFBTUMsa0JBQWtCLENBQUNDO0lBQ3JCLE1BQU1DLFdBQVdDLFlBQVlGO0lBQzdCLDBFQUEwRTtJQUMxRSxJQUFJQyxVQUFVO1FBQ1ZBLFNBQVNFLE9BQU8sQ0FBQyxDQUFDQyxLQUFPQyxRQUFRRDtJQUNyQztBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTUUsZ0JBQWdCLENBQUNDO0lBQ25CQSxRQUFRSixPQUFPLENBQUMsQ0FBQ0s7UUFDYixJQUFJQSxNQUFNQyxNQUFNLEtBQUtoQixNQUNqQmlCO1FBQ0osSUFBSTNCLE9BQU80QixHQUFHLENBQUNILE1BQU1DLE1BQU0sR0FDdkJHLFVBQVVKLE1BQU1DLE1BQU07SUFDOUI7QUFDSjtBQUNBOzs7Q0FHQyxHQUNELFNBQVNJLGdCQUFnQlQs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d0YsR0FBRyxDQUFDM0U7UUFDaEI7UUFDQW9NLFNBQVM7WUFDTGpOLFFBQVF1RyxNQUFNLENBQUMxRjtRQUNuQjtRQUNBa0ksV0FBVyxJQUFNL0ksUUFBUW9CLEdBQUcsQ0FBQ1A7SUFDakM7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTXFNLGVBQWU7SUFDakJDLFNBQVMsQ0FBQ3RNLElBQUl1TTtRQUNWYixZQUFZMUwsSUFBSXVNLFFBQVFsSCxLQUFLLElBQUksQ0FBQztJQUN0QztJQUNBLHNCQUFzQjtJQUN0Qm1ILGFBQWEsSUFBTyxFQUFDO0FBQ3pCO0FBRW9FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2FpZ29ueGFuaC8uL25vZGVfbW9kdWxlcy9AZm9ybWtpdC9hdXRvLWFuaW1hdGUvaW5kZXgubWpzP2E4ZDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIHNldCBvZiBhbGwgdGhlIHBhcmVudHMgY3VycmVudGx5IGJlaW5nIG9ic2VydmUuIFRoaXMgaXMgdGhlIG9ubHkgbm9uIHdlYWtcbiAqIHJlZ2lzdHJ5LlxuICovXG5jb25zdCBwYXJlbnRzID0gbmV3IFNldCgpO1xuLyoqXG4gKiBFbGVtZW50IGNvb3JkaW5hdGVzIHRoYXQgaXMgY29uc3RhbnRseSBrZXB0IHVwIHRvIGRhdGUuXG4gKi9cbmNvbnN0IGNvb3JkcyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIFNpYmxpbmdzIG9mIGVsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgZG9tLlxuICovXG5jb25zdCBzaWJsaW5ncyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEFuaW1hdGlvbnMgdGhhdCBhcmUgY3VycmVudGx5IHJ1bm5pbmcuXG4gKi9cbmNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBBIG1hcCBvZiBleGlzdGluZyBpbnRlcnNlY3Rpb24gb2JzZXJ2ZXJzIHVzZWQgdG8gdHJhY2sgZWxlbWVudCBtb3ZlbWVudHMuXG4gKi9cbmNvbnN0IGludGVyc2VjdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBJbnRlcnZhbHMgZm9yIGF1dG9tYXRpY2FsbHkgY2hlY2tpbmcgdGhlIHBvc2l0aW9uIG9mIGVsZW1lbnRzIG9jY2FzaW9uYWxseS5cbiAqL1xuY29uc3QgaW50ZXJ2YWxzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgZWFjaCBncm91cCBvZiBlbGVtZW50cy5cbiAqL1xuY29uc3Qgb3B0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIERlYm91bmNlIGNvdW50ZXJzIGJ5IGlkLCB1c2VkIHRvIGRlYm91bmNlIGNhbGxzIHRvIHVwZGF0ZSBwb3NpdGlvbnMuXG4gKi9cbmNvbnN0IGRlYm91bmNlcyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEFsbCBwYXJlbnRzIHRoYXQgYXJlIGN1cnJlbnRseSBlbmFibGVkIGFyZSB0cmFja2VkIGhlcmUuXG4gKi9cbmNvbnN0IGVuYWJsZWQgPSBuZXcgV2Vha1NldCgpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgdXNlZCB0byBjYWxjdWxhdGUgdHJhbnNpdGlvbnMuXG4gKi9cbmxldCByb290O1xuLyoqXG4gKiBUaGUgcm9vdOKAmXMgWFkgc2Nyb2xsIHBvc2l0aW9ucy5cbiAqL1xubGV0IHNjcm9sbFggPSAwO1xubGV0IHNjcm9sbFkgPSAwO1xuLyoqXG4gKiBVc2VkIHRvIHNpZ24gYW4gZWxlbWVudCBhcyB0aGUgdGFyZ2V0LlxuICovXG5jb25zdCBUR1QgPSBcIl9fYWFfdGd0XCI7XG4vKipcbiAqIFVzZWQgdG8gc2lnbiBhbiBlbGVtZW50IGFzIGJlaW5nIHBhcnQgb2YgYSByZW1vdmFsLlxuICovXG5jb25zdCBERUwgPSBcIl9fYWFfZGVsXCI7XG4vKipcbiAqIFVzZWQgdG8gc2lnbiBhbiBlbGVtZW50IGFzIGJlaW5nIFwibmV3XCIuIFdoZW4gYW4gZWxlbWVudCBpcyByZW1vdmVkIGZyb20gdGhlXG4gKiBkb20sIGJ1dCBtYXkgY3ljbGUgYmFjayBpbiB3ZSBjYW4gc2lnbiBpdCB3aXRoIG5ldyB0byBlbnN1cmUgdGhlIG5leHQgdGltZVxuICogaXQgaXMgcmVjb2duaXplZCB3ZSBjb25zaWRlciBpdCBuZXcuXG4gKi9cbmNvbnN0IE5FVyA9IFwiX19hYV9uZXdcIjtcbi8qKlxuICogQ2FsbGJhY2sgZm9yIGhhbmRsaW5nIGFsbCBtdXRhdGlvbnMuXG4gKiBAcGFyYW0gbXV0YXRpb25zIC0gQSBtdXRhdGlvbiBsaXN0XG4gKi9cbmNvbnN0IGhhbmRsZU11dGF0aW9ucyA9IChtdXRhdGlvbnMpID0+IHtcbiAgICBjb25zdCBlbGVtZW50cyA9IGdldEVsZW1lbnRzKG11dGF0aW9ucyk7XG4gICAgLy8gSWYgZWxlbWVudHMgaXMgXCJmYWxzZVwiIHRoYXQgbWVhbnMgdGhpcyBtdXRhdGlvbiB0aGF0IHNob3VsZCBiZSBpZ25vcmVkLlxuICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKChlbCkgPT4gYW5pbWF0ZShlbCkpO1xuICAgIH1cbn07XG4vKipcbiAqXG4gKiBAcGFyYW0gZW50cmllcyAtIEVsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIHJlc2l6ZWQuXG4gKi9cbmNvbnN0IGhhbmRsZVJlc2l6ZXMgPSAoZW50cmllcykgPT4ge1xuICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgaWYgKGVudHJ5LnRhcmdldCA9PT0gcm9vdClcbiAgICAgICAgICAgIHVwZGF0ZUFsbFBvcygpO1xuICAgICAgICBpZiAoY29vcmRzLmhhcyhlbnRyeS50YXJnZXQpKVxuICAgICAgICAgICAgdXBkYXRlUG9zKGVudHJ5LnRhcmdldCk7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBPYnNlcnZlIHRoaXMgZWxlbWVudHMgcG9zaXRpb24uXG4gKiBAcGFyYW0gZWwgLSBUaGUgZWxlbWVudCB0byBvYnNlcnZlIHRoZSBwb3NpdGlvbiBvZi5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZVBvc2l0aW9uKGVsKSB7XG4gICAgY29uc3Qgb2xkT2JzZXJ2ZXIgPSBpbnRlcnNlY3Rpb25zLmdldChlbCk7XG4gICAgb2xkT2JzZXJ2ZXIgPT09IG51bGwgfHwgb2xkT2JzZXJ2ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9sZE9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICBsZXQgcmVjdCA9IGNvb3Jkcy5nZXQoZWwpO1xuICAgIGxldCBpbnZvY2F0aW9ucyA9IDA7XG4gICAgY29uc3QgYnVmZmVyID0gNTtcbiAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgcmVjdCA9IGdldENvb3JkcyhlbCk7XG4gICAgICAgIGNvb3Jkcy5zZXQoZWwsIHJlY3QpO1xuICAgIH1cbiAgICBjb25zdCB7IG9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQgfSA9IHJvb3Q7XG4gICAgY29uc3Qgcm9vdE1hcmdpbnMgPSBbXG4gICAgICAgIHJlY3QudG9wIC0gYnVmZmVyLFxuICAgICAgICBvZmZzZXRXaWR0aCAtIChyZWN0LmxlZnQgKyBidWZmZXIgKyByZWN0LndpZHRoKSxcbiAgICAgICAgb2Zmc2V0SGVpZ2h0IC0gKHJlY3QudG9wICsgYnVmZmVyICsgcmVjdC5oZWlnaHQpLFxuICAgICAgICByZWN0LmxlZnQgLSBidWZmZXIsXG4gICAgXTtcbiAgICBjb25zdCByb290TWFyZ2luID0gcm9vdE1hcmdpbnNcbiAgICAgICAgLm1hcCgocHgpID0+IGAkey0xICogTWF0aC5mbG9vcihweCl9cHhgKVxuICAgICAgICAuam9pbihcIiBcIik7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICArK2ludm9jYXRpb25zID4gMSAmJiB1cGRhdGVQb3MoZWwpO1xuICAgIH0sIHtcbiAgICAgICAgcm9vdCxcbiAgICAgICAgdGhyZXNob2xkOiAxLFxuICAgICAgICByb290TWFyZ2luLFxuICAgIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWwpO1xuICAgIGludGVyc2VjdGlvbnMuc2V0KGVsLCBvYnNlcnZlcik7XG59XG4vKipcbiAqIFVwZGF0ZSB0aGUgZXhhY3QgcG9zaXRpb24gb2YgYSBnaXZlbiBlbGVtZW50LlxuICogQHBhcmFtIGVsIC0gQW4gZWxlbWVudCB0byB1cGRhdGUgdGhlIHBvc2l0aW9uIG9mLlxuICovXG5mdW5jdGlvbiB1cGRhdGVQb3MoZWwpIHtcbiAgICBjbGVhclRpbWVvdXQoZGVib3VuY2VzLmdldChlbCkpO1xuICAgIGNvbnN0IG9wdGlvbnNPclBsdWdpbiA9IGdldE9wdGlvbnMoZWwpO1xuICAgIGNvbnN0IGRlbGF5ID0gaXNQbHVnaW4ob3B0aW9uc09yUGx1Z2luKSA/IDUwMCA6IG9wdGlvbnNPclBsdWdpbi5kdXJhdGlvbjtcbiAgICBkZWJvdW5jZXMuc2V0KGVsLCBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudEFuaW1hdGlvbiA9IGFuaW1hdGlvbnMuZ2V0KGVsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IChjdXJyZW50QW5pbWF0aW9uID09PSBudWxsIHx8IGN1cnJlbnRBbmltYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRBbmltYXRpb24uZmluaXNoZWQpO1xuICAgICAgICAgICAgY29vcmRzLnNldChlbCwgZ2V0Q29vcmRzKGVsKSk7XG4gICAgICAgICAgICBvYnNlcnZlUG9zaXRpb24oZWwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBlcnJvcnMgYXMgdGhlIGAuZmluaXNoZWRgIHByb21pc2UgaXMgcmVqZWN0ZWQgd2hlbiBhbmltYXRpb25zIHdlcmUgY2FuY2VsbGVkXG4gICAgICAgIH1cbiAgICB9LCBkZWxheSkpO1xufVxuLyoqXG4gKiBVcGRhdGVzIGFsbCBwb3NpdGlvbnMgdGhhdCBhcmUgY3VycmVudGx5IGJlaW5nIHRyYWNrZWQuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUFsbFBvcygpIHtcbiAgICBjbGVhclRpbWVvdXQoZGVib3VuY2VzLmdldChyb290KSk7XG4gICAgZGVib3VuY2VzLnNldChyb290LCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcGFyZW50cy5mb3JFYWNoKChwYXJlbnQpID0+IGZvckVhY2gocGFyZW50LCAoZWwpID0+IGxvd1ByaW9yaXR5KCgpID0+IHVwZGF0ZVBvcyhlbCkpKSk7XG4gICAgfSwgMTAwKSk7XG59XG4vKipcbiAqIEl0cyBwb3NzaWJsZSBmb3IgYSBxdWljayBzY3JvbGwgb3Igb3RoZXIgZmFzdCBldmVudHMgdG8gZ2V0IHBhc3QgdGhlXG4gKiBpbnRlcnNlY3Rpb24gb2JzZXJ2ZXIsIHNvIG9jY2FzaW9uYWxseSB3ZSBuZWVkIHdhbnQgXCJjb2xkLXBvbGxcIiBmb3IgdGhlXG4gKiBsYXRlc3RzIGFuZCBncmVhdGVzdCBwb3NpdGlvbi4gV2UgdHJ5IHRvIGRvIHRoaXMgaW4gdGhlIG1vc3Qgbm9uLWRpc3J1cHRpdmVcbiAqIGZhc2hpb24gcG9zc2libGUuIEZpcnN0IHdlIG9ubHkgZG8gdGhpcyBldmVyIGNvdXBsZSBzZWNvbmRzLCBzdGFnZ2FyZCBieSBhXG4gKiByYW5kb20gb2Zmc2V0LlxuICogQHBhcmFtIGVsIC0gRWxlbWVudFxuICovXG5mdW5jdGlvbiBwb2xsKGVsKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGludGVydmFscy5zZXQoZWwsIHNldEludGVydmFsKCgpID0+IGxvd1ByaW9yaXR5KHVwZGF0ZVBvcy5iaW5kKG51bGwsIGVsKSksIDIwMDApKTtcbiAgICB9LCBNYXRoLnJvdW5kKDIwMDAgKiBNYXRoLnJhbmRvbSgpKSk7XG59XG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gdGhhdCBpcyBub24gY3JpdGljYWwgYXQgc29tZSBwb2ludC5cbiAqIEBwYXJhbSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBsb3dQcmlvcml0eShjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdElkbGVDYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4gY2FsbGJhY2soKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gY2FsbGJhY2soKSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgbXV0YXRpb24gb2JzZXJ2ZXIgcmVzcG9uc2libGUgZm9yIHdhdGNoaW5nIGVhY2ggcm9vdCBlbGVtZW50LlxuICovXG5sZXQgbXV0YXRpb25zO1xuLyoqXG4gKiBBIHJlc2l6ZSBvYnNlcnZlciwgcmVzcG9uc2libGUgZm9yIHJlY2FsY3VsYXRpbmcgZWxlbWVudHMgb24gcmVzaXplLlxuICovXG5sZXQgcmVzaXplO1xuLyoqXG4gKiBFbnN1cmUgdGhlIGJyb3dzZXIgaXMgc3VwcG9ydGVkLlxuICovXG5jb25zdCBzdXBwb3J0ZWRCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIlJlc2l6ZU9ic2VydmVyXCIgaW4gd2luZG93O1xuLyoqXG4gKiBJZiB0aGlzIGlzIGluIGEgYnJvd3NlciwgaW5pdGlhbGl6ZSBvdXIgV2ViIEFQSXNcbiAqL1xuaWYgKHN1cHBvcnRlZEJyb3dzZXIpIHtcbiAgICByb290ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIG11dGF0aW9ucyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGhhbmRsZU11dGF0aW9ucyk7XG4gICAgcmVzaXplID0gbmV3IFJlc2l6ZU9ic2VydmVyKGhhbmRsZVJlc2l6ZXMpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsICgpID0+IHtcbiAgICAgICAgc2Nyb2xsWSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgICBzY3JvbGxYID0gd2luZG93LnNjcm9sbFg7XG4gICAgfSk7XG4gICAgcmVzaXplLm9ic2VydmUocm9vdCk7XG59XG4vKipcbiAqIFJldHJpZXZlcyBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgbWF5IGhhdmUgYmVlbiBhZmZlY3RlZCBieSB0aGUgbGFzdCBtdXRhdGlvblxuICogaW5jbHVkaW5nIG9uZXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCBhbmQgYXJlIG5vIGxvbmdlciBpbiB0aGUgRE9NLlxuICogQHBhcmFtIG11dGF0aW9ucyAtIEEgbXV0YXRpb24gbGlzdC5cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGdldEVsZW1lbnRzKG11dGF0aW9ucykge1xuICAgIGNvbnN0IG9ic2VydmVkTm9kZXMgPSBtdXRhdGlvbnMucmVkdWNlKChub2RlcywgbXV0YXRpb24pID0+IHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLm5vZGVzLFxuICAgICAgICAgICAgLi4uQXJyYXkuZnJvbShtdXRhdGlvbi5hZGRlZE5vZGVzKSxcbiAgICAgICAgICAgIC4uLkFycmF5LmZyb20obXV0YXRpb24ucmVtb3ZlZE5vZGVzKSxcbiAgICAgICAgXTtcbiAgICB9LCBbXSk7XG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiBfb25seV8gY29tbWVudCBub2RlcyBhcmUgb2JzZXJ2ZWRcbiAgICBjb25zdCBvbmx5Q29tbWVudE5vZGVzT2JzZXJ2ZWQgPSBvYnNlcnZlZE5vZGVzLmV2ZXJ5KChub2RlKSA9PiBub2RlLm5vZGVOYW1lID09PSBcIiNjb21tZW50XCIpO1xuICAgIGlmIChvbmx5Q29tbWVudE5vZGVzT2JzZXJ2ZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gbXV0YXRpb25zLnJlZHVjZSgoZWxlbWVudHMsIG11dGF0aW9uKSA9PiB7XG4gICAgICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgd2UgZmluZCBhIHB1cnBvc2VmdWxseSBkZWxldGVkIG5vZGUuXG4gICAgICAgIGlmIChlbGVtZW50cyA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChtdXRhdGlvbi50YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICB0YXJnZXQobXV0YXRpb24udGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICghZWxlbWVudHMuaGFzKG11dGF0aW9uLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5hZGQobXV0YXRpb24udGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9uLnRhcmdldC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG11dGF0aW9uLnRhcmdldC5jaGlsZHJlbi5pdGVtKGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChERUwgaW4gY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQobXV0YXRpb24udGFyZ2V0LCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLmFkZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG11dGF0aW9uLnJlbW92ZWROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9uLnJlbW92ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG11dGF0aW9uLnJlbW92ZWROb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKERFTCBpbiBjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLmFkZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQobXV0YXRpb24udGFyZ2V0LCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncy5zZXQoY2hpbGQsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbi5wcmV2aW91c1NpYmxpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24ubmV4dFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSwgbmV3IFNldCgpKTtcbn1cbi8qKlxuICogQXNzaWduIHRoZSB0YXJnZXQgdG8gYW4gZWxlbWVudC5cbiAqIEBwYXJhbSBlbCAtIFRoZSByb290IGVsZW1lbnRcbiAqIEBwYXJhbSBjaGlsZFxuICovXG5mdW5jdGlvbiB0YXJnZXQoZWwsIGNoaWxkKSB7XG4gICAgaWYgKCFjaGlsZCAmJiAhKFRHVCBpbiBlbCkpXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgVEdULCB7IHZhbHVlOiBlbCB9KTtcbiAgICBlbHNlIGlmIChjaGlsZCAmJiAhKFRHVCBpbiBjaGlsZCkpXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGlsZCwgVEdULCB7IHZhbHVlOiBlbCB9KTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGF0IGtpbmQgb2YgY2hhbmdlIHRvb2sgcGxhY2Ugb24gdGhlIGdpdmVuIGVsZW1lbnQgYW5kIHRoZW5cbiAqIHBlcmZvcm1zIHRoZSBwcm9wZXIgYW5pbWF0aW9uIGJhc2VkIG9uIHRoYXQuXG4gKiBAcGFyYW0gZWwgLSBUaGUgc3BlY2lmaWMgZWxlbWVudCB0byBhbmltYXRlLlxuICovXG5mdW5jdGlvbiBhbmltYXRlKGVsKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGlzTW91bnRlZCA9IGVsLmlzQ29ubmVjdGVkO1xuICAgIGNvbnN0IHByZUV4aXN0aW5nID0gY29vcmRzLmhhcyhlbCk7XG4gICAgaWYgKGlzTW91bnRlZCAmJiBzaWJsaW5ncy5oYXMoZWwpKVxuICAgICAgICBzaWJsaW5ncy5kZWxldGUoZWwpO1xuICAgIGlmIChhbmltYXRpb25zLmhhcyhlbCkpIHtcbiAgICAgICAgKF9hID0gYW5pbWF0aW9ucy5nZXQoZWwpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsKCk7XG4gICAgfVxuICAgIGlmIChORVcgaW4gZWwpIHtcbiAgICAgICAgYWRkKGVsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJlRXhpc3RpbmcgJiYgaXNNb3VudGVkKSB7XG4gICAgICAgIHJlbWFpbihlbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByZUV4aXN0aW5nICYmICFpc01vdW50ZWQpIHtcbiAgICAgICAgcmVtb3ZlKGVsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFkZChlbCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZW1vdmVzIGFsbCBub24tZGlnaXRzIGZyb20gYSBzdHJpbmcgYW5kIGNhc3RzIHRvIGEgbnVtYmVyLlxuICogQHBhcmFtIHN0ciAtIEEgc3RyaW5nIGNvbnRhaW5pbmcgYSBwaXhlbCB2YWx1ZS5cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHJhdyhzdHIpIHtcbiAgICByZXR1cm4gTnVtYmVyKHN0ci5yZXBsYWNlKC9bXjAtOS5cXC1dL2csIFwiXCIpKTtcbn1cbi8qKlxuICogR2V0IHRoZSBzY3JvbGwgb2Zmc2V0IG9mIGVsZW1lbnRzXG4gKiBAcGFyYW0gZWwgLSBFbGVtZW50XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRTY3JvbGxPZmZzZXQoZWwpIHtcbiAgICBsZXQgcCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgICAgaWYgKHAuc2Nyb2xsTGVmdCB8fCBwLnNjcm9sbFRvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogcC5zY3JvbGxMZWZ0LCB5OiBwLnNjcm9sbFRvcCB9O1xuICAgICAgICB9XG4gICAgICAgIHAgPSBwLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbn1cbi8qKlxuICogR2V0IHRoZSBjb29yZGluYXRlcyBvZiBlbGVtZW50cyBhZGp1c3RlZCBmb3Igc2Nyb2xsIHBvc2l0aW9uLlxuICogQHBhcmFtIGVsIC0gRWxlbWVudFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0Q29vcmRzKGVsKSB7XG4gICAgY29uc3QgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0U2Nyb2xsT2Zmc2V0KGVsKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHJlY3QudG9wICsgeSxcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgeCxcbiAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgd2lkdGgvaGVpZ2h0IHRoYXQgdGhlIGVsZW1lbnQgc2hvdWxkIGJlIHRyYW5zaXRpb25lZCBiZXR3ZWVuLlxuICogVGhpcyB0YWtlcyBpbnRvIGFjY291bnQgYm94LXNpemluZy5cbiAqIEBwYXJhbSBlbCAtIEVsZW1lbnQgYmVpbmcgYW5pbWF0ZWRcbiAqIEBwYXJhbSBvbGRDb29yZHMgLSBPbGQgc2V0IG9mIENvb3JkaW5hdGVzIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0gbmV3Q29vcmRzIC0gTmV3IHNldCBvZiBDb29yZGluYXRlcyBjb29yZGluYXRlc1xuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblNpemVzKGVsLCBvbGRDb29yZHMsIG5ld0Nvb3Jkcykge1xuICAgIGxldCB3aWR0aEZyb20gPSBvbGRDb29yZHMud2lkdGg7XG4gICAgbGV0IGhlaWdodEZyb20gPSBvbGRDb29yZHMuaGVpZ2h0O1xuICAgIGxldCB3aWR0aFRvID0gbmV3Q29vcmRzLndpZHRoO1xuICAgIGxldCBoZWlnaHRUbyA9IG5ld0Nvb3Jkcy5oZWlnaHQ7XG4gICAgY29uc3Qgc3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgY29uc3Qgc2l6aW5nID0gc3R5bGVzLmdldFByb3BlcnR5VmFsdWUoXCJib3gtc2l6aW5nXCIpO1xuICAgIGlmIChzaXppbmcgPT09IFwiY29udGVudC1ib3hcIikge1xuICAgICAgICBjb25zdCBwYWRkaW5nWSA9IHJhdyhzdHlsZXMucGFkZGluZ1RvcCkgK1xuICAgICAgICAgICAgcmF3KHN0eWxlcy5wYWRkaW5nQm90dG9tKSArXG4gICAgICAgICAgICByYXcoc3R5bGVzLmJvcmRlclRvcFdpZHRoKSArXG4gICAgICAgICAgICByYXcoc3R5bGVzLmJvcmRlckJvdHRvbVdpZHRoKTtcbiAgICAgICAgY29uc3QgcGFkZGluZ1ggPSByYXcoc3R5bGVzLnBhZGRpbmdMZWZ0KSArXG4gICAgICAgICAgICByYXcoc3R5bGVzLnBhZGRpbmdSaWdodCkgK1xuICAgICAgICAgICAgcmF3KHN0eWxlcy5ib3JkZXJSaWdodFdpZHRoKSArXG4gICAgICAgICAgICByYXcoc3R5bGVzLmJvcmRlckxlZnRXaWR0aCk7XG4gICAgICAgIHdpZHRoRnJvbSAtPSBwYWRkaW5nWDtcbiAgICAgICAgd2lkdGhUbyAtPSBwYWRkaW5nWDtcbiAgICAgICAgaGVpZ2h0RnJvbSAtPSBwYWRkaW5nWTtcbiAgICAgICAgaGVpZ2h0VG8gLT0gcGFkZGluZ1k7XG4gICAgfVxuICAgIHJldHVybiBbd2lkdGhGcm9tLCB3aWR0aFRvLCBoZWlnaHRGcm9tLCBoZWlnaHRUb10ubWFwKE1hdGgucm91bmQpO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgYW5pbWF0aW9uIG9wdGlvbnMgZm9yIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gKiBAcGFyYW0gZWwgLSBFbGVtZW50IHRvIHJldHJpZXZlIG9wdGlvbnMgZm9yLlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0T3B0aW9ucyhlbCkge1xuICAgIHJldHVybiBUR1QgaW4gZWwgJiYgb3B0aW9ucy5oYXMoZWxbVEdUXSlcbiAgICAgICAgPyBvcHRpb25zLmdldChlbFtUR1RdKVxuICAgICAgICA6IHsgZHVyYXRpb246IDI1MCwgZWFzaW5nOiBcImVhc2UtaW4tb3V0XCIgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgdGFyZ2V0IG9mIGEgZ2l2ZW4gYW5pbWF0aW9uIChnZW5lcmFsbHkgdGhlIHBhcmVudCkuXG4gKiBAcGFyYW0gZWwgLSBBbiBlbGVtZW50IHRvIGNoZWNrIGZvciBhIHRhcmdldFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0VGFyZ2V0KGVsKSB7XG4gICAgaWYgKFRHVCBpbiBlbClcbiAgICAgICAgcmV0dXJuIGVsW1RHVF07XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGFuaW1hdGlvbnMgYXJlIGVuYWJsZWQgb3IgZGlzYWJsZWQgZm9yIGEgZ2l2ZW4gZWxlbWVudC5cbiAqIEBwYXJhbSBlbCAtIEFueSBlbGVtZW50XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBpc0VuYWJsZWQoZWwpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZWwpO1xuICAgIHJldHVybiB0YXJnZXQgPyBlbmFibGVkLmhhcyh0YXJnZXQpIDogZmFsc2U7XG59XG4vKipcbiAqIEl0ZXJhdGUgb3ZlciB0aGUgY2hpbGRyZW4gb2YgYSBnaXZlbiBwYXJlbnQuXG4gKiBAcGFyYW0gcGFyZW50IC0gQSBwYXJlbnQgZWxlbWVudFxuICogQHBhcmFtIGNhbGxiYWNrIC0gQSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBmb3JFYWNoKHBhcmVudCwgLi4uY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhwYXJlbnQsIG9wdGlvbnMuaGFzKHBhcmVudCkpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbi5pdGVtKGkpO1xuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soY2hpbGQsIG9wdGlvbnMuaGFzKGNoaWxkKSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIHR1cGxlIHRvIHByb3ZpZGUgY29uc2lzdGVudCBpbnRlcmZhY2VcbiAqL1xuZnVuY3Rpb24gZ2V0UGx1Z2luVHVwbGUocGx1Z2luUmV0dXJuKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGx1Z2luUmV0dXJuKSlcbiAgICAgICAgcmV0dXJuIHBsdWdpblJldHVybjtcbiAgICByZXR1cm4gW3BsdWdpblJldHVybl07XG59XG4vKipcbiAqIERldGVybWluZSBpZiBjb25maWcgaXMgcGx1Z2luXG4gKi9cbmZ1bmN0aW9uIGlzUGx1Z2luKGNvbmZpZykge1xuICAgIHJldHVybiB0eXBlb2YgY29uZmlnID09PSBcImZ1bmN0aW9uXCI7XG59XG4vKipcbiAqIFRoZSBlbGVtZW50IGluIHF1ZXN0aW9uIGlzIHJlbWFpbmluZyBpbiB0aGUgRE9NLlxuICogQHBhcmFtIGVsIC0gRWxlbWVudCB0byBmbGlwXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiByZW1haW4oZWwpIHtcbiAgICBjb25zdCBvbGRDb29yZHMgPSBjb29yZHMuZ2V0KGVsKTtcbiAgICBjb25zdCBuZXdDb29yZHMgPSBnZXRDb29yZHMoZWwpO1xuICAgIGlmICghaXNFbmFibGVkKGVsKSlcbiAgICAgICAgcmV0dXJuIGNvb3Jkcy5zZXQoZWwsIG5ld0Nvb3Jkcyk7XG4gICAgbGV0IGFuaW1hdGlvbjtcbiAgICBpZiAoIW9sZENvb3JkcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHBsdWdpbk9yT3B0aW9ucyA9IGdldE9wdGlvbnMoZWwpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luT3JPcHRpb25zICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgZGVsdGFYID0gb2xkQ29vcmRzLmxlZnQgLSBuZXdDb29yZHMubGVmdDtcbiAgICAgICAgY29uc3QgZGVsdGFZID0gb2xkQ29vcmRzLnRvcCAtIG5ld0Nvb3Jkcy50b3A7XG4gICAgICAgIGNvbnN0IFt3aWR0aEZyb20sIHdpZHRoVG8sIGhlaWdodEZyb20sIGhlaWdodFRvXSA9IGdldFRyYW5zaXRpb25TaXplcyhlbCwgb2xkQ29vcmRzLCBuZXdDb29yZHMpO1xuICAgICAgICBjb25zdCBzdGFydCA9IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke2RlbHRhWH1weCwgJHtkZWx0YVl9cHgpYCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZW5kID0ge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKDAsIDApYCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHdpZHRoRnJvbSAhPT0gd2lkdGhUbykge1xuICAgICAgICAgICAgc3RhcnQud2lkdGggPSBgJHt3aWR0aEZyb219cHhgO1xuICAgICAgICAgICAgZW5kLndpZHRoID0gYCR7d2lkdGhUb31weGA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodEZyb20gIT09IGhlaWdodFRvKSB7XG4gICAgICAgICAgICBzdGFydC5oZWlnaHQgPSBgJHtoZWlnaHRGcm9tfXB4YDtcbiAgICAgICAgICAgIGVuZC5oZWlnaHQgPSBgJHtoZWlnaHRUb31weGA7XG4gICAgICAgIH1cbiAgICAgICAgYW5pbWF0aW9uID0gZWwuYW5pbWF0ZShbc3RhcnQsIGVuZF0sIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBwbHVnaW5Pck9wdGlvbnMuZHVyYXRpb24sXG4gICAgICAgICAgICBlYXNpbmc6IHBsdWdpbk9yT3B0aW9ucy5lYXNpbmcsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgW2tleWZyYW1lc10gPSBnZXRQbHVnaW5UdXBsZShwbHVnaW5Pck9wdGlvbnMoZWwsIFwicmVtYWluXCIsIG9sZENvb3JkcywgbmV3Q29vcmRzKSk7XG4gICAgICAgIGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oa2V5ZnJhbWVzKTtcbiAgICAgICAgYW5pbWF0aW9uLnBsYXkoKTtcbiAgICB9XG4gICAgYW5pbWF0aW9ucy5zZXQoZWwsIGFuaW1hdGlvbik7XG4gICAgY29vcmRzLnNldChlbCwgbmV3Q29vcmRzKTtcbiAgICBhbmltYXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImZpbmlzaFwiLCB1cGRhdGVQb3MuYmluZChudWxsLCBlbCkpO1xufVxuLyoqXG4gKiBBZGRzIHRoZSBlbGVtZW50IHdpdGggYSB0cmFuc2l0aW9uLlxuICogQHBhcmFtIGVsIC0gQW5pbWF0ZXMgdGhlIGVsZW1lbnQgYmVpbmcgYWRkZWQuXG4gKi9cbmZ1bmN0aW9uIGFkZChlbCkge1xuICAgIGlmIChORVcgaW4gZWwpXG4gICAgICAgIGRlbGV0ZSBlbFtORVddO1xuICAgIGNvbnN0IG5ld0Nvb3JkcyA9IGdldENvb3JkcyhlbCk7XG4gICAgY29vcmRzLnNldChlbCwgbmV3Q29vcmRzKTtcbiAgICBjb25zdCBwbHVnaW5Pck9wdGlvbnMgPSBnZXRPcHRpb25zKGVsKTtcbiAgICBpZiAoIWlzRW5hYmxlZChlbCkpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgYW5pbWF0aW9uO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luT3JPcHRpb25zICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYW5pbWF0aW9uID0gZWwuYW5pbWF0ZShbXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogXCJzY2FsZSguOTgpXCIsIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiBcInNjYWxlKDAuOTgpXCIsIG9wYWNpdHk6IDAsIG9mZnNldDogMC41IH0sXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogXCJzY2FsZSgxKVwiLCBvcGFjaXR5OiAxIH0sXG4gICAgICAgIF0sIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBwbHVnaW5Pck9wdGlvbnMuZHVyYXRpb24gKiAxLjUsXG4gICAgICAgICAgICBlYXNpbmc6IFwiZWFzZS1pblwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IFtrZXlmcmFtZXNdID0gZ2V0UGx1Z2luVHVwbGUocGx1Z2luT3JPcHRpb25zKGVsLCBcImFkZFwiLCBuZXdDb29yZHMpKTtcbiAgICAgICAgYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbihrZXlmcmFtZXMpO1xuICAgICAgICBhbmltYXRpb24ucGxheSgpO1xuICAgIH1cbiAgICBhbmltYXRpb25zLnNldChlbCwgYW5pbWF0aW9uKTtcbiAgICBhbmltYXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImZpbmlzaFwiLCB1cGRhdGVQb3MuYmluZChudWxsLCBlbCkpO1xufVxuLyoqXG4gKiBDbGVhbiB1cCBhZnRlciByZW1vdmluZyBhbiBlbGVtZW50IGZyb20gdGhlIGRvbS5cbiAqIEBwYXJhbSBlbCAtIEVsZW1lbnQgYmVpbmcgcmVtb3ZlZFxuICogQHBhcmFtIHN0eWxlcyAtIE9wdGlvbmFsIHN0eWxlcyB0aGF0IHNob3VsZCBiZSByZW1vdmVkIGZyb20gdGhlIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGNsZWFuVXAoZWwsIHN0eWxlcykge1xuICAgIHZhciBfYTtcbiAgICBlbC5yZW1vdmUoKTtcbiAgICBjb29yZHMuZGVsZXRlKGVsKTtcbiAgICBzaWJsaW5ncy5kZWxldGUoZWwpO1xuICAgIGFuaW1hdGlvbnMuZGVsZXRlKGVsKTtcbiAgICAoX2EgPSBpbnRlcnNlY3Rpb25zLmdldChlbCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChERUwgaW4gZWwpXG4gICAgICAgICAgICBkZWxldGUgZWxbREVMXTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsLCBORVcsIHsgdmFsdWU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKHN0eWxlcyAmJiBlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN0eWxlIGluIHN0eWxlcykge1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlW3N0eWxlXSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCAwKTtcbn1cbi8qKlxuICogQW5pbWF0ZXMgdGhlIHJlbW92YWwgb2YgYW4gZWxlbWVudC5cbiAqIEBwYXJhbSBlbCAtIEVsZW1lbnQgdG8gcmVtb3ZlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZShlbCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXNpYmxpbmdzLmhhcyhlbCkgfHwgIWNvb3Jkcy5oYXMoZWwpKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgW3ByZXYsIG5leHRdID0gc2libGluZ3MuZ2V0KGVsKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsIERFTCwgeyB2YWx1ZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgIGNvbnN0IGZpbmFsWCA9IHdpbmRvdy5zY3JvbGxYO1xuICAgIGNvbnN0IGZpbmFsWSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgIGlmIChuZXh0ICYmIG5leHQucGFyZW50Tm9kZSAmJiBuZXh0LnBhcmVudE5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgIG5leHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIG5leHQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcmV2ICYmIHByZXYucGFyZW50Tm9kZSkge1xuICAgICAgICBwcmV2LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgKF9hID0gZ2V0VGFyZ2V0KGVsKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG4gICAgaWYgKCFpc0VuYWJsZWQoZWwpKVxuICAgICAgICByZXR1cm4gY2xlYW5VcChlbCk7XG4gICAgY29uc3QgW3RvcCwgbGVmdCwgd2lkdGgsIGhlaWdodF0gPSBkZWxldGVQb3NpdGlvbihlbCk7XG4gICAgY29uc3Qgb3B0aW9uc09yUGx1Z2luID0gZ2V0T3B0aW9ucyhlbCk7XG4gICAgY29uc3Qgb2xkQ29vcmRzID0gY29vcmRzLmdldChlbCk7XG4gICAgaWYgKGZpbmFsWCAhPT0gc2Nyb2xsWCB8fCBmaW5hbFkgIT09IHNjcm9sbFkpIHtcbiAgICAgICAgYWRqdXN0U2Nyb2xsKGVsLCBmaW5hbFgsIGZpbmFsWSwgb3B0aW9uc09yUGx1Z2luKTtcbiAgICB9XG4gICAgbGV0IGFuaW1hdGlvbjtcbiAgICBsZXQgc3R5bGVSZXNldCA9IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgdG9wOiBgJHt0b3B9cHhgLFxuICAgICAgICBsZWZ0OiBgJHtsZWZ0fXB4YCxcbiAgICAgICAgd2lkdGg6IGAke3dpZHRofXB4YCxcbiAgICAgICAgaGVpZ2h0OiBgJHtoZWlnaHR9cHhgLFxuICAgICAgICBtYXJnaW46IFwiMFwiLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBcImNlbnRlclwiLFxuICAgICAgICB6SW5kZXg6IFwiMTAwXCIsXG4gICAgfTtcbiAgICBpZiAoIWlzUGx1Z2luKG9wdGlvbnNPclBsdWdpbikpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihlbC5zdHlsZSwgc3R5bGVSZXNldCk7XG4gICAgICAgIGFuaW1hdGlvbiA9IGVsLmFuaW1hdGUoW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgxKVwiLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSguOTgpXCIsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sIHsgZHVyYXRpb246IG9wdGlvbnNPclBsdWdpbi5kdXJhdGlvbiwgZWFzaW5nOiBcImVhc2Utb3V0XCIgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBba2V5ZnJhbWVzLCBvcHRpb25zXSA9IGdldFBsdWdpblR1cGxlKG9wdGlvbnNPclBsdWdpbihlbCwgXCJyZW1vdmVcIiwgb2xkQ29vcmRzKSk7XG4gICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnN0eWxlUmVzZXQpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgc3R5bGVSZXNldCA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3R5bGVSZXNldCkgfHwgc3R5bGVSZXNldDtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZWwuc3R5bGUsIHN0eWxlUmVzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oa2V5ZnJhbWVzKTtcbiAgICAgICAgYW5pbWF0aW9uLnBsYXkoKTtcbiAgICB9XG4gICAgYW5pbWF0aW9ucy5zZXQoZWwsIGFuaW1hdGlvbik7XG4gICAgYW5pbWF0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJmaW5pc2hcIiwgY2xlYW5VcC5iaW5kKG51bGwsIGVsLCBzdHlsZVJlc2V0KSk7XG59XG4vKipcbiAqIElmIHRoZSBlbGVtZW50IGJlaW5nIHJlbW92ZWQgaXMgYXQgdGhlIHZlcnkgYm90dG9tIG9mIHRoZSBwYWdlLCBhbmQgdGhlXG4gKiB0aGUgcGFnZSB3YXMgc2Nyb2xsZWQgaW50byBhIHNwYWNlIGJlaW5nIFwibWFkZSBhdmFpbGFibGVcIiBieSB0aGUgZWxlbWVudFxuICogdGhhdCB3YXMgcmVtb3ZlZCwgdGhlIHBhZ2Ugc2Nyb2xsIHdpbGwgaGF2ZSBqdW1wZWQgdXAgc29tZSBhbW91bnQuIFdlIG5lZWRcbiAqIHRvIG9mZnNldCB0aGUganVtcCBieSB0aGUgYW1vdW50IHRoYXQgdGhlIHBhZ2Ugd2FzIFwiYXV0b21hdGljYWxseVwiIHNjcm9sbGVkXG4gKiB1cC4gV2UgY2FuIGRvIHRoaXMgYnkgY29tcGFyaW5nIHRoZSBzY3JvbGwgcG9zaXRpb24gYmVmb3JlIGFuZCBhZnRlciB0aGVcbiAqIGVsZW1lbnQgd2FzIHJlbW92ZWQsIGFuZCB0aGVuIG9mZnNldHRpbmcgYnkgdGhhdCBhbW91bnQuXG4gKlxuICogQHBhcmFtIGVsIC0gVGhlIGVsZW1lbnQgYmVpbmcgZGVsZXRlZFxuICogQHBhcmFtIGZpbmFsWCAtIFRoZSBmaW5hbCBYIHNjcm9sbCBwb3NpdGlvblxuICogQHBhcmFtIGZpbmFsWSAtIFRoZSBmaW5hbCBZIHNjcm9sbCBwb3NpdGlvblxuICogQHBhcmFtIG9wdGlvbnNPclBsdWdpbiAtIFRoZSBvcHRpb25zIG9yIHBsdWdpblxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gYWRqdXN0U2Nyb2xsKGVsLCBmaW5hbFgsIGZpbmFsWSwgb3B0aW9uc09yUGx1Z2luKSB7XG4gICAgY29uc3Qgc2Nyb2xsRGVsdGFYID0gc2Nyb2xsWCAtIGZpbmFsWDtcbiAgICBjb25zdCBzY3JvbGxEZWx0YVkgPSBzY3JvbGxZIC0gZmluYWxZO1xuICAgIGNvbnN0IHNjcm9sbEJlZm9yZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvcjtcbiAgICBjb25zdCBzY3JvbGxCZWhhdmlvciA9IGdldENvbXB1dGVkU3R5bGUocm9vdCkuc2Nyb2xsQmVoYXZpb3I7XG4gICAgaWYgKHNjcm9sbEJlaGF2aW9yID09PSBcInNtb290aFwiKSB7XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IFwiYXV0b1wiO1xuICAgIH1cbiAgICB3aW5kb3cuc2Nyb2xsVG8od2luZG93LnNjcm9sbFggKyBzY3JvbGxEZWx0YVgsIHdpbmRvdy5zY3JvbGxZICsgc2Nyb2xsRGVsdGFZKTtcbiAgICBpZiAoIWVsLnBhcmVudEVsZW1lbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBwYXJlbnQgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgIGxldCBsYXN0SGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodDtcbiAgICBsZXQgbGFzdFdpZHRoID0gcGFyZW50LmNsaWVudFdpZHRoO1xuICAgIGNvbnN0IHN0YXJ0U2Nyb2xsID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgLy8gSGVyZSB3ZSB1c2UgYSBtYW51YWwgc2Nyb2xsIGFuaW1hdGlvbiB0byBrZWVwIHRoZSBlbGVtZW50IHVzaW5nIHRoZSBzYW1lXG4gICAgLy8gZWFzaW5nIGFuZCB0aW1pbmcgYXMgdGhlIHBhcmVudOKAmXMgc2Nyb2xsIGFuaW1hdGlvbi5cbiAgICBmdW5jdGlvbiBzbW9vdGhTY3JvbGwoKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzUGx1Z2luKG9wdGlvbnNPclBsdWdpbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVkgPSBsYXN0SGVpZ2h0IC0gcGFyZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YVggPSBsYXN0V2lkdGggLSBwYXJlbnQuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0U2Nyb2xsICsgb3B0aW9uc09yUGx1Z2luLmR1cmF0aW9uID4gcGVyZm9ybWFuY2Uubm93KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHdpbmRvdy5zY3JvbGxYIC0gZGVsdGFYLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiB3aW5kb3cuc2Nyb2xsWSAtIGRlbHRhWSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RIZWlnaHQgPSBwYXJlbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBsYXN0V2lkdGggPSBwYXJlbnQuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHNtb290aFNjcm9sbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gc2Nyb2xsQmVmb3JlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNtb290aFNjcm9sbCgpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCBiZWluZyByZW1vdmVkLlxuICogQHBhcmFtIGVsIC0gVGhlIGVsZW1lbnQgYmVpbmcgZGVsZXRlZFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZGVsZXRlUG9zaXRpb24oZWwpIHtcbiAgICBjb25zdCBvbGRDb29yZHMgPSBjb29yZHMuZ2V0KGVsKTtcbiAgICBjb25zdCBbd2lkdGgsICwgaGVpZ2h0XSA9IGdldFRyYW5zaXRpb25TaXplcyhlbCwgb2xkQ29vcmRzLCBnZXRDb29yZHMoZWwpKTtcbiAgICBsZXQgb2Zmc2V0UGFyZW50ID0gZWwucGFyZW50RWxlbWVudDtcbiAgICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmXG4gICAgICAgIChnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09IFwic3RhdGljXCIgfHxcbiAgICAgICAgICAgIG9mZnNldFBhcmVudCBpbnN0YW5jZW9mIEhUTUxCb2R5RWxlbWVudCkpIHtcbiAgICAgICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIGlmICghb2Zmc2V0UGFyZW50KVxuICAgICAgICBvZmZzZXRQYXJlbnQgPSBkb2N1bWVudC5ib2R5O1xuICAgIGNvbnN0IHBhcmVudFN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KTtcbiAgICBjb25zdCBwYXJlbnRDb29yZHMgPSBjb29yZHMuZ2V0KG9mZnNldFBhcmVudCkgfHwgZ2V0Q29vcmRzKG9mZnNldFBhcmVudCk7XG4gICAgY29uc3QgdG9wID0gTWF0aC5yb3VuZChvbGRDb29yZHMudG9wIC0gcGFyZW50Q29vcmRzLnRvcCkgLVxuICAgICAgICByYXcocGFyZW50U3R5bGVzLmJvcmRlclRvcFdpZHRoKTtcbiAgICBjb25zdCBsZWZ0ID0gTWF0aC5yb3VuZChvbGRDb29yZHMubGVmdCAtIHBhcmVudENvb3Jkcy5sZWZ0KSAtXG4gICAgICAgIHJhdyhwYXJlbnRTdHlsZXMuYm9yZGVyTGVmdFdpZHRoKTtcbiAgICByZXR1cm4gW3RvcCwgbGVmdCwgd2lkdGgsIGhlaWdodF07XG59XG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBhdXRvbWF0aWNhbGx5IGFkZHMgYW5pbWF0aW9uIGVmZmVjdHMgdG8gaXRzZWxmIGFuZCBpdHNcbiAqIGltbWVkaWF0ZSBjaGlsZHJlbi4gU3BlY2lmaWNhbGx5IGl0IGFkZHMgZWZmZWN0cyBmb3IgYWRkaW5nLCBtb3ZpbmcsIGFuZFxuICogcmVtb3ZpbmcgRE9NIGVsZW1lbnRzLlxuICogQHBhcmFtIGVsIC0gQSBwYXJlbnQgZWxlbWVudCB0byBhZGQgYW5pbWF0aW9ucyB0by5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IG9mIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGF1dG9BbmltYXRlKGVsLCBjb25maWcgPSB7fSkge1xuICAgIGlmIChtdXRhdGlvbnMgJiYgcmVzaXplKSB7XG4gICAgICAgIGNvbnN0IG1lZGlhUXVlcnkgPSB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpXCIpO1xuICAgICAgICBjb25zdCBpc0Rpc2FibGVkRHVlVG9SZWR1Y2VNb3Rpb24gPSBtZWRpYVF1ZXJ5Lm1hdGNoZXMgJiZcbiAgICAgICAgICAgICFpc1BsdWdpbihjb25maWcpICYmXG4gICAgICAgICAgICAhY29uZmlnLmRpc3Jlc3BlY3RVc2VyTW90aW9uUHJlZmVyZW5jZTtcbiAgICAgICAgaWYgKCFpc0Rpc2FibGVkRHVlVG9SZWR1Y2VNb3Rpb24pIHtcbiAgICAgICAgICAgIGVuYWJsZWQuYWRkKGVsKTtcbiAgICAgICAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKGVsKS5wb3NpdGlvbiA9PT0gXCJzdGF0aWNcIikge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZWwuc3R5bGUsIHsgcG9zaXRpb246IFwicmVsYXRpdmVcIiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvckVhY2goZWwsIHVwZGF0ZVBvcywgcG9sbCwgKGVsZW1lbnQpID0+IHJlc2l6ZSA9PT0gbnVsbCB8fCByZXNpemUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc2l6ZS5vYnNlcnZlKGVsZW1lbnQpKTtcbiAgICAgICAgICAgIGlmIChpc1BsdWdpbihjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zZXQoZWwsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNldChlbCwgeyBkdXJhdGlvbjogMjUwLCBlYXNpbmc6IFwiZWFzZS1pbi1vdXRcIiwgLi4uY29uZmlnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXV0YXRpb25zLm9ic2VydmUoZWwsIHsgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgICAgICAgICAgcGFyZW50cy5hZGQoZWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgcGFyZW50OiBlbCxcbiAgICAgICAgZW5hYmxlOiAoKSA9PiB7XG4gICAgICAgICAgICBlbmFibGVkLmFkZChlbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpc2FibGU6ICgpID0+IHtcbiAgICAgICAgICAgIGVuYWJsZWQuZGVsZXRlKGVsKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNFbmFibGVkOiAoKSA9PiBlbmFibGVkLmhhcyhlbCksXG4gICAgfSk7XG59XG4vKipcbiAqIFRoZSB2dWUgZGlyZWN0aXZlLlxuICovXG5jb25zdCB2QXV0b0FuaW1hdGUgPSB7XG4gICAgbW91bnRlZDogKGVsLCBiaW5kaW5nKSA9PiB7XG4gICAgICAgIGF1dG9BbmltYXRlKGVsLCBiaW5kaW5nLnZhbHVlIHx8IHt9KTtcbiAgICB9LFxuICAgIC8vIGlnbm9yZSBzc3Igc2VlICM5NjpcbiAgICBnZXRTU1JQcm9wczogKCkgPT4gKHt9KSxcbn07XG5cbmV4cG9ydCB7IGF1dG9BbmltYXRlIGFzIGRlZmF1bHQsIGdldFRyYW5zaXRpb25TaXplcywgdkF1dG9BbmltYXRlIH07XG4iXSwibmFtZXMiOlsicGFyZW50cyIsIlNldCIsImNvb3JkcyIsIldlYWtNYXAiLCJzaWJsaW5ncyIsImFuaW1hdGlvbnMiLCJpbnRlcnNlY3Rpb25zIiwiaW50ZXJ2YWxzIiwib3B0aW9ucyIsImRlYm91bmNlcyIsImVuYWJsZWQiLCJXZWFrU2V0Iiwicm9vdCIsInNjcm9sbFgiLCJzY3JvbGxZIiwiVEdUIiwiREVMIiwiTkVXIiwiaGFuZGxlTXV0YXRpb25zIiwibXV0YXRpb25zIiwiZWxlbWVudHMiLCJnZXRFbGVtZW50cyIsImZvckVhY2giLCJlbCIsImFuaW1hdGUiLCJoYW5kbGVSZXNpemVzIiwiZW50cmllcyIsImVudHJ5IiwidGFyZ2V0IiwidXBkYXRlQWxsUG9zIiwiaGFzIiwidXBkYXRlUG9zIiwib2JzZXJ2ZVBvc2l0aW9uIiwib2xkT2JzZXJ2ZXIiLCJnZXQiLCJkaXNjb25uZWN0IiwicmVjdCIsImludm9jYXRpb25zIiwiYnVmZmVyIiwiZ2V0Q29vcmRzIiwic2V0Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJyb290TWFyZ2lucyIsInRvcCIsImxlZnQiLCJ3aWR0aCIsImhlaWdodCIsInJvb3RNYXJnaW4iLCJtYXAiLCJweCIsIk1hdGgiLCJmbG9vciIsImpvaW4iLCJvYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwidGhyZXNob2xkIiwib2JzZXJ2ZSIsImNsZWFyVGltZW91dCIsIm9wdGlvbnNPclBsdWdpbiIsImdldE9wdGlvbnMiLCJkZWxheSIsImlzUGx1Z2luIiwiZHVyYXRpb24iLCJzZXRUaW1lb3V0IiwiY3VycmVudEFuaW1hdGlvbiIsImZpbmlzaGVkIiwicGFyZW50IiwibG93UHJpb3JpdHkiLCJwb2xsIiwic2V0SW50ZXJ2YWwiLCJiaW5kIiwicm91bmQiLCJyYW5kb20iLCJjYWxsYmFjayIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyZXNpemUiLCJzdXBwb3J0ZWRCcm93c2VyIiwid2luZG93IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJNdXRhdGlvbk9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiLCJhZGRFdmVudExpc3RlbmVyIiwib2JzZXJ2ZWROb2RlcyIsInJlZHVjZSIsIm5vZGVzIiwibXV0YXRpb24iLCJBcnJheSIsImZyb20iLCJhZGRlZE5vZGVzIiwicmVtb3ZlZE5vZGVzIiwib25seUNvbW1lbnROb2Rlc09ic2VydmVkIiwiZXZlcnkiLCJub2RlIiwibm9kZU5hbWUiLCJFbGVtZW50IiwiYWRkIiwiaSIsImNoaWxkcmVuIiwibGVuZ3RoIiwiY2hpbGQiLCJpdGVtIiwicHJldmlvdXNTaWJsaW5nIiwibmV4dFNpYmxpbmciLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiX2EiLCJpc01vdW50ZWQiLCJpc0Nvbm5lY3RlZCIsInByZUV4aXN0aW5nIiwiZGVsZXRlIiwiY2FuY2VsIiwicmVtYWluIiwicmVtb3ZlIiwicmF3Iiwic3RyIiwiTnVtYmVyIiwicmVwbGFjZSIsImdldFNjcm9sbE9mZnNldCIsInAiLCJwYXJlbnRFbGVtZW50Iiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsIngiLCJ5IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZ2V0VHJhbnNpdGlvblNpemVzIiwib2xkQ29vcmRzIiwibmV3Q29vcmRzIiwid2lkdGhGcm9tIiwiaGVpZ2h0RnJvbSIsIndpZHRoVG8iLCJoZWlnaHRUbyIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJzaXppbmciLCJnZXRQcm9wZXJ0eVZhbHVlIiwicGFkZGluZ1kiLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJwYWRkaW5nWCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwiYm9yZGVyUmlnaHRXaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsImVhc2luZyIsImdldFRhcmdldCIsInVuZGVmaW5lZCIsImlzRW5hYmxlZCIsImNhbGxiYWNrcyIsImdldFBsdWdpblR1cGxlIiwicGx1Z2luUmV0dXJuIiwiaXNBcnJheSIsImNvbmZpZyIsImFuaW1hdGlvbiIsInBsdWdpbk9yT3B0aW9ucyIsImRlbHRhWCIsImRlbHRhWSIsInN0YXJ0IiwidHJhbnNmb3JtIiwiZW5kIiwia2V5ZnJhbWVzIiwiQW5pbWF0aW9uIiwicGxheSIsIm9wYWNpdHkiLCJvZmZzZXQiLCJjbGVhblVwIiwiY29uZmlndXJhYmxlIiwiSFRNTEVsZW1lbnQiLCJzdHlsZSIsInByZXYiLCJuZXh0IiwiZmluYWxYIiwiZmluYWxZIiwicGFyZW50Tm9kZSIsImluc2VydEJlZm9yZSIsImFwcGVuZENoaWxkIiwiZGVsZXRlUG9zaXRpb24iLCJhZGp1c3RTY3JvbGwiLCJzdHlsZVJlc2V0IiwicG9zaXRpb24iLCJtYXJnaW4iLCJwb2ludGVyRXZlbnRzIiwidHJhbnNmb3JtT3JpZ2luIiwiekluZGV4IiwiYXNzaWduIiwic2Nyb2xsRGVsdGFYIiwic2Nyb2xsRGVsdGFZIiwic2Nyb2xsQmVmb3JlIiwic2Nyb2xsQmVoYXZpb3IiLCJzY3JvbGxUbyIsImxhc3RIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJsYXN0V2lkdGgiLCJjbGllbnRXaWR0aCIsInN0YXJ0U2Nyb2xsIiwicGVyZm9ybWFuY2UiLCJub3ciLCJzbW9vdGhTY3JvbGwiLCJvZmZzZXRQYXJlbnQiLCJIVE1MQm9keUVsZW1lbnQiLCJib2R5IiwicGFyZW50U3R5bGVzIiwicGFyZW50Q29vcmRzIiwiYXV0b0FuaW1hdGUiLCJtZWRpYVF1ZXJ5IiwibWF0Y2hNZWRpYSIsImlzRGlzYWJsZWREdWVUb1JlZHVjZU1vdGlvbiIsIm1hdGNoZXMiLCJkaXNyZXNwZWN0VXNlck1vdGlvblByZWZlcmVuY2UiLCJlbGVtZW50IiwiY2hpbGRMaXN0IiwiZnJlZXplIiwiZW5hYmxlIiwiZGlzYWJsZSIsInZBdXRvQW5pbWF0ZSIsIm1vdW50ZWQiLCJiaW5kaW5nIiwiZ2V0U1NSUHJvcHMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@formkit/auto-animate/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@formkit/auto-animate/react/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@formkit/auto-animate/react/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAutoAnimate: () => (/* binding */ useAutoAnimate)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.mjs */ \"(ssr)/./node_modules/@formkit/auto-animate/index.mjs\");\n\n\n/**\n * AutoAnimate hook for adding dead-simple transitions and animations to react.\n * @param options - Auto animate options or a plugin\n * @returns\n */ function useAutoAnimate(options) {\n    const [controller, setController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n    const memoizedOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>options, []);\n    const element = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((node)=>{\n        if (node instanceof HTMLElement) {\n            setController((0,_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(node, memoizedOptions));\n        } else {\n            setController(undefined);\n        }\n    }, [\n        memoizedOptions\n    ]);\n    const setEnabled = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((enabled)=>{\n        if (controller) {\n            enabled ? controller.enable() : controller.disable();\n        }\n    }, [\n        controller\n    ]);\n    return [\n        element,\n        setEnabled\n    ];\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvYXV0by1hbmltYXRlL3JlYWN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBdUQ7QUFDaEI7QUFFdkM7Ozs7Q0FJQyxHQUNELFNBQVNJLGVBQWVDLE9BQU87SUFDM0IsTUFBTSxDQUFDQyxZQUFZQyxjQUFjLEdBQUdQLCtDQUFRQTtJQUM1QyxNQUFNUSxrQkFBa0JQLDhDQUFPQSxDQUFDLElBQU1JLFNBQVMsRUFBRTtJQUNqRCxNQUFNSSxVQUFVUCxrREFBV0EsQ0FBQyxDQUFDUTtRQUN6QixJQUFJQSxnQkFBZ0JDLGFBQWE7WUFDN0JKLGNBQWNKLHNEQUFXQSxDQUFDTyxNQUFNRjtRQUNwQyxPQUNLO1lBQ0RELGNBQWNLO1FBQ2xCO0lBQ0osR0FBRztRQUFDSjtLQUFnQjtJQUNwQixNQUFNSyxhQUFhWCxrREFBV0EsQ0FBQyxDQUFDWTtRQUM1QixJQUFJUixZQUFZO1lBQ1pRLFVBQVVSLFdBQVdTLE1BQU0sS0FBS1QsV0FBV1UsT0FBTztRQUN0RDtJQUNKLEdBQUc7UUFBQ1Y7S0FBVztJQUNmLE9BQU87UUFBQ0c7UUFBU0k7S0FBVztBQUNoQztBQUUwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NhaWdvbnhhbmgvLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvYXV0by1hbmltYXRlL3JlYWN0L2luZGV4Lm1qcz8zNTQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VNZW1vLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBhdXRvQW5pbWF0ZSBmcm9tICcuLi9pbmRleC5tanMnO1xuXG4vKipcbiAqIEF1dG9BbmltYXRlIGhvb2sgZm9yIGFkZGluZyBkZWFkLXNpbXBsZSB0cmFuc2l0aW9ucyBhbmQgYW5pbWF0aW9ucyB0byByZWFjdC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQXV0byBhbmltYXRlIG9wdGlvbnMgb3IgYSBwbHVnaW5cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHVzZUF1dG9BbmltYXRlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBbY29udHJvbGxlciwgc2V0Q29udHJvbGxlcl0gPSB1c2VTdGF0ZSgpO1xuICAgIGNvbnN0IG1lbW9pemVkT3B0aW9ucyA9IHVzZU1lbW8oKCkgPT4gb3B0aW9ucywgW10pO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB1c2VDYWxsYmFjaygobm9kZSkgPT4ge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICBzZXRDb250cm9sbGVyKGF1dG9BbmltYXRlKG5vZGUsIG1lbW9pemVkT3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0Q29udHJvbGxlcih1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfSwgW21lbW9pemVkT3B0aW9uc10pO1xuICAgIGNvbnN0IHNldEVuYWJsZWQgPSB1c2VDYWxsYmFjaygoZW5hYmxlZCkgPT4ge1xuICAgICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICAgICAgZW5hYmxlZCA/IGNvbnRyb2xsZXIuZW5hYmxlKCkgOiBjb250cm9sbGVyLmRpc2FibGUoKTtcbiAgICAgICAgfVxuICAgIH0sIFtjb250cm9sbGVyXSk7XG4gICAgcmV0dXJuIFtlbGVtZW50LCBzZXRFbmFibGVkXTtcbn1cblxuZXhwb3J0IHsgdXNlQXV0b0FuaW1hdGUgfTtcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZU1lbW8iLCJ1c2VDYWxsYmFjayIsImF1dG9BbmltYXRlIiwidXNlQXV0b0FuaW1hdGUiLCJvcHRpb25zIiwiY29udHJvbGxlciIsInNldENvbnRyb2xsZXIiLCJtZW1vaXplZE9wdGlvbnMiLCJlbGVtZW50Iiwibm9kZSIsIkhUTUxFbGVtZW50IiwidW5kZWZpbmVkIiwic2V0RW5hYmxlZCIsImVuYWJsZWQiLCJlbmFibGUiLCJkaXNhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@formkit/auto-animate/react/index.mjs\n");

/***/ })

};
;