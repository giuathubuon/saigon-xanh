"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cloudinary-core";
exports.ids = ["vendor-chunks/cloudinary-core"];
exports.modules = {

/***/ "(action-browser)/./node_modules/cloudinary-core/cloudinary-core.js":
/*!*********************************************************!*\
  !*** ./node_modules/cloudinary-core/cloudinary-core.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n   * cloudinary-core.js\n   * Cloudinary's JavaScript library - Version 2.13.1\n   * Copyright Cloudinary\n   * see https://github.com/cloudinary/cloudinary_js\n   *\n   */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! lodash/assign */ \"lodash/assign\"), __webpack_require__(/*! lodash/cloneDeep */ \"lodash/cloneDeep\"), __webpack_require__(/*! lodash/compact */ \"lodash/compact\"), __webpack_require__(/*! lodash/difference */ \"lodash/difference\"), __webpack_require__(/*! lodash/functions */ \"lodash/functions\"), __webpack_require__(/*! lodash/identity */ \"lodash/identity\"), __webpack_require__(/*! lodash/includes */ \"lodash/includes\"), __webpack_require__(/*! lodash/isArray */ \"lodash/isArray\"), __webpack_require__(/*! lodash/isElement */ \"lodash/isElement\"), __webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"), __webpack_require__(/*! lodash/isPlainObject */ \"lodash/isPlainObject\"), __webpack_require__(/*! lodash/isString */ \"lodash/isString\"), __webpack_require__(/*! lodash/merge */ \"lodash/merge\"), __webpack_require__(/*! lodash/trim */ \"lodash/trim\"));\n    else {}\n})(void 0, function(__WEBPACK_EXTERNAL_MODULE_lodash_assign__, __WEBPACK_EXTERNAL_MODULE_lodash_cloneDeep__, __WEBPACK_EXTERNAL_MODULE_lodash_compact__, __WEBPACK_EXTERNAL_MODULE_lodash_difference__, __WEBPACK_EXTERNAL_MODULE_lodash_functions__, __WEBPACK_EXTERNAL_MODULE_lodash_identity__, __WEBPACK_EXTERNAL_MODULE_lodash_includes__, __WEBPACK_EXTERNAL_MODULE_lodash_isArray__, __WEBPACK_EXTERNAL_MODULE_lodash_isElement__, __WEBPACK_EXTERNAL_MODULE_lodash_isFunction__, __WEBPACK_EXTERNAL_MODULE_lodash_isPlainObject__, __WEBPACK_EXTERNAL_MODULE_lodash_isString__, __WEBPACK_EXTERNAL_MODULE_lodash_merge__, __WEBPACK_EXTERNAL_MODULE_lodash_trim__) {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_2864__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_2864__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_2864__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_2864__.c = installedModules;\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_2864__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_2864__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    enumerable: true,\n                    get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // define __esModule on exports\n        /******/ __nested_webpack_require_2864__.r = function(exports1) {\n            /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                    value: \"Module\"\n                });\n            /******/ }\n            /******/ Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n        /******/ };\n        /******/ /******/ // create a fake namespace object\n        /******/ // mode & 1: value is a module id, require it\n        /******/ // mode & 2: merge all properties of value into the ns\n        /******/ // mode & 4: return value when already ns object\n        /******/ // mode & 8|1: behave like require\n        /******/ __nested_webpack_require_2864__.t = function(value, mode) {\n            /******/ if (mode & 1) value = __nested_webpack_require_2864__(value);\n            /******/ if (mode & 8) return value;\n            /******/ if (mode & 4 && typeof value === \"object\" && value && value.__esModule) return value;\n            /******/ var ns = Object.create(null);\n            /******/ __nested_webpack_require_2864__.r(ns);\n            /******/ Object.defineProperty(ns, \"default\", {\n                enumerable: true,\n                value: value\n            });\n            /******/ if (mode & 2 && typeof value != \"string\") for(var key in value)__nested_webpack_require_2864__.d(ns, key, (function(key) {\n                return value[key];\n            }).bind(null, key));\n            /******/ return ns;\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_2864__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_2864__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_2864__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_2864__.p = \"\";\n        /******/ /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_2864__(__nested_webpack_require_2864__.s = \"./src/namespace/cloudinary-core.js\");\n    /******/ }({\n        /***/ \"./src/namespace/cloudinary-core.js\": /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_7160__) {\n            \"use strict\";\n            // ESM COMPAT FLAG\n            __nested_webpack_require_7160__.r(__nested_webpack_exports__);\n            // EXPORTS\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"ClientHintsMetaTag\", function() {\n                return /* reexport */ clienthintsmetatag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Cloudinary\", function() {\n                return /* reexport */ cloudinary;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Condition\", function() {\n                return /* reexport */ condition;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Configuration\", function() {\n                return /* reexport */ src_configuration;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"crc32\", function() {\n                return /* reexport */ src_crc32;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Expression\", function() {\n                return /* reexport */ expression;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"FetchLayer\", function() {\n                return /* reexport */ fetchlayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"HtmlTag\", function() {\n                return /* reexport */ htmltag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"ImageTag\", function() {\n                return /* reexport */ imagetag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Layer\", function() {\n                return /* reexport */ layer_layer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"PictureTag\", function() {\n                return /* reexport */ picturetag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"SubtitlesLayer\", function() {\n                return /* reexport */ subtitleslayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"TextLayer\", function() {\n                return /* reexport */ textlayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Transformation\", function() {\n                return /* reexport */ src_transformation;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"utf8_encode\", function() {\n                return /* reexport */ src_utf8_encode;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Util\", function() {\n                return /* reexport */ lodash_namespaceObject;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"VideoTag\", function() {\n                return /* reexport */ videotag;\n            });\n            // NAMESPACE OBJECT: ./src/constants.js\n            var constants_namespaceObject = {};\n            __nested_webpack_require_7160__.r(constants_namespaceObject);\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"VERSION\", function() {\n                return VERSION;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"CF_SHARED_CDN\", function() {\n                return CF_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"OLD_AKAMAI_SHARED_CDN\", function() {\n                return OLD_AKAMAI_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"AKAMAI_SHARED_CDN\", function() {\n                return AKAMAI_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"SHARED_CDN\", function() {\n                return SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_TIMEOUT_MS\", function() {\n                return DEFAULT_TIMEOUT_MS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_POSTER_OPTIONS\", function() {\n                return DEFAULT_POSTER_OPTIONS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_SOURCE_TYPES\", function() {\n                return DEFAULT_VIDEO_SOURCE_TYPES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"SEO_TYPES\", function() {\n                return SEO_TYPES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_IMAGE_PARAMS\", function() {\n                return DEFAULT_IMAGE_PARAMS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_PARAMS\", function() {\n                return DEFAULT_VIDEO_PARAMS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_SOURCES\", function() {\n                return DEFAULT_VIDEO_SOURCES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_EXTERNAL_LIBRARIES\", function() {\n                return DEFAULT_EXTERNAL_LIBRARIES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"PLACEHOLDER_IMAGE_MODES\", function() {\n                return PLACEHOLDER_IMAGE_MODES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"ACCESSIBILITY_MODES\", function() {\n                return ACCESSIBILITY_MODES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"URL_KEYS\", function() {\n                return URL_KEYS;\n            });\n            // NAMESPACE OBJECT: ./src/util/lodash.js\n            var lodash_namespaceObject = {};\n            __nested_webpack_require_7160__.r(lodash_namespaceObject);\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getSDKAnalyticsSignature\", function() {\n                return getSDKAnalyticsSignature;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getAnalyticsOptions\", function() {\n                return getAnalyticsOptions;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"assign\", function() {\n                return assign_root_assign_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cloneDeep\", function() {\n                return cloneDeep_root_cloneDeep_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"compact\", function() {\n                return compact_root_compact_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"difference\", function() {\n                return difference_root_difference_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"functions\", function() {\n                return functions_root_functions_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"identity\", function() {\n                return identity_root_identity_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"includes\", function() {\n                return includes_root_includes_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isArray\", function() {\n                return isArray_root_isArray_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isPlainObject\", function() {\n                return isPlainObject_root_isPlainObject_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isString\", function() {\n                return isString_root_isString_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"merge\", function() {\n                return merge_root_merge_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"contains\", function() {\n                return includes_root_includes_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isIntersectionObserverSupported\", function() {\n                return isIntersectionObserverSupported;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isNativeLazyLoadSupported\", function() {\n                return isNativeLazyLoadSupported;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"detectIntersection\", function() {\n                return detectIntersection;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"omit\", function() {\n                return omit;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"allStrings\", function() {\n                return baseutil_allStrings;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"without\", function() {\n                return without;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isNumberLike\", function() {\n                return isNumberLike;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"smartEscape\", function() {\n                return smartEscape;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"defaults\", function() {\n                return defaults;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"objectProto\", function() {\n                return objectProto;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"objToString\", function() {\n                return objToString;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isObject\", function() {\n                return isObject;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"funcTag\", function() {\n                return funcTag;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"reWords\", function() {\n                return reWords;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"camelCase\", function() {\n                return camelCase;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"snakeCase\", function() {\n                return snakeCase;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"convertKeys\", function() {\n                return convertKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"withCamelCaseKeys\", function() {\n                return withCamelCaseKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"withSnakeCaseKeys\", function() {\n                return withSnakeCaseKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"base64Encode\", function() {\n                return base64Encode;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"base64EncodeURL\", function() {\n                return base64EncodeURL;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"extractUrlParams\", function() {\n                return extractUrlParams;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"patchFetchFormat\", function() {\n                return patchFetchFormat;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"optionConsume\", function() {\n                return optionConsume;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isEmpty\", function() {\n                return isEmpty;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isAndroid\", function() {\n                return isAndroid;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isEdge\", function() {\n                return isEdge;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isChrome\", function() {\n                return isChrome;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isSafari\", function() {\n                return isSafari;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isElement\", function() {\n                return isElement_root_isElement_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isFunction\", function() {\n                return isFunction_root_isFunction_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"trim\", function() {\n                return trim_root_trim_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getData\", function() {\n                return lodash_getData;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setData\", function() {\n                return lodash_setData;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getAttribute\", function() {\n                return lodash_getAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setAttribute\", function() {\n                return lodash_setAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"removeAttribute\", function() {\n                return lodash_removeAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setAttributes\", function() {\n                return setAttributes;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"hasClass\", function() {\n                return lodash_hasClass;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"addClass\", function() {\n                return lodash_addClass;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getStyles\", function() {\n                return getStyles;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cssExpand\", function() {\n                return cssExpand;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"domStyle\", function() {\n                return domStyle;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"curCSS\", function() {\n                return curCSS;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cssValue\", function() {\n                return cssValue;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"augmentWidthOrHeight\", function() {\n                return augmentWidthOrHeight;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getWidthOrHeight\", function() {\n                return getWidthOrHeight;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"width\", function() {\n                return lodash_width;\n            });\n            // CONCATENATED MODULE: ./src/utf8_encode.js\n            /**\n * UTF8 encoder\n * @private\n */ var utf8_encode;\n            /* harmony default export */ var src_utf8_encode = utf8_encode = function utf8_encode(argString) {\n                var c1, enc, end, n, start, string, stringl, utftext;\n                // http://kevin.vanzonneveld.net\n                // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)\n                // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n                // +   improved by: sowberry\n                // +    tweaked by: Jack\n                // +   bugfixed by: Onno Marsman\n                // +   improved by: Yves Sucaet\n                // +   bugfixed by: Onno Marsman\n                // +   bugfixed by: Ulrich\n                // +   bugfixed by: Rafal Kukawski\n                // +   improved by: kirilloid\n                // *     example 1: utf8_encode('Kevin van Zonneveld');\n                // *     returns 1: 'Kevin van Zonneveld'\n                if (argString === null || typeof argString === \"undefined\") {\n                    return \"\";\n                }\n                string = argString + \"\";\n                // .replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n                utftext = \"\";\n                start = void 0;\n                end = void 0;\n                stringl = 0;\n                start = end = 0;\n                stringl = string.length;\n                n = 0;\n                while(n < stringl){\n                    c1 = string.charCodeAt(n);\n                    enc = null;\n                    if (c1 < 128) {\n                        end++;\n                    } else if (c1 > 127 && c1 < 2048) {\n                        enc = String.fromCharCode(c1 >> 6 | 192, c1 & 63 | 128);\n                    } else {\n                        enc = String.fromCharCode(c1 >> 12 | 224, c1 >> 6 & 63 | 128, c1 & 63 | 128);\n                    }\n                    if (enc !== null) {\n                        if (end > start) {\n                            utftext += string.slice(start, end);\n                        }\n                        utftext += enc;\n                        start = end = n + 1;\n                    }\n                    n++;\n                }\n                if (end > start) {\n                    utftext += string.slice(start, stringl);\n                }\n                return utftext;\n            };\n            // CONCATENATED MODULE: ./src/crc32.js\n            /**\n * CRC32 calculator\n * Depends on 'utf8_encode'\n * @private\n * @param {string} str - The string to calculate the CRC32 for.\n * @return {number}\n */ function crc32(str) {\n                var crc, i, iTop, table, x, y;\n                // http://kevin.vanzonneveld.net\n                // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)\n                // +   improved by: T0bsn\n                // +   improved by: http://stackoverflow.com/questions/2647935/javascript-crc32-function-and-php-crc32-not-matching\n                // -    depends on: utf8_encode\n                // *     example 1: crc32('Kevin van Zonneveld');\n                // *     returns 1: 1249991249\n                str = src_utf8_encode(str);\n                table = \"00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D\";\n                crc = 0;\n                x = 0;\n                y = 0;\n                crc = crc ^ -1;\n                i = 0;\n                iTop = str.length;\n                while(i < iTop){\n                    y = (crc ^ str.charCodeAt(i)) & 0xFF;\n                    x = \"0x\" + table.substr(y * 9, 8);\n                    crc = crc >>> 8 ^ x;\n                    i++;\n                }\n                crc = crc ^ -1;\n                //convert to unsigned 32-bit int if needed\n                if (crc < 0) {\n                    crc += 4294967296;\n                }\n                return crc;\n            }\n            /* harmony default export */ var src_crc32 = crc32;\n            // CONCATENATED MODULE: ./src/sdkAnalytics/stringPad.js\n            function stringPad(value, targetLength, padString) {\n                targetLength = targetLength >> 0; //truncate if number or convert non-number to 0;\n                padString = String(typeof padString !== \"undefined\" ? padString : \" \");\n                if (value.length > targetLength) {\n                    return String(value);\n                } else {\n                    targetLength = targetLength - value.length;\n                    if (targetLength > padString.length) {\n                        padString += repeatStringNumTimes(padString, targetLength / padString.length);\n                    }\n                    return padString.slice(0, targetLength) + String(value);\n                }\n            }\n            function repeatStringNumTimes(string, times) {\n                var repeatedString = \"\";\n                while(times > 0){\n                    repeatedString += string;\n                    times--;\n                }\n                return repeatedString;\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/base64Map.js\n            function _toConsumableArray(arr) {\n                return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n            }\n            function _nonIterableSpread() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function _unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n            }\n            function _iterableToArray(iter) {\n                if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n            }\n            function _arrayWithoutHoles(arr) {\n                if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n            }\n            function _arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n                return arr2;\n            }\n            var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n            var base64Map_num = 0;\n            var map = {};\n            _toConsumableArray(chars).forEach(function(_char) {\n                var key = base64Map_num.toString(2);\n                key = stringPad(key, 6, \"0\");\n                map[key] = _char;\n                base64Map_num++;\n            });\n            /**\n * Map of six-bit binary codes to Base64 characters\n */ /* harmony default export */ var base64Map = map;\n            // CONCATENATED MODULE: ./src/sdkAnalytics/reverseVersion.js\n            /**\n * @description A semVer like string, x.y.z or x.y is allowed\n *              Reverses the version positions, x.y.z turns to z.y.x\n *              Pads each segment with '0' so they have length of 2\n *              Example: 1.2.3 -> 03.02.01\n * @param {string} semVer Input can be either x.y.z or x.y\n * @return {string} in the form of zz.yy.xx (\n */ function reverseVersion(semVer) {\n                if (semVer.split(\".\").length < 2) {\n                    throw new Error(\"invalid semVer, must have at least two segments\");\n                }\n                // Split by '.', reverse, create new array with padded values and concat it together\n                return semVer.split(\".\").reverse().map(function(segment) {\n                    return stringPad(segment, 2, \"0\");\n                }).join(\".\");\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/encodeVersion.js\n            /**\n * @description Encodes a semVer-like version string\n * @param {string} semVer Input can be either x.y.z or x.y\n * @return {string} A string built from 3 characters of the base64 table that encode the semVer\n */ function encodeVersion(semVer) {\n                var strResult = \"\";\n                // support x.y or x.y.z by using 'parts' as a variable\n                var parts = semVer.split(\".\").length;\n                var paddedStringLength = parts * 6; // we pad to either 12 or 18 characters\n                // reverse (but don't mirror) the version. 1.5.15 -> 15.5.1\n                // Pad to two spaces, 15.5.1 -> 15.05.01\n                var paddedReversedSemver = reverseVersion(semVer);\n                // turn 15.05.01 to a string '150501' then to a number 150501\n                var num = parseInt(paddedReversedSemver.split(\".\").join(\"\"));\n                // Represent as binary, add left padding to 12 or 18 characters.\n                // 150,501 -> 100100101111100101\n                var paddedBinary = num.toString(2);\n                paddedBinary = stringPad(paddedBinary, paddedStringLength, \"0\");\n                // Stop in case an invalid version number was provided\n                // paddedBinary must be built from sections of 6 bits\n                if (paddedBinary.length % 6 !== 0) {\n                    throw \"Version must be smaller than 43.21.26)\";\n                }\n                // turn every 6 bits into a character using the base64Map\n                paddedBinary.match(/.{1,6}/g).forEach(function(bitString) {\n                    // console.log(bitString);\n                    strResult += base64Map[bitString];\n                });\n                return strResult;\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/getSDKAnalyticsSignature.js\n            /**\n * @description Gets the SDK signature by encoding the SDK version and tech version\n * @param {{\n *    [techVersion]:string,\n *    [sdkSemver]: string,\n *    [sdkCode]: string,\n *    [feature]: string\n * }} analyticsOptions\n * @return {string} sdkAnalyticsSignature\n */ function getSDKAnalyticsSignature() {\n                var analyticsOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                try {\n                    var twoPartVersion = removePatchFromSemver(analyticsOptions.techVersion);\n                    var encodedSDKVersion = encodeVersion(analyticsOptions.sdkSemver);\n                    var encodedTechVersion = encodeVersion(twoPartVersion);\n                    var featureCode = analyticsOptions.feature;\n                    var SDKCode = analyticsOptions.sdkCode;\n                    var algoVersion = \"A\"; // The algo version is determined here, it should not be an argument\n                    return \"\".concat(algoVersion).concat(SDKCode).concat(encodedSDKVersion).concat(encodedTechVersion).concat(featureCode);\n                } catch (e) {\n                    // Either SDK or Node versions were unparsable\n                    return \"E\";\n                }\n            }\n            /**\n * @description Removes patch version from the semver if it exists\n *              Turns x.y.z OR x.y into x.y\n * @param {'x.y.z' || 'x.y' || string} semVerStr\n */ function removePatchFromSemver(semVerStr) {\n                var parts = semVerStr.split(\".\");\n                return \"\".concat(parts[0], \".\").concat(parts[1]);\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/getAnalyticsOptions.js\n            /**\n * @description Gets the analyticsOptions from options- should include sdkSemver, techVersion, sdkCode, and feature\n * @param options\n * @returns {{sdkSemver: (string), sdkCode, feature: string, techVersion: (string)} || {}}\n */ function getAnalyticsOptions(options) {\n                var analyticsOptions = {\n                    sdkSemver: options.sdkSemver,\n                    techVersion: options.techVersion,\n                    sdkCode: options.sdkCode,\n                    feature: \"0\"\n                };\n                if (options.urlAnalytics) {\n                    if (options.accessibility) {\n                        analyticsOptions.feature = \"D\";\n                    }\n                    if (options.loading === \"lazy\") {\n                        analyticsOptions.feature = \"C\";\n                    }\n                    if (options.responsive) {\n                        analyticsOptions.feature = \"A\";\n                    }\n                    if (options.placeholder) {\n                        analyticsOptions.feature = \"B\";\n                    }\n                    return analyticsOptions;\n                } else {\n                    return {};\n                }\n            }\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/assign\",\"commonjs2\":\"lodash/assign\",\"amd\":\"lodash/assign\",\"root\":[\"_\",\"assign\"]}\n            var assign_root_assign_ = __nested_webpack_require_7160__(\"lodash/assign\");\n            var assign_root_assign_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(assign_root_assign_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/cloneDeep\",\"commonjs2\":\"lodash/cloneDeep\",\"amd\":\"lodash/cloneDeep\",\"root\":[\"_\",\"cloneDeep\"]}\n            var cloneDeep_root_cloneDeep_ = __nested_webpack_require_7160__(\"lodash/cloneDeep\");\n            var cloneDeep_root_cloneDeep_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(cloneDeep_root_cloneDeep_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/compact\",\"commonjs2\":\"lodash/compact\",\"amd\":\"lodash/compact\",\"root\":[\"_\",\"compact\"]}\n            var compact_root_compact_ = __nested_webpack_require_7160__(\"lodash/compact\");\n            var compact_root_compact_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(compact_root_compact_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/difference\",\"commonjs2\":\"lodash/difference\",\"amd\":\"lodash/difference\",\"root\":[\"_\",\"difference\"]}\n            var difference_root_difference_ = __nested_webpack_require_7160__(\"lodash/difference\");\n            var difference_root_difference_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(difference_root_difference_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/functions\",\"commonjs2\":\"lodash/functions\",\"amd\":\"lodash/functions\",\"root\":[\"_\",\"functions\"]}\n            var functions_root_functions_ = __nested_webpack_require_7160__(\"lodash/functions\");\n            var functions_root_functions_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(functions_root_functions_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/identity\",\"commonjs2\":\"lodash/identity\",\"amd\":\"lodash/identity\",\"root\":[\"_\",\"identity\"]}\n            var identity_root_identity_ = __nested_webpack_require_7160__(\"lodash/identity\");\n            var identity_root_identity_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(identity_root_identity_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/includes\",\"commonjs2\":\"lodash/includes\",\"amd\":\"lodash/includes\",\"root\":[\"_\",\"includes\"]}\n            var includes_root_includes_ = __nested_webpack_require_7160__(\"lodash/includes\");\n            var includes_root_includes_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(includes_root_includes_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isArray\",\"commonjs2\":\"lodash/isArray\",\"amd\":\"lodash/isArray\",\"root\":[\"_\",\"isArray\"]}\n            var isArray_root_isArray_ = __nested_webpack_require_7160__(\"lodash/isArray\");\n            var isArray_root_isArray_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isArray_root_isArray_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isPlainObject\",\"commonjs2\":\"lodash/isPlainObject\",\"amd\":\"lodash/isPlainObject\",\"root\":[\"_\",\"isPlainObject\"]}\n            var isPlainObject_root_isPlainObject_ = __nested_webpack_require_7160__(\"lodash/isPlainObject\");\n            var isPlainObject_root_isPlainObject_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isPlainObject_root_isPlainObject_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isString\",\"commonjs2\":\"lodash/isString\",\"amd\":\"lodash/isString\",\"root\":[\"_\",\"isString\"]}\n            var isString_root_isString_ = __nested_webpack_require_7160__(\"lodash/isString\");\n            var isString_root_isString_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isString_root_isString_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/merge\",\"commonjs2\":\"lodash/merge\",\"amd\":\"lodash/merge\",\"root\":[\"_\",\"merge\"]}\n            var merge_root_merge_ = __nested_webpack_require_7160__(\"lodash/merge\");\n            var merge_root_merge_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(merge_root_merge_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isElement\",\"commonjs2\":\"lodash/isElement\",\"amd\":\"lodash/isElement\",\"root\":[\"_\",\"isElement\"]}\n            var isElement_root_isElement_ = __nested_webpack_require_7160__(\"lodash/isElement\");\n            var isElement_root_isElement_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isElement_root_isElement_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isFunction\",\"commonjs2\":\"lodash/isFunction\",\"amd\":\"lodash/isFunction\",\"root\":[\"_\",\"isFunction\"]}\n            var isFunction_root_isFunction_ = __nested_webpack_require_7160__(\"lodash/isFunction\");\n            var isFunction_root_isFunction_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isFunction_root_isFunction_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/trim\",\"commonjs2\":\"lodash/trim\",\"amd\":\"lodash/trim\",\"root\":[\"_\",\"trim\"]}\n            var trim_root_trim_ = __nested_webpack_require_7160__(\"lodash/trim\");\n            var trim_root_trim_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(trim_root_trim_);\n            // CONCATENATED MODULE: ./src/util/lazyLoad.js\n            function _typeof(o) {\n                \"@babel/helpers - typeof\";\n                return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, _typeof(o);\n            }\n            /*\n * Includes utility methods for lazy loading media\n */ /**\n * Check if IntersectionObserver is supported\n * @return {boolean} true if window.IntersectionObserver is defined\n */ function isIntersectionObserverSupported() {\n                // Check that 'IntersectionObserver' property is defined on window\n                return  false && 0;\n            }\n            /**\n * Check if native lazy loading is supported\n * @return {boolean} true if 'loading' property is defined for HTMLImageElement\n */ function isNativeLazyLoadSupported() {\n                return (typeof HTMLImageElement === \"undefined\" ? \"undefined\" : _typeof(HTMLImageElement)) === \"object\" && HTMLImageElement.prototype.loading;\n            }\n            /**\n * Calls onIntersect() when intersection is detected, or when\n * no native lazy loading or when IntersectionObserver isn't supported.\n * @param {Element} el - the element to observe\n * @param {function} onIntersect - called when the given element is in view\n */ function detectIntersection(el, onIntersect) {\n                try {\n                    if (isNativeLazyLoadSupported() || !isIntersectionObserverSupported()) {\n                        // Return if there's no need or possibility to detect intersection\n                        onIntersect();\n                        return;\n                    }\n                    // Detect intersection with given element using IntersectionObserver\n                    var observer = new IntersectionObserver(function(entries) {\n                        entries.forEach(function(entry) {\n                            if (entry.isIntersecting) {\n                                onIntersect();\n                                observer.unobserve(entry.target);\n                            }\n                        });\n                    }, {\n                        threshold: [\n                            0,\n                            0.01\n                        ]\n                    });\n                    observer.observe(el);\n                } catch (e) {\n                    onIntersect();\n                }\n            }\n            // CONCATENATED MODULE: ./src/constants.js\n            var VERSION = \"2.5.0\";\n            var CF_SHARED_CDN = \"d3jpl91pxevbkh.cloudfront.net\";\n            var OLD_AKAMAI_SHARED_CDN = \"cloudinary-a.akamaihd.net\";\n            var AKAMAI_SHARED_CDN = \"res.cloudinary.com\";\n            var SHARED_CDN = AKAMAI_SHARED_CDN;\n            var DEFAULT_TIMEOUT_MS = 10000;\n            var DEFAULT_POSTER_OPTIONS = {\n                format: \"jpg\",\n                resource_type: \"video\"\n            };\n            var DEFAULT_VIDEO_SOURCE_TYPES = [\n                \"webm\",\n                \"mp4\",\n                \"ogv\"\n            ];\n            var SEO_TYPES = {\n                \"image/upload\": \"images\",\n                \"image/private\": \"private_images\",\n                \"image/authenticated\": \"authenticated_images\",\n                \"raw/upload\": \"files\",\n                \"video/upload\": \"videos\"\n            };\n            /**\n* @const {Object} Cloudinary.DEFAULT_IMAGE_PARAMS\n* Defaults values for image parameters.\n*\n* (Previously defined using option_consume() )\n */ var DEFAULT_IMAGE_PARAMS = {\n                resource_type: \"image\",\n                transformation: [],\n                type: \"upload\"\n            };\n            /**\n* Defaults values for video parameters.\n* @const {Object} Cloudinary.DEFAULT_VIDEO_PARAMS\n* (Previously defined using option_consume() )\n */ var DEFAULT_VIDEO_PARAMS = {\n                fallback_content: \"\",\n                resource_type: \"video\",\n                source_transformation: {},\n                source_types: DEFAULT_VIDEO_SOURCE_TYPES,\n                transformation: [],\n                type: \"upload\"\n            };\n            /**\n * Recommended sources for video tag\n * @const {Object} Cloudinary.DEFAULT_VIDEO_SOURCES\n */ var DEFAULT_VIDEO_SOURCES = [\n                {\n                    type: \"mp4\",\n                    codecs: \"hev1\",\n                    transformations: {\n                        video_codec: \"h265\"\n                    }\n                },\n                {\n                    type: \"webm\",\n                    codecs: \"vp9\",\n                    transformations: {\n                        video_codec: \"vp9\"\n                    }\n                },\n                {\n                    type: \"mp4\",\n                    transformations: {\n                        video_codec: \"auto\"\n                    }\n                },\n                {\n                    type: \"webm\",\n                    transformations: {\n                        video_codec: \"auto\"\n                    }\n                }\n            ];\n            var DEFAULT_EXTERNAL_LIBRARIES = {\n                seeThru: \"https://unpkg.com/seethru@4/dist/seeThru.min.js\"\n            };\n            /**\n * Predefined placeholder transformations\n * @const {Object} Cloudinary.PLACEHOLDER_IMAGE_MODES\n */ var PLACEHOLDER_IMAGE_MODES = {\n                \"blur\": [\n                    {\n                        effect: \"blur:2000\",\n                        quality: 1,\n                        fetch_format: \"auto\"\n                    }\n                ],\n                // Default\n                \"pixelate\": [\n                    {\n                        effect: \"pixelate\",\n                        quality: 1,\n                        fetch_format: \"auto\"\n                    }\n                ],\n                // Generates a pixel size image which color is the predominant color of the original image.\n                \"predominant-color-pixel\": [\n                    {\n                        width: \"iw_div_2\",\n                        aspect_ratio: 1,\n                        crop: \"pad\",\n                        background: \"auto\"\n                    },\n                    {\n                        crop: \"crop\",\n                        width: 1,\n                        height: 1,\n                        gravity: \"north_east\"\n                    },\n                    {\n                        fetch_format: \"auto\",\n                        quality: \"auto\"\n                    }\n                ],\n                // Generates an image which color is the predominant color of the original image.\n                \"predominant-color\": [\n                    {\n                        variables: [\n                            [\n                                \"$currWidth\",\n                                \"w\"\n                            ],\n                            [\n                                \"$currHeight\",\n                                \"h\"\n                            ]\n                        ]\n                    },\n                    {\n                        width: \"iw_div_2\",\n                        aspect_ratio: 1,\n                        crop: \"pad\",\n                        background: \"auto\"\n                    },\n                    {\n                        crop: \"crop\",\n                        width: 10,\n                        height: 10,\n                        gravity: \"north_east\"\n                    },\n                    {\n                        width: \"$currWidth\",\n                        height: \"$currHeight\",\n                        crop: \"fill\"\n                    },\n                    {\n                        fetch_format: \"auto\",\n                        quality: \"auto\"\n                    }\n                ],\n                \"vectorize\": [\n                    {\n                        effect: \"vectorize:3:0.1\",\n                        fetch_format: \"svg\"\n                    }\n                ]\n            };\n            /**\n * Predefined accessibility transformations\n * @const {Object} Cloudinary.ACCESSIBILITY_MODES\n */ var ACCESSIBILITY_MODES = {\n                darkmode: \"tint:75:black\",\n                brightmode: \"tint:50:white\",\n                monochrome: \"grayscale\",\n                colorblind: \"assist_colorblind\"\n            };\n            /**\n * A list of keys used by the url() function.\n * @private\n */ var URL_KEYS = [\n                \"accessibility\",\n                \"api_secret\",\n                \"auth_token\",\n                \"cdn_subdomain\",\n                \"cloud_name\",\n                \"cname\",\n                \"format\",\n                \"placeholder\",\n                \"private_cdn\",\n                \"resource_type\",\n                \"secure\",\n                \"secure_cdn_subdomain\",\n                \"secure_distribution\",\n                \"shorten\",\n                \"sign_url\",\n                \"signature\",\n                \"ssl_detected\",\n                \"type\",\n                \"url_suffix\",\n                \"use_root_path\",\n                \"version\"\n            ];\n            /**\n * The resource storage type\n * @typedef type\n * @enum {string}\n * @property  {string} 'upload' A resource uploaded directly to Cloudinary\n * @property  {string} 'fetch' A resource fetched by Cloudinary from a 3rd party storage\n * @property  {string} 'private'\n * @property  {string} 'authenticated'\n * @property  {string} 'sprite'\n * @property  {string} 'facebook'\n * @property  {string} 'twitter'\n * @property  {string} 'youtube'\n * @property  {string} 'vimeo'\n *\n */ /**\n * The resource type\n * @typedef resourceType\n * @enum {string}\n * @property {string} 'image' An image file\n * @property {string} 'video' A video file\n * @property {string} 'raw'   A raw file\n */ // CONCATENATED MODULE: ./src/util/baseutil.js\n            function baseutil_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return baseutil_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, baseutil_typeof(o);\n            }\n            /*\n * Includes common utility methods and shims\n */ function omit(obj, keys) {\n                obj = obj || {};\n                var srcKeys = Object.keys(obj).filter(function(key) {\n                    return !includes_root_includes_default()(keys, key);\n                });\n                var filtered = {};\n                srcKeys.forEach(function(key) {\n                    return filtered[key] = obj[key];\n                });\n                return filtered;\n            }\n            /**\n * Return true if all items in list are strings\n * @function Util.allString\n * @param {Array} list - an array of items\n */ var baseutil_allStrings = function allStrings(list) {\n                return list.length && list.every(isString_root_isString_default.a);\n            };\n            /**\n* Creates a new array without the given item.\n* @function Util.without\n* @param {Array} array - original array\n* @param {*} item - the item to exclude from the new array\n* @return {Array} a new array made of the original array's items except for `item`\n */ var without = function without(array, item) {\n                return array.filter(function(v) {\n                    return v !== item;\n                });\n            };\n            /**\n* Return true is value is a number or a string representation of a number.\n* @function Util.isNumberLike\n* @param {*} value\n* @returns {boolean} true if value is a number\n* @example\n*    Util.isNumber(0) // true\n*    Util.isNumber(\"1.3\") // true\n*    Util.isNumber(\"\") // false\n*    Util.isNumber(undefined) // false\n */ var isNumberLike = function isNumberLike(value) {\n                return value != null && !isNaN(parseFloat(value));\n            };\n            /**\n * Escape all characters matching unsafe in the given string\n * @function Util.smartEscape\n * @param {string} string - source string to escape\n * @param {RegExp} unsafe - characters that must be escaped\n * @return {string} escaped string\n */ var smartEscape = function smartEscape(string) {\n                var unsafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /([^a-zA-Z0-9_.\\-\\/:]+)/g;\n                return string.replace(unsafe, function(match) {\n                    return match.split(\"\").map(function(c) {\n                        return \"%\" + c.charCodeAt(0).toString(16).toUpperCase();\n                    }).join(\"\");\n                });\n            };\n            /**\n * Assign values from sources if they are not defined in the destination.\n * Once a value is set it does not change\n * @function Util.defaults\n * @param {Object} destination - the object to assign defaults to\n * @param {...Object} source - the source object(s) to assign defaults from\n * @return {Object} destination after it was modified\n */ var defaults = function defaults(destination) {\n                for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    sources[_key - 1] = arguments[_key];\n                }\n                return sources.reduce(function(dest, source) {\n                    var key, value;\n                    for(key in source){\n                        value = source[key];\n                        if (dest[key] === void 0) {\n                            dest[key] = value;\n                        }\n                    }\n                    return dest;\n                }, destination);\n            };\n            /*********** lodash functions */ var objectProto = Object.prototype;\n            /**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */ var objToString = objectProto.toString;\n            /**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n#isObject({});\n * // => true\n *\n#isObject([1, 2, 3]);\n * // => true\n *\n#isObject(1);\n * // => false\n */ var isObject = function isObject(value) {\n                var type;\n                // Avoid a V8 JIT bug in Chrome 19-20.\n                // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n                type = baseutil_typeof(value);\n                return !!value && (type === \"object\" || type === \"function\");\n            };\n            var funcTag = \"[object Function]\";\n            /**\n* Checks if `value` is classified as a `Function` object.\n* @function Util.isFunction\n* @param {*} value The value to check.\n* @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n* @example\n*\n* function Foo(){};\n* isFunction(Foo);\n* // => true\n*\n* isFunction(/abc/);\n* // => false\n */ var isFunction = function isFunction(value) {\n                // The use of `Object#toString` avoids issues with the `typeof` operator\n                // in older versions of Chrome and Safari which return 'function' for regexes\n                // and Safari 8 which returns 'object' for typed array constructors.\n                return isObject(value) && objToString.call(value) === funcTag;\n            };\n            /*********** lodash functions */ /** Used to match words to create compound words. */ var reWords = function() {\n                var lower, upper;\n                upper = \"[A-Z]\";\n                lower = \"[a-z]+\";\n                return RegExp(upper + \"+(?=\" + upper + lower + \")|\" + upper + \"?\" + lower + \"|\" + upper + \"+|[0-9]+\", \"g\");\n            }();\n            /**\n* Convert string to camelCase\n* @function Util.camelCase\n* @param {string} source - the string to convert\n* @return {string} in camelCase format\n */ var camelCase = function camelCase(source) {\n                var words = source.match(reWords);\n                words = words.map(function(word) {\n                    return word.charAt(0).toLocaleUpperCase() + word.slice(1).toLocaleLowerCase();\n                });\n                words[0] = words[0].toLocaleLowerCase();\n                return words.join(\"\");\n            };\n            /**\n * Convert string to snake_case\n * @function Util.snakeCase\n * @param {string} source - the string to convert\n * @return {string} in snake_case format\n */ var snakeCase = function snakeCase(source) {\n                var words = source.match(reWords);\n                words = words.map(function(word) {\n                    return word.toLocaleLowerCase();\n                });\n                return words.join(\"_\");\n            };\n            /**\n * Creates a new object from source, with the keys transformed using the converter.\n * @param {object} source\n * @param {function|null} converter\n * @returns {object}\n */ var convertKeys = function convertKeys(source, converter) {\n                var result, value;\n                result = {};\n                for(var key in source){\n                    value = source[key];\n                    if (converter) {\n                        key = converter(key);\n                    }\n                    if (!isEmpty(key)) {\n                        result[key] = value;\n                    }\n                }\n                return result;\n            };\n            /**\n * Create a copy of the source object with all keys in camelCase\n * @function Util.withCamelCaseKeys\n * @param {Object} value - the object to copy\n * @return {Object} a new object\n */ var withCamelCaseKeys = function withCamelCaseKeys(source) {\n                return convertKeys(source, camelCase);\n            };\n            /**\n * Create a copy of the source object with all keys in snake_case\n * @function Util.withSnakeCaseKeys\n * @param {Object} value - the object to copy\n * @return {Object} a new object\n */ var withSnakeCaseKeys = function withSnakeCaseKeys(source) {\n                return convertKeys(source, snakeCase);\n            };\n            // Browser\n            // Node.js\n            var base64Encode = typeof btoa !== \"undefined\" && isFunction(btoa) ? btoa : typeof Buffer !== \"undefined\" && isFunction(Buffer) ? function(input) {\n                if (!(input instanceof Buffer)) {\n                    input = new Buffer.from(String(input), \"binary\");\n                }\n                return input.toString(\"base64\");\n            } : function(input) {\n                throw new Error(\"No base64 encoding function found\");\n            };\n            /**\n* Returns the Base64-decoded version of url.<br>\n* This method delegates to `btoa` if present. Otherwise it tries `Buffer`.\n* @function Util.base64EncodeURL\n* @param {string} url - the url to encode. the value is URIdecoded and then re-encoded before converting to base64 representation\n* @return {string} the base64 representation of the URL\n */ var base64EncodeURL = function base64EncodeURL(url) {\n                try {\n                    url = decodeURI(url);\n                } finally{\n                    url = encodeURI(url);\n                }\n                return base64Encode(url);\n            };\n            /**\n * Create a new object with only URL parameters\n * @param {object} options The source object\n * @return {Object} An object containing only URL parameters\n */ function extractUrlParams(options) {\n                return URL_KEYS.reduce(function(obj, key) {\n                    if (options[key] != null) {\n                        obj[key] = options[key];\n                    }\n                    return obj;\n                }, {});\n            }\n            /**\n * Handle the format parameter for fetch urls\n * @private\n * @param options url and transformation options. This argument may be changed by the function!\n */ function patchFetchFormat(options) {\n                if (options == null) {\n                    options = {};\n                }\n                if (options.type === \"fetch\") {\n                    if (options.fetch_format == null) {\n                        options.fetch_format = optionConsume(options, \"format\");\n                    }\n                }\n            }\n            /**\n * Deletes `option_name` from `options` and return the value if present.\n * If `options` doesn't contain `option_name` the default value is returned.\n * @param {Object} options a collection\n * @param {String} option_name the name (key) of the desired value\n * @param {*} [default_value] the value to return is option_name is missing\n */ function optionConsume(options, option_name, default_value) {\n                var result = options[option_name];\n                delete options[option_name];\n                if (result != null) {\n                    return result;\n                } else {\n                    return default_value;\n                }\n            }\n            /**\n * Returns true if value is empty:\n * <ul>\n *   <li>value is null or undefined</li>\n *   <li>value is an array or string of length 0</li>\n *   <li>value is an object with no keys</li>\n * </ul>\n * @function Util.isEmpty\n * @param value\n * @returns {boolean} true if value is empty\n */ function isEmpty(value) {\n                if (value == null) {\n                    return true;\n                }\n                if (typeof value.length == \"number\") {\n                    return value.length === 0;\n                }\n                if (typeof value.size == \"number\") {\n                    return value.size === 0;\n                }\n                if (baseutil_typeof(value) == \"object\") {\n                    for(var key in value){\n                        if (value.hasOwnProperty(key)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                return true;\n            }\n            // CONCATENATED MODULE: ./src/util/browser.js\n            /**\n * Based on video.js implementation:\n * https://github.com/videojs/video.js/blob/4238f5c1d88890547153e7e1de7bd0d1d8e0b236/src/js/utils/browser.js\n */ /**\n* Retrieve from the navigator the user agent property.\n* @returns user agent property.\n*/ function getUserAgent() {\n                return navigator && navigator.userAgent || \"\";\n            }\n            /**\n * Detect if current browser is any Android\n * @returns true if current browser is Android, false otherwise.\n */ function isAndroid() {\n                var userAgent = getUserAgent();\n                return /Android/i.test(userAgent);\n            }\n            /**\n * Detect if current browser is any Edge\n * @returns true if current browser is Edge, false otherwise.\n */ function isEdge() {\n                var userAgent = getUserAgent();\n                return /Edg/i.test(userAgent);\n            }\n            /**\n * Detect if current browser is chrome.\n * @returns true if current browser is Chrome, false otherwise.\n */ function isChrome() {\n                var userAgent = getUserAgent();\n                return !isEdge() && (/Chrome/i.test(userAgent) || /CriOS/i.test(userAgent));\n            }\n            /**\n * Detect if current browser is Safari.\n * @returns true if current browser is Safari, false otherwise.\n */ function isSafari() {\n                // User agents for other browsers might include \"Safari\" so we must exclude them.\n                // For example - this is the chrome user agent on windows 10:\n                // Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36\n                var userAgent = getUserAgent();\n                return /Safari/i.test(userAgent) && !isChrome() && !isAndroid() && !isEdge();\n            }\n            // CONCATENATED MODULE: ./src/util/lodash.js\n            var nodeContains;\n            /*\n * Includes utility methods and lodash / jQuery shims\n */ /**\n * Get data from the DOM element.\n *\n * This method will use jQuery's `data()` method if it is available, otherwise it will get the `data-` attribute\n * @param {Element} element - the element to get the data from\n * @param {string} name - the name of the data item\n * @returns the value associated with the `name`\n * @function Util.getData\n */ var lodash_getData = function getData(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.getAttribute):\n                        return element.getAttribute(\"data-\".concat(name));\n                    case !isFunction_root_isFunction_default()(element.getAttr):\n                        return element.getAttr(\"data-\".concat(name));\n                    case !isFunction_root_isFunction_default()(element.data):\n                        return element.data(name);\n                    case !(isFunction_root_isFunction_default()(typeof jQuery !== \"undefined\" && jQuery.fn && jQuery.fn.data) && isElement_root_isElement_default()(element)):\n                        return jQuery(element).data(name);\n                }\n            };\n            /**\n * Set data in the DOM element.\n *\n * This method will use jQuery's `data()` method if it is available, otherwise it will set the `data-` attribute\n * @function Util.setData\n * @param {Element} element - the element to set the data in\n * @param {string} name - the name of the data item\n * @param {*} value - the value to be set\n *\n */ var lodash_setData = function setData(element, name, value) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.setAttribute):\n                        return element.setAttribute(\"data-\".concat(name), value);\n                    case !isFunction_root_isFunction_default()(element.setAttr):\n                        return element.setAttr(\"data-\".concat(name), value);\n                    case !isFunction_root_isFunction_default()(element.data):\n                        return element.data(name, value);\n                    case !(isFunction_root_isFunction_default()(typeof jQuery !== \"undefined\" && jQuery.fn && jQuery.fn.data) && isElement_root_isElement_default()(element)):\n                        return jQuery(element).data(name, value);\n                }\n            };\n            /**\n * Get attribute from the DOM element.\n *\n * @function Util.getAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n * @returns {*} the value of the attribute\n *\n */ var lodash_getAttribute = function getAttribute(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.getAttribute):\n                        return element.getAttribute(name);\n                    case !isFunction_root_isFunction_default()(element.attr):\n                        return element.attr(name);\n                    case !isFunction_root_isFunction_default()(element.getAttr):\n                        return element.getAttr(name);\n                }\n            };\n            /**\n * Set attribute in the DOM element.\n *\n * @function Util.setAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n * @param {*} value - the value to be set\n */ var lodash_setAttribute = function setAttribute(element, name, value) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.setAttribute):\n                        return element.setAttribute(name, value);\n                    case !isFunction_root_isFunction_default()(element.attr):\n                        return element.attr(name, value);\n                    case !isFunction_root_isFunction_default()(element.setAttr):\n                        return element.setAttr(name, value);\n                }\n            };\n            /**\n * Remove an attribute in the DOM element.\n *\n * @function Util.removeAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n */ var lodash_removeAttribute = function removeAttribute(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.removeAttribute):\n                        return element.removeAttribute(name);\n                    default:\n                        return lodash_setAttribute(element, void 0);\n                }\n            };\n            /**\n * Set a group of attributes to the element\n * @function Util.setAttributes\n * @param {Element} element - the element to set the attributes for\n * @param {Object} attributes - a hash of attribute names and values\n */ var setAttributes = function setAttributes(element, attributes) {\n                var name, results, value;\n                results = [];\n                for(name in attributes){\n                    value = attributes[name];\n                    if (value != null) {\n                        results.push(lodash_setAttribute(element, name, value));\n                    } else {\n                        results.push(lodash_removeAttribute(element, name));\n                    }\n                }\n                return results;\n            };\n            /**\n * Checks if element has a css class\n * @function Util.hasClass\n * @param {Element} element - the element to check\n * @param {string} name - the class name\n @returns {boolean} true if the element has the class\n */ var lodash_hasClass = function hasClass(element, name) {\n                if (isElement_root_isElement_default()(element)) {\n                    return element.className.match(new RegExp(\"\\\\b\".concat(name, \"\\\\b\")));\n                }\n            };\n            /**\n * Add class to the element\n * @function Util.addClass\n * @param {Element} element - the element\n * @param {string} name - the class name to add\n */ var lodash_addClass = function addClass(element, name) {\n                if (!element.className.match(new RegExp(\"\\\\b\".concat(name, \"\\\\b\")))) {\n                    return element.className = trim_root_trim_default()(\"\".concat(element.className, \" \").concat(name));\n                }\n            };\n            // The following code is taken from jQuery\n            var getStyles = function getStyles(elem) {\n                // Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n                // IE throws on elements created in popups\n                // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n                if (elem.ownerDocument.defaultView.opener) {\n                    return elem.ownerDocument.defaultView.getComputedStyle(elem, null);\n                }\n                return window.getComputedStyle(elem, null);\n            };\n            var cssExpand = [\n                \"Top\",\n                \"Right\",\n                \"Bottom\",\n                \"Left\"\n            ];\n            nodeContains = function nodeContains(a, b) {\n                var adown, bup;\n                adown = a.nodeType === 9 ? a.documentElement : a;\n                bup = b && b.parentNode;\n                return a === bup || !!(bup && bup.nodeType === 1 && adown.contains(bup));\n            };\n            // Truncated version of jQuery.style(elem, name)\n            var domStyle = function domStyle(elem, name) {\n                if (!(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style)) {\n                    return elem.style[name];\n                }\n            };\n            var curCSS = function curCSS(elem, name, computed) {\n                var maxWidth, minWidth, ret, rmargin, style, width;\n                rmargin = /^margin/;\n                width = void 0;\n                minWidth = void 0;\n                maxWidth = void 0;\n                ret = void 0;\n                style = elem.style;\n                computed = computed || getStyles(elem);\n                if (computed) {\n                    // Support: IE9\n                    // getPropertyValue is only needed for .css('filter') (#12537)\n                    ret = computed.getPropertyValue(name) || computed[name];\n                }\n                if (computed) {\n                    if (ret === \"\" && !nodeContains(elem.ownerDocument, elem)) {\n                        ret = domStyle(elem, name);\n                    }\n                    // Support: iOS < 6\n                    // A tribute to the \"awesome hack by Dean Edwards\"\n                    // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n                    // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n                    if (rnumnonpx.test(ret) && rmargin.test(name)) {\n                        // Remember the original values\n                        width = style.width;\n                        minWidth = style.minWidth;\n                        maxWidth = style.maxWidth;\n                        // Put in the new values to get a computed value out\n                        style.minWidth = style.maxWidth = style.width = ret;\n                        ret = computed.width;\n                        // Revert the changed values\n                        style.width = width;\n                        style.minWidth = minWidth;\n                        style.maxWidth = maxWidth;\n                    }\n                }\n                // Support: IE\n                // IE returns zIndex value as an integer.\n                if (ret !== undefined) {\n                    return ret + \"\";\n                } else {\n                    return ret;\n                }\n            };\n            var cssValue = function cssValue(elem, name, convert, styles) {\n                var val;\n                val = curCSS(elem, name, styles);\n                if (convert) {\n                    return parseFloat(val);\n                } else {\n                    return val;\n                }\n            };\n            var augmentWidthOrHeight = function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {\n                var i, len, side, sides, val;\n                // If we already have the right measurement, avoid augmentation\n                // Otherwise initialize for horizontal or vertical properties\n                if (extra === (isBorderBox ? \"border\" : \"content\")) {\n                    return 0;\n                } else {\n                    sides = name === \"width\" ? [\n                        \"Right\",\n                        \"Left\"\n                    ] : [\n                        \"Top\",\n                        \"Bottom\"\n                    ];\n                    val = 0;\n                    for(i = 0, len = sides.length; i < len; i++){\n                        side = sides[i];\n                        if (extra === \"margin\") {\n                            // Both box models exclude margin, so add it if we want it\n                            val += cssValue(elem, extra + side, true, styles);\n                        }\n                        if (isBorderBox) {\n                            if (extra === \"content\") {\n                                // border-box includes padding, so remove it if we want content\n                                val -= cssValue(elem, \"padding\".concat(side), true, styles);\n                            }\n                            if (extra !== \"margin\") {\n                                // At this point, extra isn't border nor margin, so remove border\n                                val -= cssValue(elem, \"border\".concat(side, \"Width\"), true, styles);\n                            }\n                        } else {\n                            // At this point, extra isn't content, so add padding\n                            val += cssValue(elem, \"padding\".concat(side), true, styles);\n                            if (extra !== \"padding\") {\n                                // At this point, extra isn't content nor padding, so add border\n                                val += cssValue(elem, \"border\".concat(side, \"Width\"), true, styles);\n                            }\n                        }\n                    }\n                    return val;\n                }\n            };\n            var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n            var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n            var getWidthOrHeight = function getWidthOrHeight(elem, name, extra) {\n                var isBorderBox, styles, val, valueIsBorderBox;\n                // Start with offset property, which is equivalent to the border-box value\n                valueIsBorderBox = true;\n                val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight;\n                styles = getStyles(elem);\n                isBorderBox = cssValue(elem, \"boxSizing\", false, styles) === \"border-box\";\n                // Some non-html elements return undefined for offsetWidth, so check for null/undefined\n                // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n                // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n                if (val <= 0 || val == null) {\n                    // Fall back to computed then uncomputed css if necessary\n                    val = curCSS(elem, name, styles);\n                    if (val < 0 || val == null) {\n                        val = elem.style[name];\n                    }\n                    if (rnumnonpx.test(val)) {\n                        // Computed unit is not pixels. Stop here and return.\n                        return val;\n                    }\n                    // Check for style in case a browser which returns unreliable values\n                    // for getComputedStyle silently falls back to the reliable elem.style\n                    //    valueIsBorderBox = isBorderBox and (support.boxSizingReliable() or val is elem.style[name])\n                    valueIsBorderBox = isBorderBox && val === elem.style[name];\n                    // Normalize \"\", auto, and prepare for extra\n                    val = parseFloat(val) || 0;\n                }\n                // Use the active box-sizing model to add/subtract irrelevant styles\n                return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles);\n            };\n            var lodash_width = function width(element) {\n                return getWidthOrHeight(element, \"width\", \"content\");\n            };\n            /**\n * @class Util\n */ /**\n * Returns true if item is a string\n * @function Util.isString\n * @param item\n * @returns {boolean} true if item is a string\n */ /**\n * Returns true if item is empty:\n * <ul>\n *   <li>item is null or undefined</li>\n *   <li>item is an array or string of length 0</li>\n *   <li>item is an object with no keys</li>\n * </ul>\n * @function Util.isEmpty\n * @param item\n * @returns {boolean} true if item is empty\n */ /**\n * Assign source properties to destination.\n * If the property is an object it is assigned as a whole, overriding the destination object.\n * @function Util.assign\n * @param {Object} destination - the object to assign to\n */ /**\n * Recursively assign source properties to destination\n * @function Util.merge\n * @param {Object} destination - the object to assign to\n * @param {...Object} [sources] The source objects.\n */ /**\n * Create a new copy of the given object, including all internal objects.\n * @function Util.cloneDeep\n * @param {Object} value - the object to clone\n * @return {Object} a new deep copy of the object\n */ /**\n * Creates a new array from the parameter with \"falsey\" values removed\n * @function Util.compact\n * @param {Array} array - the array to remove values from\n * @return {Array} a new array without falsey values\n */ /**\n * Check if a given item is included in the given array\n * @function Util.contains\n * @param {Array} array - the array to search in\n * @param {*} item - the item to search for\n * @return {boolean} true if the item is included in the array\n */ /**\n * Returns values in the given array that are not included in the other array\n * @function Util.difference\n * @param {Array} arr - the array to select from\n * @param {Array} values - values to filter from arr\n * @return {Array} the filtered values\n */ /**\n * Returns a list of all the function names in obj\n * @function Util.functions\n * @param {Object} object - the object to inspect\n * @return {Array} a list of functions of object\n */ /**\n * Returns the provided value. This functions is used as a default predicate function.\n * @function Util.identity\n * @param {*} value\n * @return {*} the provided value\n */ /**\n * Remove leading or trailing spaces from text\n * @function Util.trim\n * @param {string} text\n * @return {string} the `text` without leading or trailing spaces\n */ // CONCATENATED MODULE: ./src/expression.js\n            function expression_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return expression_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, expression_typeof(o);\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function _createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) _defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function _toPropertyKey(t) {\n                var i = _toPrimitive(t, \"string\");\n                return \"symbol\" == expression_typeof(i) ? i : i + \"\";\n            }\n            function _toPrimitive(t, r) {\n                if (\"object\" != expression_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != expression_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            /**\n * Represents a transformation expression.\n * @param {string} expressionStr - An expression in string format.\n * @class Expression\n * Normally this class is not instantiated directly\n */ var Expression = /*#__PURE__*/ function() {\n                function Expression(expressionStr) {\n                    _classCallCheck(this, Expression);\n                    /**\n     * @protected\n     * @inner Expression-expressions\n     */ this.expressions = [];\n                    if (expressionStr != null) {\n                        this.expressions.push(Expression.normalize(expressionStr));\n                    }\n                }\n                /**\n   * Convenience constructor method\n   * @function Expression.new\n   */ return _createClass(Expression, [\n                    {\n                        key: \"serialize\",\n                        value: /**\n     * Serialize the expression\n     * @return {string} the expression as a string\n     */ function serialize() {\n                            return Expression.normalize(this.expressions.join(\"_\"));\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return this.serialize();\n                        }\n                    },\n                    {\n                        key: \"getParent\",\n                        value: function getParent() {\n                            return this.parent;\n                        }\n                    },\n                    {\n                        key: \"setParent\",\n                        value: function setParent(parent) {\n                            this.parent = parent;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"predicate\",\n                        value: function predicate(name, operator, value) {\n                            if (Expression.OPERATORS[operator] != null) {\n                                operator = Expression.OPERATORS[operator];\n                            }\n                            this.expressions.push(\"\".concat(name, \"_\").concat(operator, \"_\").concat(value));\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"and\",\n                        value: function and() {\n                            this.expressions.push(\"and\");\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"or\",\n                        value: function or() {\n                            this.expressions.push(\"or\");\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"then\",\n                        value: function then() {\n                            return this.getParent()[\"if\"](this.toString());\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height(operator, value) {\n                            return this.predicate(\"h\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(operator, value) {\n                            return this.predicate(\"w\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(operator, value) {\n                            return this.predicate(\"ar\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount(operator, value) {\n                            return this.predicate(\"pc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount(operator, value) {\n                            return this.predicate(\"fc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value(_value) {\n                            this.expressions.push(_value);\n                            return this;\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(expressionStr) {\n                            return new this(expressionStr);\n                        }\n                    },\n                    {\n                        key: \"normalize\",\n                        value: function normalize(expression) {\n                            if (expression == null) {\n                                return expression;\n                            }\n                            expression = String(expression);\n                            var operators = \"\\\\|\\\\||>=|<=|&&|!=|>|=|<|/|-|\\\\+|\\\\*|\\\\^\";\n                            // operators\n                            var operatorsPattern = \"((\" + operators + \")(?=[ _]))\";\n                            var operatorsReplaceRE = new RegExp(operatorsPattern, \"g\");\n                            expression = expression.replace(operatorsReplaceRE, function(match) {\n                                return Expression.OPERATORS[match];\n                            });\n                            // predefined variables\n                            // The :${v} part is to prevent normalization of vars with a preceding colon (such as :duration),\n                            // It won't be found in PREDEFINED_VARS and so won't be normalized.\n                            // It is done like this because ie11 does not support regex lookbehind\n                            var predefinedVarsPattern = \"(\" + Object.keys(Expression.PREDEFINED_VARS).map(function(v) {\n                                return \":\".concat(v, \"|\").concat(v);\n                            }).join(\"|\") + \")\";\n                            var userVariablePattern = \"(\\\\$_*[^_ ]+)\";\n                            var variablesReplaceRE = new RegExp(\"\".concat(userVariablePattern, \"|\").concat(predefinedVarsPattern), \"g\");\n                            expression = expression.replace(variablesReplaceRE, function(match) {\n                                return Expression.PREDEFINED_VARS[match] || match;\n                            });\n                            return expression.replace(/[ _]+/g, \"_\");\n                        }\n                    },\n                    {\n                        key: \"variable\",\n                        value: function variable(name, value) {\n                            return new this(name).value(value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width() {\n                            return new this(\"width\");\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height() {\n                            return new this(\"height\");\n                        }\n                    },\n                    {\n                        key: \"initialWidth\",\n                        value: function initialWidth() {\n                            return new this(\"initialWidth\");\n                        }\n                    },\n                    {\n                        key: \"initialHeight\",\n                        value: function initialHeight() {\n                            return new this(\"initialHeight\");\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio() {\n                            return new this(\"aspectRatio\");\n                        }\n                    },\n                    {\n                        key: \"initialAspectRatio\",\n                        value: function initialAspectRatio() {\n                            return new this(\"initialAspectRatio\");\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount() {\n                            return new this(\"pageCount\");\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount() {\n                            return new this(\"faceCount\");\n                        }\n                    },\n                    {\n                        key: \"currentPage\",\n                        value: function currentPage() {\n                            return new this(\"currentPage\");\n                        }\n                    },\n                    {\n                        key: \"tags\",\n                        value: function tags() {\n                            return new this(\"tags\");\n                        }\n                    },\n                    {\n                        key: \"pageX\",\n                        value: function pageX() {\n                            return new this(\"pageX\");\n                        }\n                    },\n                    {\n                        key: \"pageY\",\n                        value: function pageY() {\n                            return new this(\"pageY\");\n                        }\n                    }\n                ]);\n            }();\n            /**\n * @internal\n */ Expression.OPERATORS = {\n                \"=\": \"eq\",\n                \"!=\": \"ne\",\n                \"<\": \"lt\",\n                \">\": \"gt\",\n                \"<=\": \"lte\",\n                \">=\": \"gte\",\n                \"&&\": \"and\",\n                \"||\": \"or\",\n                \"*\": \"mul\",\n                \"/\": \"div\",\n                \"+\": \"add\",\n                \"-\": \"sub\",\n                \"^\": \"pow\"\n            };\n            /**\n * @internal\n */ Expression.PREDEFINED_VARS = {\n                \"aspect_ratio\": \"ar\",\n                \"aspectRatio\": \"ar\",\n                \"current_page\": \"cp\",\n                \"currentPage\": \"cp\",\n                \"duration\": \"du\",\n                \"face_count\": \"fc\",\n                \"faceCount\": \"fc\",\n                \"height\": \"h\",\n                \"initial_aspect_ratio\": \"iar\",\n                \"initial_duration\": \"idu\",\n                \"initial_height\": \"ih\",\n                \"initial_width\": \"iw\",\n                \"initialAspectRatio\": \"iar\",\n                \"initialDuration\": \"idu\",\n                \"initialHeight\": \"ih\",\n                \"initialWidth\": \"iw\",\n                \"page_count\": \"pc\",\n                \"page_x\": \"px\",\n                \"page_y\": \"py\",\n                \"pageCount\": \"pc\",\n                \"pageX\": \"px\",\n                \"pageY\": \"py\",\n                \"tags\": \"tags\",\n                \"width\": \"w\"\n            };\n            /**\n * @internal\n */ Expression.BOUNDRY = \"[ _]+\";\n            /* harmony default export */ var expression = Expression;\n            // CONCATENATED MODULE: ./src/condition.js\n            function condition_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return condition_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, condition_typeof(o);\n            }\n            function condition_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function condition_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, condition_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function condition_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) condition_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) condition_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function condition_toPropertyKey(t) {\n                var i = condition_toPrimitive(t, \"string\");\n                return \"symbol\" == condition_typeof(i) ? i : i + \"\";\n            }\n            function condition_toPrimitive(t, r) {\n                if (\"object\" != condition_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != condition_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function _callSuper(t, o, e) {\n                return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function _possibleConstructorReturn(self, call) {\n                if (call && (condition_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return _assertThisInitialized(self);\n            }\n            function _assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function _isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function _getPrototypeOf(o) {\n                _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return _getPrototypeOf(o);\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) _setPrototypeOf(subClass, superClass);\n            }\n            function _setPrototypeOf(o, p) {\n                _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return _setPrototypeOf(o, p);\n            }\n            /**\n * Represents a transformation condition.\n * @param {string} conditionStr - a condition in string format\n * @class Condition\n * @example\n * // normally this class is not instantiated directly\n * var tr = cloudinary.Transformation.new()\n *    .if().width( \">\", 1000).and().aspectRatio(\"<\", \"3:4\").then()\n *      .width(1000)\n *      .crop(\"scale\")\n *    .else()\n *      .width(500)\n *      .crop(\"scale\")\n *\n * var tr = cloudinary.Transformation.new()\n *    .if(\"w > 1000 and aspectRatio < 3:4\")\n *      .width(1000)\n *      .crop(\"scale\")\n *    .else()\n *      .width(500)\n *      .crop(\"scale\")\n *\n */ var Condition = /*#__PURE__*/ function(_Expression) {\n                function Condition(conditionStr) {\n                    condition_classCallCheck(this, Condition);\n                    return _callSuper(this, Condition, [\n                        conditionStr\n                    ]);\n                }\n                /**\n   * @function Condition#height\n   * @param {string} operator the comparison operator (e.g. \"<\", \"lt\")\n   * @param {string|number} value the right hand side value\n   * @return {Condition} this condition\n   */ _inherits(Condition, _Expression);\n                return condition_createClass(Condition, [\n                    {\n                        key: \"height\",\n                        value: function height(operator, value) {\n                            return this.predicate(\"h\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(operator, value) {\n                            return this.predicate(\"w\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(operator, value) {\n                            return this.predicate(\"ar\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount(operator, value) {\n                            return this.predicate(\"pc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount(operator, value) {\n                            return this.predicate(\"fc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"duration\",\n                        value: function duration(operator, value) {\n                            return this.predicate(\"du\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"initialDuration\",\n                        value: function initialDuration(operator, value) {\n                            return this.predicate(\"idu\", operator, value);\n                        }\n                    }\n                ]);\n            }(expression);\n            /* harmony default export */ var condition = Condition;\n            // CONCATENATED MODULE: ./src/configuration.js\n            function configuration_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return configuration_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, configuration_typeof(o);\n            }\n            function _slicedToArray(arr, i) {\n                return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || configuration_unsupportedIterableToArray(arr, i) || _nonIterableRest();\n            }\n            function _nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function configuration_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return configuration_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return configuration_arrayLikeToArray(o, minLen);\n            }\n            function configuration_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n                return arr2;\n            }\n            function _iterableToArrayLimit(r, l) {\n                var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n                if (null != t) {\n                    var e, n, i, u, a = [], f = !0, o = !1;\n                    try {\n                        if (i = (t = t.call(r)).next, 0 === l) {\n                            if (Object(t) !== t) return;\n                            f = !1;\n                        } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n                    } catch (r) {\n                        o = !0, n = r;\n                    } finally{\n                        try {\n                            if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n                        } finally{\n                            if (o) throw n;\n                        }\n                    }\n                    return a;\n                }\n            }\n            function _arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            function configuration_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function configuration_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, configuration_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function configuration_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) configuration_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) configuration_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function configuration_toPropertyKey(t) {\n                var i = configuration_toPrimitive(t, \"string\");\n                return \"symbol\" == configuration_typeof(i) ? i : i + \"\";\n            }\n            function configuration_toPrimitive(t, r) {\n                if (\"object\" != configuration_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != configuration_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            /**\n * Class for defining account configuration options.\n * Depends on 'utils'\n */ /**\n * Class for defining account configuration options.\n * @constructor Configuration\n * @param {Object} options - The account configuration parameters to set.\n * @see <a href=\"https://cloudinary.com/documentation/solution_overview#configuration_parameters\"\n *  target=\"_new\">Available configuration options</a>\n */ var configuration_Configuration = /*#__PURE__*/ function() {\n                function Configuration(options) {\n                    configuration_classCallCheck(this, Configuration);\n                    this.configuration = options == null ? {} : cloneDeep_root_cloneDeep_default()(options);\n                    defaults(this.configuration, DEFAULT_CONFIGURATION_PARAMS);\n                }\n                /**\n   * Initializes the configuration. This method is a convenience method that invokes both\n   *  {@link Configuration#fromEnvironment|fromEnvironment()} (Node.js environment only)\n   *  and {@link Configuration#fromDocument|fromDocument()}.\n   *  It first tries to retrieve the configuration from the environment variable.\n   *  If not available, it tries from the document meta tags.\n   * @function Configuration#init\n   * @return {Configuration} returns `this` for chaining\n   * @see fromDocument\n   * @see fromEnvironment\n   */ return configuration_createClass(Configuration, [\n                    {\n                        key: \"init\",\n                        value: function init() {\n                            this.fromEnvironment();\n                            this.fromDocument();\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(name, value) {\n                            this.configuration[name] = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"get\",\n                        value: function get(name) {\n                            return this.configuration[name];\n                        }\n                    },\n                    {\n                        key: \"merge\",\n                        value: function merge(config) {\n                            assign_root_assign_default()(this.configuration, cloneDeep_root_cloneDeep_default()(config));\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromDocument\",\n                        value: function fromDocument() {\n                            var el, i, len, meta_elements;\n                            meta_elements = typeof document !== \"undefined\" && document !== null ? document.querySelectorAll('meta[name^=\"cloudinary_\"]') : void 0;\n                            if (meta_elements) {\n                                for(i = 0, len = meta_elements.length; i < len; i++){\n                                    el = meta_elements[i];\n                                    this.configuration[el.getAttribute(\"name\").replace(\"cloudinary_\", \"\")] = el.getAttribute(\"content\");\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromEnvironment\",\n                        value: function fromEnvironment() {\n                            var _this = this;\n                            var cloudinary_url, query, uri, uriRegex;\n                            if (typeof process !== \"undefined\" && process !== null && process.env && process.env.CLOUDINARY_URL) {\n                                cloudinary_url = process.env.CLOUDINARY_URL;\n                                uriRegex = /cloudinary:\\/\\/(?:(\\w+)(?:\\:([\\w-]+))?@)?([\\w\\.-]+)(?:\\/([^?]*))?(?:\\?(.+))?/;\n                                uri = uriRegex.exec(cloudinary_url);\n                                if (uri) {\n                                    if (uri[3] != null) {\n                                        this.configuration[\"cloud_name\"] = uri[3];\n                                    }\n                                    if (uri[1] != null) {\n                                        this.configuration[\"api_key\"] = uri[1];\n                                    }\n                                    if (uri[2] != null) {\n                                        this.configuration[\"api_secret\"] = uri[2];\n                                    }\n                                    if (uri[4] != null) {\n                                        this.configuration[\"private_cdn\"] = uri[4] != null;\n                                    }\n                                    if (uri[4] != null) {\n                                        this.configuration[\"secure_distribution\"] = uri[4];\n                                    }\n                                    query = uri[5];\n                                    if (query != null) {\n                                        query.split(\"&\").forEach(function(value) {\n                                            var _value$split = value.split(\"=\"), _value$split2 = _slicedToArray(_value$split, 2), k = _value$split2[0], v = _value$split2[1];\n                                            if (v == null) {\n                                                v = true;\n                                            }\n                                            _this.configuration[k] = v;\n                                        });\n                                    }\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"config\",\n                        value: function config(new_config, new_value) {\n                            switch(false){\n                                case new_value === void 0:\n                                    this.set(new_config, new_value);\n                                    return this.configuration;\n                                case !isString_root_isString_default()(new_config):\n                                    return this.get(new_config);\n                                case !isPlainObject_root_isPlainObject_default()(new_config):\n                                    this.merge(new_config);\n                                    return this.configuration;\n                                default:\n                                    // Backward compatibility - return the internal object\n                                    return this.configuration;\n                            }\n                        }\n                    },\n                    {\n                        key: \"toOptions\",\n                        value: function toOptions() {\n                            return cloneDeep_root_cloneDeep_default()(this.configuration);\n                        }\n                    }\n                ]);\n            }();\n            var DEFAULT_CONFIGURATION_PARAMS = {\n                responsive_class: \"cld-responsive\",\n                responsive_use_breakpoints: true,\n                round_dpr: true,\n                secure: ( false ? 0 : void 0) === \"https:\"\n            };\n            configuration_Configuration.CONFIG_PARAMS = [\n                \"api_key\",\n                \"api_secret\",\n                \"callback\",\n                \"cdn_subdomain\",\n                \"cloud_name\",\n                \"cname\",\n                \"private_cdn\",\n                \"protocol\",\n                \"resource_type\",\n                \"responsive\",\n                \"responsive_class\",\n                \"responsive_use_breakpoints\",\n                \"responsive_width\",\n                \"round_dpr\",\n                \"secure\",\n                \"secure_cdn_subdomain\",\n                \"secure_distribution\",\n                \"shorten\",\n                \"type\",\n                \"upload_preset\",\n                \"url_suffix\",\n                \"use_root_path\",\n                \"version\",\n                \"externalLibraries\",\n                \"max_timeout_ms\"\n            ];\n            /* harmony default export */ var src_configuration = configuration_Configuration;\n            // CONCATENATED MODULE: ./src/layer/layer.js\n            function layer_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return layer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, layer_typeof(o);\n            }\n            function layer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function layer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, layer_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function layer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) layer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) layer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function layer_toPropertyKey(t) {\n                var i = layer_toPrimitive(t, \"string\");\n                return \"symbol\" == layer_typeof(i) ? i : i + \"\";\n            }\n            function layer_toPrimitive(t, r) {\n                if (\"object\" != layer_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != layer_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            var layer_Layer = /*#__PURE__*/ function() {\n                /**\n   * Layer\n   * @constructor Layer\n   * @param {Object} options - layer parameters\n   */ function Layer1(options) {\n                    var _this = this;\n                    layer_classCallCheck(this, Layer1);\n                    this.options = {};\n                    if (options != null) {\n                        [\n                            \"resourceType\",\n                            \"type\",\n                            \"publicId\",\n                            \"format\"\n                        ].forEach(function(key) {\n                            var ref;\n                            return _this.options[key] = (ref = options[key]) != null ? ref : options[snakeCase(key)];\n                        });\n                    }\n                }\n                return layer_createClass(Layer1, [\n                    {\n                        key: \"resourceType\",\n                        value: function resourceType(value) {\n                            this.options.resourceType = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"type\",\n                        value: function type(value) {\n                            this.options.type = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"publicId\",\n                        value: function publicId(value) {\n                            this.options.publicId = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"getPublicId\",\n                        value: function getPublicId() {\n                            var ref;\n                            return (ref = this.options.publicId) != null ? ref.replace(/\\//g, \":\") : void 0;\n                        }\n                    },\n                    {\n                        key: \"getFullPublicId\",\n                        value: function getFullPublicId() {\n                            if (this.options.format != null) {\n                                return this.getPublicId() + \".\" + this.options.format;\n                            } else {\n                                return this.getPublicId();\n                            }\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(value) {\n                            this.options.format = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            var components;\n                            components = [];\n                            if (this.options.publicId == null) {\n                                throw \"Must supply publicId\";\n                            }\n                            if (!(this.options.resourceType === \"image\")) {\n                                components.push(this.options.resourceType);\n                            }\n                            if (!(this.options.type === \"upload\")) {\n                                components.push(this.options.type);\n                            }\n                            components.push(this.getFullPublicId());\n                            return compact_root_compact_default()(components).join(\":\");\n                        }\n                    },\n                    {\n                        key: \"clone\",\n                        value: function clone() {\n                            return new this.constructor(this.options);\n                        }\n                    }\n                ]);\n            }();\n            /* harmony default export */ var layer_layer = layer_Layer;\n            // CONCATENATED MODULE: ./src/layer/textlayer.js\n            function textlayer_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return textlayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, textlayer_typeof(o);\n            }\n            function textlayer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function textlayer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, textlayer_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function textlayer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) textlayer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) textlayer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function textlayer_toPropertyKey(t) {\n                var i = textlayer_toPrimitive(t, \"string\");\n                return \"symbol\" == textlayer_typeof(i) ? i : i + \"\";\n            }\n            function textlayer_toPrimitive(t, r) {\n                if (\"object\" != textlayer_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != textlayer_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function textlayer_callSuper(t, o, e) {\n                return o = textlayer_getPrototypeOf(o), textlayer_possibleConstructorReturn(t, textlayer_isNativeReflectConstruct() ? Reflect.construct(o, e || [], textlayer_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function textlayer_possibleConstructorReturn(self, call) {\n                if (call && (textlayer_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return textlayer_assertThisInitialized(self);\n            }\n            function textlayer_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function textlayer_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (textlayer_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function textlayer_getPrototypeOf(o) {\n                textlayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return textlayer_getPrototypeOf(o);\n            }\n            function textlayer_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) textlayer_setPrototypeOf(subClass, superClass);\n            }\n            function textlayer_setPrototypeOf(o, p) {\n                textlayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return textlayer_setPrototypeOf(o, p);\n            }\n            var textlayer_TextLayer = /*#__PURE__*/ function(_Layer) {\n                /**\n   * @constructor TextLayer\n   * @param {Object} options - layer parameters\n   */ function TextLayer(options) {\n                    var _this;\n                    textlayer_classCallCheck(this, TextLayer);\n                    var keys;\n                    _this = textlayer_callSuper(this, TextLayer, [\n                        options\n                    ]);\n                    keys = [\n                        \"resourceType\",\n                        \"resourceType\",\n                        \"fontFamily\",\n                        \"fontSize\",\n                        \"fontWeight\",\n                        \"fontStyle\",\n                        \"textDecoration\",\n                        \"textAlign\",\n                        \"stroke\",\n                        \"letterSpacing\",\n                        \"lineSpacing\",\n                        \"fontHinting\",\n                        \"fontAntialiasing\",\n                        \"text\",\n                        \"textStyle\"\n                    ];\n                    if (options != null) {\n                        keys.forEach(function(key) {\n                            var ref;\n                            return _this.options[key] = (ref = options[key]) != null ? ref : options[snakeCase(key)];\n                        });\n                    }\n                    _this.options.resourceType = \"text\";\n                    return _this;\n                }\n                textlayer_inherits(TextLayer, _Layer);\n                return textlayer_createClass(TextLayer, [\n                    {\n                        key: \"resourceType\",\n                        value: function resourceType(_resourceType) {\n                            throw \"Cannot modify resourceType for text layers\";\n                        }\n                    },\n                    {\n                        key: \"type\",\n                        value: function type(_type) {\n                            throw \"Cannot modify type for text layers\";\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(_format) {\n                            throw \"Cannot modify format for text layers\";\n                        }\n                    },\n                    {\n                        key: \"fontFamily\",\n                        value: function fontFamily(_fontFamily) {\n                            this.options.fontFamily = _fontFamily;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontSize\",\n                        value: function fontSize(_fontSize) {\n                            this.options.fontSize = _fontSize;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontWeight\",\n                        value: function fontWeight(_fontWeight) {\n                            this.options.fontWeight = _fontWeight;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontStyle\",\n                        value: function fontStyle(_fontStyle) {\n                            this.options.fontStyle = _fontStyle;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textDecoration\",\n                        value: function textDecoration(_textDecoration) {\n                            this.options.textDecoration = _textDecoration;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textAlign\",\n                        value: function textAlign(_textAlign) {\n                            this.options.textAlign = _textAlign;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"stroke\",\n                        value: function stroke(_stroke) {\n                            this.options.stroke = _stroke;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"letterSpacing\",\n                        value: function letterSpacing(_letterSpacing) {\n                            this.options.letterSpacing = _letterSpacing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"lineSpacing\",\n                        value: function lineSpacing(_lineSpacing) {\n                            this.options.lineSpacing = _lineSpacing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontHinting\",\n                        value: function fontHinting(_fontHinting) {\n                            this.options.fontHinting = _fontHinting;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontAntialiasing\",\n                        value: function fontAntialiasing(_fontAntialiasing) {\n                            this.options.fontAntialiasing = _fontAntialiasing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"text\",\n                        value: function text(_text) {\n                            this.options.text = _text;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textStyle\",\n                        value: function textStyle(_textStyle) {\n                            this.options.textStyle = _textStyle;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            var components, hasPublicId, hasStyle, publicId, re, res, start, style, text, textSource;\n                            style = this.textStyleIdentifier();\n                            if (this.options.publicId != null) {\n                                publicId = this.getFullPublicId();\n                            }\n                            if (this.options.text != null) {\n                                hasPublicId = !isEmpty(publicId);\n                                hasStyle = !isEmpty(style);\n                                if (hasPublicId && hasStyle || !hasPublicId && !hasStyle) {\n                                    throw \"Must supply either style parameters or a public_id when providing text parameter in a text overlay/underlay, but not both!\";\n                                }\n                                re = /\\$\\([a-zA-Z]\\w*\\)/g;\n                                start = 0;\n                                //        textSource = text.replace(new RegExp(\"[,/]\", 'g'), (c)-> \"%#{c.charCodeAt(0).toString(16).toUpperCase()}\")\n                                textSource = smartEscape(this.options.text, /[,\\/]/g);\n                                text = \"\";\n                                while(res = re.exec(textSource)){\n                                    text += smartEscape(textSource.slice(start, res.index));\n                                    text += res[0];\n                                    start = res.index + res[0].length;\n                                }\n                                text += smartEscape(textSource.slice(start));\n                            }\n                            components = [\n                                this.options.resourceType,\n                                style,\n                                publicId,\n                                text\n                            ];\n                            return compact_root_compact_default()(components).join(\":\");\n                        }\n                    },\n                    {\n                        key: \"textStyleIdentifier\",\n                        value: function textStyleIdentifier() {\n                            // Note: if a text-style argument is provided as a whole, it overrides everything else, no mix and match.\n                            if (!isEmpty(this.options.textStyle)) {\n                                return this.options.textStyle;\n                            }\n                            var components;\n                            components = [];\n                            if (this.options.fontWeight !== \"normal\") {\n                                components.push(this.options.fontWeight);\n                            }\n                            if (this.options.fontStyle !== \"normal\") {\n                                components.push(this.options.fontStyle);\n                            }\n                            if (this.options.textDecoration !== \"none\") {\n                                components.push(this.options.textDecoration);\n                            }\n                            components.push(this.options.textAlign);\n                            if (this.options.stroke !== \"none\") {\n                                components.push(this.options.stroke);\n                            }\n                            if (!(isEmpty(this.options.letterSpacing) && !isNumberLike(this.options.letterSpacing))) {\n                                components.push(\"letter_spacing_\" + this.options.letterSpacing);\n                            }\n                            if (!(isEmpty(this.options.lineSpacing) && !isNumberLike(this.options.lineSpacing))) {\n                                components.push(\"line_spacing_\" + this.options.lineSpacing);\n                            }\n                            if (!isEmpty(this.options.fontAntialiasing)) {\n                                components.push(\"antialias_\" + this.options.fontAntialiasing);\n                            }\n                            if (!isEmpty(this.options.fontHinting)) {\n                                components.push(\"hinting_\" + this.options.fontHinting);\n                            }\n                            if (!isEmpty(compact_root_compact_default()(components))) {\n                                if (isEmpty(this.options.fontFamily)) {\n                                    throw \"Must supply fontFamily. \".concat(components);\n                                }\n                                if (isEmpty(this.options.fontSize) && !isNumberLike(this.options.fontSize)) {\n                                    throw \"Must supply fontSize.\";\n                                }\n                            }\n                            components.unshift(this.options.fontFamily, this.options.fontSize);\n                            components = compact_root_compact_default()(components).join(\"_\");\n                            return components;\n                        }\n                    }\n                ]);\n            }(layer_layer);\n            ;\n            /* harmony default export */ var textlayer = textlayer_TextLayer;\n            // CONCATENATED MODULE: ./src/layer/subtitleslayer.js\n            function subtitleslayer_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return subtitleslayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, subtitleslayer_typeof(o);\n            }\n            function subtitleslayer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, subtitleslayer_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function subtitleslayer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) subtitleslayer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) subtitleslayer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function subtitleslayer_toPropertyKey(t) {\n                var i = subtitleslayer_toPrimitive(t, \"string\");\n                return \"symbol\" == subtitleslayer_typeof(i) ? i : i + \"\";\n            }\n            function subtitleslayer_toPrimitive(t, r) {\n                if (\"object\" != subtitleslayer_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != subtitleslayer_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function subtitleslayer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function subtitleslayer_callSuper(t, o, e) {\n                return o = subtitleslayer_getPrototypeOf(o), subtitleslayer_possibleConstructorReturn(t, subtitleslayer_isNativeReflectConstruct() ? Reflect.construct(o, e || [], subtitleslayer_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function subtitleslayer_possibleConstructorReturn(self, call) {\n                if (call && (subtitleslayer_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return subtitleslayer_assertThisInitialized(self);\n            }\n            function subtitleslayer_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function subtitleslayer_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (subtitleslayer_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function subtitleslayer_getPrototypeOf(o) {\n                subtitleslayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return subtitleslayer_getPrototypeOf(o);\n            }\n            function subtitleslayer_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) subtitleslayer_setPrototypeOf(subClass, superClass);\n            }\n            function subtitleslayer_setPrototypeOf(o, p) {\n                subtitleslayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return subtitleslayer_setPrototypeOf(o, p);\n            }\n            var SubtitlesLayer = /*#__PURE__*/ function(_TextLayer) {\n                /**\n   * Represent a subtitles layer\n   * @constructor SubtitlesLayer\n   * @param {Object} options - layer parameters\n   */ function SubtitlesLayer(options) {\n                    var _this;\n                    subtitleslayer_classCallCheck(this, SubtitlesLayer);\n                    _this = subtitleslayer_callSuper(this, SubtitlesLayer, [\n                        options\n                    ]);\n                    _this.options.resourceType = \"subtitles\";\n                    return _this;\n                }\n                subtitleslayer_inherits(SubtitlesLayer, _TextLayer);\n                return subtitleslayer_createClass(SubtitlesLayer);\n            }(textlayer);\n            /* harmony default export */ var subtitleslayer = SubtitlesLayer;\n            // CONCATENATED MODULE: ./src/layer/fetchlayer.js\n            function fetchlayer_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return fetchlayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, fetchlayer_typeof(o);\n            }\n            function fetchlayer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function fetchlayer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, fetchlayer_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function fetchlayer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) fetchlayer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) fetchlayer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function fetchlayer_toPropertyKey(t) {\n                var i = fetchlayer_toPrimitive(t, \"string\");\n                return \"symbol\" == fetchlayer_typeof(i) ? i : i + \"\";\n            }\n            function fetchlayer_toPrimitive(t, r) {\n                if (\"object\" != fetchlayer_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != fetchlayer_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function fetchlayer_callSuper(t, o, e) {\n                return o = fetchlayer_getPrototypeOf(o), fetchlayer_possibleConstructorReturn(t, fetchlayer_isNativeReflectConstruct() ? Reflect.construct(o, e || [], fetchlayer_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function fetchlayer_possibleConstructorReturn(self, call) {\n                if (call && (fetchlayer_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return fetchlayer_assertThisInitialized(self);\n            }\n            function fetchlayer_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function fetchlayer_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (fetchlayer_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function fetchlayer_getPrototypeOf(o) {\n                fetchlayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return fetchlayer_getPrototypeOf(o);\n            }\n            function fetchlayer_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) fetchlayer_setPrototypeOf(subClass, superClass);\n            }\n            function fetchlayer_setPrototypeOf(o, p) {\n                fetchlayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return fetchlayer_setPrototypeOf(o, p);\n            }\n            var fetchlayer_FetchLayer = /*#__PURE__*/ function(_Layer) {\n                /**\n   * @class FetchLayer\n   * @classdesc Creates an image layer using a remote URL.\n   * @param {Object|string} options - layer parameters or a url\n   * @param {string} options.url the url of the image to fetch\n   */ function FetchLayer(options) {\n                    var _this;\n                    fetchlayer_classCallCheck(this, FetchLayer);\n                    _this = fetchlayer_callSuper(this, FetchLayer, [\n                        options\n                    ]);\n                    if (isString_root_isString_default()(options)) {\n                        _this.options.url = options;\n                    } else if (options != null ? options.url : void 0) {\n                        _this.options.url = options.url;\n                    }\n                    return _this;\n                }\n                fetchlayer_inherits(FetchLayer, _Layer);\n                return fetchlayer_createClass(FetchLayer, [\n                    {\n                        key: \"url\",\n                        value: function url(_url) {\n                            this.options.url = _url;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return \"fetch:\".concat(base64EncodeURL(this.options.url));\n                        }\n                    }\n                ]);\n            }(layer_layer);\n            /* harmony default export */ var fetchlayer = fetchlayer_FetchLayer;\n            // CONCATENATED MODULE: ./src/parameters.js\n            function parameters_callSuper(t, o, e) {\n                return o = parameters_getPrototypeOf(o), parameters_possibleConstructorReturn(t, parameters_isNativeReflectConstruct() ? Reflect.construct(o, e || [], parameters_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function parameters_possibleConstructorReturn(self, call) {\n                if (call && (parameters_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return parameters_assertThisInitialized(self);\n            }\n            function parameters_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function parameters_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (parameters_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function _get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    _get = Reflect.get.bind();\n                } else {\n                    _get = function _get(target, property, receiver) {\n                        var base = _superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return _get.apply(this, arguments);\n            }\n            function _superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = parameters_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function parameters_getPrototypeOf(o) {\n                parameters_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return parameters_getPrototypeOf(o);\n            }\n            function parameters_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) parameters_setPrototypeOf(subClass, superClass);\n            }\n            function parameters_setPrototypeOf(o, p) {\n                parameters_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return parameters_setPrototypeOf(o, p);\n            }\n            function parameters_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return parameters_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, parameters_typeof(o);\n            }\n            function parameters_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function parameters_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, parameters_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function parameters_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) parameters_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) parameters_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function parameters_toPropertyKey(t) {\n                var i = parameters_toPrimitive(t, \"string\");\n                return \"symbol\" == parameters_typeof(i) ? i : i + \"\";\n            }\n            function parameters_toPrimitive(t, r) {\n                if (\"object\" != parameters_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != parameters_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            /**\n * Transformation parameters\n * Depends on 'util', 'transformation'\n */ var parameters_Param = /*#__PURE__*/ function() {\n                /**\n   * Represents a single parameter.\n   * @class Param\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter.\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @ignore\n   */ function Param(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity_root_identity_default.a;\n                    parameters_classCallCheck(this, Param);\n                    /**\n     * The name of the parameter in snake_case\n     * @member {string} Param#name\n     */ this.name = name;\n                    /**\n     * The name of the serialized form of the parameter\n     * @member {string} Param#shortName\n     */ this.shortName = shortName;\n                    /**\n     * Manipulate origValue when value is called\n     * @member {function} Param#process\n     */ this.process = process1;\n                }\n                /**\n   * Set a (unprocessed) value for this parameter\n   * @function Param#set\n   * @param {*} origValue - the value of the parameter\n   * @return {Param} self for chaining\n   */ return parameters_createClass(Param, [\n                    {\n                        key: \"set\",\n                        value: function set(origValue) {\n                            this.origValue = origValue;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var val, valid;\n                            val = this.value();\n                            valid = isArray_root_isArray_default()(val) || isPlainObject_root_isPlainObject_default()(val) || isString_root_isString_default()(val) ? !isEmpty(val) : val != null;\n                            if (this.shortName != null && valid) {\n                                return \"\".concat(this.shortName, \"_\").concat(val);\n                            } else {\n                                return \"\";\n                            }\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            return this.process(this.origValue);\n                        }\n                    }\n                ], [\n                    {\n                        key: \"norm_color\",\n                        value: function norm_color(value) {\n                            return value != null ? value.replace(/^#/, \"rgb:\") : void 0;\n                        }\n                    },\n                    {\n                        key: \"build_array\",\n                        value: function build_array(arg) {\n                            if (arg == null) {\n                                return [];\n                            } else if (isArray_root_isArray_default()(arg)) {\n                                return arg;\n                            } else {\n                                return [\n                                    arg\n                                ];\n                            }\n                        }\n                    },\n                    {\n                        key: \"process_video_params\",\n                        value: function process_video_params(param) {\n                            var video;\n                            switch(param.constructor){\n                                case Object:\n                                    video = \"\";\n                                    if (\"codec\" in param) {\n                                        video = param.codec;\n                                        if (\"profile\" in param) {\n                                            video += \":\" + param.profile;\n                                            if (\"level\" in param) {\n                                                video += \":\" + param.level;\n                                                if (\"b_frames\" in param && param.b_frames === false) {\n                                                    video += \":bframes_no\";\n                                                }\n                                            }\n                                        }\n                                    }\n                                    return video;\n                                case String:\n                                    return param;\n                                default:\n                                    return null;\n                            }\n                        }\n                    }\n                ]);\n            }();\n            var parameters_ArrayParam = /*#__PURE__*/ function(_Param) {\n                /**\n   * A parameter that represents an array.\n   * @param {string} name - The name of the parameter in snake_case.\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class ArrayParam\n   * @extends Param\n   * @ignore\n   */ function ArrayParam(name, shortName) {\n                    var _this;\n                    var sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n                    var process1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n                    parameters_classCallCheck(this, ArrayParam);\n                    _this = parameters_callSuper(this, ArrayParam, [\n                        name,\n                        shortName,\n                        process1\n                    ]);\n                    _this.sep = sep;\n                    return _this;\n                }\n                parameters_inherits(ArrayParam, _Param);\n                return parameters_createClass(ArrayParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            if (this.shortName != null) {\n                                var arrayValue = this.value();\n                                if (isEmpty(arrayValue)) {\n                                    return \"\";\n                                } else if (isString_root_isString_default()(arrayValue)) {\n                                    return \"\".concat(this.shortName, \"_\").concat(arrayValue);\n                                } else {\n                                    var flat = arrayValue.map(function(t) {\n                                        return isFunction_root_isFunction_default()(t.serialize) ? t.serialize() : t;\n                                    }).join(this.sep);\n                                    return \"\".concat(this.shortName, \"_\").concat(flat);\n                                }\n                            } else {\n                                return \"\";\n                            }\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            var _this2 = this;\n                            if (isArray_root_isArray_default()(this.origValue)) {\n                                return this.origValue.map(function(v) {\n                                    return _this2.process(v);\n                                });\n                            } else {\n                                return this.process(this.origValue);\n                            }\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(origValue) {\n                            if (origValue == null || isArray_root_isArray_default()(origValue)) {\n                                return _get(parameters_getPrototypeOf(ArrayParam.prototype), \"set\", this).call(this, origValue);\n                            } else {\n                                return _get(parameters_getPrototypeOf(ArrayParam.prototype), \"set\", this).call(this, [\n                                    origValue\n                                ]);\n                            }\n                        }\n                    }\n                ]);\n            }(parameters_Param);\n            var parameters_TransformationParam = /*#__PURE__*/ function(_Param2) {\n                /**\n   * A parameter that represents a transformation\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} [shortName='t'] - The name of the serialized form of the parameter\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class TransformationParam\n   * @extends Param\n   * @ignore\n   */ function TransformationParam(name) {\n                    var _this3;\n                    var shortName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"t\";\n                    var sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n                    var process1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n                    parameters_classCallCheck(this, TransformationParam);\n                    _this3 = parameters_callSuper(this, TransformationParam, [\n                        name,\n                        shortName,\n                        process1\n                    ]);\n                    _this3.sep = sep;\n                    return _this3;\n                }\n                /**\n   * Generate string representations of the transformation.\n   * @returns {*} Returns either the transformation as a string, or an array of string representations.\n   */ parameters_inherits(TransformationParam, _Param2);\n                return parameters_createClass(TransformationParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var _this4 = this;\n                            var result = \"\";\n                            var val = this.value();\n                            if (isEmpty(val)) {\n                                return result;\n                            }\n                            // val is an array of strings so join them\n                            if (baseutil_allStrings(val)) {\n                                var joined = val.join(this.sep); // creates t1.t2.t3 in case multiple named transformations were configured\n                                if (!isEmpty(joined)) {\n                                    // in case options.transformation was not set with an empty string (val != ['']);\n                                    result = \"\".concat(this.shortName, \"_\").concat(joined);\n                                }\n                            } else {\n                                // Convert val to an array of strings\n                                result = val.map(function(t) {\n                                    if (isString_root_isString_default()(t) && !isEmpty(t)) {\n                                        return \"\".concat(_this4.shortName, \"_\").concat(t);\n                                    }\n                                    if (isFunction_root_isFunction_default()(t.serialize)) {\n                                        return t.serialize();\n                                    }\n                                    if (isPlainObject_root_isPlainObject_default()(t) && !isEmpty(t)) {\n                                        return new src_transformation(t).serialize();\n                                    }\n                                    return undefined;\n                                }).filter(function(t) {\n                                    return t;\n                                });\n                            }\n                            return result;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(origValue1) {\n                            this.origValue = origValue1;\n                            if (isArray_root_isArray_default()(this.origValue)) {\n                                return _get(parameters_getPrototypeOf(TransformationParam.prototype), \"set\", this).call(this, this.origValue);\n                            } else {\n                                return _get(parameters_getPrototypeOf(TransformationParam.prototype), \"set\", this).call(this, [\n                                    this.origValue\n                                ]);\n                            }\n                        }\n                    }\n                ]);\n            }(parameters_Param);\n            var number_pattern = \"([0-9]*)\\\\.([0-9]+)|([0-9]+)\";\n            var offset_any_pattern = \"(\" + number_pattern + \")([%pP])?\";\n            var parameters_RangeParam = /*#__PURE__*/ function(_Param3) {\n                /**\n   * A parameter that represents a range\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=norm_range_value ] - Manipulate origValue when value is called\n   * @class RangeParam\n   * @extends Param\n   * @ignore\n   */ function RangeParam(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : RangeParam.norm_range_value;\n                    parameters_classCallCheck(this, RangeParam);\n                    return parameters_callSuper(this, RangeParam, [\n                        name,\n                        shortName,\n                        process1\n                    ]);\n                }\n                parameters_inherits(RangeParam, _Param3);\n                return parameters_createClass(RangeParam, null, [\n                    {\n                        key: \"norm_range_value\",\n                        value: function norm_range_value(value) {\n                            var offset = String(value).match(new RegExp(\"^\" + offset_any_pattern + \"$\"));\n                            if (offset) {\n                                var modifier = offset[5] != null ? \"p\" : \"\";\n                                value = (offset[1] || offset[4]) + modifier;\n                            }\n                            return expression.normalize(value);\n                        }\n                    }\n                ]);\n            }(parameters_Param);\n            var parameters_RawParam = /*#__PURE__*/ function(_Param4) {\n                function RawParam(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity_root_identity_default.a;\n                    parameters_classCallCheck(this, RawParam);\n                    return parameters_callSuper(this, RawParam, [\n                        name,\n                        shortName,\n                        process1\n                    ]);\n                }\n                parameters_inherits(RawParam, _Param4);\n                return parameters_createClass(RawParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            return this.value();\n                        }\n                    }\n                ]);\n            }(parameters_Param);\n            var parameters_LayerParam = /*#__PURE__*/ function(_Param5) {\n                function LayerParam() {\n                    parameters_classCallCheck(this, LayerParam);\n                    return parameters_callSuper(this, LayerParam, arguments);\n                }\n                parameters_inherits(LayerParam, _Param5);\n                return parameters_createClass(LayerParam, [\n                    {\n                        key: \"value\",\n                        value: // Parse layer options\n                        // @return [string] layer transformation string\n                        // @private\n                        function value() {\n                            if (this.origValue == null) {\n                                return \"\";\n                            }\n                            var result;\n                            if (this.origValue instanceof layer_layer) {\n                                result = this.origValue;\n                            } else if (isPlainObject_root_isPlainObject_default()(this.origValue)) {\n                                var layerOptions = withCamelCaseKeys(this.origValue);\n                                if (layerOptions.resourceType === \"text\" || layerOptions.text != null) {\n                                    result = new textlayer(layerOptions);\n                                } else if (layerOptions.resourceType === \"subtitles\") {\n                                    result = new subtitleslayer(layerOptions);\n                                } else if (layerOptions.resourceType === \"fetch\" || layerOptions.url != null) {\n                                    result = new fetchlayer(layerOptions);\n                                } else {\n                                    result = new layer_layer(layerOptions);\n                                }\n                            } else if (isString_root_isString_default()(this.origValue)) {\n                                if (/^fetch:.+/.test(this.origValue)) {\n                                    result = new fetchlayer(this.origValue.substr(6));\n                                } else {\n                                    result = this.origValue;\n                                }\n                            } else {\n                                result = \"\";\n                            }\n                            return result.toString();\n                        }\n                    }\n                ], [\n                    {\n                        key: \"textStyle\",\n                        value: function textStyle(layer) {\n                            return new textlayer(layer).textStyleIdentifier();\n                        }\n                    }\n                ]);\n            }(parameters_Param);\n            var parameters_ExpressionParam = /*#__PURE__*/ function(_Param6) {\n                function ExpressionParam() {\n                    parameters_classCallCheck(this, ExpressionParam);\n                    return parameters_callSuper(this, ExpressionParam, arguments);\n                }\n                parameters_inherits(ExpressionParam, _Param6);\n                return parameters_createClass(ExpressionParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            return expression.normalize(_get(parameters_getPrototypeOf(ExpressionParam.prototype), \"serialize\", this).call(this));\n                        }\n                    }\n                ]);\n            }(parameters_Param);\n            // CONCATENATED MODULE: ./src/transformation.js\n            function transformation_callSuper(t, o, e) {\n                return o = transformation_getPrototypeOf(o), transformation_possibleConstructorReturn(t, transformation_isNativeReflectConstruct() ? Reflect.construct(o, e || [], transformation_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function transformation_possibleConstructorReturn(self, call) {\n                if (call && (transformation_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return transformation_assertThisInitialized(self);\n            }\n            function transformation_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function transformation_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (transformation_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function transformation_getPrototypeOf(o) {\n                transformation_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return transformation_getPrototypeOf(o);\n            }\n            function transformation_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) transformation_setPrototypeOf(subClass, superClass);\n            }\n            function transformation_setPrototypeOf(o, p) {\n                transformation_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return transformation_setPrototypeOf(o, p);\n            }\n            function transformation_slicedToArray(arr, i) {\n                return transformation_arrayWithHoles(arr) || transformation_iterableToArrayLimit(arr, i) || transformation_unsupportedIterableToArray(arr, i) || transformation_nonIterableRest();\n            }\n            function transformation_nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function transformation_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return transformation_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return transformation_arrayLikeToArray(o, minLen);\n            }\n            function transformation_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n                return arr2;\n            }\n            function transformation_iterableToArrayLimit(r, l) {\n                var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n                if (null != t) {\n                    var e, n, i, u, a = [], f = !0, o = !1;\n                    try {\n                        if (i = (t = t.call(r)).next, 0 === l) {\n                            if (Object(t) !== t) return;\n                            f = !1;\n                        } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n                    } catch (r) {\n                        o = !0, n = r;\n                    } finally{\n                        try {\n                            if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n                        } finally{\n                            if (o) throw n;\n                        }\n                    }\n                    return a;\n                }\n            }\n            function transformation_arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            function transformation_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return transformation_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, transformation_typeof(o);\n            }\n            function transformation_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function transformation_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, transformation_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function transformation_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) transformation_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) transformation_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function transformation_toPropertyKey(t) {\n                var i = transformation_toPrimitive(t, \"string\");\n                return \"symbol\" == transformation_typeof(i) ? i : i + \"\";\n            }\n            function transformation_toPrimitive(t, r) {\n                if (\"object\" != transformation_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != transformation_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            /**\n * Assign key, value to target, when value is not null.<br>\n *   This function mutates the target!\n * @param {object} target the object to assign the values to\n * @param {object} sources one or more objects to get values from\n * @returns {object} the target after the assignment\n */ function assignNotNull(target) {\n                for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    sources[_key - 1] = arguments[_key];\n                }\n                sources.forEach(function(source) {\n                    Object.keys(source).forEach(function(key) {\n                        if (source[key] != null) {\n                            target[key] = source[key];\n                        }\n                    });\n                });\n                return target;\n            }\n            /**\n * TransformationBase\n * Depends on 'configuration', 'parameters','util'\n * @internal\n */ var transformation_TransformationBase = /*#__PURE__*/ function() {\n                /**\n   * The base class for transformations.\n   * Members of this class are documented as belonging to the {@link Transformation} class for convenience.\n   * @class TransformationBase\n   */ function TransformationBase(options) {\n                    transformation_classCallCheck(this, TransformationBase);\n                    /** @private */ /** @private */ var parent, trans;\n                    parent = void 0;\n                    trans = {};\n                    /**\n     * Return an options object that can be used to create an identical Transformation\n     * @function Transformation#toOptions\n     * @return {Object} Returns a plain object representing this transformation\n     */ this.toOptions = function(withChain) {\n                        var opt = {};\n                        if (withChain == null) {\n                            withChain = true;\n                        }\n                        Object.keys(trans).forEach(function(key) {\n                            return opt[key] = trans[key].origValue;\n                        });\n                        assignNotNull(opt, this.otherOptions);\n                        if (withChain && !isEmpty(this.chained)) {\n                            var list = this.chained.map(function(tr) {\n                                return tr.toOptions();\n                            });\n                            list.push(opt);\n                            opt = {};\n                            assignNotNull(opt, this.otherOptions);\n                            opt.transformation = list;\n                        }\n                        return opt;\n                    };\n                    /**\n     * Set a parent for this object for chaining purposes.\n     *\n     * @function Transformation#setParent\n     * @param {Object} object - the parent to be assigned to\n     * @returns {Transformation} Returns this instance for chaining purposes.\n     */ this.setParent = function(object) {\n                        parent = object;\n                        if (object != null) {\n                            this.fromOptions(typeof object.toOptions === \"function\" ? object.toOptions() : void 0);\n                        }\n                        return this;\n                    };\n                    /**\n     * Returns the parent of this object in the chain\n     * @function Transformation#getParent\n     * @protected\n     * @return {Object} Returns the parent of this object if there is any\n     */ this.getParent = function() {\n                        return parent;\n                    };\n                    // Helper methods to create parameter methods\n                    // These methods are defined here because they access `trans` which is\n                    // a private member of `TransformationBase`\n                    /** @protected */ this.param = function(value, name, abbr, defaultValue, process1) {\n                        if (process1 == null) {\n                            if (isFunction_root_isFunction_default()(defaultValue)) {\n                                process1 = defaultValue;\n                            } else {\n                                process1 = identity_root_identity_default.a;\n                            }\n                        }\n                        trans[name] = new parameters_Param(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.rawParam = function(value, name, abbr, defaultValue, process1) {\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_RawParam(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.rangeParam = function(value, name, abbr, defaultValue, process1) {\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_RangeParam(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.arrayParam = function(value, name, abbr) {\n                        var sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \":\";\n                        var defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n                        var process1 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_ArrayParam(name, abbr, sep, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.transformationParam = function(value, name, abbr) {\n                        var sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \".\";\n                        var defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n                        var process1 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_TransformationParam(name, abbr, sep, process1).set(value);\n                        return this;\n                    };\n                    this.layerParam = function(value, name, abbr) {\n                        trans[name] = new parameters_LayerParam(name, abbr).set(value);\n                        return this;\n                    };\n                    // End Helper methods\n                    /**\n     * Get the value associated with the given name.\n     * @function Transformation#getValue\n     * @param {string} name - the name of the parameter\n     * @return {*} the processed value associated with the given name\n     * @description Use {@link get}.origValue for the value originally provided for the parameter\n     */ this.getValue = function(name) {\n                        var value = trans[name] && trans[name].value();\n                        return value != null ? value : this.otherOptions[name];\n                    };\n                    /**\n     * Get the parameter object for the given parameter name\n     * @function Transformation#get\n     * @param {string} name the name of the transformation parameter\n     * @returns {Param} the param object for the given name, or undefined\n     */ this.get = function(name) {\n                        return trans[name];\n                    };\n                    /**\n     * Remove a transformation option from the transformation.\n     * @function Transformation#remove\n     * @param {string} name - the name of the option to remove\n     * @return {*} Returns the option that was removed or null if no option by that name was found. The type of the\n     *              returned value depends on the value.\n     */ this.remove = function(name) {\n                        var temp;\n                        switch(false){\n                            case trans[name] == null:\n                                temp = trans[name];\n                                delete trans[name];\n                                return temp.origValue;\n                            case this.otherOptions[name] == null:\n                                temp = this.otherOptions[name];\n                                delete this.otherOptions[name];\n                                return temp;\n                            default:\n                                return null;\n                        }\n                    };\n                    /**\n     * Return an array of all the keys (option names) in the transformation.\n     * @return {Array<string>} the keys in snakeCase format\n     */ this.keys = function() {\n                        var key;\n                        return (function() {\n                            var results;\n                            results = [];\n                            for(key in trans){\n                                if (key != null) {\n                                    results.push(key.match(VAR_NAME_RE) ? key : snakeCase(key));\n                                }\n                            }\n                            return results;\n                        })().sort();\n                    };\n                    /**\n     * Returns a plain object representation of the transformation. Values are processed.\n     * @function Transformation#toPlainObject\n     * @return {Object} the transformation options as plain object\n     */ this.toPlainObject = function() {\n                        var hash, key, list;\n                        hash = {};\n                        for(key in trans){\n                            hash[key] = trans[key].value();\n                            if (isPlainObject_root_isPlainObject_default()(hash[key])) {\n                                hash[key] = cloneDeep_root_cloneDeep_default()(hash[key]);\n                            }\n                        }\n                        if (!isEmpty(this.chained)) {\n                            list = this.chained.map(function(tr) {\n                                return tr.toPlainObject();\n                            });\n                            list.push(hash);\n                            hash = {\n                                transformation: list\n                            };\n                        }\n                        return hash;\n                    };\n                    /**\n     * Complete the current transformation and chain to a new one.\n     * In the URL, transformations are chained together by slashes.\n     * @function Transformation#chain\n     * @return {Transformation} Returns this transformation for chaining\n     * @example\n     * var tr = cloudinary.Transformation.new();\n     * tr.width(10).crop('fit').chain().angle(15).serialize()\n     * // produces \"c_fit,w_10/a_15\"\n     */ this.chain = function() {\n                        var names, tr;\n                        names = Object.getOwnPropertyNames(trans);\n                        if (names.length !== 0) {\n                            tr = new this.constructor(this.toOptions(false));\n                            this.resetTransformations();\n                            this.chained.push(tr);\n                        }\n                        return this;\n                    };\n                    this.resetTransformations = function() {\n                        trans = {};\n                        return this;\n                    };\n                    this.otherOptions = {};\n                    this.chained = [];\n                    this.fromOptions(options);\n                }\n                /**\n   * Merge the provided options with own's options\n   * @param {Object} [options={}] key-value list of options\n   * @returns {Transformation} Returns this instance for chaining\n   */ return transformation_createClass(TransformationBase, [\n                    {\n                        key: \"fromOptions\",\n                        value: function fromOptions() {\n                            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                            if (options instanceof TransformationBase) {\n                                this.fromTransformation(options);\n                            } else {\n                                if (isString_root_isString_default()(options) || isArray_root_isArray_default()(options)) {\n                                    options = {\n                                        transformation: options\n                                    };\n                                }\n                                options = cloneDeep_root_cloneDeep_default()(options, function(value) {\n                                    if (value instanceof TransformationBase || value instanceof Layer) {\n                                        return new value.clone();\n                                    }\n                                });\n                                // Handling of \"if\" statements precedes other options as it creates a chained transformation\n                                if (options[\"if\"]) {\n                                    this.set(\"if\", options[\"if\"]);\n                                    delete options[\"if\"];\n                                }\n                                for(var key in options){\n                                    var opt = options[key];\n                                    if (opt != null) {\n                                        if (key.match(VAR_NAME_RE)) {\n                                            if (key !== \"$attr\") {\n                                                this.set(\"variable\", key, opt);\n                                            }\n                                        } else {\n                                            this.set(key, opt);\n                                        }\n                                    }\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromTransformation\",\n                        value: function fromTransformation(other) {\n                            var _this = this;\n                            if (other instanceof TransformationBase) {\n                                other.keys().forEach(function(key) {\n                                    return _this.set(key, other.get(key).origValue);\n                                });\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(key) {\n                            var camelKey;\n                            camelKey = camelCase(key);\n                            for(var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                                values[_key2 - 1] = arguments[_key2];\n                            }\n                            if (includes_root_includes_default()(transformation_Transformation.methods, camelKey)) {\n                                this[camelKey].apply(this, values);\n                            } else {\n                                this.otherOptions[key] = values[0];\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"hasLayer\",\n                        value: function hasLayer() {\n                            return this.getValue(\"overlay\") || this.getValue(\"underlay\");\n                        }\n                    },\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var ifParam, j, len, paramList, ref, ref1, ref2, ref3, ref4, resultArray, t, transformationList, transformationString, transformations, value, variables, vars;\n                            resultArray = this.chained.map(function(tr) {\n                                return tr.serialize();\n                            });\n                            paramList = this.keys();\n                            transformations = (ref = this.get(\"transformation\")) != null ? ref.serialize() : void 0;\n                            ifParam = (ref1 = this.get(\"if\")) != null ? ref1.serialize() : void 0;\n                            variables = processVar((ref2 = this.get(\"variables\")) != null ? ref2.value() : void 0);\n                            paramList = difference_root_difference_default()(paramList, [\n                                \"transformation\",\n                                \"if\",\n                                \"variables\"\n                            ]);\n                            vars = [];\n                            transformationList = [];\n                            for(j = 0, len = paramList.length; j < len; j++){\n                                t = paramList[j];\n                                if (t.match(VAR_NAME_RE)) {\n                                    vars.push(t + \"_\" + expression.normalize((ref3 = this.get(t)) != null ? ref3.value() : void 0));\n                                } else {\n                                    transformationList.push((ref4 = this.get(t)) != null ? ref4.serialize() : void 0);\n                                }\n                            }\n                            switch(false){\n                                case !isString_root_isString_default()(transformations):\n                                    transformationList.push(transformations);\n                                    break;\n                                case !isArray_root_isArray_default()(transformations):\n                                    resultArray = resultArray.concat(transformations);\n                            }\n                            transformationList = function() {\n                                var k, len1, results;\n                                results = [];\n                                for(k = 0, len1 = transformationList.length; k < len1; k++){\n                                    value = transformationList[k];\n                                    if (isArray_root_isArray_default()(value) && !isEmpty(value) || !isArray_root_isArray_default()(value) && value) {\n                                        results.push(value);\n                                    }\n                                }\n                                return results;\n                            }();\n                            transformationList = vars.sort().concat(variables).concat(transformationList.sort());\n                            if (ifParam === \"if_end\") {\n                                transformationList.push(ifParam);\n                            } else if (!isEmpty(ifParam)) {\n                                transformationList.unshift(ifParam);\n                            }\n                            transformationString = compact_root_compact_default()(transformationList).join(this.param_separator);\n                            if (!isEmpty(transformationString)) {\n                                resultArray.push(transformationString);\n                            }\n                            return compact_root_compact_default()(resultArray).join(this.trans_separator);\n                        }\n                    },\n                    {\n                        key: \"toHtmlAttributes\",\n                        value: /**\n     * Returns the attributes for an HTML tag.\n     * @function Cloudinary.toHtmlAttributes\n     * @return PlainObject\n     */ function toHtmlAttributes() {\n                            var _this2 = this;\n                            var attrName, height, options, ref2, ref3, value, width;\n                            options = {};\n                            var snakeCaseKey;\n                            Object.keys(this.otherOptions).forEach(function(key) {\n                                value = _this2.otherOptions[key];\n                                snakeCaseKey = snakeCase(key);\n                                if (!includes_root_includes_default()(transformation_Transformation.PARAM_NAMES, snakeCaseKey) && !includes_root_includes_default()(URL_KEYS, snakeCaseKey)) {\n                                    attrName = /^html_/.test(key) ? key.slice(5) : key;\n                                    options[attrName] = value;\n                                }\n                            });\n                            // convert all \"html_key\" to \"key\" with the same value\n                            this.keys().forEach(function(key) {\n                                if (/^html_/.test(key)) {\n                                    options[camelCase(key.slice(5))] = _this2.getValue(key);\n                                }\n                            });\n                            if (!(this.hasLayer() || this.getValue(\"angle\") || includes_root_includes_default()([\n                                \"fit\",\n                                \"limit\",\n                                \"lfill\"\n                            ], this.getValue(\"crop\")))) {\n                                width = (ref2 = this.get(\"width\")) != null ? ref2.origValue : void 0;\n                                height = (ref3 = this.get(\"height\")) != null ? ref3.origValue : void 0;\n                                if (parseFloat(width) >= 1.0) {\n                                    if (options.width == null) {\n                                        options.width = width;\n                                    }\n                                }\n                                if (parseFloat(height) >= 1.0) {\n                                    if (options.height == null) {\n                                        options.height = height;\n                                    }\n                                }\n                            }\n                            return options;\n                        }\n                    },\n                    {\n                        key: \"toHtml\",\n                        value: /**\n     * Delegate to the parent (up the call chain) to produce HTML\n     * @function Transformation#toHtml\n     * @return {string} HTML representation of the parent if possible.\n     * @example\n     * tag = cloudinary.ImageTag.new(\"sample\", {cloud_name: \"demo\"})\n     * // ImageTag {name: \"img\", publicId: \"sample\"}\n     * tag.toHtml()\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/sample\">\n     * tag.transformation().crop(\"fit\").width(300).toHtml()\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/c_fit,w_300/sample\">\n     */ function toHtml() {\n                            var ref;\n                            return (ref = this.getParent()) != null ? typeof ref.toHtml === \"function\" ? ref.toHtml() : void 0 : void 0;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return this.serialize();\n                        }\n                    },\n                    {\n                        key: \"clone\",\n                        value: function clone() {\n                            return new this.constructor(this.toOptions(true));\n                        }\n                    }\n                ], [\n                    {\n                        key: \"listNames\",\n                        value: function listNames() {\n                            return transformation_Transformation.methods;\n                        }\n                    },\n                    {\n                        key: \"isValidParamName\",\n                        value: function isValidParamName(name) {\n                            return transformation_Transformation.methods.indexOf(camelCase(name)) >= 0;\n                        }\n                    }\n                ]);\n            }();\n            var VAR_NAME_RE = /^\\$[a-zA-Z0-9]+$/;\n            transformation_TransformationBase.prototype.trans_separator = \"/\";\n            transformation_TransformationBase.prototype.param_separator = \",\";\n            function lastArgCallback(args) {\n                var callback;\n                callback = args != null ? args[args.length - 1] : void 0;\n                if (isFunction_root_isFunction_default()(callback)) {\n                    return callback;\n                } else {\n                    return void 0;\n                }\n            }\n            function processVar(varArray) {\n                var j, len, name, results, v;\n                if (isArray_root_isArray_default()(varArray)) {\n                    results = [];\n                    for(j = 0, len = varArray.length; j < len; j++){\n                        var _varArray$j = transformation_slicedToArray(varArray[j], 2);\n                        name = _varArray$j[0];\n                        v = _varArray$j[1];\n                        results.push(\"\".concat(name, \"_\").concat(expression.normalize(v)));\n                    }\n                    return results;\n                } else {\n                    return varArray;\n                }\n            }\n            function processCustomFunction(_ref) {\n                var function_type = _ref.function_type, source = _ref.source;\n                if (function_type === \"remote\") {\n                    return [\n                        function_type,\n                        btoa(source)\n                    ].join(\":\");\n                } else if (function_type === \"wasm\") {\n                    return [\n                        function_type,\n                        source\n                    ].join(\":\");\n                }\n            }\n            /**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n * @const Transformation.methods\n * @private\n * @ignore\n * @type {Array<string>}\n */ /**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n * @const {Array<string>} Transformation.PARAM_NAMES\n * @private\n * @ignore\n * @see toHtmlAttributes\n */ var transformation_Transformation = /*#__PURE__*/ function(_TransformationBase) {\n                /**\n   * Represents a single transformation.\n   * @class Transformation\n   * @example\n   * t = new cloudinary.Transformation();\n   * t.angle(20).crop(\"scale\").width(\"auto\");\n   *\n   * // or\n   *\n   * t = new cloudinary.Transformation( {angle: 20, crop: \"scale\", width: \"auto\"});\n   * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\"\n   *  target=\"_blank\">Available image transformations</a>\n   * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\"\n   *  target=\"_blank\">Available video transformations</a>\n   */ function Transformation(options) {\n                    transformation_classCallCheck(this, Transformation);\n                    return transformation_callSuper(this, Transformation, [\n                        options\n                    ]);\n                }\n                /**\n   * Convenience constructor\n   * @param {Object} options\n   * @return {Transformation}\n   * @example cl = cloudinary.Transformation.new( {angle: 20, crop: \"scale\", width: \"auto\"})\n   */ transformation_inherits(Transformation, _TransformationBase);\n                return transformation_createClass(Transformation, [\n                    {\n                        key: \"angle\",\n                        value: /*\n      Transformation Parameters\n    */ function angle(value) {\n                            return this.arrayParam(value, \"angle\", \"a\", \".\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"audioCodec\",\n                        value: function audioCodec(value) {\n                            return this.param(value, \"audio_codec\", \"ac\");\n                        }\n                    },\n                    {\n                        key: \"audioFrequency\",\n                        value: function audioFrequency(value) {\n                            return this.param(value, \"audio_frequency\", \"af\");\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(value) {\n                            return this.param(value, \"aspect_ratio\", \"ar\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"background\",\n                        value: function background(value) {\n                            return this.param(value, \"background\", \"b\", parameters_Param.norm_color);\n                        }\n                    },\n                    {\n                        key: \"bitRate\",\n                        value: function bitRate(value) {\n                            return this.param(value, \"bit_rate\", \"br\");\n                        }\n                    },\n                    {\n                        key: \"border\",\n                        value: function border(value) {\n                            return this.param(value, \"border\", \"bo\", function(border) {\n                                if (isPlainObject_root_isPlainObject_default()(border)) {\n                                    border = assign_root_assign_default()({}, {\n                                        color: \"black\",\n                                        width: 2\n                                    }, border);\n                                    return \"\".concat(border.width, \"px_solid_\").concat(parameters_Param.norm_color(border.color));\n                                } else {\n                                    return border;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"color\",\n                        value: function color(value) {\n                            return this.param(value, \"color\", \"co\", parameters_Param.norm_color);\n                        }\n                    },\n                    {\n                        key: \"colorSpace\",\n                        value: function colorSpace(value) {\n                            return this.param(value, \"color_space\", \"cs\");\n                        }\n                    },\n                    {\n                        key: \"crop\",\n                        value: function crop(value) {\n                            return this.param(value, \"crop\", \"c\");\n                        }\n                    },\n                    {\n                        key: \"customFunction\",\n                        value: function customFunction(value) {\n                            return this.param(value, \"custom_function\", \"fn\", function() {\n                                return processCustomFunction(value);\n                            });\n                        }\n                    },\n                    {\n                        key: \"customPreFunction\",\n                        value: function customPreFunction(value) {\n                            if (this.get(\"custom_function\")) {\n                                return;\n                            }\n                            return this.rawParam(value, \"custom_function\", \"\", function() {\n                                value = processCustomFunction(value);\n                                return value ? \"fn_pre:\".concat(value) : value;\n                            });\n                        }\n                    },\n                    {\n                        key: \"defaultImage\",\n                        value: function defaultImage(value) {\n                            return this.param(value, \"default_image\", \"d\");\n                        }\n                    },\n                    {\n                        key: \"delay\",\n                        value: function delay(value) {\n                            return this.param(value, \"delay\", \"dl\");\n                        }\n                    },\n                    {\n                        key: \"density\",\n                        value: function density(value) {\n                            return this.param(value, \"density\", \"dn\");\n                        }\n                    },\n                    {\n                        key: \"duration\",\n                        value: function duration(value) {\n                            return this.rangeParam(value, \"duration\", \"du\");\n                        }\n                    },\n                    {\n                        key: \"dpr\",\n                        value: function dpr(value) {\n                            return this.param(value, \"dpr\", \"dpr\", function(dpr) {\n                                dpr = dpr.toString();\n                                if (dpr != null ? dpr.match(/^\\d+$/) : void 0) {\n                                    return dpr + \".0\";\n                                } else {\n                                    return expression.normalize(dpr);\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"effect\",\n                        value: function effect(value) {\n                            return this.arrayParam(value, \"effect\", \"e\", \":\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"else\",\n                        value: function _else() {\n                            return this[\"if\"](\"else\");\n                        }\n                    },\n                    {\n                        key: \"endIf\",\n                        value: function endIf() {\n                            return this[\"if\"](\"end\");\n                        }\n                    },\n                    {\n                        key: \"endOffset\",\n                        value: function endOffset(value) {\n                            return this.rangeParam(value, \"end_offset\", \"eo\");\n                        }\n                    },\n                    {\n                        key: \"fallbackContent\",\n                        value: function fallbackContent(value) {\n                            return this.param(value, \"fallback_content\");\n                        }\n                    },\n                    {\n                        key: \"fetchFormat\",\n                        value: function fetchFormat(value) {\n                            return this.param(value, \"fetch_format\", \"f\");\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(value) {\n                            return this.param(value, \"format\");\n                        }\n                    },\n                    {\n                        key: \"flags\",\n                        value: function flags(value) {\n                            return this.arrayParam(value, \"flags\", \"fl\", \".\");\n                        }\n                    },\n                    {\n                        key: \"gravity\",\n                        value: function gravity(value) {\n                            return this.param(value, \"gravity\", \"g\");\n                        }\n                    },\n                    {\n                        key: \"fps\",\n                        value: function fps(value) {\n                            return this.param(value, \"fps\", \"fps\", function(fps) {\n                                if (isString_root_isString_default()(fps)) {\n                                    return fps;\n                                } else if (isArray_root_isArray_default()(fps)) {\n                                    return fps.join(\"-\");\n                                } else {\n                                    return fps;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height(value) {\n                            var _this3 = this;\n                            return this.param(value, \"height\", \"h\", function() {\n                                if (_this3.getValue(\"crop\") || _this3.getValue(\"overlay\") || _this3.getValue(\"underlay\")) {\n                                    return expression.normalize(value);\n                                } else {\n                                    return null;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"htmlHeight\",\n                        value: function htmlHeight(value) {\n                            return this.param(value, \"html_height\");\n                        }\n                    },\n                    {\n                        key: \"htmlWidth\",\n                        value: function htmlWidth(value) {\n                            return this.param(value, \"html_width\");\n                        }\n                    },\n                    {\n                        key: \"if\",\n                        value: function _if() {\n                            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n                            var i, ifVal, j, ref, trIf, trRest;\n                            switch(value){\n                                case \"else\":\n                                    this.chain();\n                                    return this.param(value, \"if\", \"if\");\n                                case \"end\":\n                                    this.chain();\n                                    for(i = j = ref = this.chained.length - 1; j >= 0; i = j += -1){\n                                        ifVal = this.chained[i].getValue(\"if\");\n                                        if (ifVal === \"end\") {\n                                            break;\n                                        } else if (ifVal != null) {\n                                            trIf = Transformation[\"new\"]()[\"if\"](ifVal);\n                                            this.chained[i].remove(\"if\");\n                                            trRest = this.chained[i];\n                                            this.chained[i] = Transformation[\"new\"]().transformation([\n                                                trIf,\n                                                trRest\n                                            ]);\n                                            if (ifVal !== \"else\") {\n                                                break;\n                                            }\n                                        }\n                                    }\n                                    return this.param(value, \"if\", \"if\");\n                                case \"\":\n                                    return condition[\"new\"]().setParent(this);\n                                default:\n                                    return this.param(value, \"if\", \"if\", function(value) {\n                                        return condition[\"new\"](value).toString();\n                                    });\n                            }\n                        }\n                    },\n                    {\n                        key: \"keyframeInterval\",\n                        value: function keyframeInterval(value) {\n                            return this.param(value, \"keyframe_interval\", \"ki\");\n                        }\n                    },\n                    {\n                        key: \"ocr\",\n                        value: function ocr(value) {\n                            return this.param(value, \"ocr\", \"ocr\");\n                        }\n                    },\n                    {\n                        key: \"offset\",\n                        value: function offset(value) {\n                            var end_o, start_o;\n                            var _ref2 = isFunction_root_isFunction_default()(value != null ? value.split : void 0) ? value.split(\"..\") : isArray_root_isArray_default()(value) ? value : [\n                                null,\n                                null\n                            ];\n                            var _ref3 = transformation_slicedToArray(_ref2, 2);\n                            start_o = _ref3[0];\n                            end_o = _ref3[1];\n                            if (start_o != null) {\n                                this.startOffset(start_o);\n                            }\n                            if (end_o != null) {\n                                return this.endOffset(end_o);\n                            }\n                        }\n                    },\n                    {\n                        key: \"opacity\",\n                        value: function opacity(value) {\n                            return this.param(value, \"opacity\", \"o\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"overlay\",\n                        value: function overlay(value) {\n                            return this.layerParam(value, \"overlay\", \"l\");\n                        }\n                    },\n                    {\n                        key: \"page\",\n                        value: function page(value) {\n                            return this.param(value, \"page\", \"pg\");\n                        }\n                    },\n                    {\n                        key: \"poster\",\n                        value: function poster(value) {\n                            return this.param(value, \"poster\");\n                        }\n                    },\n                    {\n                        key: \"prefix\",\n                        value: function prefix(value) {\n                            return this.param(value, \"prefix\", \"p\");\n                        }\n                    },\n                    {\n                        key: \"quality\",\n                        value: function quality(value) {\n                            return this.param(value, \"quality\", \"q\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"radius\",\n                        value: function radius(value) {\n                            return this.arrayParam(value, \"radius\", \"r\", \":\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"rawTransformation\",\n                        value: function rawTransformation(value) {\n                            return this.rawParam(value, \"raw_transformation\");\n                        }\n                    },\n                    {\n                        key: \"size\",\n                        value: function size(value) {\n                            var height, width;\n                            if (isFunction_root_isFunction_default()(value != null ? value.split : void 0)) {\n                                var _value$split = value.split(\"x\");\n                                var _value$split2 = transformation_slicedToArray(_value$split, 2);\n                                width = _value$split2[0];\n                                height = _value$split2[1];\n                                this.width(width);\n                                return this.height(height);\n                            }\n                        }\n                    },\n                    {\n                        key: \"sourceTypes\",\n                        value: function sourceTypes(value) {\n                            return this.param(value, \"source_types\");\n                        }\n                    },\n                    {\n                        key: \"sourceTransformation\",\n                        value: function sourceTransformation(value) {\n                            return this.param(value, \"source_transformation\");\n                        }\n                    },\n                    {\n                        key: \"startOffset\",\n                        value: function startOffset(value) {\n                            return this.rangeParam(value, \"start_offset\", \"so\");\n                        }\n                    },\n                    {\n                        key: \"streamingProfile\",\n                        value: function streamingProfile(value) {\n                            return this.param(value, \"streaming_profile\", \"sp\");\n                        }\n                    },\n                    {\n                        key: \"transformation\",\n                        value: function transformation(value) {\n                            return this.transformationParam(value, \"transformation\", \"t\");\n                        }\n                    },\n                    {\n                        key: \"underlay\",\n                        value: function underlay(value) {\n                            return this.layerParam(value, \"underlay\", \"u\");\n                        }\n                    },\n                    {\n                        key: \"variable\",\n                        value: function variable(name, value) {\n                            return this.param(value, name, name);\n                        }\n                    },\n                    {\n                        key: \"variables\",\n                        value: function variables(values) {\n                            return this.arrayParam(values, \"variables\");\n                        }\n                    },\n                    {\n                        key: \"videoCodec\",\n                        value: function videoCodec(value) {\n                            return this.param(value, \"video_codec\", \"vc\", parameters_Param.process_video_params);\n                        }\n                    },\n                    {\n                        key: \"videoSampling\",\n                        value: function videoSampling(value) {\n                            return this.param(value, \"video_sampling\", \"vs\");\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(value) {\n                            var _this4 = this;\n                            return this.param(value, \"width\", \"w\", function() {\n                                if (_this4.getValue(\"crop\") || _this4.getValue(\"overlay\") || _this4.getValue(\"underlay\")) {\n                                    return expression.normalize(value);\n                                } else {\n                                    return null;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"x\",\n                        value: function x(value) {\n                            return this.param(value, \"x\", \"x\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"y\",\n                        value: function y(value) {\n                            return this.param(value, \"y\", \"y\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"zoom\",\n                        value: function zoom(value) {\n                            return this.param(value, \"zoom\", \"z\", expression.normalize);\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(options) {\n                            return new Transformation(options);\n                        }\n                    }\n                ]);\n            }(transformation_TransformationBase);\n            /**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n */ transformation_Transformation.methods = [\n                \"angle\",\n                \"audioCodec\",\n                \"audioFrequency\",\n                \"aspectRatio\",\n                \"background\",\n                \"bitRate\",\n                \"border\",\n                \"color\",\n                \"colorSpace\",\n                \"crop\",\n                \"customFunction\",\n                \"customPreFunction\",\n                \"defaultImage\",\n                \"delay\",\n                \"density\",\n                \"duration\",\n                \"dpr\",\n                \"effect\",\n                \"else\",\n                \"endIf\",\n                \"endOffset\",\n                \"fallbackContent\",\n                \"fetchFormat\",\n                \"format\",\n                \"flags\",\n                \"gravity\",\n                \"fps\",\n                \"height\",\n                \"htmlHeight\",\n                \"htmlWidth\",\n                \"if\",\n                \"keyframeInterval\",\n                \"ocr\",\n                \"offset\",\n                \"opacity\",\n                \"overlay\",\n                \"page\",\n                \"poster\",\n                \"prefix\",\n                \"quality\",\n                \"radius\",\n                \"rawTransformation\",\n                \"size\",\n                \"sourceTypes\",\n                \"sourceTransformation\",\n                \"startOffset\",\n                \"streamingProfile\",\n                \"transformation\",\n                \"underlay\",\n                \"variable\",\n                \"variables\",\n                \"videoCodec\",\n                \"videoSampling\",\n                \"width\",\n                \"x\",\n                \"y\",\n                \"zoom\"\n            ];\n            /**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n */ transformation_Transformation.PARAM_NAMES = transformation_Transformation.methods.map(snakeCase).concat(src_configuration.CONFIG_PARAMS);\n            /* harmony default export */ var src_transformation = transformation_Transformation;\n            // CONCATENATED MODULE: ./src/tags/htmltag.js\n            function htmltag_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return htmltag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, htmltag_typeof(o);\n            }\n            function htmltag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function htmltag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, htmltag_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function htmltag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) htmltag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) htmltag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function htmltag_toPropertyKey(t) {\n                var i = htmltag_toPrimitive(t, \"string\");\n                return \"symbol\" == htmltag_typeof(i) ? i : i + \"\";\n            }\n            function htmltag_toPrimitive(t, r) {\n                if (\"object\" != htmltag_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != htmltag_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            /**\n * Generic HTML tag\n * Depends on 'transformation', 'util'\n */ /**\n * Represents an HTML (DOM) tag\n * @constructor HtmlTag\n * @param {string} name - the name of the tag\n * @param {string} [publicId]\n * @param {Object} options\n * @example tag = new HtmlTag( 'div', { 'width': 10})\n */ var htmltag_HtmlTag = /*#__PURE__*/ function() {\n                function HtmlTag(name, publicId, options) {\n                    htmltag_classCallCheck(this, HtmlTag);\n                    var transformation;\n                    this.name = name;\n                    this.publicId = publicId;\n                    if (options == null) {\n                        if (isPlainObject_root_isPlainObject_default()(publicId)) {\n                            options = publicId;\n                            this.publicId = void 0;\n                        } else {\n                            options = {};\n                        }\n                    }\n                    transformation = new src_transformation(options);\n                    transformation.setParent(this);\n                    this.transformation = function() {\n                        return transformation;\n                    };\n                }\n                /**\n   * Convenience constructor\n   * Creates a new instance of an HTML (DOM) tag\n   * @function HtmlTag.new\n   * @param {string} name - the name of the tag\n   * @param {string} [publicId]\n   * @param {Object} options\n   * @return {HtmlTag}\n   * @example tag = HtmlTag.new( 'div', { 'width': 10})\n   */ return htmltag_createClass(HtmlTag, [\n                    {\n                        key: \"htmlAttrs\",\n                        value: /**\n     * combine key and value from the `attr` to generate an HTML tag attributes string.\n     * `Transformation::toHtmlTagOptions` is used to filter out transformation and configuration keys.\n     * @protected\n     * @param {Object} attrs\n     * @return {string} the attributes in the format `'key1=\"value1\" key2=\"value2\"'`\n     * @ignore\n     */ function htmlAttrs(attrs) {\n                            var key, pairs, value;\n                            return pairs = (function() {\n                                var results;\n                                results = [];\n                                for(key in attrs){\n                                    value = escapeQuotes(attrs[key]);\n                                    if (value) {\n                                        results.push(htmltag_toAttribute(key, value));\n                                    }\n                                }\n                                return results;\n                            })().sort().join(\" \");\n                        }\n                    },\n                    {\n                        key: \"getOptions\",\n                        value: function getOptions() {\n                            return this.transformation().toOptions();\n                        }\n                    },\n                    {\n                        key: \"getOption\",\n                        value: function getOption(name) {\n                            return this.transformation().getValue(name);\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            // The attributes are be computed from the options every time this method is invoked.\n                            var htmlAttributes = this.transformation().toHtmlAttributes();\n                            Object.keys(htmlAttributes).forEach(function(key) {\n                                if (isPlainObject_root_isPlainObject_default()(htmlAttributes[key])) {\n                                    delete htmlAttributes[key];\n                                }\n                            });\n                            if (htmlAttributes.attributes) {\n                                // Currently HTML attributes are defined both at the top level and under 'attributes'\n                                merge_root_merge_default()(htmlAttributes, htmlAttributes.attributes);\n                                delete htmlAttributes.attributes;\n                            }\n                            return htmlAttributes;\n                        }\n                    },\n                    {\n                        key: \"setAttr\",\n                        value: function setAttr(name, value) {\n                            this.transformation().set(\"html_\".concat(name), value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"getAttr\",\n                        value: function getAttr(name) {\n                            return this.attributes()[\"html_\".concat(name)] || this.attributes()[name];\n                        }\n                    },\n                    {\n                        key: \"removeAttr\",\n                        value: function removeAttr(name) {\n                            var ref;\n                            return (ref = this.transformation().remove(\"html_\".concat(name))) != null ? ref : this.transformation().remove(name);\n                        }\n                    },\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"openTag\",\n                        value: function openTag() {\n                            var tag = \"<\" + this.name;\n                            var htmlAttrs = this.htmlAttrs(this.attributes());\n                            if (htmlAttrs && htmlAttrs.length > 0) {\n                                tag += \" \" + htmlAttrs;\n                            }\n                            return tag + \">\";\n                        }\n                    },\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"</\".concat(this.name, \">\");\n                        }\n                    },\n                    {\n                        key: \"toHtml\",\n                        value: function toHtml() {\n                            return this.openTag() + this.content() + this.closeTag();\n                        }\n                    },\n                    {\n                        key: \"toDOM\",\n                        value: function toDOM() {\n                            var element, name, ref, value;\n                            if (!isFunction_root_isFunction_default()(typeof document !== \"undefined\" && document !== null ? document.createElement : void 0)) {\n                                throw \"Can't create DOM if document is not present!\";\n                            }\n                            element = document.createElement(this.name);\n                            ref = this.attributes();\n                            for(name in ref){\n                                value = ref[name];\n                                element.setAttribute(name, value);\n                            }\n                            return element;\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(name, publicId, options) {\n                            return new this(name, publicId, options);\n                        }\n                    },\n                    {\n                        key: \"isResponsive\",\n                        value: function isResponsive(tag, responsiveClass) {\n                            var dataSrc;\n                            dataSrc = lodash_getData(tag, \"src-cache\") || lodash_getData(tag, \"src\");\n                            return lodash_hasClass(tag, responsiveClass) && /\\bw_auto\\b/.exec(dataSrc);\n                        }\n                    }\n                ]);\n            }();\n            ;\n            /**\n * Represent the given key and value as an HTML attribute.\n * @function toAttribute\n * @protected\n * @param {string} key - attribute name\n * @param {*|boolean} value - the value of the attribute. If the value is boolean `true`, return the key only.\n * @returns {string} the attribute\n *\n */ function htmltag_toAttribute(key, value) {\n                if (!value) {\n                    return void 0;\n                } else if (value === true) {\n                    return key;\n                } else {\n                    return \"\".concat(key, '=\"').concat(value, '\"');\n                }\n            }\n            /**\n * If given value is a string, replaces quotes with character entities (&#34;, &#39;)\n * @param value - value to change\n * @returns {*} changed value\n */ function escapeQuotes(value) {\n                return isString_root_isString_default()(value) ? value.replace('\"', \"&#34;\").replace(\"'\", \"&#39;\") : value;\n            }\n            /* harmony default export */ var htmltag = htmltag_HtmlTag;\n            // CONCATENATED MODULE: ./src/url.js\n            var _excluded = [\n                \"placeholder\",\n                \"accessibility\"\n            ];\n            function _objectWithoutProperties(source, excluded) {\n                if (source == null) return {};\n                var target = _objectWithoutPropertiesLoose(source, excluded);\n                var key, i;\n                if (Object.getOwnPropertySymbols) {\n                    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n                    for(i = 0; i < sourceSymbolKeys.length; i++){\n                        key = sourceSymbolKeys[i];\n                        if (excluded.indexOf(key) >= 0) continue;\n                        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n                        target[key] = source[key];\n                    }\n                }\n                return target;\n            }\n            function _objectWithoutPropertiesLoose(source, excluded) {\n                if (source == null) return {};\n                var target = {};\n                var sourceKeys = Object.keys(source);\n                var key, i;\n                for(i = 0; i < sourceKeys.length; i++){\n                    key = sourceKeys[i];\n                    if (excluded.indexOf(key) >= 0) continue;\n                    target[key] = source[key];\n                }\n                return target;\n            }\n            /**\n * Adds protocol, host, pathname prefixes to given string\n * @param str\n * @returns {string}\n */ function makeUrl(str) {\n                var prefix = document.location.protocol + \"//\" + document.location.host;\n                if (str[0] === \"?\") {\n                    prefix += document.location.pathname;\n                } else if (str[0] !== \"/\") {\n                    prefix += document.location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n                }\n                return prefix + str;\n            }\n            /**\n * Check is given string is a url\n * @param str\n * @returns {boolean}\n */ function isUrl(str) {\n                return str ? !!str.match(/^https?:\\//) : false;\n            }\n            // Produce a number between 1 and 5 to be used for cdn sub domains designation\n            function cdnSubdomainNumber(publicId) {\n                return src_crc32(publicId) % 5 + 1;\n            }\n            /**\n * Removes signature from options and returns the signature\n * Makes sure signature is empty or of this format: s--signature--\n * @param {object} options\n * @returns {string} the formatted signature\n */ function handleSignature(options) {\n                var signature = options.signature;\n                var isFormatted = !signature || signature.indexOf(\"s--\") === 0 && signature.substr(-2) === \"--\";\n                delete options.signature;\n                return isFormatted ? signature : \"s--\".concat(signature, \"--\");\n            }\n            /**\n * Create the URL prefix for Cloudinary resources.\n * @param {string} publicId the resource public ID\n * @param {object} options additional options\n * @param {string} options.cloud_name - the cloud name.\n * @param {boolean} [options.cdn_subdomain=false] - Whether to automatically build URLs with\n *  multiple CDN sub-domains.\n * @param {string} [options.private_cdn] - Boolean (default: false). Should be set to true for Advanced plan's users\n *  that have a private CDN distribution.\n * @param {string} [options.protocol=\"http://\"] - the URI protocol to use. If options.secure is true,\n *  the value is overridden to \"https://\"\n * @param {string} [options.secure_distribution] - The domain name of the CDN distribution to use for building HTTPS URLs.\n *  Relevant only for Advanced plan's users that have a private CDN distribution.\n * @param {string} [options.cname] - Custom domain name to use for building HTTP URLs.\n *  Relevant only for Advanced plan's users that have a private CDN distribution and a custom CNAME.\n * @param {boolean} [options.secure_cdn_subdomain=true] - When options.secure is true and this parameter is false,\n *  the subdomain is set to \"res\".\n * @param {boolean} [options.secure=false] - Force HTTPS URLs of images even if embedded in non-secure HTTP pages.\n *  When this value is true, options.secure_distribution will be used as host if provided, and options.protocol is set\n *  to \"https://\".\n * @returns {string} the URL prefix for the resource.\n * @private\n */ function handlePrefix(publicId, options) {\n                if (options.cloud_name && options.cloud_name[0] === \"/\") {\n                    return \"/res\" + options.cloud_name;\n                }\n                // defaults\n                var protocol = \"http://\";\n                var cdnPart = \"\";\n                var subdomain = \"res\";\n                var host = \".cloudinary.com\";\n                var path = \"/\" + options.cloud_name;\n                // modifications\n                if (options.protocol) {\n                    protocol = options.protocol + \"//\";\n                }\n                if (options.private_cdn) {\n                    cdnPart = options.cloud_name + \"-\";\n                    path = \"\";\n                }\n                if (options.cdn_subdomain) {\n                    subdomain = \"res-\" + cdnSubdomainNumber(publicId);\n                }\n                if (options.secure) {\n                    protocol = \"https://\";\n                    if (options.secure_cdn_subdomain === false) {\n                        subdomain = \"res\";\n                    }\n                    if (options.secure_distribution != null && options.secure_distribution !== OLD_AKAMAI_SHARED_CDN && options.secure_distribution !== SHARED_CDN) {\n                        cdnPart = \"\";\n                        subdomain = \"\";\n                        host = options.secure_distribution;\n                    }\n                } else if (options.cname) {\n                    protocol = \"http://\";\n                    cdnPart = \"\";\n                    subdomain = options.cdn_subdomain ? \"a\" + (src_crc32(publicId) % 5 + 1) + \".\" : \"\";\n                    host = options.cname;\n                }\n                return [\n                    protocol,\n                    cdnPart,\n                    subdomain,\n                    host,\n                    path\n                ].join(\"\");\n            }\n            /**\n * Return the resource type and action type based on the given configuration\n * @function Cloudinary#handleResourceType\n * @param {Object|string} resource_type\n * @param {string} [type='upload']\n * @param {string} [url_suffix]\n * @param {boolean} [use_root_path]\n * @param {boolean} [shorten]\n * @returns {string} resource_type/type\n * @ignore\n */ function handleResourceType(_ref) {\n                var _ref$resource_type = _ref.resource_type, resource_type = _ref$resource_type === void 0 ? \"image\" : _ref$resource_type, _ref$type = _ref.type, type = _ref$type === void 0 ? \"upload\" : _ref$type, url_suffix = _ref.url_suffix, use_root_path = _ref.use_root_path, shorten = _ref.shorten;\n                var options, resourceType = resource_type;\n                if (isPlainObject_root_isPlainObject_default()(resourceType)) {\n                    options = resourceType;\n                    resourceType = options.resource_type;\n                    type = options.type;\n                    shorten = options.shorten;\n                }\n                if (type == null) {\n                    type = \"upload\";\n                }\n                if (url_suffix != null) {\n                    resourceType = SEO_TYPES[\"\".concat(resourceType, \"/\").concat(type)];\n                    type = null;\n                    if (resourceType == null) {\n                        throw new Error(\"URL Suffix only supported for \".concat(Object.keys(SEO_TYPES).join(\", \")));\n                    }\n                }\n                if (use_root_path) {\n                    if (resourceType === \"image\" && type === \"upload\" || resourceType === \"images\") {\n                        resourceType = null;\n                        type = null;\n                    } else {\n                        throw new Error(\"Root path only supported for image/upload\");\n                    }\n                }\n                if (shorten && resourceType === \"image\" && type === \"upload\") {\n                    resourceType = \"iu\";\n                    type = null;\n                }\n                return [\n                    resourceType,\n                    type\n                ].join(\"/\");\n            }\n            /**\n * Encode publicId\n * @param publicId\n * @returns {string} encoded publicId\n */ function encodePublicId(publicId) {\n                return encodeURIComponent(publicId).replace(/%3A/g, \":\").replace(/%2F/g, \"/\");\n            }\n            /**\n * Encode and format publicId\n * @param publicId\n * @param options\n * @returns {string} publicId\n */ function formatPublicId(publicId, options) {\n                if (isUrl(publicId)) {\n                    publicId = encodePublicId(publicId);\n                } else {\n                    try {\n                        // Make sure publicId is URI encoded.\n                        publicId = decodeURIComponent(publicId);\n                    } catch (error) {}\n                    publicId = encodePublicId(publicId);\n                    if (options.url_suffix) {\n                        publicId = publicId + \"/\" + options.url_suffix;\n                    }\n                    if (options.format) {\n                        if (!options.trust_public_id) {\n                            publicId = publicId.replace(/\\.(jpg|png|gif|webp)$/, \"\");\n                        }\n                        publicId = publicId + \".\" + options.format;\n                    }\n                }\n                return publicId;\n            }\n            /**\n * Get any error with url options\n * @param options\n * @returns {string} if error, otherwise return undefined\n */ function validate(options) {\n                var cloud_name = options.cloud_name, url_suffix = options.url_suffix;\n                if (!cloud_name) {\n                    return \"Unknown cloud_name\";\n                }\n                if (url_suffix && url_suffix.match(/[\\.\\/]/)) {\n                    return \"url_suffix should not include . or /\";\n                }\n            }\n            /**\n * Get version part of the url\n * @param publicId\n * @param options\n * @returns {string}\n */ function handleVersion(publicId, options) {\n                // force_version param means to make sure there is a version in the url (Default is true)\n                var isForceVersion = options.force_version || typeof options.force_version === \"undefined\";\n                // Is version included in publicId or in options, or publicId is a url (doesn't need version)\n                var isVersionExist = publicId.indexOf(\"/\") < 0 || publicId.match(/^v[0-9]+/) || isUrl(publicId) || options.version;\n                if (isForceVersion && !isVersionExist) {\n                    options.version = 1;\n                }\n                return options.version ? \"v\".concat(options.version) : \"\";\n            }\n            /**\n * Get final transformation component for url string\n * @param options\n * @returns {string}\n */ function handleTransformation(options) {\n                var _ref2 = options || {}, placeholder = _ref2.placeholder, accessibility = _ref2.accessibility, otherOptions = _objectWithoutProperties(_ref2, _excluded);\n                var result = new src_transformation(otherOptions);\n                // Append accessibility transformations\n                if (accessibility && ACCESSIBILITY_MODES[accessibility]) {\n                    result.chain().effect(ACCESSIBILITY_MODES[accessibility]);\n                }\n                // Append placeholder transformations\n                if (placeholder) {\n                    if (placeholder === \"predominant-color\" && result.getValue(\"width\") && result.getValue(\"height\")) {\n                        placeholder += \"-pixel\";\n                    }\n                    var placeholderTransformations = PLACEHOLDER_IMAGE_MODES[placeholder] || PLACEHOLDER_IMAGE_MODES.blur;\n                    placeholderTransformations.forEach(function(t) {\n                        return result.chain().transformation(t);\n                    });\n                }\n                return result.serialize();\n            }\n            /**\n * If type is 'fetch', update publicId to be a url\n * @param publicId\n * @param type\n * @returns {string}\n */ function preparePublicId(publicId, _ref3) {\n                var type = _ref3.type;\n                return !isUrl(publicId) && type === \"fetch\" ? makeUrl(publicId) : publicId;\n            }\n            /**\n * Generate url string\n * @param publicId\n * @param options\n * @returns {string} final url\n */ function urlString(publicId, options) {\n                if (isUrl(publicId) && (options.type === \"upload\" || options.type === \"asset\")) {\n                    return publicId;\n                }\n                var version = handleVersion(publicId, options);\n                var transformationString = handleTransformation(options);\n                var prefix = handlePrefix(publicId, options);\n                var signature = handleSignature(options);\n                var resourceType = handleResourceType(options);\n                publicId = formatPublicId(publicId, options);\n                return compact_root_compact_default()([\n                    prefix,\n                    resourceType,\n                    signature,\n                    transformationString,\n                    version,\n                    publicId\n                ]).join(\"/\").replace(/([^:])\\/+/g, \"$1/\") // replace '///' with '//'\n                .replace(\" \", \"%20\");\n            }\n            /**\n * Merge options and config with defaults\n * update options fetch_format according to 'type' param\n * @param options\n * @param config\n * @returns {*} updated options\n */ function prepareOptions(options, config) {\n                if (options instanceof src_transformation) {\n                    options = options.toOptions();\n                }\n                options = defaults({}, options, config, DEFAULT_IMAGE_PARAMS);\n                if (options.type === \"fetch\") {\n                    options.fetch_format = options.fetch_format || options.format;\n                }\n                return options;\n            }\n            /**\n * Generates a URL for any asset in your Media library.\n * @function url\n * @ignore\n * @param {string} publicId - The public ID of the media asset.\n * @param {Object} [options={}] - The {@link Transformation} parameters to include in the URL.\n * @param {object} [config={}] - URL configuration parameters\n * @param {type} [options.type='upload'] - The asset's storage type.\n *  For details on all fetch types, see\n * <a href=\"https://cloudinary.com/documentation/image_transformations#fetching_images_from_remote_locations\"\n *  target=\"_blank\">Fetch types</a>.\n * @param {Object} [options.resource_type='image'] - The type of asset. <p>Possible values:<br/>\n *  - `image`<br/>\n *  - `video`<br/>\n *  - `raw`\n * @param {signature} [options.signature='s--12345678--'] - The signature component of a\n *  signed delivery URL of the format: /s--SIGNATURE--/.\n *  For details on signatures, see\n * <a href=\"https://cloudinary.com/documentation/signatures\" target=\"_blank\">Signatures</a>.\n * @return {string} The media asset URL.\n * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\" target=\"_blank\">\n *  Available image transformations</a>\n * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\" target=\"_blank\">\n *  Available video transformations</a>\n */ function url_url(publicId) {\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                if (!publicId) {\n                    return publicId;\n                }\n                options = prepareOptions(options, config);\n                publicId = preparePublicId(publicId, options);\n                var error = validate(options);\n                if (error) {\n                    throw error;\n                }\n                var resultUrl = urlString(publicId, options);\n                if (options.urlAnalytics) {\n                    var analyticsOptions = getAnalyticsOptions(options);\n                    var sdkAnalyticsSignature = getSDKAnalyticsSignature(analyticsOptions);\n                    // url might already have a '?' query param\n                    var appender = \"?\";\n                    if (resultUrl.indexOf(\"?\") >= 0) {\n                        appender = \"&\";\n                    }\n                    resultUrl = \"\".concat(resultUrl).concat(appender, \"_a=\").concat(sdkAnalyticsSignature);\n                }\n                if (options.auth_token) {\n                    var _appender = resultUrl.indexOf(\"?\") >= 0 ? \"&\" : \"?\";\n                    resultUrl = \"\".concat(resultUrl).concat(_appender, \"__cld_token__=\").concat(options.auth_token);\n                }\n                return resultUrl;\n            }\n            ;\n            // CONCATENATED MODULE: ./src/util/generateBreakpoints.js\n            function generateBreakpoints_slicedToArray(arr, i) {\n                return generateBreakpoints_arrayWithHoles(arr) || generateBreakpoints_iterableToArrayLimit(arr, i) || generateBreakpoints_unsupportedIterableToArray(arr, i) || generateBreakpoints_nonIterableRest();\n            }\n            function generateBreakpoints_nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function generateBreakpoints_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return generateBreakpoints_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return generateBreakpoints_arrayLikeToArray(o, minLen);\n            }\n            function generateBreakpoints_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n                return arr2;\n            }\n            function generateBreakpoints_iterableToArrayLimit(r, l) {\n                var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n                if (null != t) {\n                    var e, n, i, u, a = [], f = !0, o = !1;\n                    try {\n                        if (i = (t = t.call(r)).next, 0 === l) {\n                            if (Object(t) !== t) return;\n                            f = !1;\n                        } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n                    } catch (r) {\n                        o = !0, n = r;\n                    } finally{\n                        try {\n                            if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n                        } finally{\n                            if (o) throw n;\n                        }\n                    }\n                    return a;\n                }\n            }\n            function generateBreakpoints_arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            /**\n * Helper function. Gets or populates srcset breakpoints using provided parameters\n * Either the breakpoints or min_width, max_width, max_images must be provided.\n *\n * @private\n * @param {srcset} srcset Options with either `breakpoints` or `min_width`, `max_width`, and `max_images`\n *\n * @return {number[]} Array of breakpoints\n *\n */ function generateBreakpoints(srcset) {\n                var breakpoints = srcset.breakpoints || [];\n                if (breakpoints.length) {\n                    return breakpoints;\n                }\n                var _map = [\n                    srcset.min_width,\n                    srcset.max_width,\n                    srcset.max_images\n                ].map(Number), _map2 = generateBreakpoints_slicedToArray(_map, 3), min_width = _map2[0], max_width = _map2[1], max_images = _map2[2];\n                if ([\n                    min_width,\n                    max_width,\n                    max_images\n                ].some(isNaN)) {\n                    throw \"Either (min_width, max_width, max_images) \" + \"or breakpoints must be provided to the image srcset attribute\";\n                }\n                if (min_width > max_width) {\n                    throw \"min_width must be less than max_width\";\n                }\n                if (max_images <= 0) {\n                    throw \"max_images must be a positive integer\";\n                } else if (max_images === 1) {\n                    min_width = max_width;\n                }\n                var stepSize = Math.ceil((max_width - min_width) / Math.max(max_images - 1, 1));\n                for(var current = min_width; current < max_width; current += stepSize){\n                    breakpoints.push(current);\n                }\n                breakpoints.push(max_width);\n                return breakpoints;\n            }\n            // CONCATENATED MODULE: ./src/util/srcsetUtils.js\n            var srcsetUtils_isEmpty = isEmpty;\n            /**\n * Options used to generate the srcset attribute.\n * @typedef {object} srcset\n * @property {(number[]|string[])}   [breakpoints] An array of breakpoints.\n * @property {number}                [min_width]   Minimal width of the srcset images.\n * @property {number}                [max_width]   Maximal width of the srcset images.\n * @property {number}                [max_images]  Number of srcset images to generate.\n * @property {object|string}         [transformation] The transformation to use in the srcset urls.\n * @property {boolean}               [sizes] Whether to calculate and add the sizes attribute.\n */ /**\n * Helper function. Generates a single srcset item url\n *\n * @private\n * @param {string} public_id  Public ID of the resource.\n * @param {number} width      Width in pixels of the srcset item.\n * @param {object|string} transformation\n * @param {object} options    Additional options.\n *\n * @return {string} Resulting URL of the item\n */ function scaledUrl(public_id, width, transformation) {\n                var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n                var configParams = extractUrlParams(options);\n                transformation = transformation || options;\n                configParams.raw_transformation = new src_transformation([\n                    merge_root_merge_default.a({}, transformation),\n                    {\n                        crop: \"scale\",\n                        width: width\n                    }\n                ]).toString();\n                return url_url(public_id, configParams);\n            }\n            /**\n * If cache is enabled, get the breakpoints from the cache. If the values were not found in the cache,\n * or cache is not enabled, generate the values.\n * @param {srcset} srcset The srcset configuration parameters\n * @param {string} public_id\n * @param {object} options\n * @return {*|Array}\n */ function getOrGenerateBreakpoints(public_id) {\n                var srcset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                return generateBreakpoints(srcset);\n            }\n            /**\n * Helper function. Generates srcset attribute value of the HTML img tag\n * @private\n *\n * @param {string} public_id  Public ID of the resource\n * @param {number[]} breakpoints An array of breakpoints (in pixels)\n * @param {object} transformation The transformation\n * @param {object} options Includes html tag options, transformation options\n * @return {string} Resulting srcset attribute value\n */ function generateSrcsetAttribute(public_id, breakpoints, transformation, options) {\n                options = cloneDeep_root_cloneDeep_default.a(options);\n                patchFetchFormat(options);\n                return breakpoints.map(function(width) {\n                    return \"\".concat(scaledUrl(public_id, width, transformation, options), \" \").concat(width, \"w\");\n                }).join(\", \");\n            }\n            /**\n * Helper function. Generates sizes attribute value of the HTML img tag\n * @private\n * @param {number[]} breakpoints An array of breakpoints.\n * @return {string} Resulting sizes attribute value\n */ function generateSizesAttribute(breakpoints) {\n                if (breakpoints == null) {\n                    return \"\";\n                }\n                return breakpoints.map(function(width) {\n                    return \"(max-width: \".concat(width, \"px) \").concat(width, \"px\");\n                }).join(\", \");\n            }\n            /**\n * Helper function. Generates srcset and sizes attributes of the image tag\n *\n * Generated attributes are added to attributes argument\n *\n * @private\n * @param {string}    publicId  The public ID of the resource\n * @param {object}    attributes Existing HTML attributes.\n * @param {srcset}    srcsetData\n * @param {object}    options    Additional options.\n *\n * @return array The responsive attributes\n */ function generateImageResponsiveAttributes(publicId) {\n                var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var srcsetData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n                // Create both srcset and sizes here to avoid fetching breakpoints twice\n                var responsiveAttributes = {};\n                if (srcsetUtils_isEmpty(srcsetData)) {\n                    return responsiveAttributes;\n                }\n                var generateSizes = !attributes.sizes && srcsetData.sizes === true;\n                var generateSrcset = !attributes.srcset;\n                if (generateSrcset || generateSizes) {\n                    var breakpoints = getOrGenerateBreakpoints(publicId, srcsetData, options);\n                    if (generateSrcset) {\n                        var transformation = srcsetData.transformation;\n                        var srcsetAttr = generateSrcsetAttribute(publicId, breakpoints, transformation, options);\n                        if (!srcsetUtils_isEmpty(srcsetAttr)) {\n                            responsiveAttributes.srcset = srcsetAttr;\n                        }\n                    }\n                    if (generateSizes) {\n                        var sizesAttr = generateSizesAttribute(breakpoints);\n                        if (!srcsetUtils_isEmpty(sizesAttr)) {\n                            responsiveAttributes.sizes = sizesAttr;\n                        }\n                    }\n                }\n                return responsiveAttributes;\n            }\n            /**\n * Generate a media query\n *\n * @private\n * @param {object} options configuration options\n * @param {number|string} options.min_width\n * @param {number|string} options.max_width\n * @return {string} a media query string\n */ function generateMediaAttr(options) {\n                var mediaQuery = [];\n                if (options != null) {\n                    if (options.min_width != null) {\n                        mediaQuery.push(\"(min-width: \".concat(options.min_width, \"px)\"));\n                    }\n                    if (options.max_width != null) {\n                        mediaQuery.push(\"(max-width: \".concat(options.max_width, \"px)\"));\n                    }\n                }\n                return mediaQuery.join(\" and \");\n            }\n            var srcsetUrl = scaledUrl;\n            // CONCATENATED MODULE: ./src/tags/imagetag.js\n            function imagetag_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return imagetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, imagetag_typeof(o);\n            }\n            function imagetag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function imagetag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, imagetag_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function imagetag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) imagetag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) imagetag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function imagetag_toPropertyKey(t) {\n                var i = imagetag_toPrimitive(t, \"string\");\n                return \"symbol\" == imagetag_typeof(i) ? i : i + \"\";\n            }\n            function imagetag_toPrimitive(t, r) {\n                if (\"object\" != imagetag_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != imagetag_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function imagetag_callSuper(t, o, e) {\n                return o = imagetag_getPrototypeOf(o), imagetag_possibleConstructorReturn(t, imagetag_isNativeReflectConstruct() ? Reflect.construct(o, e || [], imagetag_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function imagetag_possibleConstructorReturn(self, call) {\n                if (call && (imagetag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return imagetag_assertThisInitialized(self);\n            }\n            function imagetag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function imagetag_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (imagetag_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function imagetag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    imagetag_get = Reflect.get.bind();\n                } else {\n                    imagetag_get = function _get(target, property, receiver) {\n                        var base = imagetag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return imagetag_get.apply(this, arguments);\n            }\n            function imagetag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = imagetag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function imagetag_getPrototypeOf(o) {\n                imagetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return imagetag_getPrototypeOf(o);\n            }\n            function imagetag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) imagetag_setPrototypeOf(subClass, superClass);\n            }\n            function imagetag_setPrototypeOf(o, p) {\n                imagetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return imagetag_setPrototypeOf(o, p);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Image tag using Cloudinary as the source.\n * @constructor ImageTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var imagetag_ImageTag = /*#__PURE__*/ function(_HtmlTag) {\n                function ImageTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    imagetag_classCallCheck(this, ImageTag);\n                    return imagetag_callSuper(this, ImageTag, [\n                        \"img\",\n                        publicId,\n                        options\n                    ]);\n                }\n                /** @override */ imagetag_inherits(ImageTag, _HtmlTag);\n                return imagetag_createClass(ImageTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var attr, options, srcAttribute;\n                            attr = imagetag_get(imagetag_getPrototypeOf(ImageTag.prototype), \"attributes\", this).call(this) || {};\n                            options = this.getOptions();\n                            var attributes = this.getOption(\"attributes\") || {};\n                            var srcsetParam = this.getOption(\"srcset\") || attributes.srcset;\n                            var responsiveAttributes = {};\n                            if (isString_root_isString_default()(srcsetParam)) {\n                                responsiveAttributes.srcset = srcsetParam;\n                            } else {\n                                responsiveAttributes = generateImageResponsiveAttributes(this.publicId, attributes, srcsetParam, options);\n                            }\n                            if (!isEmpty(responsiveAttributes)) {\n                                delete attr.width;\n                                delete attr.height;\n                            }\n                            merge_root_merge_default()(attr, responsiveAttributes);\n                            srcAttribute = options.responsive && !options.client_hints ? \"data-src\" : \"src\";\n                            if (attr[srcAttribute] == null) {\n                                attr[srcAttribute] = url_url(this.publicId, this.getOptions());\n                            }\n                            return attr;\n                        }\n                    }\n                ]);\n            }(htmltag);\n            ;\n            /* harmony default export */ var imagetag = imagetag_ImageTag;\n            // CONCATENATED MODULE: ./src/tags/sourcetag.js\n            function sourcetag_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return sourcetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, sourcetag_typeof(o);\n            }\n            function sourcetag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function sourcetag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, sourcetag_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function sourcetag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) sourcetag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) sourcetag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function sourcetag_toPropertyKey(t) {\n                var i = sourcetag_toPrimitive(t, \"string\");\n                return \"symbol\" == sourcetag_typeof(i) ? i : i + \"\";\n            }\n            function sourcetag_toPrimitive(t, r) {\n                if (\"object\" != sourcetag_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != sourcetag_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function sourcetag_callSuper(t, o, e) {\n                return o = sourcetag_getPrototypeOf(o), sourcetag_possibleConstructorReturn(t, sourcetag_isNativeReflectConstruct() ? Reflect.construct(o, e || [], sourcetag_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function sourcetag_possibleConstructorReturn(self, call) {\n                if (call && (sourcetag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return sourcetag_assertThisInitialized(self);\n            }\n            function sourcetag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function sourcetag_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (sourcetag_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function sourcetag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    sourcetag_get = Reflect.get.bind();\n                } else {\n                    sourcetag_get = function _get(target, property, receiver) {\n                        var base = sourcetag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return sourcetag_get.apply(this, arguments);\n            }\n            function sourcetag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = sourcetag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function sourcetag_getPrototypeOf(o) {\n                sourcetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return sourcetag_getPrototypeOf(o);\n            }\n            function sourcetag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) sourcetag_setPrototypeOf(subClass, superClass);\n            }\n            function sourcetag_setPrototypeOf(o, p) {\n                sourcetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return sourcetag_setPrototypeOf(o, p);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Image tag using Cloudinary as the source.\n * @constructor SourceTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var sourcetag_SourceTag = /*#__PURE__*/ function(_HtmlTag) {\n                function SourceTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    sourcetag_classCallCheck(this, SourceTag);\n                    return sourcetag_callSuper(this, SourceTag, [\n                        \"source\",\n                        publicId,\n                        options\n                    ]);\n                }\n                /** @override */ sourcetag_inherits(SourceTag, _HtmlTag);\n                return sourcetag_createClass(SourceTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var srcsetParam = this.getOption(\"srcset\");\n                            var attr = sourcetag_get(sourcetag_getPrototypeOf(SourceTag.prototype), \"attributes\", this).call(this) || {};\n                            var options = this.getOptions();\n                            merge_root_merge_default()(attr, generateImageResponsiveAttributes(this.publicId, attr, srcsetParam, options));\n                            if (!attr.srcset) {\n                                attr.srcset = url_url(this.publicId, options);\n                            }\n                            if (!attr.media && options.media) {\n                                attr.media = generateMediaAttr(options.media);\n                            }\n                            return attr;\n                        }\n                    }\n                ]);\n            }(htmltag);\n            ;\n            /* harmony default export */ var sourcetag = sourcetag_SourceTag;\n            // CONCATENATED MODULE: ./src/tags/picturetag.js\n            function picturetag_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return picturetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, picturetag_typeof(o);\n            }\n            function picturetag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function picturetag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, picturetag_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function picturetag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) picturetag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) picturetag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function picturetag_toPropertyKey(t) {\n                var i = picturetag_toPrimitive(t, \"string\");\n                return \"symbol\" == picturetag_typeof(i) ? i : i + \"\";\n            }\n            function picturetag_toPrimitive(t, r) {\n                if (\"object\" != picturetag_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != picturetag_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function picturetag_callSuper(t, o, e) {\n                return o = picturetag_getPrototypeOf(o), picturetag_possibleConstructorReturn(t, picturetag_isNativeReflectConstruct() ? Reflect.construct(o, e || [], picturetag_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function picturetag_possibleConstructorReturn(self, call) {\n                if (call && (picturetag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return picturetag_assertThisInitialized(self);\n            }\n            function picturetag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function picturetag_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (picturetag_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function picturetag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    picturetag_get = Reflect.get.bind();\n                } else {\n                    picturetag_get = function _get(target, property, receiver) {\n                        var base = picturetag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return picturetag_get.apply(this, arguments);\n            }\n            function picturetag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = picturetag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function picturetag_getPrototypeOf(o) {\n                picturetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return picturetag_getPrototypeOf(o);\n            }\n            function picturetag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) picturetag_setPrototypeOf(subClass, superClass);\n            }\n            function picturetag_setPrototypeOf(o, p) {\n                picturetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return picturetag_setPrototypeOf(o, p);\n            }\n            var picturetag_PictureTag = /*#__PURE__*/ function(_HtmlTag) {\n                function PictureTag(publicId) {\n                    var _this;\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    var sources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n                    picturetag_classCallCheck(this, PictureTag);\n                    _this = picturetag_callSuper(this, PictureTag, [\n                        \"picture\",\n                        publicId,\n                        options\n                    ]);\n                    _this.widthList = sources;\n                    return _this;\n                }\n                /** @override */ picturetag_inherits(PictureTag, _HtmlTag);\n                return picturetag_createClass(PictureTag, [\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            var _this2 = this;\n                            return this.widthList.map(function(_ref) {\n                                var min_width = _ref.min_width, max_width = _ref.max_width, transformation = _ref.transformation;\n                                var options = _this2.getOptions();\n                                var sourceTransformation = new src_transformation(options);\n                                sourceTransformation.chain().fromOptions(typeof transformation === \"string\" ? {\n                                    raw_transformation: transformation\n                                } : transformation);\n                                options = extractUrlParams(options);\n                                options.media = {\n                                    min_width: min_width,\n                                    max_width: max_width\n                                };\n                                options.transformation = sourceTransformation;\n                                return new sourcetag(_this2.publicId, options).toHtml();\n                            }).join(\"\") + new imagetag(this.publicId, this.getOptions()).toHtml();\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var attr = picturetag_get(picturetag_getPrototypeOf(PictureTag.prototype), \"attributes\", this).call(this);\n                            delete attr.width;\n                            delete attr.height;\n                            return attr;\n                        }\n                    },\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"</\" + this.name + \">\";\n                        }\n                    }\n                ]);\n            }(htmltag);\n            ;\n            /* harmony default export */ var picturetag = picturetag_PictureTag;\n            // CONCATENATED MODULE: ./src/tags/videotag.js\n            function videotag_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return videotag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, videotag_typeof(o);\n            }\n            function videotag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function videotag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, videotag_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function videotag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) videotag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) videotag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function videotag_toPropertyKey(t) {\n                var i = videotag_toPrimitive(t, \"string\");\n                return \"symbol\" == videotag_typeof(i) ? i : i + \"\";\n            }\n            function videotag_toPrimitive(t, r) {\n                if (\"object\" != videotag_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != videotag_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function videotag_callSuper(t, o, e) {\n                return o = videotag_getPrototypeOf(o), videotag_possibleConstructorReturn(t, videotag_isNativeReflectConstruct() ? Reflect.construct(o, e || [], videotag_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function videotag_possibleConstructorReturn(self, call) {\n                if (call && (videotag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return videotag_assertThisInitialized(self);\n            }\n            function videotag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function videotag_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (videotag_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function videotag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    videotag_get = Reflect.get.bind();\n                } else {\n                    videotag_get = function _get(target, property, receiver) {\n                        var base = videotag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return videotag_get.apply(this, arguments);\n            }\n            function videotag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = videotag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function videotag_getPrototypeOf(o) {\n                videotag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return videotag_getPrototypeOf(o);\n            }\n            function videotag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) videotag_setPrototypeOf(subClass, superClass);\n            }\n            function videotag_setPrototypeOf(o, p) {\n                videotag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return videotag_setPrototypeOf(o, p);\n            }\n            /**\n * Video Tag\n * Depends on 'tags/htmltag', 'util', 'cloudinary'\n */ var VIDEO_TAG_PARAMS = [\n                \"source_types\",\n                \"source_transformation\",\n                \"fallback_content\",\n                \"poster\",\n                \"sources\"\n            ];\n            var videotag_DEFAULT_VIDEO_SOURCE_TYPES = [\n                \"webm\",\n                \"mp4\",\n                \"ogv\"\n            ];\n            var videotag_DEFAULT_POSTER_OPTIONS = {\n                format: \"jpg\",\n                resource_type: \"video\"\n            };\n            /**\n * Creates an HTML (DOM) Video tag using Cloudinary as the source.\n * @constructor VideoTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var videotag_VideoTag = /*#__PURE__*/ function(_HtmlTag) {\n                function VideoTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    videotag_classCallCheck(this, VideoTag);\n                    options = defaults({}, options, DEFAULT_VIDEO_PARAMS);\n                    return videotag_callSuper(this, VideoTag, [\n                        \"video\",\n                        publicId.replace(/\\.(mp4|ogv|webm)$/, \"\"),\n                        options\n                    ]);\n                }\n                /**\n   * Set the transformation to apply on each source\n   * @function VideoTag#setSourceTransformation\n   * @param {Object} an object with pairs of source type and source transformation\n   * @returns {VideoTag} Returns this instance for chaining purposes.\n   */ videotag_inherits(VideoTag, _HtmlTag);\n                return videotag_createClass(VideoTag, [\n                    {\n                        key: \"setSourceTransformation\",\n                        value: function setSourceTransformation(value) {\n                            this.transformation().sourceTransformation(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setSourceTypes\",\n                        value: function setSourceTypes(value) {\n                            this.transformation().sourceTypes(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setPoster\",\n                        value: function setPoster(value) {\n                            this.transformation().poster(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setFallbackContent\",\n                        value: function setFallbackContent(value) {\n                            this.transformation().fallbackContent(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            var _this = this;\n                            var sourceTypes = this.transformation().getValue(\"source_types\");\n                            var sourceTransformation = this.transformation().getValue(\"source_transformation\");\n                            var fallback = this.transformation().getValue(\"fallback_content\");\n                            var sources = this.getOption(\"sources\");\n                            var innerTags = [];\n                            if (isArray_root_isArray_default()(sources) && !isEmpty(sources)) {\n                                innerTags = sources.map(function(source) {\n                                    var src = url_url(_this.publicId, defaults({}, source.transformations || {}, {\n                                        resource_type: \"video\",\n                                        format: source.type\n                                    }), _this.getOptions());\n                                    return _this.createSourceTag(src, source.type, source.codecs);\n                                });\n                            } else {\n                                if (isEmpty(sourceTypes)) {\n                                    sourceTypes = videotag_DEFAULT_VIDEO_SOURCE_TYPES;\n                                }\n                                if (isArray_root_isArray_default()(sourceTypes)) {\n                                    innerTags = sourceTypes.map(function(srcType) {\n                                        var src = url_url(_this.publicId, defaults({}, sourceTransformation[srcType] || {}, {\n                                            resource_type: \"video\",\n                                            format: srcType\n                                        }), _this.getOptions());\n                                        return _this.createSourceTag(src, srcType);\n                                    });\n                                }\n                            }\n                            return innerTags.join(\"\") + fallback;\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var sourceTypes = this.getOption(\"source_types\");\n                            var poster = this.getOption(\"poster\");\n                            if (poster === undefined) {\n                                poster = {};\n                            }\n                            if (isPlainObject_root_isPlainObject_default()(poster)) {\n                                var defaultOptions = poster.public_id != null ? DEFAULT_IMAGE_PARAMS : videotag_DEFAULT_POSTER_OPTIONS;\n                                poster = url_url(poster.public_id || this.publicId, defaults({}, poster, defaultOptions, this.getOptions()));\n                            }\n                            var attr = videotag_get(videotag_getPrototypeOf(VideoTag.prototype), \"attributes\", this).call(this) || {};\n                            attr = omit(attr, VIDEO_TAG_PARAMS);\n                            var sources = this.getOption(\"sources\");\n                            // In case of empty sourceTypes - fallback to default source types is used.\n                            var hasSourceTags = !isEmpty(sources) || isEmpty(sourceTypes) || isArray_root_isArray_default()(sourceTypes);\n                            if (!hasSourceTags) {\n                                attr[\"src\"] = url_url(this.publicId, this.getOptions(), {\n                                    resource_type: \"video\",\n                                    format: sourceTypes\n                                });\n                            }\n                            if (poster != null) {\n                                attr[\"poster\"] = poster;\n                            }\n                            return attr;\n                        }\n                    },\n                    {\n                        key: \"createSourceTag\",\n                        value: function createSourceTag(src, sourceType) {\n                            var codecs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n                            var mimeType = null;\n                            if (!isEmpty(sourceType)) {\n                                var videoType = sourceType === \"ogv\" ? \"ogg\" : sourceType;\n                                mimeType = \"video/\" + videoType;\n                                if (!isEmpty(codecs)) {\n                                    var codecsStr = isArray_root_isArray_default()(codecs) ? codecs.join(\", \") : codecs;\n                                    mimeType += \"; codecs=\" + codecsStr;\n                                }\n                            }\n                            return \"<source \" + this.htmlAttrs({\n                                src: src,\n                                type: mimeType\n                            }) + \">\";\n                        }\n                    }\n                ]);\n            }(htmltag);\n            /* harmony default export */ var videotag = videotag_VideoTag;\n            // CONCATENATED MODULE: ./src/tags/clienthintsmetatag.js\n            function clienthintsmetatag_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return clienthintsmetatag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, clienthintsmetatag_typeof(o);\n            }\n            function clienthintsmetatag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function clienthintsmetatag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, clienthintsmetatag_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function clienthintsmetatag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) clienthintsmetatag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) clienthintsmetatag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function clienthintsmetatag_toPropertyKey(t) {\n                var i = clienthintsmetatag_toPrimitive(t, \"string\");\n                return \"symbol\" == clienthintsmetatag_typeof(i) ? i : i + \"\";\n            }\n            function clienthintsmetatag_toPrimitive(t, r) {\n                if (\"object\" != clienthintsmetatag_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != clienthintsmetatag_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function clienthintsmetatag_callSuper(t, o, e) {\n                return o = clienthintsmetatag_getPrototypeOf(o), clienthintsmetatag_possibleConstructorReturn(t, clienthintsmetatag_isNativeReflectConstruct() ? Reflect.construct(o, e || [], clienthintsmetatag_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function clienthintsmetatag_possibleConstructorReturn(self, call) {\n                if (call && (clienthintsmetatag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return clienthintsmetatag_assertThisInitialized(self);\n            }\n            function clienthintsmetatag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function clienthintsmetatag_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (clienthintsmetatag_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function clienthintsmetatag_getPrototypeOf(o) {\n                clienthintsmetatag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return clienthintsmetatag_getPrototypeOf(o);\n            }\n            function clienthintsmetatag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) clienthintsmetatag_setPrototypeOf(subClass, superClass);\n            }\n            function clienthintsmetatag_setPrototypeOf(o, p) {\n                clienthintsmetatag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return clienthintsmetatag_setPrototypeOf(o, p);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Meta tag that enables Client-Hints for the HTML page. <br/>\n *  See\n *  <a href=\"https://cloudinary.com/documentation/responsive_images#automating_responsive_images_with_client_hints\"\n *  target=\"_new\">Automating responsive images with Client Hints</a> for more details.\n * @constructor ClientHintsMetaTag\n * @extends HtmlTag\n * @param {object} options\n * @example\n * tag = new ClientHintsMetaTag()\n * //returns: <meta http-equiv=\"Accept-CH\" content=\"DPR, Viewport-Width, Width\">\n */ var clienthintsmetatag_ClientHintsMetaTag = /*#__PURE__*/ function(_HtmlTag) {\n                function ClientHintsMetaTag(options) {\n                    clienthintsmetatag_classCallCheck(this, ClientHintsMetaTag);\n                    return clienthintsmetatag_callSuper(this, ClientHintsMetaTag, [\n                        \"meta\",\n                        void 0,\n                        assign_root_assign_default()({\n                            \"http-equiv\": \"Accept-CH\",\n                            content: \"DPR, Viewport-Width, Width\"\n                        }, options)\n                    ]);\n                }\n                /** @override */ clienthintsmetatag_inherits(ClientHintsMetaTag, _HtmlTag);\n                return clienthintsmetatag_createClass(ClientHintsMetaTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    }\n                ]);\n            }(htmltag);\n            ;\n            /* harmony default export */ var clienthintsmetatag = clienthintsmetatag_ClientHintsMetaTag;\n            // CONCATENATED MODULE: ./src/util/parse/normalizeToArray.js\n            function normalizeToArray_toConsumableArray(arr) {\n                return normalizeToArray_arrayWithoutHoles(arr) || normalizeToArray_iterableToArray(arr) || normalizeToArray_unsupportedIterableToArray(arr) || normalizeToArray_nonIterableSpread();\n            }\n            function normalizeToArray_nonIterableSpread() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function normalizeToArray_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return normalizeToArray_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return normalizeToArray_arrayLikeToArray(o, minLen);\n            }\n            function normalizeToArray_iterableToArray(iter) {\n                if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n            }\n            function normalizeToArray_arrayWithoutHoles(arr) {\n                if (Array.isArray(arr)) return normalizeToArray_arrayLikeToArray(arr);\n            }\n            function normalizeToArray_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n                return arr2;\n            }\n            /**\n * @desc normalize elements, support a single element, array or nodelist, always outputs array\n * @param elements<HTMLElement[]>\n * @returns {[]}\n */ function normalizeToArray(elements) {\n                if (isArray_root_isArray_default()(elements)) {\n                    return elements;\n                } else if (elements.constructor.name === \"NodeList\") {\n                    return normalizeToArray_toConsumableArray(elements); // ensure an array is always returned, even if nodelist\n                } else if (isString_root_isString_default()(elements)) {\n                    return Array.prototype.slice.call(document.querySelectorAll(elements), 0);\n                } else {\n                    return [\n                        elements\n                    ];\n                }\n            }\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/mountCloudinaryVideoTag.js\n            /**\n * @param {HTMLElement} htmlElContainer\n * @param {object} clInstance cloudinary instance\n * @param {string} publicId\n * @param {object} options - TransformationOptions\n * @returns Promise<HTMLElement>\n */ function mountCloudinaryVideoTag(htmlElContainer, clInstance, publicId, options) {\n                return new Promise(function(resolve, reject) {\n                    htmlElContainer.innerHTML = clInstance.videoTag(publicId, options).toHtml();\n                    // All videos under the html container must have a width of 100%, or they might overflow from the container\n                    var cloudinaryVideoElement = htmlElContainer.querySelector(\".cld-transparent-video\");\n                    cloudinaryVideoElement.style.width = \"100%\";\n                    resolve(htmlElContainer);\n                });\n            }\n            /* harmony default export */ var transparentVideo_mountCloudinaryVideoTag = mountCloudinaryVideoTag;\n            // CONCATENATED MODULE: ./src/util/transformations/addFlag.js\n            /**\n * @description - Function will push a flag to incoming options\n * @param {{transformation} | {...transformation}} options - These options are the same options provided to all our SDK methods\n *                           We expect options to either be the transformation itself, or an object containing\n *                           an array of transformations\n *\n * @param {string} flag\n * @returns the mutated options object\n */ function addFlagToOptions(options, flag) {\n                // Do we have transformation\n                if (options.transformation) {\n                    options.transformation.push({\n                        flags: [\n                            flag\n                        ]\n                    });\n                } else {\n                    // no transformation\n                    // ensure the flags are extended\n                    if (!options.flags) {\n                        options.flags = [];\n                    }\n                    if (typeof options.flags === \"string\") {\n                        options.flags = [\n                            options.flags\n                        ];\n                    }\n                    options.flags.push(flag);\n                }\n            }\n            /* harmony default export */ var addFlag = addFlagToOptions;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/enforceOptionsForTransparentVideo.js\n            /**\n * @description - Enforce option structure, sets defaults and ensures alpha flag exists\n * @param options {TransformationOptions}\n */ function enforceOptionsForTransparentVideo(options) {\n                options.autoplay = true;\n                options.muted = true;\n                options.controls = false;\n                options.max_timeout_ms = options.max_timeout_ms || DEFAULT_TIMEOUT_MS;\n                options[\"class\"] = options[\"class\"] || \"\";\n                options[\"class\"] += \" cld-transparent-video\";\n                options.externalLibraries = options.externalLibraries || {};\n                if (!options.externalLibraries.seeThru) {\n                    options.externalLibraries.seeThru = DEFAULT_EXTERNAL_LIBRARIES.seeThru;\n                }\n                // ensure there's an alpha transformation present\n                // this is a non documented internal flag\n                addFlag(options, \"alpha\");\n            }\n            /* harmony default export */ var transparentVideo_enforceOptionsForTransparentVideo = enforceOptionsForTransparentVideo;\n            // CONCATENATED MODULE: ./src/util/xhr/loadScript.js\n            /**\n * @description - Given a string URL, this function will load the script and resolve the promise.\n *                The function doesn't resolve any value,\n *                this is not a UMD loader where you can get your library name back.\n * @param scriptURL {string}\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @param isAlreadyLoaded {boolean} if true, the loadScript resolves immediately\n *                                  this is used for multiple invocations - prevents the script from being loaded multiple times\n * @return {Promise<any | {status:string, message:string}>}\n */ function loadScript(scriptURL, max_timeout_ms, isAlreadyLoaded) {\n                return new Promise(function(resolve, reject) {\n                    if (isAlreadyLoaded) {\n                        resolve();\n                    } else {\n                        var scriptTag = document.createElement(\"script\");\n                        scriptTag.src = scriptURL;\n                        var timerID = setTimeout(function() {\n                            reject({\n                                status: \"error\",\n                                message: \"Timeout loading script \".concat(scriptURL)\n                            });\n                        }, max_timeout_ms); // 10 seconds for timeout\n                        scriptTag.onerror = function() {\n                            clearTimeout(timerID); // clear timeout reject error\n                            reject({\n                                status: \"error\",\n                                message: \"Error loading \".concat(scriptURL)\n                            });\n                        };\n                        scriptTag.onload = function() {\n                            clearTimeout(timerID); // clear timeout reject error\n                            resolve();\n                        };\n                        document.head.appendChild(scriptTag);\n                    }\n                });\n            }\n            /* harmony default export */ var xhr_loadScript = loadScript;\n            // CONCATENATED MODULE: ./src/util/xhr/getBlobFromURL.js\n            /**\n * Reject on timeout\n * @param maxTimeoutMS\n * @param reject\n * @returns {number} timerID\n */ function rejectOnTimeout(maxTimeoutMS, reject) {\n                return setTimeout(function() {\n                    reject({\n                        status: \"error\",\n                        message: \"Timeout loading Blob URL\"\n                    });\n                }, maxTimeoutMS);\n            }\n            /**\n * @description Converts a URL to a BLOB URL\n * @param {string} urlToLoad\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @return {Promise<{\n *   status: 'success' | 'error'\n *   message?: string,\n *    payload: {\n *      url: string\n *    }\n * }>}\n */ function getBlobFromURL(urlToLoad, maxTimeoutMS) {\n                return new Promise(function(resolve, reject) {\n                    var timerID = rejectOnTimeout(maxTimeoutMS, reject);\n                    // If fetch exists, use it to fetch blob, otherwise use XHR.\n                    // XHR causes issues on safari 14.1 so we prefer fetch\n                    var fetchBlob = typeof fetch !== \"undefined\" && fetch ? loadUrlUsingFetch : loadUrlUsingXhr;\n                    fetchBlob(urlToLoad).then(function(blob) {\n                        resolve({\n                            status: \"success\",\n                            payload: {\n                                blobURL: URL.createObjectURL(blob)\n                            }\n                        });\n                    })[\"catch\"](function() {\n                        reject({\n                            status: \"error\",\n                            message: \"Error loading Blob URL\"\n                        });\n                    })[\"finally\"](function() {\n                        // Clear the timeout timer on fail or success.\n                        clearTimeout(timerID);\n                    });\n                });\n            }\n            /**\n * Use fetch function to fetch file\n * @param urlToLoad\n * @returns {Promise<unknown>}\n */ function loadUrlUsingFetch(urlToLoad) {\n                return new Promise(function(resolve, reject) {\n                    fetch(urlToLoad).then(function(response) {\n                        response.blob().then(function(blob) {\n                            resolve(blob);\n                        });\n                    })[\"catch\"](function() {\n                        reject(\"error\");\n                    });\n                });\n            }\n            /**\n * Use XHR to fetch file\n * @param urlToLoad\n * @returns {Promise<unknown>}\n */ function loadUrlUsingXhr(urlToLoad) {\n                return new Promise(function(resolve, reject) {\n                    var xhr = new XMLHttpRequest();\n                    xhr.responseType = \"blob\";\n                    xhr.onload = function(response) {\n                        resolve(xhr.response);\n                    };\n                    xhr.onerror = function() {\n                        reject(\"error\");\n                    };\n                    xhr.open(\"GET\", urlToLoad, true);\n                    xhr.send();\n                });\n            }\n            /* harmony default export */ var xhr_getBlobFromURL = getBlobFromURL;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/createHiddenVideoTag.js\n            /**\n * @description Creates a hidden HTMLVideoElement with the specified videoOptions\n * @param {{autoplay, playsinline, loop, muted, poster, blobURL, videoURL }} videoOptions\n * @param {boolean} videoOptions.autoplay - autoplays the video if true\n * @param {string} videoOptions.blobURL - the blobURL to set as video.src\n * @param {string} videoOptions.videoURL - the original videoURL the user created (with transformations)\n * @return {HTMLVideoElement}\n */ function createHiddenVideoTag(videoOptions) {\n                var autoplay = videoOptions.autoplay, playsinline = videoOptions.playsinline, loop = videoOptions.loop, muted = videoOptions.muted, poster = videoOptions.poster, blobURL = videoOptions.blobURL, videoURL = videoOptions.videoURL;\n                var el = document.createElement(\"video\");\n                el.style.visibility = \"hidden\";\n                el.position = \"absolute\";\n                el.x = 0;\n                el.y = 0;\n                el.src = blobURL;\n                el.setAttribute(\"data-video-url\", videoURL); // for debugging/testing\n                autoplay && el.setAttribute(\"autoplay\", autoplay);\n                playsinline && el.setAttribute(\"playsinline\", playsinline);\n                loop && el.setAttribute(\"loop\", loop);\n                muted && el.setAttribute(\"muted\", muted);\n                muted && (el.muted = muted); // this is also needed for autoplay, on top of setAttribute\n                poster && el.setAttribute(\"poster\", poster);\n                // Free memory at the end of the file loading.\n                el.onload = function() {\n                    URL.revokeObjectURL(blobURL);\n                };\n                return el;\n            }\n            /* harmony default export */ var transparentVideo_createHiddenVideoTag = createHiddenVideoTag;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/instantiateSeeThru.js\n            /**\n * @description This function creates a new instanc eof seeThru (seeThru.create()) and returns a promise of the seeThru instance\n * @param {HTMLVideoElement} videoElement\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @param {string} customClass - A classname to be added to the canvas element created by seeThru\n * @param {boolean} autoPlay\n * @return {Promise<any>} SeeThru instance or rejection error\n */ function instantiateSeeThru(videoElement, max_timeout_ms, customClass, autoPlay) {\n                var _window = window, seeThru = _window.seeThru, setTimeout1 = _window.setTimeout, clearTimeout1 = _window.clearTimeout;\n                return new Promise(function(resolve, reject) {\n                    var timerID = setTimeout1(function() {\n                        reject({\n                            status: \"error\",\n                            message: \"Timeout instantiating seeThru instance\"\n                        });\n                    }, max_timeout_ms);\n                    if (seeThru) {\n                        var seeThruInstance = seeThru.create(videoElement).ready(function() {\n                            // clear timeout reject error\n                            clearTimeout1(timerID);\n                            // force container width, else the canvas can overflow out\n                            var canvasElement = seeThruInstance.getCanvas();\n                            canvasElement.style.width = \"100%\";\n                            canvasElement.className += \" \" + customClass;\n                            // start the video if autoplay is set\n                            if (autoPlay) {\n                                seeThruInstance.play();\n                            }\n                            resolve(seeThruInstance);\n                        });\n                    } else {\n                        reject({\n                            status: \"error\",\n                            message: \"Error instantiating seeThru instance\"\n                        });\n                    }\n                });\n            }\n            /* harmony default export */ var transparentVideo_instantiateSeeThru = instantiateSeeThru;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/mountSeeThruCanvasTag.js\n            /**\n *\n * @param {HTMLElement} htmlElContainer\n * @param {string} videoURL\n * @param {TransformationOptions} options\n * @return {Promise<any>}\n */ function mountSeeThruCanvasTag(htmlElContainer, videoURL, options) {\n                var poster = options.poster, autoplay = options.autoplay, playsinline = options.playsinline, loop = options.loop, muted = options.muted;\n                videoURL = videoURL + \".mp4\"; // seeThru always uses mp4\n                return new Promise(function(resolve, reject) {\n                    xhr_loadScript(options.externalLibraries.seeThru, options.max_timeout_ms, window.seeThru).then(function() {\n                        xhr_getBlobFromURL(videoURL, options.max_timeout_ms).then(function(_ref) {\n                            var payload = _ref.payload;\n                            var videoElement = transparentVideo_createHiddenVideoTag({\n                                blobURL: payload.blobURL,\n                                videoURL: videoURL,\n                                // for debugging/testing\n                                poster: poster,\n                                autoplay: autoplay,\n                                playsinline: playsinline,\n                                loop: loop,\n                                muted: muted\n                            });\n                            htmlElContainer.appendChild(videoElement);\n                            transparentVideo_instantiateSeeThru(videoElement, options.max_timeout_ms, options[\"class\"], options.autoplay).then(function() {\n                                resolve(htmlElContainer);\n                            })[\"catch\"](function(err) {\n                                reject(err);\n                            });\n                        // catch for getBlobFromURL()\n                        })[\"catch\"](function(_ref2) {\n                            var status = _ref2.status, message = _ref2.message;\n                            reject({\n                                status: status,\n                                message: message\n                            });\n                        });\n                    // catch for loadScript()\n                    })[\"catch\"](function(_ref3) {\n                        var status = _ref3.status, message = _ref3.message;\n                        reject({\n                            status: status,\n                            message: message\n                        });\n                    });\n                });\n            }\n            /* harmony default export */ var transparentVideo_mountSeeThruCanvasTag = mountSeeThruCanvasTag;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/checkSupportForTransparency.js\n            /**\n * @return {Promise<boolean>} - Whether the browser supports transparent videos or not\n */ function checkSupportForTransparency() {\n                return new Promise(function(resolve, reject) {\n                    // Resolve early for safari.\n                    // Currently (29 December 2021) Safari can play webm/vp9,\n                    // but it does not support transparent video in the format we're outputting\n                    if (isSafari()) {\n                        resolve(false);\n                    }\n                    var video = document.createElement(\"video\");\n                    var canPlay = video.canPlayType && video.canPlayType('video/webm; codecs=\"vp9\"');\n                    resolve(canPlay === \"maybe\" || canPlay === \"probably\");\n                });\n            }\n            /* harmony default export */ var transparentVideo_checkSupportForTransparency = checkSupportForTransparency;\n            // CONCATENATED MODULE: ./src/cloudinary.js\n            function cloudinary_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return cloudinary_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, cloudinary_typeof(o);\n            }\n            function cloudinary_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function cloudinary_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, cloudinary_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function cloudinary_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) cloudinary_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) cloudinary_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function cloudinary_toPropertyKey(t) {\n                var i = cloudinary_toPrimitive(t, \"string\");\n                return \"symbol\" == cloudinary_typeof(i) ? i : i + \"\";\n            }\n            function cloudinary_toPrimitive(t, r) {\n                if (\"object\" != cloudinary_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != cloudinary_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            var applyBreakpoints, closestAbove, defaultBreakpoints, cloudinary_findContainerWidth, cloudinary_maxWidth, updateDpr;\n            //\n            defaultBreakpoints = function defaultBreakpoints(width) {\n                var steps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n                return steps * Math.ceil(width / steps);\n            };\n            closestAbove = function closestAbove(list, value) {\n                var i;\n                i = list.length - 2;\n                while(i >= 0 && list[i] >= value){\n                    i--;\n                }\n                return list[i + 1];\n            };\n            applyBreakpoints = function applyBreakpoints(tag, width, steps, options) {\n                var ref, ref1, ref2, responsive_use_breakpoints;\n                responsive_use_breakpoints = (ref = (ref1 = (ref2 = options[\"responsive_use_breakpoints\"]) != null ? ref2 : options[\"responsive_use_stoppoints\"]) != null ? ref1 : this.config(\"responsive_use_breakpoints\")) != null ? ref : this.config(\"responsive_use_stoppoints\");\n                if (!responsive_use_breakpoints || responsive_use_breakpoints === \"resize\" && !options.resizing) {\n                    return width;\n                } else {\n                    return this.calc_breakpoint(tag, width, steps);\n                }\n            };\n            cloudinary_findContainerWidth = function findContainerWidth(element) {\n                var containerWidth, style;\n                containerWidth = 0;\n                while((element = element != null ? element.parentNode : void 0) instanceof Element && !containerWidth){\n                    style = window.getComputedStyle(element);\n                    if (!/^inline/.test(style.display)) {\n                        containerWidth = lodash_width(element);\n                    }\n                }\n                return containerWidth;\n            };\n            updateDpr = function updateDpr(dataSrc, roundDpr) {\n                return dataSrc.replace(/\\bdpr_(1\\.0|auto)\\b/g, \"dpr_\" + this.device_pixel_ratio(roundDpr));\n            };\n            cloudinary_maxWidth = function maxWidth(requiredWidth, tag) {\n                var imageWidth;\n                imageWidth = lodash_getData(tag, \"width\") || 0;\n                if (requiredWidth > imageWidth) {\n                    imageWidth = requiredWidth;\n                    lodash_setData(tag, \"width\", requiredWidth);\n                }\n                return imageWidth;\n            };\n            var cloudinary_Cloudinary = /*#__PURE__*/ function() {\n                /**\n   * Creates a new Cloudinary instance.\n   * @class Cloudinary\n   * @classdesc Main class for accessing Cloudinary functionality.\n   * @param {Object} options - A {@link Configuration} object for globally configuring Cloudinary account settings.\n   * @example<br/>\n   *  var cl = new cloudinary.Cloudinary( { cloud_name: \"mycloud\"});<br/>\n   *  var imgTag = cl.image(\"myPicID\");\n   * @see <a href=\"https://cloudinary.com/documentation/solution_overview#configuration_parameters\" target=\"_blank\">\n   *  Available configuration options</a>\n   */ function Cloudinary(options) {\n                    cloudinary_classCallCheck(this, Cloudinary);\n                    var configuration;\n                    this.devicePixelRatioCache = {};\n                    this.responsiveConfig = {};\n                    this.responsiveResizeInitialized = false;\n                    configuration = new src_configuration(options);\n                    // Provided for backward compatibility\n                    this.config = function(newConfig, newValue) {\n                        return configuration.config(newConfig, newValue);\n                    };\n                    /**\n     * Use \\<meta\\> tags in the document to configure this `cloudinary` instance.\n     * @return This {Cloudinary} instance for chaining.\n     */ this.fromDocument = function() {\n                        configuration.fromDocument();\n                        return this;\n                    };\n                    /**\n     * Use environment variables to configure this `cloudinary` instance.\n     * @return This {Cloudinary} instance for chaining.\n     */ this.fromEnvironment = function() {\n                        configuration.fromEnvironment();\n                        return this;\n                    };\n                    /**\n     * Initializes the configuration of this `cloudinary` instance.\n     *  This is a convenience method that invokes both {@link Configuration#fromEnvironment|fromEnvironment()}\n     *  (Node.js environment only) and {@link Configuration#fromDocument|fromDocument()}.\n     *  It first tries to retrieve the configuration from the environment variable.\n     *  If not available, it tries from the document meta tags.\n     * @function Cloudinary#init\n     * @see Configuration#init\n     * @return This {Cloudinary} instance for chaining.\n     */ this.init = function() {\n                        configuration.init();\n                        return this;\n                    };\n                }\n                /**\n   * Convenience constructor\n   * @param {Object} options\n   * @return {Cloudinary}\n   * @example cl = cloudinary.Cloudinary.new( { cloud_name: \"mycloud\"})\n   */ return cloudinary_createClass(Cloudinary, [\n                    {\n                        key: \"url\",\n                        value: /**\n     * Generates a URL for any asset in your Media library.\n     * @function Cloudinary#url\n     * @param {string} publicId - The public ID of the media asset.\n     * @param {Object} [options] - The {@link Transformation} parameters to include in the URL.\n     * @param {type} [options.type='upload'] - The asset's storage type.\n     *  For details on all fetch types, see\n     * <a href=\"https://cloudinary.com/documentation/image_transformations#fetching_images_from_remote_locations\"\n     *  target=\"_blank\">Fetch types</a>.\n     * @param {resourceType} [options.resource_type='image'] - The type of asset. Possible values:<br/>\n     *  - `image`<br/>\n     *  - `video`<br/>\n     *  - `raw`\n     * @return {string} The media asset URL.\n     * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\" target=\"_blank\">\n     *  Available image transformations</a>\n     * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\" target=\"_blank\">\n     *  Available video transformations</a>\n     */ function url(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            return url_url(publicId, options, this.config());\n                        }\n                    },\n                    {\n                        key: \"video_url\",\n                        value: function video_url(publicId, options) {\n                            options = assign_root_assign_default()({\n                                resource_type: \"video\"\n                            }, options);\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"video_thumbnail_url\",\n                        value: function video_thumbnail_url(publicId, options) {\n                            options = assign_root_assign_default()({}, DEFAULT_POSTER_OPTIONS, options);\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"transformation_string\",\n                        value: function transformation_string(options) {\n                            return new src_transformation(options).serialize();\n                        }\n                    },\n                    {\n                        key: \"image\",\n                        value: function image(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            var client_hints, img, ref;\n                            img = this.imageTag(publicId, options);\n                            client_hints = (ref = options.client_hints != null ? options.client_hints : this.config(\"client_hints\")) != null ? ref : false;\n                            if (options.src == null && !client_hints) {\n                                // src must be removed before creating the DOM element to avoid loading the image\n                                img.setAttr(\"src\", \"\");\n                            }\n                            img = img.toDOM();\n                            if (!client_hints) {\n                                // cache the image src\n                                lodash_setData(img, \"src-cache\", this.url(publicId, options));\n                                // set image src taking responsiveness in account\n                                this.cloudinary_update(img, options);\n                            }\n                            return img;\n                        }\n                    },\n                    {\n                        key: \"imageTag\",\n                        value: function imageTag(publicId, options) {\n                            var tag;\n                            tag = new imagetag(publicId, this.config());\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"pictureTag\",\n                        value: function pictureTag(publicId, options, sources) {\n                            var tag;\n                            tag = new picturetag(publicId, this.config(), sources);\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"sourceTag\",\n                        value: function sourceTag(publicId, options) {\n                            var tag;\n                            tag = new sourcetag(publicId, this.config());\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"video_thumbnail\",\n                        value: function video_thumbnail(publicId, options) {\n                            return this.image(publicId, merge_root_merge_default()({}, DEFAULT_POSTER_OPTIONS, options));\n                        }\n                    },\n                    {\n                        key: \"facebook_profile_image\",\n                        value: function facebook_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"facebook\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"twitter_profile_image\",\n                        value: function twitter_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"twitter\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"twitter_name_profile_image\",\n                        value: function twitter_name_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"twitter_name\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"gravatar_image\",\n                        value: function gravatar_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"gravatar\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"fetch_image\",\n                        value: function fetch_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"fetch\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"video\",\n                        value: function video(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            return this.videoTag(publicId, options).toHtml();\n                        }\n                    },\n                    {\n                        key: \"videoTag\",\n                        value: function videoTag(publicId, options) {\n                            options = defaults({}, options, this.config());\n                            return new videotag(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"sprite_css\",\n                        value: function sprite_css(publicId, options) {\n                            options = assign_root_assign_default()({\n                                type: \"sprite\"\n                            }, options);\n                            if (!publicId.match(/.css$/)) {\n                                options.format = \"css\";\n                            }\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"responsive\",\n                        value: function responsive(options) {\n                            var _this = this;\n                            var bootstrap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n                            var ref, ref1, ref2, responsiveClass, responsiveResize, timeout;\n                            this.responsiveConfig = merge_root_merge_default()(this.responsiveConfig || {}, options);\n                            responsiveClass = (ref = this.responsiveConfig.responsive_class) != null ? ref : this.config(\"responsive_class\");\n                            if (bootstrap) {\n                                this.cloudinary_update(\"img.\".concat(responsiveClass, \", img.cld-hidpi\"), this.responsiveConfig);\n                            }\n                            responsiveResize = (ref1 = (ref2 = this.responsiveConfig.responsive_resize) != null ? ref2 : this.config(\"responsive_resize\")) != null ? ref1 : true;\n                            if (responsiveResize && !this.responsiveResizeInitialized) {\n                                this.responsiveConfig.resizing = this.responsiveResizeInitialized = true;\n                                timeout = null;\n                                var makeResponsive = function makeResponsive() {\n                                    var debounce, ref3, ref4, reset, run, wait, waitFunc;\n                                    debounce = (ref3 = (ref4 = _this.responsiveConfig.responsive_debounce) != null ? ref4 : _this.config(\"responsive_debounce\")) != null ? ref3 : 100;\n                                    reset = function reset() {\n                                        if (timeout) {\n                                            clearTimeout(timeout);\n                                            timeout = null;\n                                        }\n                                    };\n                                    run = function run() {\n                                        return _this.cloudinary_update(\"img.\".concat(responsiveClass), _this.responsiveConfig);\n                                    };\n                                    waitFunc = function waitFunc() {\n                                        reset();\n                                        return run();\n                                    };\n                                    wait = function wait() {\n                                        reset();\n                                        timeout = setTimeout(waitFunc, debounce);\n                                    };\n                                    if (debounce) {\n                                        return wait();\n                                    } else {\n                                        return run();\n                                    }\n                                };\n                                window.addEventListener(\"resize\", makeResponsive);\n                                return function() {\n                                    return window.removeEventListener(\"resize\", makeResponsive);\n                                };\n                            }\n                        }\n                    },\n                    {\n                        key: \"calc_breakpoint\",\n                        value: function calc_breakpoint(element, width, steps) {\n                            var breakpoints = lodash_getData(element, \"breakpoints\") || lodash_getData(element, \"stoppoints\") || this.config(\"breakpoints\") || this.config(\"stoppoints\") || defaultBreakpoints;\n                            if (isFunction_root_isFunction_default()(breakpoints)) {\n                                return breakpoints(width, steps);\n                            } else {\n                                if (isString_root_isString_default()(breakpoints)) {\n                                    breakpoints = breakpoints.split(\",\").map(function(point) {\n                                        return parseInt(point);\n                                    }).sort(function(a, b) {\n                                        return a - b;\n                                    });\n                                }\n                                return closestAbove(breakpoints, width);\n                            }\n                        }\n                    },\n                    {\n                        key: \"calc_stoppoint\",\n                        value: function calc_stoppoint(element, width, steps) {\n                            return this.calc_breakpoint(element, width, steps);\n                        }\n                    },\n                    {\n                        key: \"device_pixel_ratio\",\n                        value: function device_pixel_ratio(roundDpr) {\n                            roundDpr = roundDpr == null ? true : roundDpr;\n                            var dpr = ( false ? 0 : void 0) || 1;\n                            if (roundDpr) {\n                                dpr = Math.ceil(dpr);\n                            }\n                            if (dpr <= 0 || dpr === 0 / 0) {\n                                dpr = 1;\n                            }\n                            var dprString = dpr.toString();\n                            if (dprString.match(/^\\d+$/)) {\n                                dprString += \".0\";\n                            }\n                            return dprString;\n                        }\n                    },\n                    {\n                        key: \"processImageTags\",\n                        value: function processImageTags(nodes, options) {\n                            if (isEmpty(nodes)) {\n                                // similar to `$.fn.cloudinary`\n                                return this;\n                            }\n                            options = defaults({}, options || {}, this.config());\n                            var images = nodes.filter(function(node) {\n                                return /^img$/i.test(node.tagName);\n                            }).map(function(node) {\n                                var imgOptions = assign_root_assign_default()({\n                                    width: node.getAttribute(\"width\"),\n                                    height: node.getAttribute(\"height\"),\n                                    src: node.getAttribute(\"src\")\n                                }, options);\n                                var publicId = imgOptions[\"source\"] || imgOptions[\"src\"];\n                                delete imgOptions[\"source\"];\n                                delete imgOptions[\"src\"];\n                                var attr = new src_transformation(imgOptions).toHtmlAttributes();\n                                lodash_setData(node, \"src-cache\", url_url(publicId, imgOptions));\n                                node.setAttribute(\"width\", attr.width);\n                                node.setAttribute(\"height\", attr.height);\n                                return node;\n                            });\n                            this.cloudinary_update(images, options);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"cloudinary_update\",\n                        value: function cloudinary_update(elements, options) {\n                            var _this2 = this;\n                            var containerWidth, dataSrc, match, ref4, requiredWidth;\n                            if (elements === null) {\n                                return this;\n                            }\n                            if (options == null) {\n                                options = {};\n                            }\n                            var responsive = options.responsive != null ? options.responsive : this.config(\"responsive\");\n                            elements = normalizeToArray(elements);\n                            var responsiveClass;\n                            if (this.responsiveConfig && this.responsiveConfig.responsive_class != null) {\n                                responsiveClass = this.responsiveConfig.responsive_class;\n                            } else if (options.responsive_class != null) {\n                                responsiveClass = options.responsive_class;\n                            } else {\n                                responsiveClass = this.config(\"responsive_class\");\n                            }\n                            var roundDpr = options.round_dpr != null ? options.round_dpr : this.config(\"round_dpr\");\n                            elements.forEach(function(tag) {\n                                if (/img/i.test(tag.tagName)) {\n                                    var setUrl = true;\n                                    if (responsive) {\n                                        lodash_addClass(tag, responsiveClass);\n                                    }\n                                    dataSrc = lodash_getData(tag, \"src-cache\") || lodash_getData(tag, \"src\");\n                                    if (!isEmpty(dataSrc)) {\n                                        // Update dpr according to the device's devicePixelRatio\n                                        dataSrc = updateDpr.call(_this2, dataSrc, roundDpr);\n                                        if (htmltag.isResponsive(tag, responsiveClass)) {\n                                            containerWidth = cloudinary_findContainerWidth(tag);\n                                            if (containerWidth !== 0) {\n                                                if (/w_auto:breakpoints/.test(dataSrc)) {\n                                                    requiredWidth = cloudinary_maxWidth(containerWidth, tag);\n                                                    if (requiredWidth) {\n                                                        dataSrc = dataSrc.replace(/w_auto:breakpoints([_0-9]*)(:[0-9]+)?/, \"w_auto:breakpoints$1:\".concat(requiredWidth));\n                                                    } else {\n                                                        setUrl = false;\n                                                    }\n                                                } else {\n                                                    match = /w_auto(:(\\d+))?/.exec(dataSrc);\n                                                    if (match) {\n                                                        requiredWidth = applyBreakpoints.call(_this2, tag, containerWidth, match[2], options);\n                                                        requiredWidth = cloudinary_maxWidth(requiredWidth, tag);\n                                                        if (requiredWidth) {\n                                                            dataSrc = dataSrc.replace(/w_auto[^,\\/]*/g, \"w_\".concat(requiredWidth));\n                                                        } else {\n                                                            setUrl = false;\n                                                        }\n                                                    }\n                                                }\n                                                lodash_removeAttribute(tag, \"width\");\n                                                if (!options.responsive_preserve_height) {\n                                                    lodash_removeAttribute(tag, \"height\");\n                                                }\n                                            } else {\n                                                // Container doesn't know the size yet - usually because the image is hidden or outside the DOM.\n                                                setUrl = false;\n                                            }\n                                        }\n                                        var isLazyLoading = options.loading === \"lazy\" && !_this2.isNativeLazyLoadSupported() && _this2.isLazyLoadSupported() && !elements[0].getAttribute(\"src\");\n                                        if (setUrl || isLazyLoading) {\n                                            // If data-width exists, set width to be data-width\n                                            _this2.setAttributeIfExists(elements[0], \"width\", \"data-width\");\n                                        }\n                                        if (setUrl && !isLazyLoading) {\n                                            lodash_setAttribute(tag, \"src\", dataSrc);\n                                        }\n                                    }\n                                }\n                            });\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setAttributeIfExists\",\n                        value: function setAttributeIfExists(element, toAttribute, fromAttribute) {\n                            var attributeValue = element.getAttribute(fromAttribute);\n                            if (attributeValue != null) {\n                                lodash_setAttribute(element, toAttribute, attributeValue);\n                            }\n                        }\n                    },\n                    {\n                        key: \"isLazyLoadSupported\",\n                        value: function isLazyLoadSupported() {\n                            return window && \"IntersectionObserver\" in window;\n                        }\n                    },\n                    {\n                        key: \"isNativeLazyLoadSupported\",\n                        value: function isNativeLazyLoadSupported() {\n                            return \"loading\" in HTMLImageElement.prototype;\n                        }\n                    },\n                    {\n                        key: \"transformation\",\n                        value: function transformation(options) {\n                            return src_transformation[\"new\"](this.config()).fromOptions(options).setParent(this);\n                        }\n                    },\n                    {\n                        key: \"injectTransparentVideoElement\",\n                        value: function injectTransparentVideoElement(htmlElContainer, publicId) {\n                            var _this3 = this;\n                            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                            return new Promise(function(resolve, reject) {\n                                if (!htmlElContainer) {\n                                    reject({\n                                        status: \"error\",\n                                        message: \"Expecting htmlElContainer to be HTMLElement\"\n                                    });\n                                }\n                                transparentVideo_enforceOptionsForTransparentVideo(options);\n                                var videoURL = _this3.video_url(publicId, options);\n                                transparentVideo_checkSupportForTransparency().then(function(isNativelyTransparent) {\n                                    var mountPromise;\n                                    if (isNativelyTransparent) {\n                                        mountPromise = transparentVideo_mountCloudinaryVideoTag(htmlElContainer, _this3, publicId, options);\n                                        resolve(htmlElContainer);\n                                    } else {\n                                        mountPromise = transparentVideo_mountSeeThruCanvasTag(htmlElContainer, videoURL, options);\n                                    }\n                                    mountPromise.then(function() {\n                                        resolve(htmlElContainer);\n                                    })[\"catch\"](function(_ref) {\n                                        var status = _ref.status, message = _ref.message;\n                                        reject({\n                                            status: status,\n                                            message: message\n                                        });\n                                    });\n                                // catch for checkSupportForTransparency()\n                                })[\"catch\"](function(_ref2) {\n                                    var status = _ref2.status, message = _ref2.message;\n                                    reject({\n                                        status: status,\n                                        message: message\n                                    });\n                                });\n                            });\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(options) {\n                            return new this(options);\n                        }\n                    }\n                ]);\n            }();\n            assign_root_assign_default()(cloudinary_Cloudinary, constants_namespaceObject);\n            /* harmony default export */ var cloudinary = cloudinary_Cloudinary;\n            // CONCATENATED MODULE: ./src/namespace/cloudinary-core.js\n            /**\n * Creates the namespace for Cloudinary\n */ /* harmony default export */ var cloudinary_core = __nested_webpack_exports__[\"default\"] = {\n                ClientHintsMetaTag: clienthintsmetatag,\n                Cloudinary: cloudinary,\n                Condition: condition,\n                Configuration: src_configuration,\n                crc32: src_crc32,\n                Expression: expression,\n                FetchLayer: fetchlayer,\n                HtmlTag: htmltag,\n                ImageTag: imagetag,\n                Layer: layer_layer,\n                PictureTag: picturetag,\n                SubtitlesLayer: subtitleslayer,\n                TextLayer: textlayer,\n                Transformation: src_transformation,\n                utf8_encode: src_utf8_encode,\n                Util: lodash_namespaceObject,\n                VideoTag: videotag\n            };\n        /***/ },\n        /***/ \"lodash/assign\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_assign__;\n        /***/ },\n        /***/ \"lodash/cloneDeep\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_cloneDeep__;\n        /***/ },\n        /***/ \"lodash/compact\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_compact__;\n        /***/ },\n        /***/ \"lodash/difference\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_difference__;\n        /***/ },\n        /***/ \"lodash/functions\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_functions__;\n        /***/ },\n        /***/ \"lodash/identity\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_identity__;\n        /***/ },\n        /***/ \"lodash/includes\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_includes__;\n        /***/ },\n        /***/ \"lodash/isArray\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isArray__;\n        /***/ },\n        /***/ \"lodash/isElement\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isElement__;\n        /***/ },\n        /***/ \"lodash/isFunction\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isFunction__;\n        /***/ },\n        /***/ \"lodash/isPlainObject\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isPlainObject__;\n        /***/ },\n        /***/ \"lodash/isString\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isString__;\n        /***/ },\n        /***/ \"lodash/merge\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_merge__;\n        /***/ },\n        /***/ \"lodash/trim\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_trim__;\n        /***/ }\n    });\n}); //# sourceMappingURL=cloudinary-core.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jbG91ZGluYXJ5LWNvcmUvY2xvdWRpbmFyeS1jb3JlLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7O0dBTUcsR0FDRixVQUFTQSxpQ0FBaUNDLElBQUksRUFBRUMsT0FBTztJQUN2RCxJQUFHLElBQWlELEVBQ25ERSxPQUFPRCxPQUFPLEdBQUdELFFBQVFHLG1CQUFPQSxDQUFDLG9DQUFlLEdBQUdBLG1CQUFPQSxDQUFDLDBDQUFrQixHQUFHQSxtQkFBT0EsQ0FBQyxzQ0FBZ0IsR0FBR0EsbUJBQU9BLENBQUMsNENBQW1CLEdBQUdBLG1CQUFPQSxDQUFDLDBDQUFrQixHQUFHQSxtQkFBT0EsQ0FBQyx3Q0FBaUIsR0FBR0EsbUJBQU9BLENBQUMsd0NBQWlCLEdBQUdBLG1CQUFPQSxDQUFDLHNDQUFnQixHQUFHQSxtQkFBT0EsQ0FBQywwQ0FBa0IsR0FBR0EsbUJBQU9BLENBQUMsNENBQW1CLEdBQUdBLG1CQUFPQSxDQUFDLGtEQUFzQixHQUFHQSxtQkFBT0EsQ0FBQyx3Q0FBaUIsR0FBR0EsbUJBQU9BLENBQUMsa0NBQWMsR0FBR0EsbUJBQU9BLENBQUMsZ0NBQWE7U0FDM1osRUFLNFY7QUFDbFcsR0FBRyxRQUFNLFNBQVNHLHlDQUF5QyxFQUFFQyw0Q0FBNEMsRUFBRUMsMENBQTBDLEVBQUVDLDZDQUE2QyxFQUFFQyw0Q0FBNEMsRUFBRUMsMkNBQTJDLEVBQUVDLDJDQUEyQyxFQUFFQywwQ0FBMEMsRUFBRUMsNENBQTRDLEVBQUVDLDZDQUE2QyxFQUFFQyxnREFBZ0QsRUFBRUMsMkNBQTJDLEVBQUVDLHdDQUF3QyxFQUFFQyx1Q0FBdUM7SUFDdm9CLE9BQWdCLE1BQUgsR0FBSSxTQUFTQyxPQUFPO1FBQ2pDLE1BQU0sR0FBSSxtQkFBbUI7UUFDN0IsTUFBTSxHQUFJLElBQUlDLG1CQUFtQixDQUFDO1FBQ2xDLE1BQU0sR0FDTixNQUFNLEdBQUksdUJBQXVCO1FBQ2pDLE1BQU0sR0FBSSxTQUFTQywrQkFB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VztRQUVqQixHQUFHLEdBQUc7UUFFTixHQUFHLEdBQUcsa0JBQ04sR0FBRyxHQUFJLFNBQVNWLE9BQU0sRUFBRUQsUUFBTztZQUUvQkMsUUFBT0QsT0FBTyxHQUFHWTtRQUVqQixHQUFHLEdBQUc7UUFFTixHQUFHLEdBQUcsb0JBQ04sR0FBRyxHQUFJLFNBQVNYLE9BQU0sRUFBRUQsUUFBTztZQUUvQkMsUUFBT0QsT0FBTyxHQUFHYTtRQUVqQixHQUFHLEdBQUc7UUFFTixHQUFHLEdBQUcscUJBQ04sR0FBRyxHQUFJLFNBQVNaLE9BQU0sRUFBRUQsUUFBTztZQUUvQkMsUUFBT0QsT0FBTyxHQUFHYztRQUVqQixHQUFHLEdBQUc7UUFFTixHQUFHLEdBQUcsd0JBQ04sR0FBRyxHQUFJLFNBQVNiLE9BQU0sRUFBRUQsUUFBTztZQUUvQkMsUUFBT0QsT0FBTyxHQUFHZTtRQUVqQixHQUFHLEdBQUc7UUFFTixHQUFHLEdBQUcsbUJBQ04sR0FBRyxHQUFJLFNBQVNkLE9BQU0sRUFBRUQsUUFBTztZQUUvQkMsUUFBT0QsT0FBTyxHQUFHZ0I7UUFFakIsR0FBRyxHQUFHO1FBRU4sR0FBRyxHQUFHLGdCQUNOLEdBQUcsR0FBSSxTQUFTZixPQUFNLEVBQUVELFFBQU87WUFFL0JDLFFBQU9ELE9BQU8sR0FBR2lCO1FBRWpCLEdBQUcsR0FBRztRQUVOLEdBQUcsR0FBRyxlQUNOLEdBQUcsR0FBSSxTQUFTaEIsT0FBTSxFQUFFRCxRQUFPO1lBRS9CQyxRQUFPRCxPQUFPLEdBQUdrQjtRQUVqQixHQUFHLEdBQUc7SUFFRztBQUNULElBQ0EsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2FpZ29ueGFuaC8uL25vZGVfbW9kdWxlcy9jbG91ZGluYXJ5LWNvcmUvY2xvdWRpbmFyeS1jb3JlLmpzP2Y3M2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gICAqIGNsb3VkaW5hcnktY29yZS5qc1xuICAgKiBDbG91ZGluYXJ5J3MgSmF2YVNjcmlwdCBsaWJyYXJ5IC0gVmVyc2lvbiAyLjEzLjFcbiAgICogQ29weXJpZ2h0IENsb3VkaW5hcnlcbiAgICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jbG91ZGluYXJ5L2Nsb3VkaW5hcnlfanNcbiAgICpcbiAgICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJsb2Rhc2gvYXNzaWduXCIpLCByZXF1aXJlKFwibG9kYXNoL2Nsb25lRGVlcFwiKSwgcmVxdWlyZShcImxvZGFzaC9jb21wYWN0XCIpLCByZXF1aXJlKFwibG9kYXNoL2RpZmZlcmVuY2VcIiksIHJlcXVpcmUoXCJsb2Rhc2gvZnVuY3Rpb25zXCIpLCByZXF1aXJlKFwibG9kYXNoL2lkZW50aXR5XCIpLCByZXF1aXJlKFwibG9kYXNoL2luY2x1ZGVzXCIpLCByZXF1aXJlKFwibG9kYXNoL2lzQXJyYXlcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNFbGVtZW50XCIpLCByZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiKSwgcmVxdWlyZShcImxvZGFzaC9pc1N0cmluZ1wiKSwgcmVxdWlyZShcImxvZGFzaC9tZXJnZVwiKSwgcmVxdWlyZShcImxvZGFzaC90cmltXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImxvZGFzaC9hc3NpZ25cIiwgXCJsb2Rhc2gvY2xvbmVEZWVwXCIsIFwibG9kYXNoL2NvbXBhY3RcIiwgXCJsb2Rhc2gvZGlmZmVyZW5jZVwiLCBcImxvZGFzaC9mdW5jdGlvbnNcIiwgXCJsb2Rhc2gvaWRlbnRpdHlcIiwgXCJsb2Rhc2gvaW5jbHVkZXNcIiwgXCJsb2Rhc2gvaXNBcnJheVwiLCBcImxvZGFzaC9pc0VsZW1lbnRcIiwgXCJsb2Rhc2gvaXNGdW5jdGlvblwiLCBcImxvZGFzaC9pc1BsYWluT2JqZWN0XCIsIFwibG9kYXNoL2lzU3RyaW5nXCIsIFwibG9kYXNoL21lcmdlXCIsIFwibG9kYXNoL3RyaW1cIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiY2xvdWRpbmFyeVwiXSA9IGZhY3RvcnkocmVxdWlyZShcImxvZGFzaC9hc3NpZ25cIiksIHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVEZWVwXCIpLCByZXF1aXJlKFwibG9kYXNoL2NvbXBhY3RcIiksIHJlcXVpcmUoXCJsb2Rhc2gvZGlmZmVyZW5jZVwiKSwgcmVxdWlyZShcImxvZGFzaC9mdW5jdGlvbnNcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaWRlbnRpdHlcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaW5jbHVkZXNcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNBcnJheVwiKSwgcmVxdWlyZShcImxvZGFzaC9pc0VsZW1lbnRcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNGdW5jdGlvblwiKSwgcmVxdWlyZShcImxvZGFzaC9pc1BsYWluT2JqZWN0XCIpLCByZXF1aXJlKFwibG9kYXNoL2lzU3RyaW5nXCIpLCByZXF1aXJlKFwibG9kYXNoL21lcmdlXCIpLCByZXF1aXJlKFwibG9kYXNoL3RyaW1cIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImNsb3VkaW5hcnlcIl0gPSBmYWN0b3J5KHJvb3RbXCJfXCJdW1wiYXNzaWduXCJdLCByb290W1wiX1wiXVtcImNsb25lRGVlcFwiXSwgcm9vdFtcIl9cIl1bXCJjb21wYWN0XCJdLCByb290W1wiX1wiXVtcImRpZmZlcmVuY2VcIl0sIHJvb3RbXCJfXCJdW1wiZnVuY3Rpb25zXCJdLCByb290W1wiX1wiXVtcImlkZW50aXR5XCJdLCByb290W1wiX1wiXVtcImluY2x1ZGVzXCJdLCByb290W1wiX1wiXVtcImlzQXJyYXlcIl0sIHJvb3RbXCJfXCJdW1wiaXNFbGVtZW50XCJdLCByb290W1wiX1wiXVtcImlzRnVuY3Rpb25cIl0sIHJvb3RbXCJfXCJdW1wiaXNQbGFpbk9iamVjdFwiXSwgcm9vdFtcIl9cIl1bXCJpc1N0cmluZ1wiXSwgcm9vdFtcIl9cIl1bXCJtZXJnZVwiXSwgcm9vdFtcIl9cIl1bXCJ0cmltXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2Fzc2lnbl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9jbG9uZURlZXBfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfY29tcGFjdF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9kaWZmZXJlbmNlX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2Z1bmN0aW9uc19fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pZGVudGl0eV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pbmNsdWRlc19fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc0FycmF5X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzRWxlbWVudF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc0Z1bmN0aW9uX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzUGxhaW5PYmplY3RfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNTdHJpbmdfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfbWVyZ2VfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfdHJpbV9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL25hbWVzcGFjZS9jbG91ZGluYXJ5LWNvcmUuanNcIik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovICh7XG5cbi8qKiovIFwiLi9zcmMvbmFtZXNwYWNlL2Nsb3VkaW5hcnktY29yZS5qc1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIEVTTSBDT01QQVQgRkxBR1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBFWFBPUlRTXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDbGllbnRIaW50c01ldGFUYWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBjbGllbnRoaW50c21ldGF0YWc7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQ2xvdWRpbmFyeVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGNsb3VkaW5hcnk7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQ29uZGl0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gY29uZGl0aW9uOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNvbmZpZ3VyYXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBzcmNfY29uZmlndXJhdGlvbjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjcmMzMlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIHNyY19jcmMzMjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJFeHByZXNzaW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gZXhwcmVzc2lvbjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJGZXRjaExheWVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gZmV0Y2hsYXllcjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJIdG1sVGFnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gaHRtbHRhZzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJJbWFnZVRhZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGltYWdldGFnOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkxheWVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gbGF5ZXJfbGF5ZXI7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiUGljdHVyZVRhZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIHBpY3R1cmV0YWc7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiU3VidGl0bGVzTGF5ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBzdWJ0aXRsZXNsYXllcjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJUZXh0TGF5ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyB0ZXh0bGF5ZXI7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVHJhbnNmb3JtYXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBzcmNfdHJhbnNmb3JtYXRpb247IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidXRmOF9lbmNvZGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBzcmNfdXRmOF9lbmNvZGU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVXRpbFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGxvZGFzaF9uYW1lc3BhY2VPYmplY3Q7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVmlkZW9UYWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyB2aWRlb3RhZzsgfSk7XG5cbi8vIE5BTUVTUEFDRSBPQkpFQ1Q6IC4vc3JjL2NvbnN0YW50cy5qc1xudmFyIGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QgPSB7fTtcbl9fd2VicGFja19yZXF1aXJlX18ucihjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIlZFUlNJT05cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBWRVJTSU9OOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkNGX1NIQVJFRF9DRE5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDRl9TSEFSRURfQ0ROOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIk9MRF9BS0FNQUlfU0hBUkVEX0NETlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIE9MRF9BS0FNQUlfU0hBUkVEX0NETjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJBS0FNQUlfU0hBUkVEX0NETlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEFLQU1BSV9TSEFSRURfQ0ROOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIlNIQVJFRF9DRE5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTSEFSRURfQ0ROOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkRFRkFVTFRfVElNRU9VVF9NU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERFRkFVTFRfVElNRU9VVF9NUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJERUZBVUxUX1BPU1RFUl9PUFRJT05TXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gREVGQVVMVF9QT1NURVJfT1BUSU9OUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJERUZBVUxUX1ZJREVPX1NPVVJDRV9UWVBFU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERFRkFVTFRfVklERU9fU09VUkNFX1RZUEVTOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIlNFT19UWVBFU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNFT19UWVBFUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJERUZBVUxUX0lNQUdFX1BBUkFNU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERFRkFVTFRfSU1BR0VfUEFSQU1TOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkRFRkFVTFRfVklERU9fUEFSQU1TXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gREVGQVVMVF9WSURFT19QQVJBTVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiREVGQVVMVF9WSURFT19TT1VSQ0VTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gREVGQVVMVF9WSURFT19TT1VSQ0VTOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkRFRkFVTFRfRVhURVJOQUxfTElCUkFSSUVTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gREVGQVVMVF9FWFRFUk5BTF9MSUJSQVJJRVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiUExBQ0VIT0xERVJfSU1BR0VfTU9ERVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBQTEFDRUhPTERFUl9JTUFHRV9NT0RFUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJBQ0NFU1NJQklMSVRZX01PREVTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQUNDRVNTSUJJTElUWV9NT0RFUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJVUkxfS0VZU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFVSTF9LRVlTOyB9KTtcblxuLy8gTkFNRVNQQUNFIE9CSkVDVDogLi9zcmMvdXRpbC9sb2Rhc2guanNcbnZhciBsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0ID0ge307XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIobG9kYXNoX25hbWVzcGFjZU9iamVjdCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJnZXRTREtBbmFseXRpY3NTaWduYXR1cmVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRTREtBbmFseXRpY3NTaWduYXR1cmU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZ2V0QW5hbHl0aWNzT3B0aW9uc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEFuYWx5dGljc09wdGlvbnM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiYXNzaWduXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJjbG9uZURlZXBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImNvbXBhY3RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZGlmZmVyZW5jZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRpZmZlcmVuY2Vfcm9vdF9kaWZmZXJlbmNlX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJmdW5jdGlvbnNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmdW5jdGlvbnNfcm9vdF9mdW5jdGlvbnNfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlkZW50aXR5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaWRlbnRpdHlfcm9vdF9pZGVudGl0eV9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaW5jbHVkZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpbmNsdWRlc19yb290X2luY2x1ZGVzX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc0FycmF5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzUGxhaW5PYmplY3RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNTdHJpbmdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJtZXJnZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImNvbnRhaW5zXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNJbnRlcnNlY3Rpb25PYnNlcnZlclN1cHBvcnRlZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzSW50ZXJzZWN0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZGV0ZWN0SW50ZXJzZWN0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGV0ZWN0SW50ZXJzZWN0aW9uOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIm9taXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBvbWl0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImFsbFN0cmluZ3NcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBiYXNldXRpbF9hbGxTdHJpbmdzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIndpdGhvdXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB3aXRob3V0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzTnVtYmVyTGlrZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzTnVtYmVyTGlrZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJzbWFydEVzY2FwZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNtYXJ0RXNjYXBlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImRlZmF1bHRzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGVmYXVsdHM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwib2JqZWN0UHJvdG9cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBvYmplY3RQcm90bzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJvYmpUb1N0cmluZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG9ialRvU3RyaW5nOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzT2JqZWN0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNPYmplY3Q7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZnVuY1RhZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZ1bmNUYWc7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwicmVXb3Jkc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJlV29yZHM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiY2FtZWxDYXNlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2FtZWxDYXNlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcInNuYWtlQ2FzZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNuYWtlQ2FzZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJjb252ZXJ0S2V5c1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbnZlcnRLZXlzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIndpdGhDYW1lbENhc2VLZXlzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gd2l0aENhbWVsQ2FzZUtleXM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwid2l0aFNuYWtlQ2FzZUtleXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB3aXRoU25ha2VDYXNlS2V5czsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJiYXNlNjRFbmNvZGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBiYXNlNjRFbmNvZGU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiYmFzZTY0RW5jb2RlVVJMXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYmFzZTY0RW5jb2RlVVJMOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImV4dHJhY3RVcmxQYXJhbXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBleHRyYWN0VXJsUGFyYW1zOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcInBhdGNoRmV0Y2hGb3JtYXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwYXRjaEZldGNoRm9ybWF0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIm9wdGlvbkNvbnN1bWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBvcHRpb25Db25zdW1lOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzRW1wdHlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0VtcHR5OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzQW5kcm9pZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzQW5kcm9pZDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc0VkZ2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0VkZ2U7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNDaHJvbWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0Nocm9tZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc1NhZmFyaVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzU2FmYXJpOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzRWxlbWVudFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzRWxlbWVudF9yb290X2lzRWxlbWVudF9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNGdW5jdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJ0cmltXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJpbV9yb290X3RyaW1fZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImdldERhdGFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2Rhc2hfZ2V0RGF0YTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJzZXREYXRhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX3NldERhdGE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZ2V0QXR0cmlidXRlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX2dldEF0dHJpYnV0ZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJzZXRBdHRyaWJ1dGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2Rhc2hfc2V0QXR0cmlidXRlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcInJlbW92ZUF0dHJpYnV0ZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZGFzaF9yZW1vdmVBdHRyaWJ1dGU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwic2V0QXR0cmlidXRlc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNldEF0dHJpYnV0ZXM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaGFzQ2xhc3NcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2Rhc2hfaGFzQ2xhc3M7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiYWRkQ2xhc3NcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2Rhc2hfYWRkQ2xhc3M7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZ2V0U3R5bGVzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0U3R5bGVzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImNzc0V4cGFuZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNzc0V4cGFuZDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJkb21TdHlsZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRvbVN0eWxlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImN1ckNTU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGN1ckNTUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJjc3NWYWx1ZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNzc1ZhbHVlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImF1Z21lbnRXaWR0aE9ySGVpZ2h0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXVnbWVudFdpZHRoT3JIZWlnaHQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZ2V0V2lkdGhPckhlaWdodFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFdpZHRoT3JIZWlnaHQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwid2lkdGhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2Rhc2hfd2lkdGg7IH0pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGY4X2VuY29kZS5qc1xuLyoqXG4gKiBVVEY4IGVuY29kZXJcbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1dGY4X2VuY29kZTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY191dGY4X2VuY29kZSA9ICh1dGY4X2VuY29kZSA9IGZ1bmN0aW9uIHV0ZjhfZW5jb2RlKGFyZ1N0cmluZykge1xuICB2YXIgYzEsIGVuYywgZW5kLCBuLCBzdGFydCwgc3RyaW5nLCBzdHJpbmdsLCB1dGZ0ZXh0O1xuICAvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxuICAvLyArICAgb3JpZ2luYWwgYnk6IFdlYnRvb2xraXQuaW5mbyAoaHR0cDovL3d3dy53ZWJ0b29sa2l0LmluZm8vKVxuICAvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAvLyArICAgaW1wcm92ZWQgYnk6IHNvd2JlcnJ5XG4gIC8vICsgICAgdHdlYWtlZCBieTogSmFja1xuICAvLyArICAgYnVnZml4ZWQgYnk6IE9ubm8gTWFyc21hblxuICAvLyArICAgaW1wcm92ZWQgYnk6IFl2ZXMgU3VjYWV0XG4gIC8vICsgICBidWdmaXhlZCBieTogT25ubyBNYXJzbWFuXG4gIC8vICsgICBidWdmaXhlZCBieTogVWxyaWNoXG4gIC8vICsgICBidWdmaXhlZCBieTogUmFmYWwgS3VrYXdza2lcbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBraXJpbGxvaWRcbiAgLy8gKiAgICAgZXhhbXBsZSAxOiB1dGY4X2VuY29kZSgnS2V2aW4gdmFuIFpvbm5ldmVsZCcpO1xuICAvLyAqICAgICByZXR1cm5zIDE6ICdLZXZpbiB2YW4gWm9ubmV2ZWxkJ1xuICBpZiAoYXJnU3RyaW5nID09PSBudWxsIHx8IHR5cGVvZiBhcmdTdHJpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHN0cmluZyA9IGFyZ1N0cmluZyArICcnO1xuICAvLyAucmVwbGFjZSgvXFxyXFxuL2csIFwiXFxuXCIpLnJlcGxhY2UoL1xcci9nLCBcIlxcblwiKTtcbiAgdXRmdGV4dCA9ICcnO1xuICBzdGFydCA9IHZvaWQgMDtcbiAgZW5kID0gdm9pZCAwO1xuICBzdHJpbmdsID0gMDtcbiAgc3RhcnQgPSBlbmQgPSAwO1xuICBzdHJpbmdsID0gc3RyaW5nLmxlbmd0aDtcbiAgbiA9IDA7XG4gIHdoaWxlIChuIDwgc3RyaW5nbCkge1xuICAgIGMxID0gc3RyaW5nLmNoYXJDb2RlQXQobik7XG4gICAgZW5jID0gbnVsbDtcbiAgICBpZiAoYzEgPCAxMjgpIHtcbiAgICAgIGVuZCsrO1xuICAgIH0gZWxzZSBpZiAoYzEgPiAxMjcgJiYgYzEgPCAyMDQ4KSB7XG4gICAgICBlbmMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMxID4+IDYgfCAxOTIsIGMxICYgNjMgfCAxMjgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMxID4+IDEyIHwgMjI0LCBjMSA+PiA2ICYgNjMgfCAxMjgsIGMxICYgNjMgfCAxMjgpO1xuICAgIH1cbiAgICBpZiAoZW5jICE9PSBudWxsKSB7XG4gICAgICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICAgICAgdXRmdGV4dCArPSBzdHJpbmcuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICB1dGZ0ZXh0ICs9IGVuYztcbiAgICAgIHN0YXJ0ID0gZW5kID0gbiArIDE7XG4gICAgfVxuICAgIG4rKztcbiAgfVxuICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICB1dGZ0ZXh0ICs9IHN0cmluZy5zbGljZShzdGFydCwgc3RyaW5nbCk7XG4gIH1cbiAgcmV0dXJuIHV0ZnRleHQ7XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NyYzMyLmpzXG5cblxuLyoqXG4gKiBDUkMzMiBjYWxjdWxhdG9yXG4gKiBEZXBlbmRzIG9uICd1dGY4X2VuY29kZSdcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBjYWxjdWxhdGUgdGhlIENSQzMyIGZvci5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gY3JjMzIoc3RyKSB7XG4gIHZhciBjcmMsIGksIGlUb3AsIHRhYmxlLCB4LCB5O1xuICAvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxuICAvLyArICAgb3JpZ2luYWwgYnk6IFdlYnRvb2xraXQuaW5mbyAoaHR0cDovL3d3dy53ZWJ0b29sa2l0LmluZm8vKVxuICAvLyArICAgaW1wcm92ZWQgYnk6IFQwYnNuXG4gIC8vICsgICBpbXByb3ZlZCBieTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNjQ3OTM1L2phdmFzY3JpcHQtY3JjMzItZnVuY3Rpb24tYW5kLXBocC1jcmMzMi1ub3QtbWF0Y2hpbmdcbiAgLy8gLSAgICBkZXBlbmRzIG9uOiB1dGY4X2VuY29kZVxuICAvLyAqICAgICBleGFtcGxlIDE6IGNyYzMyKCdLZXZpbiB2YW4gWm9ubmV2ZWxkJyk7XG4gIC8vICogICAgIHJldHVybnMgMTogMTI0OTk5MTI0OVxuICBzdHIgPSBzcmNfdXRmOF9lbmNvZGUoc3RyKTtcbiAgdGFibGUgPSAnMDAwMDAwMDAgNzcwNzMwOTYgRUUwRTYxMkMgOTkwOTUxQkEgMDc2REM0MTkgNzA2QUY0OEYgRTk2M0E1MzUgOUU2NDk1QTMgMEVEQjg4MzIgNzlEQ0I4QTQgRTBENUU5MUUgOTdEMkQ5ODggMDlCNjRDMkIgN0VCMTdDQkQgRTdCODJEMDcgOTBCRjFEOTEgMURCNzEwNjQgNkFCMDIwRjIgRjNCOTcxNDggODRCRTQxREUgMUFEQUQ0N0QgNkREREU0RUIgRjRENEI1NTEgODNEMzg1QzcgMTM2Qzk4NTYgNjQ2QkE4QzAgRkQ2MkY5N0EgOEE2NUM5RUMgMTQwMTVDNEYgNjMwNjZDRDkgRkEwRjNENjMgOEQwODBERjUgM0I2RTIwQzggNEM2OTEwNUUgRDU2MDQxRTQgQTI2NzcxNzIgM0MwM0U0RDEgNEIwNEQ0NDcgRDIwRDg1RkQgQTUwQUI1NkIgMzVCNUE4RkEgNDJCMjk4NkMgREJCQkM5RDYgQUNCQ0Y5NDAgMzJEODZDRTMgNDVERjVDNzUgRENENjBEQ0YgQUJEMTNENTkgMjZEOTMwQUMgNTFERTAwM0EgQzhENzUxODAgQkZEMDYxMTYgMjFCNEY0QjUgNTZCM0M0MjMgQ0ZCQTk1OTkgQjhCREE1MEYgMjgwMkI4OUUgNUYwNTg4MDggQzYwQ0Q5QjIgQjEwQkU5MjQgMkY2RjdDODcgNTg2ODRDMTEgQzE2MTFEQUIgQjY2NjJEM0QgNzZEQzQxOTAgMDFEQjcxMDYgOThEMjIwQkMgRUZENTEwMkEgNzFCMTg1ODkgMDZCNkI1MUYgOUZCRkU0QTUgRThCOEQ0MzMgNzgwN0M5QTIgMEYwMEY5MzQgOTYwOUE4OEUgRTEwRTk4MTggN0Y2QTBEQkIgMDg2RDNEMkQgOTE2NDZDOTcgRTY2MzVDMDEgNkI2QjUxRjQgMUM2QzYxNjIgODU2NTMwRDggRjI2MjAwNEUgNkMwNjk1RUQgMUIwMUE1N0IgODIwOEY0QzEgRjUwRkM0NTcgNjVCMEQ5QzYgMTJCN0U5NTAgOEJCRUI4RUEgRkNCOTg4N0MgNjJERDFEREYgMTVEQTJENDkgOENEMzdDRjMgRkJENDRDNjUgNERCMjYxNTggM0FCNTUxQ0UgQTNCQzAwNzQgRDRCQjMwRTIgNEFERkE1NDEgM0REODk1RDcgQTREMUM0NkQgRDNENkY0RkIgNDM2OUU5NkEgMzQ2RUQ5RkMgQUQ2Nzg4NDYgREE2MEI4RDAgNDQwNDJENzMgMzMwMzFERTUgQUEwQTRDNUYgREQwRDdDQzkgNTAwNTcxM0MgMjcwMjQxQUEgQkUwQjEwMTAgQzkwQzIwODYgNTc2OEI1MjUgMjA2Rjg1QjMgQjk2NkQ0MDkgQ0U2MUU0OUYgNUVERUY5MEUgMjlEOUM5OTggQjBEMDk4MjIgQzdEN0E4QjQgNTlCMzNEMTcgMkVCNDBEODEgQjdCRDVDM0IgQzBCQTZDQUQgRURCODgzMjAgOUFCRkIzQjYgMDNCNkUyMEMgNzRCMUQyOUEgRUFENTQ3MzkgOUREMjc3QUYgMDREQjI2MTUgNzNEQzE2ODMgRTM2MzBCMTIgOTQ2NDNCODQgMEQ2RDZBM0UgN0E2QTVBQTggRTQwRUNGMEIgOTMwOUZGOUQgMEEwMEFFMjcgN0QwNzlFQjEgRjAwRjkzNDQgODcwOEEzRDIgMUUwMUYyNjggNjkwNkMyRkUgRjc2MjU3NUQgODA2NTY3Q0IgMTk2QzM2NzEgNkU2QjA2RTcgRkVENDFCNzYgODlEMzJCRTAgMTBEQTdBNUEgNjdERDRBQ0MgRjlCOURGNkYgOEVCRUVGRjkgMTdCN0JFNDMgNjBCMDhFRDUgRDZENkEzRTggQTFEMTkzN0UgMzhEOEMyQzQgNEZERkYyNTIgRDFCQjY3RjEgQTZCQzU3NjcgM0ZCNTA2REQgNDhCMjM2NEIgRDgwRDJCREEgQUYwQTFCNEMgMzYwMzRBRjYgNDEwNDdBNjAgREY2MEVGQzMgQTg2N0RGNTUgMzE2RThFRUYgNDY2OUJFNzkgQ0I2MUIzOEMgQkM2NjgzMUEgMjU2RkQyQTAgNTI2OEUyMzYgQ0MwQzc3OTUgQkIwQjQ3MDMgMjIwMjE2QjkgNTUwNTI2MkYgQzVCQTNCQkUgQjJCRDBCMjggMkJCNDVBOTIgNUNCMzZBMDQgQzJEN0ZGQTcgQjVEMENGMzEgMkNEOTlFOEIgNUJERUFFMUQgOUI2NEMyQjAgRUM2M0YyMjYgNzU2QUEzOUMgMDI2RDkzMEEgOUMwOTA2QTkgRUIwRTM2M0YgNzIwNzY3ODUgMDUwMDU3MTMgOTVCRjRBODIgRTJCODdBMTQgN0JCMTJCQUUgMENCNjFCMzggOTJEMjhFOUIgRTVENUJFMEQgN0NEQ0VGQjcgMEJEQkRGMjEgODZEM0QyRDQgRjFENEUyNDIgNjhEREIzRjggMUZEQTgzNkUgODFCRTE2Q0QgRjZCOTI2NUIgNkZCMDc3RTEgMThCNzQ3NzcgODgwODVBRTYgRkYwRjZBNzAgNjYwNjNCQ0EgMTEwMTBCNUMgOEY2NTlFRkYgRjg2MkFFNjkgNjE2QkZGRDMgMTY2Q0NGNDUgQTAwQUUyNzggRDcwREQyRUUgNEUwNDgzNTQgMzkwM0IzQzIgQTc2NzI2NjEgRDA2MDE2RjcgNDk2OTQ3NEQgM0U2RTc3REIgQUVEMTZBNEEgRDlENjVBREMgNDBERjBCNjYgMzdEODNCRjAgQTlCQ0FFNTMgREVCQjlFQzUgNDdCMkNGN0YgMzBCNUZGRTkgQkRCREYyMUMgQ0FCQUMyOEEgNTNCMzkzMzAgMjRCNEEzQTYgQkFEMDM2MDUgQ0RENzA2OTMgNTRERTU3MjkgMjNEOTY3QkYgQjM2NjdBMkUgQzQ2MTRBQjggNUQ2ODFCMDIgMkE2RjJCOTQgQjQwQkJFMzcgQzMwQzhFQTEgNUEwNURGMUIgMkQwMkVGOEQnO1xuICBjcmMgPSAwO1xuICB4ID0gMDtcbiAgeSA9IDA7XG4gIGNyYyA9IGNyYyBeIC0xO1xuICBpID0gMDtcbiAgaVRvcCA9IHN0ci5sZW5ndGg7XG4gIHdoaWxlIChpIDwgaVRvcCkge1xuICAgIHkgPSAoY3JjIF4gc3RyLmNoYXJDb2RlQXQoaSkpICYgMHhGRjtcbiAgICB4ID0gJzB4JyArIHRhYmxlLnN1YnN0cih5ICogOSwgOCk7XG4gICAgY3JjID0gY3JjID4+PiA4IF4geDtcbiAgICBpKys7XG4gIH1cbiAgY3JjID0gY3JjIF4gLTE7XG4gIC8vY29udmVydCB0byB1bnNpZ25lZCAzMi1iaXQgaW50IGlmIG5lZWRlZFxuICBpZiAoY3JjIDwgMCkge1xuICAgIGNyYyArPSA0Mjk0OTY3Mjk2O1xuICB9XG4gIHJldHVybiBjcmM7XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfY3JjMzIgPSAoY3JjMzIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc2RrQW5hbHl0aWNzL3N0cmluZ1BhZC5qc1xuZnVuY3Rpb24gc3RyaW5nUGFkKHZhbHVlLCB0YXJnZXRMZW5ndGgsIHBhZFN0cmluZykge1xuICB0YXJnZXRMZW5ndGggPSB0YXJnZXRMZW5ndGggPj4gMDsgLy90cnVuY2F0ZSBpZiBudW1iZXIgb3IgY29udmVydCBub24tbnVtYmVyIHRvIDA7XG4gIHBhZFN0cmluZyA9IFN0cmluZyh0eXBlb2YgcGFkU3RyaW5nICE9PSAndW5kZWZpbmVkJyA/IHBhZFN0cmluZyA6ICcgJyk7XG4gIGlmICh2YWx1ZS5sZW5ndGggPiB0YXJnZXRMZW5ndGgpIHtcbiAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXRMZW5ndGggPSB0YXJnZXRMZW5ndGggLSB2YWx1ZS5sZW5ndGg7XG4gICAgaWYgKHRhcmdldExlbmd0aCA+IHBhZFN0cmluZy5sZW5ndGgpIHtcbiAgICAgIHBhZFN0cmluZyArPSByZXBlYXRTdHJpbmdOdW1UaW1lcyhwYWRTdHJpbmcsIHRhcmdldExlbmd0aCAvIHBhZFN0cmluZy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gcGFkU3RyaW5nLnNsaWNlKDAsIHRhcmdldExlbmd0aCkgKyBTdHJpbmcodmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiByZXBlYXRTdHJpbmdOdW1UaW1lcyhzdHJpbmcsIHRpbWVzKSB7XG4gIHZhciByZXBlYXRlZFN0cmluZyA9IFwiXCI7XG4gIHdoaWxlICh0aW1lcyA+IDApIHtcbiAgICByZXBlYXRlZFN0cmluZyArPSBzdHJpbmc7XG4gICAgdGltZXMtLTtcbiAgfVxuICByZXR1cm4gcmVwZWF0ZWRTdHJpbmc7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZGtBbmFseXRpY3MvYmFzZTY0TWFwLmpzXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuXG52YXIgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG52YXIgYmFzZTY0TWFwX251bSA9IDA7XG52YXIgbWFwID0ge307XG5fdG9Db25zdW1hYmxlQXJyYXkoY2hhcnMpLmZvckVhY2goZnVuY3Rpb24gKF9jaGFyKSB7XG4gIHZhciBrZXkgPSBiYXNlNjRNYXBfbnVtLnRvU3RyaW5nKDIpO1xuICBrZXkgPSBzdHJpbmdQYWQoa2V5LCA2LCAnMCcpO1xuICBtYXBba2V5XSA9IF9jaGFyO1xuICBiYXNlNjRNYXBfbnVtKys7XG59KTtcblxuLyoqXG4gKiBNYXAgb2Ygc2l4LWJpdCBiaW5hcnkgY29kZXMgdG8gQmFzZTY0IGNoYXJhY3RlcnNcbiAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgYmFzZTY0TWFwID0gKG1hcCk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZGtBbmFseXRpY3MvcmV2ZXJzZVZlcnNpb24uanNcblxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBBIHNlbVZlciBsaWtlIHN0cmluZywgeC55Lnogb3IgeC55IGlzIGFsbG93ZWRcbiAqICAgICAgICAgICAgICBSZXZlcnNlcyB0aGUgdmVyc2lvbiBwb3NpdGlvbnMsIHgueS56IHR1cm5zIHRvIHoueS54XG4gKiAgICAgICAgICAgICAgUGFkcyBlYWNoIHNlZ21lbnQgd2l0aCAnMCcgc28gdGhleSBoYXZlIGxlbmd0aCBvZiAyXG4gKiAgICAgICAgICAgICAgRXhhbXBsZTogMS4yLjMgLT4gMDMuMDIuMDFcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZW1WZXIgSW5wdXQgY2FuIGJlIGVpdGhlciB4LnkueiBvciB4LnlcbiAqIEByZXR1cm4ge3N0cmluZ30gaW4gdGhlIGZvcm0gb2YgenoueXkueHggKFxuICovXG5mdW5jdGlvbiByZXZlcnNlVmVyc2lvbihzZW1WZXIpIHtcbiAgaWYgKHNlbVZlci5zcGxpdCgnLicpLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2VtVmVyLCBtdXN0IGhhdmUgYXQgbGVhc3QgdHdvIHNlZ21lbnRzJyk7XG4gIH1cblxuICAvLyBTcGxpdCBieSAnLicsIHJldmVyc2UsIGNyZWF0ZSBuZXcgYXJyYXkgd2l0aCBwYWRkZWQgdmFsdWVzIGFuZCBjb25jYXQgaXQgdG9nZXRoZXJcbiAgcmV0dXJuIHNlbVZlci5zcGxpdCgnLicpLnJldmVyc2UoKS5tYXAoZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICByZXR1cm4gc3RyaW5nUGFkKHNlZ21lbnQsIDIsICcwJyk7XG4gIH0pLmpvaW4oJy4nKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3Nka0FuYWx5dGljcy9lbmNvZGVWZXJzaW9uLmpzXG5cblxuXG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEVuY29kZXMgYSBzZW1WZXItbGlrZSB2ZXJzaW9uIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IHNlbVZlciBJbnB1dCBjYW4gYmUgZWl0aGVyIHgueS56IG9yIHgueVxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyBidWlsdCBmcm9tIDMgY2hhcmFjdGVycyBvZiB0aGUgYmFzZTY0IHRhYmxlIHRoYXQgZW5jb2RlIHRoZSBzZW1WZXJcbiAqL1xuZnVuY3Rpb24gZW5jb2RlVmVyc2lvbihzZW1WZXIpIHtcbiAgdmFyIHN0clJlc3VsdCA9ICcnO1xuXG4gIC8vIHN1cHBvcnQgeC55IG9yIHgueS56IGJ5IHVzaW5nICdwYXJ0cycgYXMgYSB2YXJpYWJsZVxuICB2YXIgcGFydHMgPSBzZW1WZXIuc3BsaXQoJy4nKS5sZW5ndGg7XG4gIHZhciBwYWRkZWRTdHJpbmdMZW5ndGggPSBwYXJ0cyAqIDY7IC8vIHdlIHBhZCB0byBlaXRoZXIgMTIgb3IgMTggY2hhcmFjdGVyc1xuXG4gIC8vIHJldmVyc2UgKGJ1dCBkb24ndCBtaXJyb3IpIHRoZSB2ZXJzaW9uLiAxLjUuMTUgLT4gMTUuNS4xXG4gIC8vIFBhZCB0byB0d28gc3BhY2VzLCAxNS41LjEgLT4gMTUuMDUuMDFcbiAgdmFyIHBhZGRlZFJldmVyc2VkU2VtdmVyID0gcmV2ZXJzZVZlcnNpb24oc2VtVmVyKTtcblxuICAvLyB0dXJuIDE1LjA1LjAxIHRvIGEgc3RyaW5nICcxNTA1MDEnIHRoZW4gdG8gYSBudW1iZXIgMTUwNTAxXG4gIHZhciBudW0gPSBwYXJzZUludChwYWRkZWRSZXZlcnNlZFNlbXZlci5zcGxpdCgnLicpLmpvaW4oJycpKTtcblxuICAvLyBSZXByZXNlbnQgYXMgYmluYXJ5LCBhZGQgbGVmdCBwYWRkaW5nIHRvIDEyIG9yIDE4IGNoYXJhY3RlcnMuXG4gIC8vIDE1MCw1MDEgLT4gMTAwMTAwMTAxMTExMTAwMTAxXG5cbiAgdmFyIHBhZGRlZEJpbmFyeSA9IG51bS50b1N0cmluZygyKTtcbiAgcGFkZGVkQmluYXJ5ID0gc3RyaW5nUGFkKHBhZGRlZEJpbmFyeSwgcGFkZGVkU3RyaW5nTGVuZ3RoLCAnMCcpO1xuXG4gIC8vIFN0b3AgaW4gY2FzZSBhbiBpbnZhbGlkIHZlcnNpb24gbnVtYmVyIHdhcyBwcm92aWRlZFxuICAvLyBwYWRkZWRCaW5hcnkgbXVzdCBiZSBidWlsdCBmcm9tIHNlY3Rpb25zIG9mIDYgYml0c1xuICBpZiAocGFkZGVkQmluYXJ5Lmxlbmd0aCAlIDYgIT09IDApIHtcbiAgICB0aHJvdyAnVmVyc2lvbiBtdXN0IGJlIHNtYWxsZXIgdGhhbiA0My4yMS4yNiknO1xuICB9XG5cbiAgLy8gdHVybiBldmVyeSA2IGJpdHMgaW50byBhIGNoYXJhY3RlciB1c2luZyB0aGUgYmFzZTY0TWFwXG4gIHBhZGRlZEJpbmFyeS5tYXRjaCgvLnsxLDZ9L2cpLmZvckVhY2goZnVuY3Rpb24gKGJpdFN0cmluZykge1xuICAgIC8vIGNvbnNvbGUubG9nKGJpdFN0cmluZyk7XG4gICAgc3RyUmVzdWx0ICs9IGJhc2U2NE1hcFtiaXRTdHJpbmddO1xuICB9KTtcbiAgcmV0dXJuIHN0clJlc3VsdDtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3Nka0FuYWx5dGljcy9nZXRTREtBbmFseXRpY3NTaWduYXR1cmUuanNcblxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBHZXRzIHRoZSBTREsgc2lnbmF0dXJlIGJ5IGVuY29kaW5nIHRoZSBTREsgdmVyc2lvbiBhbmQgdGVjaCB2ZXJzaW9uXG4gKiBAcGFyYW0ge3tcbiAqICAgIFt0ZWNoVmVyc2lvbl06c3RyaW5nLFxuICogICAgW3Nka1NlbXZlcl06IHN0cmluZyxcbiAqICAgIFtzZGtDb2RlXTogc3RyaW5nLFxuICogICAgW2ZlYXR1cmVdOiBzdHJpbmdcbiAqIH19IGFuYWx5dGljc09wdGlvbnNcbiAqIEByZXR1cm4ge3N0cmluZ30gc2RrQW5hbHl0aWNzU2lnbmF0dXJlXG4gKi9cbmZ1bmN0aW9uIGdldFNES0FuYWx5dGljc1NpZ25hdHVyZSgpIHtcbiAgdmFyIGFuYWx5dGljc09wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB0cnkge1xuICAgIHZhciB0d29QYXJ0VmVyc2lvbiA9IHJlbW92ZVBhdGNoRnJvbVNlbXZlcihhbmFseXRpY3NPcHRpb25zLnRlY2hWZXJzaW9uKTtcbiAgICB2YXIgZW5jb2RlZFNES1ZlcnNpb24gPSBlbmNvZGVWZXJzaW9uKGFuYWx5dGljc09wdGlvbnMuc2RrU2VtdmVyKTtcbiAgICB2YXIgZW5jb2RlZFRlY2hWZXJzaW9uID0gZW5jb2RlVmVyc2lvbih0d29QYXJ0VmVyc2lvbik7XG4gICAgdmFyIGZlYXR1cmVDb2RlID0gYW5hbHl0aWNzT3B0aW9ucy5mZWF0dXJlO1xuICAgIHZhciBTREtDb2RlID0gYW5hbHl0aWNzT3B0aW9ucy5zZGtDb2RlO1xuICAgIHZhciBhbGdvVmVyc2lvbiA9ICdBJzsgLy8gVGhlIGFsZ28gdmVyc2lvbiBpcyBkZXRlcm1pbmVkIGhlcmUsIGl0IHNob3VsZCBub3QgYmUgYW4gYXJndW1lbnRcblxuICAgIHJldHVybiBcIlwiLmNvbmNhdChhbGdvVmVyc2lvbikuY29uY2F0KFNES0NvZGUpLmNvbmNhdChlbmNvZGVkU0RLVmVyc2lvbikuY29uY2F0KGVuY29kZWRUZWNoVmVyc2lvbikuY29uY2F0KGZlYXR1cmVDb2RlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIEVpdGhlciBTREsgb3IgTm9kZSB2ZXJzaW9ucyB3ZXJlIHVucGFyc2FibGVcbiAgICByZXR1cm4gJ0UnO1xuICB9XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgcGF0Y2ggdmVyc2lvbiBmcm9tIHRoZSBzZW12ZXIgaWYgaXQgZXhpc3RzXG4gKiAgICAgICAgICAgICAgVHVybnMgeC55LnogT1IgeC55IGludG8geC55XG4gKiBAcGFyYW0geyd4LnkueicgfHwgJ3gueScgfHwgc3RyaW5nfSBzZW1WZXJTdHJcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlUGF0Y2hGcm9tU2VtdmVyKHNlbVZlclN0cikge1xuICB2YXIgcGFydHMgPSBzZW1WZXJTdHIuc3BsaXQoJy4nKTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHBhcnRzWzBdLCBcIi5cIikuY29uY2F0KHBhcnRzWzFdKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3Nka0FuYWx5dGljcy9nZXRBbmFseXRpY3NPcHRpb25zLmpzXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBHZXRzIHRoZSBhbmFseXRpY3NPcHRpb25zIGZyb20gb3B0aW9ucy0gc2hvdWxkIGluY2x1ZGUgc2RrU2VtdmVyLCB0ZWNoVmVyc2lvbiwgc2RrQ29kZSwgYW5kIGZlYXR1cmVcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7e3Nka1NlbXZlcjogKHN0cmluZyksIHNka0NvZGUsIGZlYXR1cmU6IHN0cmluZywgdGVjaFZlcnNpb246IChzdHJpbmcpfSB8fCB7fX1cbiAqL1xuZnVuY3Rpb24gZ2V0QW5hbHl0aWNzT3B0aW9ucyhvcHRpb25zKSB7XG4gIHZhciBhbmFseXRpY3NPcHRpb25zID0ge1xuICAgIHNka1NlbXZlcjogb3B0aW9ucy5zZGtTZW12ZXIsXG4gICAgdGVjaFZlcnNpb246IG9wdGlvbnMudGVjaFZlcnNpb24sXG4gICAgc2RrQ29kZTogb3B0aW9ucy5zZGtDb2RlLFxuICAgIGZlYXR1cmU6ICcwJ1xuICB9O1xuICBpZiAob3B0aW9ucy51cmxBbmFseXRpY3MpIHtcbiAgICBpZiAob3B0aW9ucy5hY2Nlc3NpYmlsaXR5KSB7XG4gICAgICBhbmFseXRpY3NPcHRpb25zLmZlYXR1cmUgPSAnRCc7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxvYWRpbmcgPT09ICdsYXp5Jykge1xuICAgICAgYW5hbHl0aWNzT3B0aW9ucy5mZWF0dXJlID0gJ0MnO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICBhbmFseXRpY3NPcHRpb25zLmZlYXR1cmUgPSAnQSc7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnBsYWNlaG9sZGVyKSB7XG4gICAgICBhbmFseXRpY3NPcHRpb25zLmZlYXR1cmUgPSAnQic7XG4gICAgfVxuICAgIHJldHVybiBhbmFseXRpY3NPcHRpb25zO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2Fzc2lnblwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvYXNzaWduXCIsXCJhbWRcIjpcImxvZGFzaC9hc3NpZ25cIixcInJvb3RcIjpbXCJfXCIsXCJhc3NpZ25cIl19XG52YXIgYXNzaWduX3Jvb3RfYXNzaWduXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvYXNzaWduXCIpO1xudmFyIGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihhc3NpZ25fcm9vdF9hc3NpZ25fKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2Nsb25lRGVlcFwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvY2xvbmVEZWVwXCIsXCJhbWRcIjpcImxvZGFzaC9jbG9uZURlZXBcIixcInJvb3RcIjpbXCJfXCIsXCJjbG9uZURlZXBcIl19XG52YXIgY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvY2xvbmVEZWVwXCIpO1xudmFyIGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2NvbXBhY3RcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2NvbXBhY3RcIixcImFtZFwiOlwibG9kYXNoL2NvbXBhY3RcIixcInJvb3RcIjpbXCJfXCIsXCJjb21wYWN0XCJdfVxudmFyIGNvbXBhY3Rfcm9vdF9jb21wYWN0XyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvY29tcGFjdFwiKTtcbnZhciBjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb21wYWN0X3Jvb3RfY29tcGFjdF8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvZGlmZmVyZW5jZVwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvZGlmZmVyZW5jZVwiLFwiYW1kXCI6XCJsb2Rhc2gvZGlmZmVyZW5jZVwiLFwicm9vdFwiOltcIl9cIixcImRpZmZlcmVuY2VcIl19XG52YXIgZGlmZmVyZW5jZV9yb290X2RpZmZlcmVuY2VfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9kaWZmZXJlbmNlXCIpO1xudmFyIGRpZmZlcmVuY2Vfcm9vdF9kaWZmZXJlbmNlX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGRpZmZlcmVuY2Vfcm9vdF9kaWZmZXJlbmNlXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9mdW5jdGlvbnNcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2Z1bmN0aW9uc1wiLFwiYW1kXCI6XCJsb2Rhc2gvZnVuY3Rpb25zXCIsXCJyb290XCI6W1wiX1wiLFwiZnVuY3Rpb25zXCJdfVxudmFyIGZ1bmN0aW9uc19yb290X2Z1bmN0aW9uc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2Z1bmN0aW9uc1wiKTtcbnZhciBmdW5jdGlvbnNfcm9vdF9mdW5jdGlvbnNfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oZnVuY3Rpb25zX3Jvb3RfZnVuY3Rpb25zXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9pZGVudGl0eVwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvaWRlbnRpdHlcIixcImFtZFwiOlwibG9kYXNoL2lkZW50aXR5XCIsXCJyb290XCI6W1wiX1wiLFwiaWRlbnRpdHlcIl19XG52YXIgaWRlbnRpdHlfcm9vdF9pZGVudGl0eV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2lkZW50aXR5XCIpO1xudmFyIGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaWRlbnRpdHlfcm9vdF9pZGVudGl0eV8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvaW5jbHVkZXNcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2luY2x1ZGVzXCIsXCJhbWRcIjpcImxvZGFzaC9pbmNsdWRlc1wiLFwicm9vdFwiOltcIl9cIixcImluY2x1ZGVzXCJdfVxudmFyIGluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9pbmNsdWRlc1wiKTtcbnZhciBpbmNsdWRlc19yb290X2luY2x1ZGVzX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2lzQXJyYXlcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2lzQXJyYXlcIixcImFtZFwiOlwibG9kYXNoL2lzQXJyYXlcIixcInJvb3RcIjpbXCJfXCIsXCJpc0FycmF5XCJdfVxudmFyIGlzQXJyYXlfcm9vdF9pc0FycmF5XyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvaXNBcnJheVwiKTtcbnZhciBpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpc0FycmF5X3Jvb3RfaXNBcnJheV8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiLFwiYW1kXCI6XCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiLFwicm9vdFwiOltcIl9cIixcImlzUGxhaW5PYmplY3RcIl19XG52YXIgaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9pc1BsYWluT2JqZWN0XCIpO1xudmFyIGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0Xyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9pc1N0cmluZ1wiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvaXNTdHJpbmdcIixcImFtZFwiOlwibG9kYXNoL2lzU3RyaW5nXCIsXCJyb290XCI6W1wiX1wiLFwiaXNTdHJpbmdcIl19XG52YXIgaXNTdHJpbmdfcm9vdF9pc1N0cmluZ18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2lzU3RyaW5nXCIpO1xudmFyIGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNTdHJpbmdfcm9vdF9pc1N0cmluZ18pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvbWVyZ2VcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL21lcmdlXCIsXCJhbWRcIjpcImxvZGFzaC9tZXJnZVwiLFwicm9vdFwiOltcIl9cIixcIm1lcmdlXCJdfVxudmFyIG1lcmdlX3Jvb3RfbWVyZ2VfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9tZXJnZVwiKTtcbnZhciBtZXJnZV9yb290X21lcmdlX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKG1lcmdlX3Jvb3RfbWVyZ2VfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2lzRWxlbWVudFwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvaXNFbGVtZW50XCIsXCJhbWRcIjpcImxvZGFzaC9pc0VsZW1lbnRcIixcInJvb3RcIjpbXCJfXCIsXCJpc0VsZW1lbnRcIl19XG52YXIgaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50XyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvaXNFbGVtZW50XCIpO1xudmFyIGlzRWxlbWVudF9yb290X2lzRWxlbWVudF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpc0VsZW1lbnRfcm9vdF9pc0VsZW1lbnRfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2lzRnVuY3Rpb25cIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2lzRnVuY3Rpb25cIixcImFtZFwiOlwibG9kYXNoL2lzRnVuY3Rpb25cIixcInJvb3RcIjpbXCJfXCIsXCJpc0Z1bmN0aW9uXCJdfVxudmFyIGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvaXNGdW5jdGlvblwiKTtcbnZhciBpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvdHJpbVwiLFwiY29tbW9uanMyXCI6XCJsb2Rhc2gvdHJpbVwiLFwiYW1kXCI6XCJsb2Rhc2gvdHJpbVwiLFwicm9vdFwiOltcIl9cIixcInRyaW1cIl19XG52YXIgdHJpbV9yb290X3RyaW1fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC90cmltXCIpO1xudmFyIHRyaW1fcm9vdF90cmltX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHRyaW1fcm9vdF90cmltXyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvbGF6eUxvYWQuanNcbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbi8qXG4gKiBJbmNsdWRlcyB1dGlsaXR5IG1ldGhvZHMgZm9yIGxhenkgbG9hZGluZyBtZWRpYVxuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaXMgc3VwcG9ydGVkXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHdpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlciBpcyBkZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZXJzZWN0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQoKSB7XG4gIC8vIENoZWNrIHRoYXQgJ0ludGVyc2VjdGlvbk9ic2VydmVyJyBwcm9wZXJ0eSBpcyBkZWZpbmVkIG9uIHdpbmRvd1xuICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gXCJvYmplY3RcIiAmJiB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgbmF0aXZlIGxhenkgbG9hZGluZyBpcyBzdXBwb3J0ZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgJ2xvYWRpbmcnIHByb3BlcnR5IGlzIGRlZmluZWQgZm9yIEhUTUxJbWFnZUVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuICh0eXBlb2YgSFRNTEltYWdlRWxlbWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKEhUTUxJbWFnZUVsZW1lbnQpKSA9PT0gXCJvYmplY3RcIiAmJiBIVE1MSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5sb2FkaW5nO1xufVxuXG4vKipcbiAqIENhbGxzIG9uSW50ZXJzZWN0KCkgd2hlbiBpbnRlcnNlY3Rpb24gaXMgZGV0ZWN0ZWQsIG9yIHdoZW5cbiAqIG5vIG5hdGl2ZSBsYXp5IGxvYWRpbmcgb3Igd2hlbiBJbnRlcnNlY3Rpb25PYnNlcnZlciBpc24ndCBzdXBwb3J0ZWQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIC0gdGhlIGVsZW1lbnQgdG8gb2JzZXJ2ZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25JbnRlcnNlY3QgLSBjYWxsZWQgd2hlbiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBpbiB2aWV3XG4gKi9cbmZ1bmN0aW9uIGRldGVjdEludGVyc2VjdGlvbihlbCwgb25JbnRlcnNlY3QpIHtcbiAgdHJ5IHtcbiAgICBpZiAoaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZCgpIHx8ICFpc0ludGVyc2VjdGlvbk9ic2VydmVyU3VwcG9ydGVkKCkpIHtcbiAgICAgIC8vIFJldHVybiBpZiB0aGVyZSdzIG5vIG5lZWQgb3IgcG9zc2liaWxpdHkgdG8gZGV0ZWN0IGludGVyc2VjdGlvblxuICAgICAgb25JbnRlcnNlY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEZXRlY3QgaW50ZXJzZWN0aW9uIHdpdGggZ2l2ZW4gZWxlbWVudCB1c2luZyBJbnRlcnNlY3Rpb25PYnNlcnZlclxuICAgIHZhciBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICBvbkludGVyc2VjdCgpO1xuICAgICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbnRyeS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICB0aHJlc2hvbGQ6IFswLCAwLjAxXVxuICAgIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgb25JbnRlcnNlY3QoKTtcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29uc3RhbnRzLmpzXG52YXIgVkVSU0lPTiA9IFwiMi41LjBcIjtcbnZhciBDRl9TSEFSRURfQ0ROID0gXCJkM2pwbDkxcHhldmJraC5jbG91ZGZyb250Lm5ldFwiO1xudmFyIE9MRF9BS0FNQUlfU0hBUkVEX0NETiA9IFwiY2xvdWRpbmFyeS1hLmFrYW1haWhkLm5ldFwiO1xudmFyIEFLQU1BSV9TSEFSRURfQ0ROID0gXCJyZXMuY2xvdWRpbmFyeS5jb21cIjtcbnZhciBTSEFSRURfQ0ROID0gQUtBTUFJX1NIQVJFRF9DRE47XG52YXIgREVGQVVMVF9USU1FT1VUX01TID0gMTAwMDA7XG52YXIgREVGQVVMVF9QT1NURVJfT1BUSU9OUyA9IHtcbiAgZm9ybWF0OiAnanBnJyxcbiAgcmVzb3VyY2VfdHlwZTogJ3ZpZGVvJ1xufTtcbnZhciBERUZBVUxUX1ZJREVPX1NPVVJDRV9UWVBFUyA9IFsnd2VibScsICdtcDQnLCAnb2d2J107XG52YXIgU0VPX1RZUEVTID0ge1xuICBcImltYWdlL3VwbG9hZFwiOiBcImltYWdlc1wiLFxuICBcImltYWdlL3ByaXZhdGVcIjogXCJwcml2YXRlX2ltYWdlc1wiLFxuICBcImltYWdlL2F1dGhlbnRpY2F0ZWRcIjogXCJhdXRoZW50aWNhdGVkX2ltYWdlc1wiLFxuICBcInJhdy91cGxvYWRcIjogXCJmaWxlc1wiLFxuICBcInZpZGVvL3VwbG9hZFwiOiBcInZpZGVvc1wiXG59O1xuXG4vKipcbiogQGNvbnN0IHtPYmplY3R9IENsb3VkaW5hcnkuREVGQVVMVF9JTUFHRV9QQVJBTVNcbiogRGVmYXVsdHMgdmFsdWVzIGZvciBpbWFnZSBwYXJhbWV0ZXJzLlxuKlxuKiAoUHJldmlvdXNseSBkZWZpbmVkIHVzaW5nIG9wdGlvbl9jb25zdW1lKCkgKVxuICovXG52YXIgREVGQVVMVF9JTUFHRV9QQVJBTVMgPSB7XG4gIHJlc291cmNlX3R5cGU6IFwiaW1hZ2VcIixcbiAgdHJhbnNmb3JtYXRpb246IFtdLFxuICB0eXBlOiAndXBsb2FkJ1xufTtcblxuLyoqXG4qIERlZmF1bHRzIHZhbHVlcyBmb3IgdmlkZW8gcGFyYW1ldGVycy5cbiogQGNvbnN0IHtPYmplY3R9IENsb3VkaW5hcnkuREVGQVVMVF9WSURFT19QQVJBTVNcbiogKFByZXZpb3VzbHkgZGVmaW5lZCB1c2luZyBvcHRpb25fY29uc3VtZSgpIClcbiAqL1xudmFyIERFRkFVTFRfVklERU9fUEFSQU1TID0ge1xuICBmYWxsYmFja19jb250ZW50OiAnJyxcbiAgcmVzb3VyY2VfdHlwZTogXCJ2aWRlb1wiLFxuICBzb3VyY2VfdHJhbnNmb3JtYXRpb246IHt9LFxuICBzb3VyY2VfdHlwZXM6IERFRkFVTFRfVklERU9fU09VUkNFX1RZUEVTLFxuICB0cmFuc2Zvcm1hdGlvbjogW10sXG4gIHR5cGU6ICd1cGxvYWQnXG59O1xuXG4vKipcbiAqIFJlY29tbWVuZGVkIHNvdXJjZXMgZm9yIHZpZGVvIHRhZ1xuICogQGNvbnN0IHtPYmplY3R9IENsb3VkaW5hcnkuREVGQVVMVF9WSURFT19TT1VSQ0VTXG4gKi9cbnZhciBERUZBVUxUX1ZJREVPX1NPVVJDRVMgPSBbe1xuICB0eXBlOiBcIm1wNFwiLFxuICBjb2RlY3M6IFwiaGV2MVwiLFxuICB0cmFuc2Zvcm1hdGlvbnM6IHtcbiAgICB2aWRlb19jb2RlYzogXCJoMjY1XCJcbiAgfVxufSwge1xuICB0eXBlOiBcIndlYm1cIixcbiAgY29kZWNzOiBcInZwOVwiLFxuICB0cmFuc2Zvcm1hdGlvbnM6IHtcbiAgICB2aWRlb19jb2RlYzogXCJ2cDlcIlxuICB9XG59LCB7XG4gIHR5cGU6IFwibXA0XCIsXG4gIHRyYW5zZm9ybWF0aW9uczoge1xuICAgIHZpZGVvX2NvZGVjOiBcImF1dG9cIlxuICB9XG59LCB7XG4gIHR5cGU6IFwid2VibVwiLFxuICB0cmFuc2Zvcm1hdGlvbnM6IHtcbiAgICB2aWRlb19jb2RlYzogXCJhdXRvXCJcbiAgfVxufV07XG52YXIgREVGQVVMVF9FWFRFUk5BTF9MSUJSQVJJRVMgPSB7XG4gIHNlZVRocnU6ICdodHRwczovL3VucGtnLmNvbS9zZWV0aHJ1QDQvZGlzdC9zZWVUaHJ1Lm1pbi5qcydcbn07XG5cbi8qKlxuICogUHJlZGVmaW5lZCBwbGFjZWhvbGRlciB0cmFuc2Zvcm1hdGlvbnNcbiAqIEBjb25zdCB7T2JqZWN0fSBDbG91ZGluYXJ5LlBMQUNFSE9MREVSX0lNQUdFX01PREVTXG4gKi9cbnZhciBQTEFDRUhPTERFUl9JTUFHRV9NT0RFUyA9IHtcbiAgJ2JsdXInOiBbe1xuICAgIGVmZmVjdDogJ2JsdXI6MjAwMCcsXG4gICAgcXVhbGl0eTogMSxcbiAgICBmZXRjaF9mb3JtYXQ6ICdhdXRvJ1xuICB9XSxcbiAgLy8gRGVmYXVsdFxuICAncGl4ZWxhdGUnOiBbe1xuICAgIGVmZmVjdDogJ3BpeGVsYXRlJyxcbiAgICBxdWFsaXR5OiAxLFxuICAgIGZldGNoX2Zvcm1hdDogJ2F1dG8nXG4gIH1dLFxuICAvLyBHZW5lcmF0ZXMgYSBwaXhlbCBzaXplIGltYWdlIHdoaWNoIGNvbG9yIGlzIHRoZSBwcmVkb21pbmFudCBjb2xvciBvZiB0aGUgb3JpZ2luYWwgaW1hZ2UuXG4gICdwcmVkb21pbmFudC1jb2xvci1waXhlbCc6IFt7XG4gICAgd2lkdGg6ICdpd19kaXZfMicsXG4gICAgYXNwZWN0X3JhdGlvOiAxLFxuICAgIGNyb3A6ICdwYWQnLFxuICAgIGJhY2tncm91bmQ6ICdhdXRvJ1xuICB9LCB7XG4gICAgY3JvcDogJ2Nyb3AnLFxuICAgIHdpZHRoOiAxLFxuICAgIGhlaWdodDogMSxcbiAgICBncmF2aXR5OiAnbm9ydGhfZWFzdCdcbiAgfSwge1xuICAgIGZldGNoX2Zvcm1hdDogJ2F1dG8nLFxuICAgIHF1YWxpdHk6ICdhdXRvJ1xuICB9XSxcbiAgLy8gR2VuZXJhdGVzIGFuIGltYWdlIHdoaWNoIGNvbG9yIGlzIHRoZSBwcmVkb21pbmFudCBjb2xvciBvZiB0aGUgb3JpZ2luYWwgaW1hZ2UuXG4gICdwcmVkb21pbmFudC1jb2xvcic6IFt7XG4gICAgdmFyaWFibGVzOiBbWyckY3VycldpZHRoJywgJ3cnXSwgWyckY3VyckhlaWdodCcsICdoJ11dXG4gIH0sIHtcbiAgICB3aWR0aDogJ2l3X2Rpdl8yJyxcbiAgICBhc3BlY3RfcmF0aW86IDEsXG4gICAgY3JvcDogJ3BhZCcsXG4gICAgYmFja2dyb3VuZDogJ2F1dG8nXG4gIH0sIHtcbiAgICBjcm9wOiAnY3JvcCcsXG4gICAgd2lkdGg6IDEwLFxuICAgIGhlaWdodDogMTAsXG4gICAgZ3Jhdml0eTogJ25vcnRoX2Vhc3QnXG4gIH0sIHtcbiAgICB3aWR0aDogJyRjdXJyV2lkdGgnLFxuICAgIGhlaWdodDogJyRjdXJySGVpZ2h0JyxcbiAgICBjcm9wOiAnZmlsbCdcbiAgfSwge1xuICAgIGZldGNoX2Zvcm1hdDogJ2F1dG8nLFxuICAgIHF1YWxpdHk6ICdhdXRvJ1xuICB9XSxcbiAgJ3ZlY3Rvcml6ZSc6IFt7XG4gICAgZWZmZWN0OiAndmVjdG9yaXplOjM6MC4xJyxcbiAgICBmZXRjaF9mb3JtYXQ6ICdzdmcnXG4gIH1dXG59O1xuXG4vKipcbiAqIFByZWRlZmluZWQgYWNjZXNzaWJpbGl0eSB0cmFuc2Zvcm1hdGlvbnNcbiAqIEBjb25zdCB7T2JqZWN0fSBDbG91ZGluYXJ5LkFDQ0VTU0lCSUxJVFlfTU9ERVNcbiAqL1xudmFyIEFDQ0VTU0lCSUxJVFlfTU9ERVMgPSB7XG4gIGRhcmttb2RlOiAndGludDo3NTpibGFjaycsXG4gIGJyaWdodG1vZGU6ICd0aW50OjUwOndoaXRlJyxcbiAgbW9ub2Nocm9tZTogJ2dyYXlzY2FsZScsXG4gIGNvbG9yYmxpbmQ6ICdhc3Npc3RfY29sb3JibGluZCdcbn07XG5cbi8qKlxuICogQSBsaXN0IG9mIGtleXMgdXNlZCBieSB0aGUgdXJsKCkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgVVJMX0tFWVMgPSBbJ2FjY2Vzc2liaWxpdHknLCAnYXBpX3NlY3JldCcsICdhdXRoX3Rva2VuJywgJ2Nkbl9zdWJkb21haW4nLCAnY2xvdWRfbmFtZScsICdjbmFtZScsICdmb3JtYXQnLCAncGxhY2Vob2xkZXInLCAncHJpdmF0ZV9jZG4nLCAncmVzb3VyY2VfdHlwZScsICdzZWN1cmUnLCAnc2VjdXJlX2Nkbl9zdWJkb21haW4nLCAnc2VjdXJlX2Rpc3RyaWJ1dGlvbicsICdzaG9ydGVuJywgJ3NpZ25fdXJsJywgJ3NpZ25hdHVyZScsICdzc2xfZGV0ZWN0ZWQnLCAndHlwZScsICd1cmxfc3VmZml4JywgJ3VzZV9yb290X3BhdGgnLCAndmVyc2lvbiddO1xuXG4vKipcbiAqIFRoZSByZXNvdXJjZSBzdG9yYWdlIHR5cGVcbiAqIEB0eXBlZGVmIHR5cGVcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAcHJvcGVydHkgIHtzdHJpbmd9ICd1cGxvYWQnIEEgcmVzb3VyY2UgdXBsb2FkZWQgZGlyZWN0bHkgdG8gQ2xvdWRpbmFyeVxuICogQHByb3BlcnR5ICB7c3RyaW5nfSAnZmV0Y2gnIEEgcmVzb3VyY2UgZmV0Y2hlZCBieSBDbG91ZGluYXJ5IGZyb20gYSAzcmQgcGFydHkgc3RvcmFnZVxuICogQHByb3BlcnR5ICB7c3RyaW5nfSAncHJpdmF0ZSdcbiAqIEBwcm9wZXJ0eSAge3N0cmluZ30gJ2F1dGhlbnRpY2F0ZWQnXG4gKiBAcHJvcGVydHkgIHtzdHJpbmd9ICdzcHJpdGUnXG4gKiBAcHJvcGVydHkgIHtzdHJpbmd9ICdmYWNlYm9vaydcbiAqIEBwcm9wZXJ0eSAge3N0cmluZ30gJ3R3aXR0ZXInXG4gKiBAcHJvcGVydHkgIHtzdHJpbmd9ICd5b3V0dWJlJ1xuICogQHByb3BlcnR5ICB7c3RyaW5nfSAndmltZW8nXG4gKlxuICovXG5cbi8qKlxuICogVGhlIHJlc291cmNlIHR5cGVcbiAqIEB0eXBlZGVmIHJlc291cmNlVHlwZVxuICogQGVudW0ge3N0cmluZ31cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAnaW1hZ2UnIEFuIGltYWdlIGZpbGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAndmlkZW8nIEEgdmlkZW8gZmlsZVxuICogQHByb3BlcnR5IHtzdHJpbmd9ICdyYXcnICAgQSByYXcgZmlsZVxuICovXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2Jhc2V1dGlsLmpzXG5mdW5jdGlvbiBiYXNldXRpbF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBiYXNldXRpbF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgYmFzZXV0aWxfdHlwZW9mKG8pOyB9XG4vKlxuICogSW5jbHVkZXMgY29tbW9uIHV0aWxpdHkgbWV0aG9kcyBhbmQgc2hpbXNcbiAqL1xuXG5cbmZ1bmN0aW9uIG9taXQob2JqLCBrZXlzKSB7XG4gIG9iaiA9IG9iaiB8fCB7fTtcbiAgdmFyIHNyY0tleXMgPSBPYmplY3Qua2V5cyhvYmopLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICFpbmNsdWRlc19yb290X2luY2x1ZGVzX2RlZmF1bHQoKShrZXlzLCBrZXkpO1xuICB9KTtcbiAgdmFyIGZpbHRlcmVkID0ge307XG4gIHNyY0tleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGZpbHRlcmVkW2tleV0gPSBvYmpba2V5XTtcbiAgfSk7XG4gIHJldHVybiBmaWx0ZXJlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBhbGwgaXRlbXMgaW4gbGlzdCBhcmUgc3RyaW5nc1xuICogQGZ1bmN0aW9uIFV0aWwuYWxsU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IC0gYW4gYXJyYXkgb2YgaXRlbXNcbiAqL1xudmFyIGJhc2V1dGlsX2FsbFN0cmluZ3MgPSBmdW5jdGlvbiBhbGxTdHJpbmdzKGxpc3QpIHtcbiAgcmV0dXJuIGxpc3QubGVuZ3RoICYmIGxpc3QuZXZlcnkoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0LmEpO1xufTtcblxuLyoqXG4qIENyZWF0ZXMgYSBuZXcgYXJyYXkgd2l0aG91dCB0aGUgZ2l2ZW4gaXRlbS5cbiogQGZ1bmN0aW9uIFV0aWwud2l0aG91dFxuKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIG9yaWdpbmFsIGFycmF5XG4qIEBwYXJhbSB7Kn0gaXRlbSAtIHRoZSBpdGVtIHRvIGV4Y2x1ZGUgZnJvbSB0aGUgbmV3IGFycmF5XG4qIEByZXR1cm4ge0FycmF5fSBhIG5ldyBhcnJheSBtYWRlIG9mIHRoZSBvcmlnaW5hbCBhcnJheSdzIGl0ZW1zIGV4Y2VwdCBmb3IgYGl0ZW1gXG4gKi9cbnZhciB3aXRob3V0ID0gZnVuY3Rpb24gd2l0aG91dChhcnJheSwgaXRlbSkge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYgIT09IGl0ZW07XG4gIH0pO1xufTtcblxuLyoqXG4qIFJldHVybiB0cnVlIGlzIHZhbHVlIGlzIGEgbnVtYmVyIG9yIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbnVtYmVyLlxuKiBAZnVuY3Rpb24gVXRpbC5pc051bWJlckxpa2VcbiogQHBhcmFtIHsqfSB2YWx1ZVxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB2YWx1ZSBpcyBhIG51bWJlclxuKiBAZXhhbXBsZVxuKiAgICBVdGlsLmlzTnVtYmVyKDApIC8vIHRydWVcbiogICAgVXRpbC5pc051bWJlcihcIjEuM1wiKSAvLyB0cnVlXG4qICAgIFV0aWwuaXNOdW1iZXIoXCJcIikgLy8gZmFsc2VcbiogICAgVXRpbC5pc051bWJlcih1bmRlZmluZWQpIC8vIGZhbHNlXG4gKi9cbnZhciBpc051bWJlckxpa2UgPSBmdW5jdGlvbiBpc051bWJlckxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgIWlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKTtcbn07XG5cbi8qKlxuICogRXNjYXBlIGFsbCBjaGFyYWN0ZXJzIG1hdGNoaW5nIHVuc2FmZSBpbiB0aGUgZ2l2ZW4gc3RyaW5nXG4gKiBAZnVuY3Rpb24gVXRpbC5zbWFydEVzY2FwZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIHNvdXJjZSBzdHJpbmcgdG8gZXNjYXBlXG4gKiBAcGFyYW0ge1JlZ0V4cH0gdW5zYWZlIC0gY2hhcmFjdGVycyB0aGF0IG11c3QgYmUgZXNjYXBlZFxuICogQHJldHVybiB7c3RyaW5nfSBlc2NhcGVkIHN0cmluZ1xuICovXG52YXIgc21hcnRFc2NhcGUgPSBmdW5jdGlvbiBzbWFydEVzY2FwZShzdHJpbmcpIHtcbiAgdmFyIHVuc2FmZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogLyhbXmEtekEtWjAtOV8uXFwtXFwvOl0rKS9nO1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UodW5zYWZlLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gbWF0Y2guc3BsaXQoXCJcIikubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gXCIlXCIgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFzc2lnbiB2YWx1ZXMgZnJvbSBzb3VyY2VzIGlmIHRoZXkgYXJlIG5vdCBkZWZpbmVkIGluIHRoZSBkZXN0aW5hdGlvbi5cbiAqIE9uY2UgYSB2YWx1ZSBpcyBzZXQgaXQgZG9lcyBub3QgY2hhbmdlXG4gKiBAZnVuY3Rpb24gVXRpbC5kZWZhdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IGRlc3RpbmF0aW9uIC0gdGhlIG9iamVjdCB0byBhc3NpZ24gZGVmYXVsdHMgdG9cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2UgLSB0aGUgc291cmNlIG9iamVjdChzKSB0byBhc3NpZ24gZGVmYXVsdHMgZnJvbVxuICogQHJldHVybiB7T2JqZWN0fSBkZXN0aW5hdGlvbiBhZnRlciBpdCB3YXMgbW9kaWZpZWRcbiAqL1xudmFyIGRlZmF1bHRzID0gZnVuY3Rpb24gZGVmYXVsdHMoZGVzdGluYXRpb24pIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHNvdXJjZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiBzb3VyY2VzLnJlZHVjZShmdW5jdGlvbiAoZGVzdCwgc291cmNlKSB7XG4gICAgdmFyIGtleSwgdmFsdWU7XG4gICAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgICB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgaWYgKGRlc3Rba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlc3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfSwgZGVzdGluYXRpb24pO1xufTtcblxuLyoqKioqKioqKioqIGxvZGFzaCBmdW5jdGlvbnMgKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiNpc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuI2lzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuI2lzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGU7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB0eXBlID0gYmFzZXV0aWxfdHlwZW9mKHZhbHVlKTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufTtcbnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxuLyoqXG4qIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiogQGZ1bmN0aW9uIFV0aWwuaXNGdW5jdGlvblxuKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiogQGV4YW1wbGVcbipcbiogZnVuY3Rpb24gRm9vKCl7fTtcbiogaXNGdW5jdGlvbihGb28pO1xuKiAvLyA9PiB0cnVlXG4qXG4qIGlzRnVuY3Rpb24oL2FiYy8pO1xuKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpIHdoaWNoIHJldHVybiAnZnVuY3Rpb24nIGZvciByZWdleGVzXG4gIC8vIGFuZCBTYWZhcmkgOCB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcnMuXG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IGZ1bmNUYWc7XG59O1xuXG4vKioqKioqKioqKiogbG9kYXNoIGZ1bmN0aW9ucyAqL1xuLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgdG8gY3JlYXRlIGNvbXBvdW5kIHdvcmRzLiAqL1xudmFyIHJlV29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsb3dlciwgdXBwZXI7XG4gIHVwcGVyID0gJ1tBLVpdJztcbiAgbG93ZXIgPSAnW2Etel0rJztcbiAgcmV0dXJuIFJlZ0V4cCh1cHBlciArICcrKD89JyArIHVwcGVyICsgbG93ZXIgKyAnKXwnICsgdXBwZXIgKyAnPycgKyBsb3dlciArICd8JyArIHVwcGVyICsgJyt8WzAtOV0rJywgJ2cnKTtcbn0oKTtcblxuLyoqXG4qIENvbnZlcnQgc3RyaW5nIHRvIGNhbWVsQ2FzZVxuKiBAZnVuY3Rpb24gVXRpbC5jYW1lbENhc2VcbiogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSAtIHRoZSBzdHJpbmcgdG8gY29udmVydFxuKiBAcmV0dXJuIHtzdHJpbmd9IGluIGNhbWVsQ2FzZSBmb3JtYXRcbiAqL1xudmFyIGNhbWVsQ2FzZSA9IGZ1bmN0aW9uIGNhbWVsQ2FzZShzb3VyY2UpIHtcbiAgdmFyIHdvcmRzID0gc291cmNlLm1hdGNoKHJlV29yZHMpO1xuICB3b3JkcyA9IHdvcmRzLm1hcChmdW5jdGlvbiAod29yZCkge1xuICAgIHJldHVybiB3b3JkLmNoYXJBdCgwKS50b0xvY2FsZVVwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICB9KTtcbiAgd29yZHNbMF0gPSB3b3Jkc1swXS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICByZXR1cm4gd29yZHMuam9pbignJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgc3RyaW5nIHRvIHNuYWtlX2Nhc2VcbiAqIEBmdW5jdGlvbiBVdGlsLnNuYWtlQ2FzZVxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSAtIHRoZSBzdHJpbmcgdG8gY29udmVydFxuICogQHJldHVybiB7c3RyaW5nfSBpbiBzbmFrZV9jYXNlIGZvcm1hdFxuICovXG52YXIgc25ha2VDYXNlID0gZnVuY3Rpb24gc25ha2VDYXNlKHNvdXJjZSkge1xuICB2YXIgd29yZHMgPSBzb3VyY2UubWF0Y2gocmVXb3Jkcyk7XG4gIHdvcmRzID0gd29yZHMubWFwKGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgcmV0dXJuIHdvcmQudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgfSk7XG4gIHJldHVybiB3b3Jkcy5qb2luKCdfJyk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IGZyb20gc291cmNlLCB3aXRoIHRoZSBrZXlzIHRyYW5zZm9ybWVkIHVzaW5nIHRoZSBjb252ZXJ0ZXIuXG4gKiBAcGFyYW0ge29iamVjdH0gc291cmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufG51bGx9IGNvbnZlcnRlclxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xudmFyIGNvbnZlcnRLZXlzID0gZnVuY3Rpb24gY29udmVydEtleXMoc291cmNlLCBjb252ZXJ0ZXIpIHtcbiAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgdmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAoY29udmVydGVyKSB7XG4gICAgICBrZXkgPSBjb252ZXJ0ZXIoa2V5KTtcbiAgICB9XG4gICAgaWYgKCFpc0VtcHR5KGtleSkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGNvcHkgb2YgdGhlIHNvdXJjZSBvYmplY3Qgd2l0aCBhbGwga2V5cyBpbiBjYW1lbENhc2VcbiAqIEBmdW5jdGlvbiBVdGlsLndpdGhDYW1lbENhc2VLZXlzXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSB0aGUgb2JqZWN0IHRvIGNvcHlcbiAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0XG4gKi9cbnZhciB3aXRoQ2FtZWxDYXNlS2V5cyA9IGZ1bmN0aW9uIHdpdGhDYW1lbENhc2VLZXlzKHNvdXJjZSkge1xuICByZXR1cm4gY29udmVydEtleXMoc291cmNlLCBjYW1lbENhc2UpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBjb3B5IG9mIHRoZSBzb3VyY2Ugb2JqZWN0IHdpdGggYWxsIGtleXMgaW4gc25ha2VfY2FzZVxuICogQGZ1bmN0aW9uIFV0aWwud2l0aFNuYWtlQ2FzZUtleXNcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAtIHRoZSBvYmplY3QgdG8gY29weVxuICogQHJldHVybiB7T2JqZWN0fSBhIG5ldyBvYmplY3RcbiAqL1xudmFyIHdpdGhTbmFrZUNhc2VLZXlzID0gZnVuY3Rpb24gd2l0aFNuYWtlQ2FzZUtleXMoc291cmNlKSB7XG4gIHJldHVybiBjb252ZXJ0S2V5cyhzb3VyY2UsIHNuYWtlQ2FzZSk7XG59O1xuXG4vLyBCcm93c2VyXG4vLyBOb2RlLmpzXG52YXIgYmFzZTY0RW5jb2RlID0gdHlwZW9mIGJ0b2EgIT09ICd1bmRlZmluZWQnICYmIGlzRnVuY3Rpb24oYnRvYSkgPyBidG9hIDogdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNGdW5jdGlvbihCdWZmZXIpID8gZnVuY3Rpb24gKGlucHV0KSB7XG4gIGlmICghKGlucHV0IGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIGlucHV0ID0gbmV3IEJ1ZmZlci5mcm9tKFN0cmluZyhpbnB1dCksICdiaW5hcnknKTtcbiAgfVxuICByZXR1cm4gaW5wdXQudG9TdHJpbmcoJ2Jhc2U2NCcpO1xufSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJObyBiYXNlNjQgZW5jb2RpbmcgZnVuY3Rpb24gZm91bmRcIik7XG59O1xuXG4vKipcbiogUmV0dXJucyB0aGUgQmFzZTY0LWRlY29kZWQgdmVyc2lvbiBvZiB1cmwuPGJyPlxuKiBUaGlzIG1ldGhvZCBkZWxlZ2F0ZXMgdG8gYGJ0b2FgIGlmIHByZXNlbnQuIE90aGVyd2lzZSBpdCB0cmllcyBgQnVmZmVyYC5cbiogQGZ1bmN0aW9uIFV0aWwuYmFzZTY0RW5jb2RlVVJMXG4qIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSB0aGUgdXJsIHRvIGVuY29kZS4gdGhlIHZhbHVlIGlzIFVSSWRlY29kZWQgYW5kIHRoZW4gcmUtZW5jb2RlZCBiZWZvcmUgY29udmVydGluZyB0byBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiogQHJldHVybiB7c3RyaW5nfSB0aGUgYmFzZTY0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBVUkxcbiAqL1xudmFyIGJhc2U2NEVuY29kZVVSTCA9IGZ1bmN0aW9uIGJhc2U2NEVuY29kZVVSTCh1cmwpIHtcbiAgdHJ5IHtcbiAgICB1cmwgPSBkZWNvZGVVUkkodXJsKTtcbiAgfSBmaW5hbGx5IHtcbiAgICB1cmwgPSBlbmNvZGVVUkkodXJsKTtcbiAgfVxuICByZXR1cm4gYmFzZTY0RW5jb2RlKHVybCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCBvbmx5IFVSTCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBUaGUgc291cmNlIG9iamVjdFxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBvbmx5IFVSTCBwYXJhbWV0ZXJzXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RVcmxQYXJhbXMob3B0aW9ucykge1xuICByZXR1cm4gVVJMX0tFWVMucmVkdWNlKGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAgIGlmIChvcHRpb25zW2tleV0gIT0gbnVsbCkge1xuICAgICAgb2JqW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH0sIHt9KTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgdGhlIGZvcm1hdCBwYXJhbWV0ZXIgZm9yIGZldGNoIHVybHNcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gb3B0aW9ucyB1cmwgYW5kIHRyYW5zZm9ybWF0aW9uIG9wdGlvbnMuIFRoaXMgYXJndW1lbnQgbWF5IGJlIGNoYW5nZWQgYnkgdGhlIGZ1bmN0aW9uIVxuICovXG5mdW5jdGlvbiBwYXRjaEZldGNoRm9ybWF0KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAob3B0aW9ucy50eXBlID09PSBcImZldGNoXCIpIHtcbiAgICBpZiAob3B0aW9ucy5mZXRjaF9mb3JtYXQgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5mZXRjaF9mb3JtYXQgPSBvcHRpb25Db25zdW1lKG9wdGlvbnMsIFwiZm9ybWF0XCIpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERlbGV0ZXMgYG9wdGlvbl9uYW1lYCBmcm9tIGBvcHRpb25zYCBhbmQgcmV0dXJuIHRoZSB2YWx1ZSBpZiBwcmVzZW50LlxuICogSWYgYG9wdGlvbnNgIGRvZXNuJ3QgY29udGFpbiBgb3B0aW9uX25hbWVgIHRoZSBkZWZhdWx0IHZhbHVlIGlzIHJldHVybmVkLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgYSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uX25hbWUgdGhlIG5hbWUgKGtleSkgb2YgdGhlIGRlc2lyZWQgdmFsdWVcbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRfdmFsdWVdIHRoZSB2YWx1ZSB0byByZXR1cm4gaXMgb3B0aW9uX25hbWUgaXMgbWlzc2luZ1xuICovXG5mdW5jdGlvbiBvcHRpb25Db25zdW1lKG9wdGlvbnMsIG9wdGlvbl9uYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvcHRpb25zW29wdGlvbl9uYW1lXTtcbiAgZGVsZXRlIG9wdGlvbnNbb3B0aW9uX25hbWVdO1xuICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkZWZhdWx0X3ZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGVtcHR5OlxuICogPHVsPlxuICogICA8bGk+dmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQ8L2xpPlxuICogICA8bGk+dmFsdWUgaXMgYW4gYXJyYXkgb3Igc3RyaW5nIG9mIGxlbmd0aCAwPC9saT5cbiAqICAgPGxpPnZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIG5vIGtleXM8L2xpPlxuICogPC91bD5cbiAqIEBmdW5jdGlvbiBVdGlsLmlzRW1wdHlcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdmFsdWUgaXMgZW1wdHlcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUubGVuZ3RoID09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdmFsdWUubGVuZ3RoID09PSAwO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUuc2l6ZSA9PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNpemUgPT09IDA7XG4gIH1cbiAgaWYgKGJhc2V1dGlsX3R5cGVvZih2YWx1ZSkgPT0gXCJvYmplY3RcIikge1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvYnJvd3Nlci5qc1xuLyoqXG4gKiBCYXNlZCBvbiB2aWRlby5qcyBpbXBsZW1lbnRhdGlvbjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2Jsb2IvNDIzOGY1YzFkODg4OTA1NDcxNTNlN2UxZGU3YmQwZDFkOGUwYjIzNi9zcmMvanMvdXRpbHMvYnJvd3Nlci5qc1xuICovXG5cbi8qKlxuKiBSZXRyaWV2ZSBmcm9tIHRoZSBuYXZpZ2F0b3IgdGhlIHVzZXIgYWdlbnQgcHJvcGVydHkuXG4qIEByZXR1cm5zIHVzZXIgYWdlbnQgcHJvcGVydHkuXG4qL1xuZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICByZXR1cm4gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG59XG5cbi8qKlxuICogRGV0ZWN0IGlmIGN1cnJlbnQgYnJvd3NlciBpcyBhbnkgQW5kcm9pZFxuICogQHJldHVybnMgdHJ1ZSBpZiBjdXJyZW50IGJyb3dzZXIgaXMgQW5kcm9pZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0FuZHJvaWQoKSB7XG4gIHZhciB1c2VyQWdlbnQgPSBnZXRVc2VyQWdlbnQoKTtcbiAgcmV0dXJuIC9BbmRyb2lkL2kudGVzdCh1c2VyQWdlbnQpO1xufVxuXG4vKipcbiAqIERldGVjdCBpZiBjdXJyZW50IGJyb3dzZXIgaXMgYW55IEVkZ2VcbiAqIEByZXR1cm5zIHRydWUgaWYgY3VycmVudCBicm93c2VyIGlzIEVkZ2UsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNFZGdlKCkge1xuICB2YXIgdXNlckFnZW50ID0gZ2V0VXNlckFnZW50KCk7XG4gIHJldHVybiAvRWRnL2kudGVzdCh1c2VyQWdlbnQpO1xufVxuXG4vKipcbiAqIERldGVjdCBpZiBjdXJyZW50IGJyb3dzZXIgaXMgY2hyb21lLlxuICogQHJldHVybnMgdHJ1ZSBpZiBjdXJyZW50IGJyb3dzZXIgaXMgQ2hyb21lLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzQ2hyb21lKCkge1xuICB2YXIgdXNlckFnZW50ID0gZ2V0VXNlckFnZW50KCk7XG4gIHJldHVybiAhaXNFZGdlKCkgJiYgKC9DaHJvbWUvaS50ZXN0KHVzZXJBZ2VudCkgfHwgL0NyaU9TL2kudGVzdCh1c2VyQWdlbnQpKTtcbn1cblxuLyoqXG4gKiBEZXRlY3QgaWYgY3VycmVudCBicm93c2VyIGlzIFNhZmFyaS5cbiAqIEByZXR1cm5zIHRydWUgaWYgY3VycmVudCBicm93c2VyIGlzIFNhZmFyaSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgLy8gVXNlciBhZ2VudHMgZm9yIG90aGVyIGJyb3dzZXJzIG1pZ2h0IGluY2x1ZGUgXCJTYWZhcmlcIiBzbyB3ZSBtdXN0IGV4Y2x1ZGUgdGhlbS5cbiAgLy8gRm9yIGV4YW1wbGUgLSB0aGlzIGlzIHRoZSBjaHJvbWUgdXNlciBhZ2VudCBvbiB3aW5kb3dzIDEwOlxuICAvLyBNb3ppbGxhLzUuMCAoV2luZG93cyBOVCAxMC4wOyBXaW42NDsgeDY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvOTYuMC40NjY0LjExMCBTYWZhcmkvNTM3LjM2XG4gIHZhciB1c2VyQWdlbnQgPSBnZXRVc2VyQWdlbnQoKTtcbiAgcmV0dXJuIC9TYWZhcmkvaS50ZXN0KHVzZXJBZ2VudCkgJiYgIWlzQ2hyb21lKCkgJiYgIWlzQW5kcm9pZCgpICYmICFpc0VkZ2UoKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvbG9kYXNoLmpzXG52YXIgbm9kZUNvbnRhaW5zO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qXG4gKiBJbmNsdWRlcyB1dGlsaXR5IG1ldGhvZHMgYW5kIGxvZGFzaCAvIGpRdWVyeSBzaGltc1xuICovXG4vKipcbiAqIEdldCBkYXRhIGZyb20gdGhlIERPTSBlbGVtZW50LlxuICpcbiAqIFRoaXMgbWV0aG9kIHdpbGwgdXNlIGpRdWVyeSdzIGBkYXRhKClgIG1ldGhvZCBpZiBpdCBpcyBhdmFpbGFibGUsIG90aGVyd2lzZSBpdCB3aWxsIGdldCB0aGUgYGRhdGEtYCBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIHRoZSBlbGVtZW50IHRvIGdldCB0aGUgZGF0YSBmcm9tXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBkYXRhIGl0ZW1cbiAqIEByZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGBuYW1lYFxuICogQGZ1bmN0aW9uIFV0aWwuZ2V0RGF0YVxuICovXG52YXIgbG9kYXNoX2dldERhdGEgPSBmdW5jdGlvbiBnZXREYXRhKGVsZW1lbnQsIG5hbWUpIHtcbiAgc3dpdGNoIChmYWxzZSkge1xuICAgIGNhc2UgIShlbGVtZW50ID09IG51bGwpOlxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5nZXRBdHRyaWJ1dGUpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1cIi5jb25jYXQobmFtZSkpO1xuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LmdldEF0dHIpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cihcImRhdGEtXCIuY29uY2F0KG5hbWUpKTtcbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5kYXRhKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmRhdGEobmFtZSk7XG4gICAgY2FzZSAhKGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKSh0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5mbiAmJiBqUXVlcnkuZm4uZGF0YSkgJiYgaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50X2RlZmF1bHQoKShlbGVtZW50KSk6XG4gICAgICByZXR1cm4galF1ZXJ5KGVsZW1lbnQpLmRhdGEobmFtZSk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IGRhdGEgaW4gdGhlIERPTSBlbGVtZW50LlxuICpcbiAqIFRoaXMgbWV0aG9kIHdpbGwgdXNlIGpRdWVyeSdzIGBkYXRhKClgIG1ldGhvZCBpZiBpdCBpcyBhdmFpbGFibGUsIG90aGVyd2lzZSBpdCB3aWxsIHNldCB0aGUgYGRhdGEtYCBhdHRyaWJ1dGVcbiAqIEBmdW5jdGlvbiBVdGlsLnNldERhdGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIHRoZSBlbGVtZW50IHRvIHNldCB0aGUgZGF0YSBpblxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgZGF0YSBpdGVtXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIGJlIHNldFxuICpcbiAqL1xudmFyIGxvZGFzaF9zZXREYXRhID0gZnVuY3Rpb24gc2V0RGF0YShlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgY2FzZSAhKGVsZW1lbnQgPT0gbnVsbCk6XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LnNldEF0dHJpYnV0ZSk6XG4gICAgICByZXR1cm4gZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLVwiLmNvbmNhdChuYW1lKSwgdmFsdWUpO1xuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LnNldEF0dHIpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuc2V0QXR0cihcImRhdGEtXCIuY29uY2F0KG5hbWUpLCB2YWx1ZSk7XG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuZGF0YSk6XG4gICAgICByZXR1cm4gZWxlbWVudC5kYXRhKG5hbWUsIHZhbHVlKTtcbiAgICBjYXNlICEoaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmZuICYmIGpRdWVyeS5mbi5kYXRhKSAmJiBpc0VsZW1lbnRfcm9vdF9pc0VsZW1lbnRfZGVmYXVsdCgpKGVsZW1lbnQpKTpcbiAgICAgIHJldHVybiBqUXVlcnkoZWxlbWVudCkuZGF0YShuYW1lLCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IGF0dHJpYnV0ZSBmcm9tIHRoZSBET00gZWxlbWVudC5cbiAqXG4gKiBAZnVuY3Rpb24gVXRpbC5nZXRBdHRyaWJ1dGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIHRoZSBlbGVtZW50IHRvIHNldCB0aGUgYXR0cmlidXRlIGZvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7Kn0gdGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGVcbiAqXG4gKi9cbnZhciBsb2Rhc2hfZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGVsZW1lbnQsIG5hbWUpIHtcbiAgc3dpdGNoIChmYWxzZSkge1xuICAgIGNhc2UgIShlbGVtZW50ID09IG51bGwpOlxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5nZXRBdHRyaWJ1dGUpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LmF0dHIpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuYXR0cihuYW1lKTtcbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5nZXRBdHRyKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHIobmFtZSk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IGF0dHJpYnV0ZSBpbiB0aGUgRE9NIGVsZW1lbnQuXG4gKlxuICogQGZ1bmN0aW9uIFV0aWwuc2V0QXR0cmlidXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGF0dHJpYnV0ZSBmb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBiZSBzZXRcbiAqL1xudmFyIGxvZGFzaF9zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgc3dpdGNoIChmYWxzZSkge1xuICAgIGNhc2UgIShlbGVtZW50ID09IG51bGwpOlxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5zZXRBdHRyaWJ1dGUpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5hdHRyKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmF0dHIobmFtZSwgdmFsdWUpO1xuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LnNldEF0dHIpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuc2V0QXR0cihuYW1lLCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGF0dHJpYnV0ZSBpbiB0aGUgRE9NIGVsZW1lbnQuXG4gKlxuICogQGZ1bmN0aW9uIFV0aWwucmVtb3ZlQXR0cmlidXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGF0dHJpYnV0ZSBmb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICovXG52YXIgbG9kYXNoX3JlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCBuYW1lKSB7XG4gIHN3aXRjaCAoZmFsc2UpIHtcbiAgICBjYXNlICEoZWxlbWVudCA9PSBudWxsKTpcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKTpcbiAgICAgIHJldHVybiBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGxvZGFzaF9zZXRBdHRyaWJ1dGUoZWxlbWVudCwgdm9pZCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgYSBncm91cCBvZiBhdHRyaWJ1dGVzIHRvIHRoZSBlbGVtZW50XG4gKiBAZnVuY3Rpb24gVXRpbC5zZXRBdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGF0dHJpYnV0ZXMgZm9yXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlcyAtIGEgaGFzaCBvZiBhdHRyaWJ1dGUgbmFtZXMgYW5kIHZhbHVlc1xuICovXG52YXIgc2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICB2YXIgbmFtZSwgcmVzdWx0cywgdmFsdWU7XG4gIHJlc3VsdHMgPSBbXTtcbiAgZm9yIChuYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdHMucHVzaChsb2Rhc2hfc2V0QXR0cmlidXRlKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdHMucHVzaChsb2Rhc2hfcmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsIG5hbWUpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBlbGVtZW50IGhhcyBhIGNzcyBjbGFzc1xuICogQGZ1bmN0aW9uIFV0aWwuaGFzQ2xhc3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIHRoZSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBjbGFzcyBuYW1lXG4gQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGVsZW1lbnQgaGFzIHRoZSBjbGFzc1xuICovXG52YXIgbG9kYXNoX2hhc0NsYXNzID0gZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICBpZiAoaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50X2RlZmF1bHQoKShlbGVtZW50KSkge1xuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTmFtZS5tYXRjaChuZXcgUmVnRXhwKFwiXFxcXGJcIi5jb25jYXQobmFtZSwgXCJcXFxcYlwiKSkpO1xuICB9XG59O1xuXG4vKipcbiAqIEFkZCBjbGFzcyB0byB0aGUgZWxlbWVudFxuICogQGZ1bmN0aW9uIFV0aWwuYWRkQ2xhc3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBjbGFzcyBuYW1lIHRvIGFkZFxuICovXG52YXIgbG9kYXNoX2FkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICBpZiAoIWVsZW1lbnQuY2xhc3NOYW1lLm1hdGNoKG5ldyBSZWdFeHAoXCJcXFxcYlwiLmNvbmNhdChuYW1lLCBcIlxcXFxiXCIpKSkpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc05hbWUgPSB0cmltX3Jvb3RfdHJpbV9kZWZhdWx0KCkoXCJcIi5jb25jYXQoZWxlbWVudC5jbGFzc05hbWUsIFwiIFwiKS5jb25jYXQobmFtZSkpO1xuICB9XG59O1xuXG4vLyBUaGUgZm9sbG93aW5nIGNvZGUgaXMgdGFrZW4gZnJvbSBqUXVlcnlcbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiBnZXRTdHlsZXMoZWxlbSkge1xuICAvLyBTdXBwb3J0OiBJRTw9MTErLCBGaXJlZm94PD0zMCsgKCMxNTA5OCwgIzE0MTUwKVxuICAvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcbiAgLy8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG4gIGlmIChlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcub3BlbmVyKSB7XG4gICAgcmV0dXJuIGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW0sIG51bGwpO1xuICB9XG4gIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKTtcbn07XG52YXIgY3NzRXhwYW5kID0gW1wiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCJdO1xubm9kZUNvbnRhaW5zID0gZnVuY3Rpb24gbm9kZUNvbnRhaW5zKGEsIGIpIHtcbiAgdmFyIGFkb3duLCBidXA7XG4gIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYTtcbiAgYnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG4gIHJldHVybiBhID09PSBidXAgfHwgISEoYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiBhZG93bi5jb250YWlucyhidXApKTtcbn07XG5cbi8vIFRydW5jYXRlZCB2ZXJzaW9uIG9mIGpRdWVyeS5zdHlsZShlbGVtLCBuYW1lKVxudmFyIGRvbVN0eWxlID0gZnVuY3Rpb24gZG9tU3R5bGUoZWxlbSwgbmFtZSkge1xuICBpZiAoISghZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUpKSB7XG4gICAgcmV0dXJuIGVsZW0uc3R5bGVbbmFtZV07XG4gIH1cbn07XG52YXIgY3VyQ1NTID0gZnVuY3Rpb24gY3VyQ1NTKGVsZW0sIG5hbWUsIGNvbXB1dGVkKSB7XG4gIHZhciBtYXhXaWR0aCwgbWluV2lkdGgsIHJldCwgcm1hcmdpbiwgc3R5bGUsIHdpZHRoO1xuICBybWFyZ2luID0gL15tYXJnaW4vO1xuICB3aWR0aCA9IHZvaWQgMDtcbiAgbWluV2lkdGggPSB2b2lkIDA7XG4gIG1heFdpZHRoID0gdm9pZCAwO1xuICByZXQgPSB2b2lkIDA7XG4gIHN0eWxlID0gZWxlbS5zdHlsZTtcbiAgY29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoZWxlbSk7XG4gIGlmIChjb21wdXRlZCkge1xuICAgIC8vIFN1cHBvcnQ6IElFOVxuICAgIC8vIGdldFByb3BlcnR5VmFsdWUgaXMgb25seSBuZWVkZWQgZm9yIC5jc3MoJ2ZpbHRlcicpICgjMTI1MzcpXG4gICAgcmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSB8fCBjb21wdXRlZFtuYW1lXTtcbiAgfVxuICBpZiAoY29tcHV0ZWQpIHtcbiAgICBpZiAocmV0ID09PSBcIlwiICYmICFub2RlQ29udGFpbnMoZWxlbS5vd25lckRvY3VtZW50LCBlbGVtKSkge1xuICAgICAgcmV0ID0gZG9tU3R5bGUoZWxlbSwgbmFtZSk7XG4gICAgfVxuICAgIC8vIFN1cHBvcnQ6IGlPUyA8IDZcbiAgICAvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG4gICAgLy8gaU9TIDwgNiAoYXQgbGVhc3QpIHJldHVybnMgcGVyY2VudGFnZSBmb3IgYSBsYXJnZXIgc2V0IG9mIHZhbHVlcywgYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVsc1xuICAgIC8vIHRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzogaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuICAgIGlmIChybnVtbm9ucHgudGVzdChyZXQpICYmIHJtYXJnaW4udGVzdChuYW1lKSkge1xuICAgICAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuICAgICAgd2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgIG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG4gICAgICBtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuICAgICAgLy8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuICAgICAgc3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuICAgICAgcmV0ID0gY29tcHV0ZWQud2lkdGg7XG4gICAgICAvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG4gICAgICBzdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgc3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcbiAgICAgIHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgfVxuICB9XG4gIC8vIFN1cHBvcnQ6IElFXG4gIC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG4gIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXQgKyBcIlwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn07XG52YXIgY3NzVmFsdWUgPSBmdW5jdGlvbiBjc3NWYWx1ZShlbGVtLCBuYW1lLCBjb252ZXJ0LCBzdHlsZXMpIHtcbiAgdmFyIHZhbDtcbiAgdmFsID0gY3VyQ1NTKGVsZW0sIG5hbWUsIHN0eWxlcyk7XG4gIGlmIChjb252ZXJ0KSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG59O1xudmFyIGF1Z21lbnRXaWR0aE9ySGVpZ2h0ID0gZnVuY3Rpb24gYXVnbWVudFdpZHRoT3JIZWlnaHQoZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMpIHtcbiAgdmFyIGksIGxlbiwgc2lkZSwgc2lkZXMsIHZhbDtcbiAgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSByaWdodCBtZWFzdXJlbWVudCwgYXZvaWQgYXVnbWVudGF0aW9uXG4gIC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcbiAgaWYgKGV4dHJhID09PSAoaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgc2lkZXMgPSBuYW1lID09PSBcIndpZHRoXCIgPyBbXCJSaWdodFwiLCBcIkxlZnRcIl0gOiBbXCJUb3BcIiwgXCJCb3R0b21cIl07XG4gICAgdmFsID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBzaWRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2lkZSA9IHNpZGVzW2ldO1xuICAgICAgaWYgKGV4dHJhID09PSBcIm1hcmdpblwiKSB7XG4gICAgICAgIC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcbiAgICAgICAgdmFsICs9IGNzc1ZhbHVlKGVsZW0sIGV4dHJhICsgc2lkZSwgdHJ1ZSwgc3R5bGVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0JvcmRlckJveCkge1xuICAgICAgICBpZiAoZXh0cmEgPT09IFwiY29udGVudFwiKSB7XG4gICAgICAgICAgLy8gYm9yZGVyLWJveCBpbmNsdWRlcyBwYWRkaW5nLCBzbyByZW1vdmUgaXQgaWYgd2Ugd2FudCBjb250ZW50XG4gICAgICAgICAgdmFsIC09IGNzc1ZhbHVlKGVsZW0sIFwicGFkZGluZ1wiLmNvbmNhdChzaWRlKSwgdHJ1ZSwgc3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmEgIT09IFwibWFyZ2luXCIpIHtcbiAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBib3JkZXIgbm9yIG1hcmdpbiwgc28gcmVtb3ZlIGJvcmRlclxuICAgICAgICAgIHZhbCAtPSBjc3NWYWx1ZShlbGVtLCBcImJvcmRlclwiLmNvbmNhdChzaWRlLCBcIldpZHRoXCIpLCB0cnVlLCBzdHlsZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuICAgICAgICB2YWwgKz0gY3NzVmFsdWUoZWxlbSwgXCJwYWRkaW5nXCIuY29uY2F0KHNpZGUpLCB0cnVlLCBzdHlsZXMpO1xuICAgICAgICBpZiAoZXh0cmEgIT09IFwicGFkZGluZ1wiKSB7XG4gICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuICAgICAgICAgIHZhbCArPSBjc3NWYWx1ZShlbGVtLCBcImJvcmRlclwiLmNvbmNhdChzaWRlLCBcIldpZHRoXCIpLCB0cnVlLCBzdHlsZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH1cbn07XG52YXIgcG51bSA9IC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvLnNvdXJjZTtcbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIik7XG52YXIgZ2V0V2lkdGhPckhlaWdodCA9IGZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoZWxlbSwgbmFtZSwgZXh0cmEpIHtcbiAgdmFyIGlzQm9yZGVyQm94LCBzdHlsZXMsIHZhbCwgdmFsdWVJc0JvcmRlckJveDtcbiAgLy8gU3RhcnQgd2l0aCBvZmZzZXQgcHJvcGVydHksIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJvcmRlci1ib3ggdmFsdWVcbiAgdmFsdWVJc0JvcmRlckJveCA9IHRydWU7XG4gIHZhbCA9IG5hbWUgPT09IFwid2lkdGhcIiA/IGVsZW0ub2Zmc2V0V2lkdGggOiBlbGVtLm9mZnNldEhlaWdodDtcbiAgc3R5bGVzID0gZ2V0U3R5bGVzKGVsZW0pO1xuICBpc0JvcmRlckJveCA9IGNzc1ZhbHVlKGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMpID09PSBcImJvcmRlci1ib3hcIjtcbiAgLy8gU29tZSBub24taHRtbCBlbGVtZW50cyByZXR1cm4gdW5kZWZpbmVkIGZvciBvZmZzZXRXaWR0aCwgc28gY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkXG4gIC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxuICAvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2NjhcbiAgaWYgKHZhbCA8PSAwIHx8IHZhbCA9PSBudWxsKSB7XG4gICAgLy8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG4gICAgdmFsID0gY3VyQ1NTKGVsZW0sIG5hbWUsIHN0eWxlcyk7XG4gICAgaWYgKHZhbCA8IDAgfHwgdmFsID09IG51bGwpIHtcbiAgICAgIHZhbCA9IGVsZW0uc3R5bGVbbmFtZV07XG4gICAgfVxuICAgIGlmIChybnVtbm9ucHgudGVzdCh2YWwpKSB7XG4gICAgICAvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgLy8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcbiAgICAvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG4gICAgLy8gICAgdmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94IGFuZCAoc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIG9yIHZhbCBpcyBlbGVtLnN0eWxlW25hbWVdKVxuICAgIHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJiB2YWwgPT09IGVsZW0uc3R5bGVbbmFtZV07XG4gICAgLy8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKSB8fCAwO1xuICB9XG4gIC8vIFVzZSB0aGUgYWN0aXZlIGJveC1zaXppbmcgbW9kZWwgdG8gYWRkL3N1YnRyYWN0IGlycmVsZXZhbnQgc3R5bGVzXG4gIHJldHVybiB2YWwgKyBhdWdtZW50V2lkdGhPckhlaWdodChlbGVtLCBuYW1lLCBleHRyYSB8fCAoaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIpLCB2YWx1ZUlzQm9yZGVyQm94LCBzdHlsZXMpO1xufTtcbnZhciBsb2Rhc2hfd2lkdGggPSBmdW5jdGlvbiB3aWR0aChlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KGVsZW1lbnQsIFwid2lkdGhcIiwgXCJjb250ZW50XCIpO1xufTtcblxuLyoqXG4gKiBAY2xhc3MgVXRpbFxuICovXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBpdGVtIGlzIGEgc3RyaW5nXG4gKiBAZnVuY3Rpb24gVXRpbC5pc1N0cmluZ1xuICogQHBhcmFtIGl0ZW1cbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGl0ZW0gaXMgYSBzdHJpbmdcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgaXRlbSBpcyBlbXB0eTpcbiAqIDx1bD5cbiAqICAgPGxpPml0ZW0gaXMgbnVsbCBvciB1bmRlZmluZWQ8L2xpPlxuICogICA8bGk+aXRlbSBpcyBhbiBhcnJheSBvciBzdHJpbmcgb2YgbGVuZ3RoIDA8L2xpPlxuICogICA8bGk+aXRlbSBpcyBhbiBvYmplY3Qgd2l0aCBubyBrZXlzPC9saT5cbiAqIDwvdWw+XG4gKiBAZnVuY3Rpb24gVXRpbC5pc0VtcHR5XG4gKiBAcGFyYW0gaXRlbVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgaXRlbSBpcyBlbXB0eVxuICovXG4vKipcbiAqIEFzc2lnbiBzb3VyY2UgcHJvcGVydGllcyB0byBkZXN0aW5hdGlvbi5cbiAqIElmIHRoZSBwcm9wZXJ0eSBpcyBhbiBvYmplY3QgaXQgaXMgYXNzaWduZWQgYXMgYSB3aG9sZSwgb3ZlcnJpZGluZyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQGZ1bmN0aW9uIFV0aWwuYXNzaWduXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdGluYXRpb24gLSB0aGUgb2JqZWN0IHRvIGFzc2lnbiB0b1xuICovXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGFzc2lnbiBzb3VyY2UgcHJvcGVydGllcyB0byBkZXN0aW5hdGlvblxuICogQGZ1bmN0aW9uIFV0aWwubWVyZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvbiAtIHRoZSBvYmplY3QgdG8gYXNzaWduIHRvXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqL1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgY29weSBvZiB0aGUgZ2l2ZW4gb2JqZWN0LCBpbmNsdWRpbmcgYWxsIGludGVybmFsIG9iamVjdHMuXG4gKiBAZnVuY3Rpb24gVXRpbC5jbG9uZURlZXBcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAtIHRoZSBvYmplY3QgdG8gY2xvbmVcbiAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgZGVlcCBjb3B5IG9mIHRoZSBvYmplY3RcbiAqL1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGFycmF5IGZyb20gdGhlIHBhcmFtZXRlciB3aXRoIFwiZmFsc2V5XCIgdmFsdWVzIHJlbW92ZWRcbiAqIEBmdW5jdGlvbiBVdGlsLmNvbXBhY3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gdGhlIGFycmF5IHRvIHJlbW92ZSB2YWx1ZXMgZnJvbVxuICogQHJldHVybiB7QXJyYXl9IGEgbmV3IGFycmF5IHdpdGhvdXQgZmFsc2V5IHZhbHVlc1xuICovXG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gaXRlbSBpcyBpbmNsdWRlZCBpbiB0aGUgZ2l2ZW4gYXJyYXlcbiAqIEBmdW5jdGlvbiBVdGlsLmNvbnRhaW5zXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIHRoZSBhcnJheSB0byBzZWFyY2ggaW5cbiAqIEBwYXJhbSB7Kn0gaXRlbSAtIHRoZSBpdGVtIHRvIHNlYXJjaCBmb3JcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGl0ZW0gaXMgaW5jbHVkZWQgaW4gdGhlIGFycmF5XG4gKi9cbi8qKlxuICogUmV0dXJucyB2YWx1ZXMgaW4gdGhlIGdpdmVuIGFycmF5IHRoYXQgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3RoZXIgYXJyYXlcbiAqIEBmdW5jdGlvbiBVdGlsLmRpZmZlcmVuY2VcbiAqIEBwYXJhbSB7QXJyYXl9IGFyciAtIHRoZSBhcnJheSB0byBzZWxlY3QgZnJvbVxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIC0gdmFsdWVzIHRvIGZpbHRlciBmcm9tIGFyclxuICogQHJldHVybiB7QXJyYXl9IHRoZSBmaWx0ZXJlZCB2YWx1ZXNcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgdGhlIGZ1bmN0aW9uIG5hbWVzIGluIG9ialxuICogQGZ1bmN0aW9uIFV0aWwuZnVuY3Rpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gdGhlIG9iamVjdCB0byBpbnNwZWN0XG4gKiBAcmV0dXJuIHtBcnJheX0gYSBsaXN0IG9mIGZ1bmN0aW9ucyBvZiBvYmplY3RcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBwcm92aWRlZCB2YWx1ZS4gVGhpcyBmdW5jdGlvbnMgaXMgdXNlZCBhcyBhIGRlZmF1bHQgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICogQGZ1bmN0aW9uIFV0aWwuaWRlbnRpdHlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4geyp9IHRoZSBwcm92aWRlZCB2YWx1ZVxuICovXG4vKipcbiAqIFJlbW92ZSBsZWFkaW5nIG9yIHRyYWlsaW5nIHNwYWNlcyBmcm9tIHRleHRcbiAqIEBmdW5jdGlvbiBVdGlsLnRyaW1cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBgdGV4dGAgd2l0aG91dCBsZWFkaW5nIG9yIHRyYWlsaW5nIHNwYWNlc1xuICovXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9leHByZXNzaW9uLmpzXG5mdW5jdGlvbiBleHByZXNzaW9uX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIGV4cHJlc3Npb25fdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIGV4cHJlc3Npb25fdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBleHByZXNzaW9uX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gZXhwcmVzc2lvbl90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gZXhwcmVzc2lvbl90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNmb3JtYXRpb24gZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uU3RyIC0gQW4gZXhwcmVzc2lvbiBpbiBzdHJpbmcgZm9ybWF0LlxuICogQGNsYXNzIEV4cHJlc3Npb25cbiAqIE5vcm1hbGx5IHRoaXMgY2xhc3MgaXMgbm90IGluc3RhbnRpYXRlZCBkaXJlY3RseVxuICovXG52YXIgRXhwcmVzc2lvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV4cHJlc3Npb24oZXhwcmVzc2lvblN0cikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFeHByZXNzaW9uKTtcbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGlubmVyIEV4cHJlc3Npb24tZXhwcmVzc2lvbnNcbiAgICAgKi9cbiAgICB0aGlzLmV4cHJlc3Npb25zID0gW107XG4gICAgaWYgKGV4cHJlc3Npb25TdHIgIT0gbnVsbCkge1xuICAgICAgdGhpcy5leHByZXNzaW9ucy5wdXNoKEV4cHJlc3Npb24ubm9ybWFsaXplKGV4cHJlc3Npb25TdHIpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgY29uc3RydWN0b3IgbWV0aG9kXG4gICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLm5ld1xuICAgKi9cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFeHByZXNzaW9uLCBbe1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIGV4cHJlc3Npb25cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBleHByZXNzaW9uIGFzIGEgc3RyaW5nXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgcmV0dXJuIEV4cHJlc3Npb24ubm9ybWFsaXplKHRoaXMuZXhwcmVzc2lvbnMuam9pbihcIl9cIikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGFyZW50IHRyYW5zZm9ybWF0aW9uIG9mIHRoaXMgZXhwcmVzc2lvblxuICAgICAqIEByZXR1cm4gVHJhbnNmb3JtYXRpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYXJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGFyZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcGFyZW50IHRyYW5zZm9ybWF0aW9uIG9mIHRoaXMgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7VHJhbnNmb3JtYXRpb259IHRoZSBwYXJlbnQgdHJhbnNmb3JtYXRpb25cbiAgICAgKiBAcmV0dXJuIHtFeHByZXNzaW9ufSB0aGlzIGV4cHJlc3Npb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRQYXJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGFyZW50KHBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBleHByZXNzaW9uXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jcHJlZGljYXRlXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicHJlZGljYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZWRpY2F0ZShuYW1lLCBvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIGlmIChFeHByZXNzaW9uLk9QRVJBVE9SU1tvcGVyYXRvcl0gIT0gbnVsbCkge1xuICAgICAgICBvcGVyYXRvciA9IEV4cHJlc3Npb24uT1BFUkFUT1JTW29wZXJhdG9yXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwcmVzc2lvbnMucHVzaChcIlwiLmNvbmNhdChuYW1lLCBcIl9cIikuY29uY2F0KG9wZXJhdG9yLCBcIl9cIikuY29uY2F0KHZhbHVlKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbiNhbmRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5kKCkge1xuICAgICAgdGhpcy5leHByZXNzaW9ucy5wdXNoKFwiYW5kXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jb3JcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcigpIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbnMucHVzaChcIm9yXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uY2x1ZGUgZXhwcmVzc2lvblxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uI3RoZW5cbiAgICAgKiBAcmV0dXJuIHtUcmFuc2Zvcm1hdGlvbn0gdGhlIHRyYW5zZm9ybWF0aW9uIHRoaXMgZXhwcmVzc2lvbiBpcyBkZWZpbmVkIGZvclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRoZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGhlbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFBhcmVudCgpW1wiaWZcIl0odGhpcy50b1N0cmluZygpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbiNoZWlnaHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtFeHByZXNzaW9ufSB0aGlzIGV4cHJlc3Npb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJoZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGVpZ2h0KG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwiaFwiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uI3dpZHRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7RXhwcmVzc2lvbn0gdGhpcyBleHByZXNzaW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwid2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2lkdGgob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJ3XCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jYXNwZWN0UmF0aW9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtFeHByZXNzaW9ufSB0aGlzIGV4cHJlc3Npb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhc3BlY3RSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3BlY3RSYXRpbyhvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcImFyXCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jcGFnZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtFeHByZXNzaW9ufSB0aGlzIGV4cHJlc3Npb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwYWdlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFnZUNvdW50KG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwicGNcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbiNmYWNlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0V4cHJlc3Npb259IHRoaXMgZXhwcmVzc2lvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZhY2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmYWNlQ291bnQob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJmY1wiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShfdmFsdWUpIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbnMucHVzaChfdmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICovXG4gIH1dLCBbe1xuICAgIGtleTogXCJuZXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25ldyhleHByZXNzaW9uU3RyKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoZXhwcmVzc2lvblN0cik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIGEgc3RyaW5nIGV4cHJlc3Npb25cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNub3JtYWxpemVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBhIGV4cHJlc3Npb24sIGUuZy4gXCJ3IGd0IDEwMFwiLCBcIndpZHRoX2d0XzEwMFwiLCBcIndpZHRoID4gMTAwXCJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBub3JtYWxpemVkIGZvcm0gb2YgdGhlIHZhbHVlIGV4cHJlc3Npb24sIGUuZy4gXCJ3X2d0XzEwMFwiXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibm9ybWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1hbGl6ZShleHByZXNzaW9uKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgfVxuICAgICAgZXhwcmVzc2lvbiA9IFN0cmluZyhleHByZXNzaW9uKTtcbiAgICAgIHZhciBvcGVyYXRvcnMgPSBcIlxcXFx8XFxcXHx8Pj18PD18JiZ8IT18Pnw9fDx8L3wtfFxcXFwrfFxcXFwqfFxcXFxeXCI7XG5cbiAgICAgIC8vIG9wZXJhdG9yc1xuICAgICAgdmFyIG9wZXJhdG9yc1BhdHRlcm4gPSBcIigoXCIgKyBvcGVyYXRvcnMgKyBcIikoPz1bIF9dKSlcIjtcbiAgICAgIHZhciBvcGVyYXRvcnNSZXBsYWNlUkUgPSBuZXcgUmVnRXhwKG9wZXJhdG9yc1BhdHRlcm4sIFwiZ1wiKTtcbiAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnJlcGxhY2Uob3BlcmF0b3JzUmVwbGFjZVJFLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIEV4cHJlc3Npb24uT1BFUkFUT1JTW21hdGNoXTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBwcmVkZWZpbmVkIHZhcmlhYmxlc1xuICAgICAgLy8gVGhlIDoke3Z9IHBhcnQgaXMgdG8gcHJldmVudCBub3JtYWxpemF0aW9uIG9mIHZhcnMgd2l0aCBhIHByZWNlZGluZyBjb2xvbiAoc3VjaCBhcyA6ZHVyYXRpb24pLFxuICAgICAgLy8gSXQgd29uJ3QgYmUgZm91bmQgaW4gUFJFREVGSU5FRF9WQVJTIGFuZCBzbyB3b24ndCBiZSBub3JtYWxpemVkLlxuICAgICAgLy8gSXQgaXMgZG9uZSBsaWtlIHRoaXMgYmVjYXVzZSBpZTExIGRvZXMgbm90IHN1cHBvcnQgcmVnZXggbG9va2JlaGluZFxuICAgICAgdmFyIHByZWRlZmluZWRWYXJzUGF0dGVybiA9IFwiKFwiICsgT2JqZWN0LmtleXMoRXhwcmVzc2lvbi5QUkVERUZJTkVEX1ZBUlMpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gXCI6XCIuY29uY2F0KHYsIFwifFwiKS5jb25jYXQodik7XG4gICAgICB9KS5qb2luKFwifFwiKSArIFwiKVwiO1xuICAgICAgdmFyIHVzZXJWYXJpYWJsZVBhdHRlcm4gPSAnKFxcXFwkXypbXl8gXSspJztcbiAgICAgIHZhciB2YXJpYWJsZXNSZXBsYWNlUkUgPSBuZXcgUmVnRXhwKFwiXCIuY29uY2F0KHVzZXJWYXJpYWJsZVBhdHRlcm4sIFwifFwiKS5jb25jYXQocHJlZGVmaW5lZFZhcnNQYXR0ZXJuKSwgXCJnXCIpO1xuICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ucmVwbGFjZSh2YXJpYWJsZXNSZXBsYWNlUkUsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICByZXR1cm4gRXhwcmVzc2lvbi5QUkVERUZJTkVEX1ZBUlNbbWF0Y2hdIHx8IG1hdGNoO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZXhwcmVzc2lvbi5yZXBsYWNlKC9bIF9dKy9nLCAnXycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YXJpYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YXJpYWJsZShuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKG5hbWUpLnZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcIndpZHRoXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi53aWR0aFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIndpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpZHRoKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwid2lkdGhcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJoZWlnaHRcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLmhlaWdodFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoZWlnaHQoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJoZWlnaHRcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJpbml0aWFsV2lkdGhcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLmluaXRpYWxXaWR0aFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsV2lkdGgoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJpbml0aWFsV2lkdGhcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJpbml0aWFsSGVpZ2h0XCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5pbml0aWFsSGVpZ2h0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbEhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsSGVpZ2h0KCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwiaW5pdGlhbEhlaWdodFwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcImFzcGVjdFJhdGlvXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5hc3BlY3RSYXRpb1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFzcGVjdFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzcGVjdFJhdGlvKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwiYXNwZWN0UmF0aW9cIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJpbml0aWFsQXNwZWN0UmF0aW9cIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLmluaXRpYWxBc3BlY3RSYXRpb1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxBc3BlY3RSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsQXNwZWN0UmF0aW8oKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJpbml0aWFsQXNwZWN0UmF0aW9cIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJwYWdlQ291bnRcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLnBhZ2VDb3VudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInBhZ2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWdlQ291bnQoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJwYWdlQ291bnRcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwiZmFjZUNvdW50XCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5mYWNlQ291bnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJmYWNlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFjZUNvdW50KCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwiZmFjZUNvdW50XCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwiY3VycmVudFBhZ2VcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLmN1cnJlbnRQYWdlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY3VycmVudFBhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VycmVudFBhZ2UoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJjdXJyZW50UGFnZVwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcInRhZ3NcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLnRhZ3NcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0YWdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRhZ3MoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJ0YWdzXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwicGFnZVhcIlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uLnBhZ2VYXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZVhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFnZVgoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoXCJwYWdlWFwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcInBhZ2VZXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5wYWdlWVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInBhZ2VZXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhZ2VZKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwicGFnZVlcIik7XG4gICAgfVxuICB9XSk7XG59KCk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5FeHByZXNzaW9uLk9QRVJBVE9SUyA9IHtcbiAgXCI9XCI6ICdlcScsXG4gIFwiIT1cIjogJ25lJyxcbiAgXCI8XCI6ICdsdCcsXG4gIFwiPlwiOiAnZ3QnLFxuICBcIjw9XCI6ICdsdGUnLFxuICBcIj49XCI6ICdndGUnLFxuICBcIiYmXCI6ICdhbmQnLFxuICBcInx8XCI6ICdvcicsXG4gIFwiKlwiOiBcIm11bFwiLFxuICBcIi9cIjogXCJkaXZcIixcbiAgXCIrXCI6IFwiYWRkXCIsXG4gIFwiLVwiOiBcInN1YlwiLFxuICBcIl5cIjogXCJwb3dcIlxufTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuRXhwcmVzc2lvbi5QUkVERUZJTkVEX1ZBUlMgPSB7XG4gIFwiYXNwZWN0X3JhdGlvXCI6IFwiYXJcIixcbiAgXCJhc3BlY3RSYXRpb1wiOiBcImFyXCIsXG4gIFwiY3VycmVudF9wYWdlXCI6IFwiY3BcIixcbiAgXCJjdXJyZW50UGFnZVwiOiBcImNwXCIsXG4gIFwiZHVyYXRpb25cIjogXCJkdVwiLFxuICBcImZhY2VfY291bnRcIjogXCJmY1wiLFxuICBcImZhY2VDb3VudFwiOiBcImZjXCIsXG4gIFwiaGVpZ2h0XCI6IFwiaFwiLFxuICBcImluaXRpYWxfYXNwZWN0X3JhdGlvXCI6IFwiaWFyXCIsXG4gIFwiaW5pdGlhbF9kdXJhdGlvblwiOiBcImlkdVwiLFxuICBcImluaXRpYWxfaGVpZ2h0XCI6IFwiaWhcIixcbiAgXCJpbml0aWFsX3dpZHRoXCI6IFwiaXdcIixcbiAgXCJpbml0aWFsQXNwZWN0UmF0aW9cIjogXCJpYXJcIixcbiAgXCJpbml0aWFsRHVyYXRpb25cIjogXCJpZHVcIixcbiAgXCJpbml0aWFsSGVpZ2h0XCI6IFwiaWhcIixcbiAgXCJpbml0aWFsV2lkdGhcIjogXCJpd1wiLFxuICBcInBhZ2VfY291bnRcIjogXCJwY1wiLFxuICBcInBhZ2VfeFwiOiBcInB4XCIsXG4gIFwicGFnZV95XCI6IFwicHlcIixcbiAgXCJwYWdlQ291bnRcIjogXCJwY1wiLFxuICBcInBhZ2VYXCI6IFwicHhcIixcbiAgXCJwYWdlWVwiOiBcInB5XCIsXG4gIFwidGFnc1wiOiBcInRhZ3NcIixcbiAgXCJ3aWR0aFwiOiBcIndcIlxufTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuRXhwcmVzc2lvbi5CT1VORFJZID0gXCJbIF9dK1wiO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZXhwcmVzc2lvbiA9IChFeHByZXNzaW9uKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbmRpdGlvbi5qc1xuZnVuY3Rpb24gY29uZGl0aW9uX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIGNvbmRpdGlvbl90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgY29uZGl0aW9uX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gY29uZGl0aW9uX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIGNvbmRpdGlvbl9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29uZGl0aW9uX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBjb25kaXRpb25fY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBjb25kaXRpb25fZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGNvbmRpdGlvbl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gY29uZGl0aW9uX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IGNvbmRpdGlvbl90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gY29uZGl0aW9uX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gY29uZGl0aW9uX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gY29uZGl0aW9uX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBjb25kaXRpb25fdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChjb25kaXRpb25fdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNmb3JtYXRpb24gY29uZGl0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbmRpdGlvblN0ciAtIGEgY29uZGl0aW9uIGluIHN0cmluZyBmb3JtYXRcbiAqIEBjbGFzcyBDb25kaXRpb25cbiAqIEBleGFtcGxlXG4gKiAvLyBub3JtYWxseSB0aGlzIGNsYXNzIGlzIG5vdCBpbnN0YW50aWF0ZWQgZGlyZWN0bHlcbiAqIHZhciB0ciA9IGNsb3VkaW5hcnkuVHJhbnNmb3JtYXRpb24ubmV3KClcbiAqICAgIC5pZigpLndpZHRoKCBcIj5cIiwgMTAwMCkuYW5kKCkuYXNwZWN0UmF0aW8oXCI8XCIsIFwiMzo0XCIpLnRoZW4oKVxuICogICAgICAud2lkdGgoMTAwMClcbiAqICAgICAgLmNyb3AoXCJzY2FsZVwiKVxuICogICAgLmVsc2UoKVxuICogICAgICAud2lkdGgoNTAwKVxuICogICAgICAuY3JvcChcInNjYWxlXCIpXG4gKlxuICogdmFyIHRyID0gY2xvdWRpbmFyeS5UcmFuc2Zvcm1hdGlvbi5uZXcoKVxuICogICAgLmlmKFwidyA+IDEwMDAgYW5kIGFzcGVjdFJhdGlvIDwgMzo0XCIpXG4gKiAgICAgIC53aWR0aCgxMDAwKVxuICogICAgICAuY3JvcChcInNjYWxlXCIpXG4gKiAgICAuZWxzZSgpXG4gKiAgICAgIC53aWR0aCg1MDApXG4gKiAgICAgIC5jcm9wKFwic2NhbGVcIilcbiAqXG4gKi9cbnZhciBDb25kaXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FeHByZXNzaW9uKSB7XG4gIGZ1bmN0aW9uIENvbmRpdGlvbihjb25kaXRpb25TdHIpIHtcbiAgICBjb25kaXRpb25fY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29uZGl0aW9uKTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBDb25kaXRpb24sIFtjb25kaXRpb25TdHJdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gQ29uZGl0aW9uI2hlaWdodFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAqIEByZXR1cm4ge0NvbmRpdGlvbn0gdGhpcyBjb25kaXRpb25cbiAgICovXG4gIF9pbmhlcml0cyhDb25kaXRpb24sIF9FeHByZXNzaW9uKTtcbiAgcmV0dXJuIGNvbmRpdGlvbl9jcmVhdGVDbGFzcyhDb25kaXRpb24sIFt7XG4gICAga2V5OiBcImhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoZWlnaHQob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJoXCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENvbmRpdGlvbiN3aWR0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0NvbmRpdGlvbn0gdGhpcyBjb25kaXRpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ3aWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aWR0aChvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcIndcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQ29uZGl0aW9uI2FzcGVjdFJhdGlvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7Q29uZGl0aW9ufSB0aGlzIGNvbmRpdGlvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFzcGVjdFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzcGVjdFJhdGlvKG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwiYXJcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQ29uZGl0aW9uI3BhZ2VzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7Q29uZGl0aW9ufSB0aGlzIGNvbmRpdGlvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInBhZ2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWdlQ291bnQob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJwY1wiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBDb25kaXRpb24jZmFjZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtDb25kaXRpb259IHRoaXMgY29uZGl0aW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZmFjZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZhY2VDb3VudChvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcImZjXCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENvbmRpdGlvbiNkdXJhdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0NvbmRpdGlvbn0gdGhpcyBjb25kaXRpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkdXJhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkdXJhdGlvbihvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcImR1XCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENvbmRpdGlvbiNpbml0aWFsRHVyYXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtDb25kaXRpb259IHRoaXMgY29uZGl0aW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbER1cmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxEdXJhdGlvbihvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcImlkdVwiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cbiAgfV0pO1xufShleHByZXNzaW9uKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbmRpdGlvbiA9IChDb25kaXRpb24pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29uZmlndXJhdGlvbi5qc1xuZnVuY3Rpb24gY29uZmlndXJhdGlvbl90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBjb25maWd1cmF0aW9uX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBjb25maWd1cmF0aW9uX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBjb25maWd1cmF0aW9uX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBjb25maWd1cmF0aW9uX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gY29uZmlndXJhdGlvbl9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gY29uZmlndXJhdGlvbl9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIGNvbmZpZ3VyYXRpb25fYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cbmZ1bmN0aW9uIGNvbmZpZ3VyYXRpb25fY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gY29uZmlndXJhdGlvbl9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29uZmlndXJhdGlvbl90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gY29uZmlndXJhdGlvbl9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGNvbmZpZ3VyYXRpb25fZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGNvbmZpZ3VyYXRpb25fZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIGNvbmZpZ3VyYXRpb25fdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gY29uZmlndXJhdGlvbl90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gY29uZmlndXJhdGlvbl90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIGNvbmZpZ3VyYXRpb25fdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBjb25maWd1cmF0aW9uX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBjb25maWd1cmF0aW9uX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG4vKipcbiAqIENsYXNzIGZvciBkZWZpbmluZyBhY2NvdW50IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqIERlcGVuZHMgb24gJ3V0aWxzJ1xuICovXG5cblxuXG4vKipcbiAqIENsYXNzIGZvciBkZWZpbmluZyBhY2NvdW50IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqIEBjb25zdHJ1Y3RvciBDb25maWd1cmF0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBhY2NvdW50IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyB0byBzZXQuXG4gKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCJcbiAqICB0YXJnZXQ9XCJfbmV3XCI+QXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAqL1xudmFyIGNvbmZpZ3VyYXRpb25fQ29uZmlndXJhdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24ob3B0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25fY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29uZmlndXJhdGlvbik7XG4gICAgdGhpcy5jb25maWd1cmF0aW9uID0gb3B0aW9ucyA9PSBudWxsID8ge30gOiBjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfZGVmYXVsdCgpKG9wdGlvbnMpO1xuICAgIGRlZmF1bHRzKHRoaXMuY29uZmlndXJhdGlvbiwgREVGQVVMVF9DT05GSUdVUkFUSU9OX1BBUkFNUyk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbmZpZ3VyYXRpb24uIFRoaXMgbWV0aG9kIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIHRoYXQgaW52b2tlcyBib3RoXG4gICAqICB7QGxpbmsgQ29uZmlndXJhdGlvbiNmcm9tRW52aXJvbm1lbnR8ZnJvbUVudmlyb25tZW50KCl9IChOb2RlLmpzIGVudmlyb25tZW50IG9ubHkpXG4gICAqICBhbmQge0BsaW5rIENvbmZpZ3VyYXRpb24jZnJvbURvY3VtZW50fGZyb21Eb2N1bWVudCgpfS5cbiAgICogIEl0IGZpcnN0IHRyaWVzIHRvIHJldHJpZXZlIHRoZSBjb25maWd1cmF0aW9uIGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICAgKiAgSWYgbm90IGF2YWlsYWJsZSwgaXQgdHJpZXMgZnJvbSB0aGUgZG9jdW1lbnQgbWV0YSB0YWdzLlxuICAgKiBAZnVuY3Rpb24gQ29uZmlndXJhdGlvbiNpbml0XG4gICAqIEByZXR1cm4ge0NvbmZpZ3VyYXRpb259IHJldHVybnMgYHRoaXNgIGZvciBjaGFpbmluZ1xuICAgKiBAc2VlIGZyb21Eb2N1bWVudFxuICAgKiBAc2VlIGZyb21FbnZpcm9ubWVudFxuICAgKi9cbiAgcmV0dXJuIGNvbmZpZ3VyYXRpb25fY3JlYXRlQ2xhc3MoQ29uZmlndXJhdGlvbiwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5mcm9tRW52aXJvbm1lbnQoKTtcbiAgICAgIHRoaXMuZnJvbURvY3VtZW50KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBuZXcgY29uZmlndXJhdGlvbiBpdGVtXG4gICAgICogQGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24jc2V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgaXRlbSB0byBzZXRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIGJlIHNldFxuICAgICAqIEByZXR1cm4ge0NvbmZpZ3VyYXRpb259XG4gICAgICpcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLmNvbmZpZ3VyYXRpb25bbmFtZV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgb2YgYSBjb25maWd1cmF0aW9uIGl0ZW1cbiAgICAgKiBAZnVuY3Rpb24gQ29uZmlndXJhdGlvbiNnZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBpdGVtIHRvIHNldFxuICAgICAqIEByZXR1cm4geyp9IHRoZSBjb25maWd1cmF0aW9uIGl0ZW1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb25bbmFtZV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1lcmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlKGNvbmZpZykge1xuICAgICAgYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh0aGlzLmNvbmZpZ3VyYXRpb24sIGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0KCkoY29uZmlnKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIENsb3VkaW5hcnkgZnJvbSBIVE1MIG1ldGEgdGFncy5cbiAgICAgKiBAZnVuY3Rpb24gQ29uZmlndXJhdGlvbiNmcm9tRG9jdW1lbnRcbiAgICAgKiBAcmV0dXJuIHtDb25maWd1cmF0aW9ufVxuICAgICAqIEBleGFtcGxlIDxtZXRhIG5hbWU9XCJjbG91ZGluYXJ5X2Nsb3VkX25hbWVcIiBjb250ZW50PVwibXljbG91ZFwiPlxuICAgICAqXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbURvY3VtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Eb2N1bWVudCgpIHtcbiAgICAgIHZhciBlbCwgaSwgbGVuLCBtZXRhX2VsZW1lbnRzO1xuICAgICAgbWV0YV9lbGVtZW50cyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudCAhPT0gbnVsbCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ21ldGFbbmFtZV49XCJjbG91ZGluYXJ5X1wiXScpIDogdm9pZCAwO1xuICAgICAgaWYgKG1ldGFfZWxlbWVudHMpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbWV0YV9lbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGVsID0gbWV0YV9lbGVtZW50c1tpXTtcbiAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25bZWwuZ2V0QXR0cmlidXRlKCduYW1lJykucmVwbGFjZSgnY2xvdWRpbmFyeV8nLCAnJyldID0gZWwuZ2V0QXR0cmlidXRlKCdjb250ZW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgQ2xvdWRpbmFyeSBmcm9tIHRoZSBgQ0xPVURJTkFSWV9VUkxgIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIG9ubHkgcnVuIHVuZGVyIE5vZGUuanMgZW52aXJvbm1lbnQuXG4gICAgICogQGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24jZnJvbUVudmlyb25tZW50XG4gICAgICogQHJlcXVpcmVzIE5vZGUuanNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJmcm9tRW52aXJvbm1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUVudmlyb25tZW50KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBjbG91ZGluYXJ5X3VybCwgcXVlcnksIHVyaSwgdXJpUmVnZXg7XG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5DTE9VRElOQVJZX1VSTCkge1xuICAgICAgICBjbG91ZGluYXJ5X3VybCA9IHByb2Nlc3MuZW52LkNMT1VESU5BUllfVVJMO1xuICAgICAgICB1cmlSZWdleCA9IC9jbG91ZGluYXJ5OlxcL1xcLyg/OihcXHcrKSg/OlxcOihbXFx3LV0rKSk/QCk/KFtcXHdcXC4tXSspKD86XFwvKFteP10qKSk/KD86XFw/KC4rKSk/LztcbiAgICAgICAgdXJpID0gdXJpUmVnZXguZXhlYyhjbG91ZGluYXJ5X3VybCk7XG4gICAgICAgIGlmICh1cmkpIHtcbiAgICAgICAgICBpZiAodXJpWzNdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvblsnY2xvdWRfbmFtZSddID0gdXJpWzNdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodXJpWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvblsnYXBpX2tleSddID0gdXJpWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodXJpWzJdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvblsnYXBpX3NlY3JldCddID0gdXJpWzJdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodXJpWzRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvblsncHJpdmF0ZV9jZG4nXSA9IHVyaVs0XSAhPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodXJpWzRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvblsnc2VjdXJlX2Rpc3RyaWJ1dGlvbiddID0gdXJpWzRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxdWVyeSA9IHVyaVs1XTtcbiAgICAgICAgICBpZiAocXVlcnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgcXVlcnkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICB2YXIgX3ZhbHVlJHNwbGl0ID0gdmFsdWUuc3BsaXQoJz0nKSxcbiAgICAgICAgICAgICAgICBfdmFsdWUkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX3ZhbHVlJHNwbGl0LCAyKSxcbiAgICAgICAgICAgICAgICBrID0gX3ZhbHVlJHNwbGl0MlswXSxcbiAgICAgICAgICAgICAgICB2ID0gX3ZhbHVlJHNwbGl0MlsxXTtcbiAgICAgICAgICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHYgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF90aGlzLmNvbmZpZ3VyYXRpb25ba10gPSB2O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgb3IgbW9kaWZ5IHRoZSBDbG91ZGluYXJ5IGNsaWVudCBjb25maWd1cmF0aW9uXG4gICAgICpcbiAgICAgKiBXYXJuaW5nOiBgY29uZmlnKClgIHJldHVybnMgdGhlIGFjdHVhbCBpbnRlcm5hbCBjb25maWd1cmF0aW9uIG9iamVjdC4gbW9kaWZ5aW5nIGl0IHdpbGwgY2hhbmdlIHRoZSBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgbWV0aG9kLiBGb3IgbmV3IGNvZGUsIHVzZSBnZXQoKSwgbWVyZ2UoKSBldGMuXG4gICAgICogQGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24jY29uZmlnXG4gICAgICogQHBhcmFtIHtoYXNofHN0cmluZ3xib29sZWFufSBuZXdfY29uZmlnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld192YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfSBjb25maWd1cmF0aW9uLCBvciB2YWx1ZVxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgZnJvbUVudmlyb25tZW50fSBmb3IgaW5pdGlhbGl6YXRpb24gdXNpbmcgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgICogQHNlZSB7QGxpbmsgZnJvbURvY3VtZW50fSBmb3IgaW5pdGlhbGl6YXRpb24gdXNpbmcgSFRNTCBtZXRhIHRhZ3NcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjb25maWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uZmlnKG5ld19jb25maWcsIG5ld192YWx1ZSkge1xuICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICBjYXNlIG5ld192YWx1ZSA9PT0gdm9pZCAwOlxuICAgICAgICAgIHRoaXMuc2V0KG5ld19jb25maWcsIG5ld192YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbjtcbiAgICAgICAgY2FzZSAhaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkobmV3X2NvbmZpZyk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KG5ld19jb25maWcpO1xuICAgICAgICBjYXNlICFpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkobmV3X2NvbmZpZyk6XG4gICAgICAgICAgdGhpcy5tZXJnZShuZXdfY29uZmlnKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkgLSByZXR1cm4gdGhlIGludGVybmFsIG9iamVjdFxuICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgICAqIEBmdW5jdGlvbiBDb25maWd1cmF0aW9uI3RvT3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGEga2V5OnZhbHVlIGNvbGxlY3Rpb24gb2YgdGhlIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRvT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b09wdGlvbnMoKSB7XG4gICAgICByZXR1cm4gY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQoKSh0aGlzLmNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgfV0pO1xufSgpO1xudmFyIERFRkFVTFRfQ09ORklHVVJBVElPTl9QQVJBTVMgPSB7XG4gIHJlc3BvbnNpdmVfY2xhc3M6ICdjbGQtcmVzcG9uc2l2ZScsXG4gIHJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzOiB0cnVlLFxuICByb3VuZF9kcHI6IHRydWUsXG4gIHNlY3VyZTogKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9PSBudWxsID8gd2luZG93LmxvY2F0aW9uID8gd2luZG93LmxvY2F0aW9uLnByb3RvY29sIDogdm9pZCAwIDogdm9pZCAwKSA9PT0gJ2h0dHBzOidcbn07XG5jb25maWd1cmF0aW9uX0NvbmZpZ3VyYXRpb24uQ09ORklHX1BBUkFNUyA9IFtcImFwaV9rZXlcIiwgXCJhcGlfc2VjcmV0XCIsIFwiY2FsbGJhY2tcIiwgXCJjZG5fc3ViZG9tYWluXCIsIFwiY2xvdWRfbmFtZVwiLCBcImNuYW1lXCIsIFwicHJpdmF0ZV9jZG5cIiwgXCJwcm90b2NvbFwiLCBcInJlc291cmNlX3R5cGVcIiwgXCJyZXNwb25zaXZlXCIsIFwicmVzcG9uc2l2ZV9jbGFzc1wiLCBcInJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzXCIsIFwicmVzcG9uc2l2ZV93aWR0aFwiLCBcInJvdW5kX2RwclwiLCBcInNlY3VyZVwiLCBcInNlY3VyZV9jZG5fc3ViZG9tYWluXCIsIFwic2VjdXJlX2Rpc3RyaWJ1dGlvblwiLCBcInNob3J0ZW5cIiwgXCJ0eXBlXCIsIFwidXBsb2FkX3ByZXNldFwiLCBcInVybF9zdWZmaXhcIiwgXCJ1c2Vfcm9vdF9wYXRoXCIsIFwidmVyc2lvblwiLCBcImV4dGVybmFsTGlicmFyaWVzXCIsIFwibWF4X3RpbWVvdXRfbXNcIl07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfY29uZmlndXJhdGlvbiA9IChjb25maWd1cmF0aW9uX0NvbmZpZ3VyYXRpb24pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbGF5ZXIvbGF5ZXIuanNcbmZ1bmN0aW9uIGxheWVyX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIGxheWVyX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBsYXllcl90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIGxheWVyX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIGxheWVyX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBsYXllcl90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gbGF5ZXJfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgbGF5ZXJfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIGxheWVyX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IGxheWVyX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBsYXllcl90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIGxheWVyX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gbGF5ZXJfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IGxheWVyX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5cbnZhciBsYXllcl9MYXllciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBMYXllclxuICAgKiBAY29uc3RydWN0b3IgTGF5ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBsYXllciBwYXJhbWV0ZXJzXG4gICAqL1xuICBmdW5jdGlvbiBMYXllcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBsYXllcl9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYXllcik7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAgW1wicmVzb3VyY2VUeXBlXCIsIFwidHlwZVwiLCBcInB1YmxpY0lkXCIsIFwiZm9ybWF0XCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICByZXR1cm4gX3RoaXMub3B0aW9uc1trZXldID0gKHJlZiA9IG9wdGlvbnNba2V5XSkgIT0gbnVsbCA/IHJlZiA6IG9wdGlvbnNbc25ha2VDYXNlKGtleSldO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsYXllcl9jcmVhdGVDbGFzcyhMYXllciwgW3tcbiAgICBrZXk6IFwicmVzb3VyY2VUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc291cmNlVHlwZSh2YWx1ZSkge1xuICAgICAgdGhpcy5vcHRpb25zLnJlc291cmNlVHlwZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHlwZSh2YWx1ZSkge1xuICAgICAgdGhpcy5vcHRpb25zLnR5cGUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwdWJsaWNJZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdWJsaWNJZCh2YWx1ZSkge1xuICAgICAgdGhpcy5vcHRpb25zLnB1YmxpY0lkID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHB1YmxpYyBJRCwgZm9ybWF0dGVkIGZvciBsYXllciBwYXJhbWV0ZXJcbiAgICAgKiBAZnVuY3Rpb24gTGF5ZXIjZ2V0UHVibGljSWRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHB1YmxpYyBJRFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFB1YmxpY0lkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFB1YmxpY0lkKCkge1xuICAgICAgdmFyIHJlZjtcbiAgICAgIHJldHVybiAocmVmID0gdGhpcy5vcHRpb25zLnB1YmxpY0lkKSAhPSBudWxsID8gcmVmLnJlcGxhY2UoL1xcLy9nLCBcIjpcIikgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwdWJsaWMgSUQsIHdpdGggZm9ybWF0IGlmIHByZXNlbnRcbiAgICAgKiBAZnVuY3Rpb24gTGF5ZXIjZ2V0RnVsbFB1YmxpY0lkXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBwdWJsaWMgSURcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRGdWxsUHVibGljSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RnVsbFB1YmxpY0lkKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQdWJsaWNJZCgpICsgXCIuXCIgKyB0aGlzLm9wdGlvbnMuZm9ybWF0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHVibGljSWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICAgICAgdGhpcy5vcHRpb25zLmZvcm1hdCA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGUgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGF5ZXJcbiAgICAgKiBAZnVuY3Rpb24gTGF5ZXIjdG9TdHJpbmdcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnRzO1xuICAgICAgY29tcG9uZW50cyA9IFtdO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wdWJsaWNJZCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IFwiTXVzdCBzdXBwbHkgcHVibGljSWRcIjtcbiAgICAgIH1cbiAgICAgIGlmICghKHRoaXMub3B0aW9ucy5yZXNvdXJjZVR5cGUgPT09IFwiaW1hZ2VcIikpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKHRoaXMub3B0aW9ucy5yZXNvdXJjZVR5cGUpO1xuICAgICAgfVxuICAgICAgaWYgKCEodGhpcy5vcHRpb25zLnR5cGUgPT09IFwidXBsb2FkXCIpKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzLm9wdGlvbnMudHlwZSk7XG4gICAgICB9XG4gICAgICBjb21wb25lbnRzLnB1c2godGhpcy5nZXRGdWxsUHVibGljSWQoKSk7XG4gICAgICByZXR1cm4gY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCgpKGNvbXBvbmVudHMpLmpvaW4oXCI6XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbGF5ZXJfbGF5ZXIgPSAobGF5ZXJfTGF5ZXIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbGF5ZXIvdGV4dGxheWVyLmpzXG5mdW5jdGlvbiB0ZXh0bGF5ZXJfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gdGV4dGxheWVyX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCB0ZXh0bGF5ZXJfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiB0ZXh0bGF5ZXJfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gdGV4dGxheWVyX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCB0ZXh0bGF5ZXJfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIHRleHRsYXllcl9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIHRleHRsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgdGV4dGxheWVyX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiB0ZXh0bGF5ZXJfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gdGV4dGxheWVyX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSB0ZXh0bGF5ZXJfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiB0ZXh0bGF5ZXJfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSB0ZXh0bGF5ZXJfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IHRleHRsYXllcl90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gdGV4dGxheWVyX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gdGV4dGxheWVyX2dldFByb3RvdHlwZU9mKG8pLCB0ZXh0bGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCB0ZXh0bGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCB0ZXh0bGF5ZXJfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIHRleHRsYXllcl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKHRleHRsYXllcl90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gdGV4dGxheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gdGV4dGxheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiB0ZXh0bGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAodGV4dGxheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIHRleHRsYXllcl9nZXRQcm90b3R5cGVPZihvKSB7IHRleHRsYXllcl9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gdGV4dGxheWVyX2dldFByb3RvdHlwZU9mKG8pOyB9XG5mdW5jdGlvbiB0ZXh0bGF5ZXJfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgdGV4dGxheWVyX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gdGV4dGxheWVyX3NldFByb3RvdHlwZU9mKG8sIHApIHsgdGV4dGxheWVyX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiB0ZXh0bGF5ZXJfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuXG52YXIgdGV4dGxheWVyX1RleHRMYXllciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xheWVyKSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3IgVGV4dExheWVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gbGF5ZXIgcGFyYW1ldGVyc1xuICAgKi9cbiAgZnVuY3Rpb24gVGV4dExheWVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgdGV4dGxheWVyX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRMYXllcik7XG4gICAgdmFyIGtleXM7XG4gICAgX3RoaXMgPSB0ZXh0bGF5ZXJfY2FsbFN1cGVyKHRoaXMsIFRleHRMYXllciwgW29wdGlvbnNdKTtcbiAgICBrZXlzID0gW1wicmVzb3VyY2VUeXBlXCIsIFwicmVzb3VyY2VUeXBlXCIsIFwiZm9udEZhbWlseVwiLCBcImZvbnRTaXplXCIsIFwiZm9udFdlaWdodFwiLCBcImZvbnRTdHlsZVwiLCBcInRleHREZWNvcmF0aW9uXCIsIFwidGV4dEFsaWduXCIsIFwic3Ryb2tlXCIsIFwibGV0dGVyU3BhY2luZ1wiLCBcImxpbmVTcGFjaW5nXCIsIFwiZm9udEhpbnRpbmdcIiwgXCJmb250QW50aWFsaWFzaW5nXCIsIFwidGV4dFwiLCBcInRleHRTdHlsZVwiXTtcbiAgICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICByZXR1cm4gX3RoaXMub3B0aW9uc1trZXldID0gKHJlZiA9IG9wdGlvbnNba2V5XSkgIT0gbnVsbCA/IHJlZiA6IG9wdGlvbnNbc25ha2VDYXNlKGtleSldO1xuICAgICAgfSk7XG4gICAgfVxuICAgIF90aGlzLm9wdGlvbnMucmVzb3VyY2VUeXBlID0gXCJ0ZXh0XCI7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHRleHRsYXllcl9pbmhlcml0cyhUZXh0TGF5ZXIsIF9MYXllcik7XG4gIHJldHVybiB0ZXh0bGF5ZXJfY3JlYXRlQ2xhc3MoVGV4dExheWVyLCBbe1xuICAgIGtleTogXCJyZXNvdXJjZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb3VyY2VUeXBlKF9yZXNvdXJjZVR5cGUpIHtcbiAgICAgIHRocm93IFwiQ2Fubm90IG1vZGlmeSByZXNvdXJjZVR5cGUgZm9yIHRleHQgbGF5ZXJzXCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHlwZShfdHlwZSkge1xuICAgICAgdGhyb3cgXCJDYW5ub3QgbW9kaWZ5IHR5cGUgZm9yIHRleHQgbGF5ZXJzXCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQoX2Zvcm1hdCkge1xuICAgICAgdGhyb3cgXCJDYW5ub3QgbW9kaWZ5IGZvcm1hdCBmb3IgdGV4dCBsYXllcnNcIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9udEZhbWlseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb250RmFtaWx5KF9mb250RmFtaWx5KSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZm9udEZhbWlseSA9IF9mb250RmFtaWx5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvbnRTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvbnRTaXplKF9mb250U2l6ZSkge1xuICAgICAgdGhpcy5vcHRpb25zLmZvbnRTaXplID0gX2ZvbnRTaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvbnRXZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9udFdlaWdodChfZm9udFdlaWdodCkge1xuICAgICAgdGhpcy5vcHRpb25zLmZvbnRXZWlnaHQgPSBfZm9udFdlaWdodDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb250U3R5bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9udFN0eWxlKF9mb250U3R5bGUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5mb250U3R5bGUgPSBfZm9udFN0eWxlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHREZWNvcmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHREZWNvcmF0aW9uKF90ZXh0RGVjb3JhdGlvbikge1xuICAgICAgdGhpcy5vcHRpb25zLnRleHREZWNvcmF0aW9uID0gX3RleHREZWNvcmF0aW9uO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRBbGlnblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0QWxpZ24oX3RleHRBbGlnbikge1xuICAgICAgdGhpcy5vcHRpb25zLnRleHRBbGlnbiA9IF90ZXh0QWxpZ247XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3Ryb2tlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0cm9rZShfc3Ryb2tlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuc3Ryb2tlID0gX3N0cm9rZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZXR0ZXJTcGFjaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxldHRlclNwYWNpbmcoX2xldHRlclNwYWNpbmcpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5sZXR0ZXJTcGFjaW5nID0gX2xldHRlclNwYWNpbmc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGluZVNwYWNpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGluZVNwYWNpbmcoX2xpbmVTcGFjaW5nKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubGluZVNwYWNpbmcgPSBfbGluZVNwYWNpbmc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9udEhpbnRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9udEhpbnRpbmcoX2ZvbnRIaW50aW5nKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZm9udEhpbnRpbmcgPSBfZm9udEhpbnRpbmc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9udEFudGlhbGlhc2luZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb250QW50aWFsaWFzaW5nKF9mb250QW50aWFsaWFzaW5nKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZm9udEFudGlhbGlhc2luZyA9IF9mb250QW50aWFsaWFzaW5nO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dChfdGV4dCkge1xuICAgICAgdGhpcy5vcHRpb25zLnRleHQgPSBfdGV4dDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0U3R5bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dFN0eWxlKF90ZXh0U3R5bGUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy50ZXh0U3R5bGUgPSBfdGV4dFN0eWxlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGUgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGF5ZXJcbiAgICAgKiBAZnVuY3Rpb24gVGV4dExheWVyI3RvU3RyaW5nXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIGNvbXBvbmVudHMsIGhhc1B1YmxpY0lkLCBoYXNTdHlsZSwgcHVibGljSWQsIHJlLCByZXMsIHN0YXJ0LCBzdHlsZSwgdGV4dCwgdGV4dFNvdXJjZTtcbiAgICAgIHN0eWxlID0gdGhpcy50ZXh0U3R5bGVJZGVudGlmaWVyKCk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnB1YmxpY0lkICE9IG51bGwpIHtcbiAgICAgICAgcHVibGljSWQgPSB0aGlzLmdldEZ1bGxQdWJsaWNJZCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgaGFzUHVibGljSWQgPSAhaXNFbXB0eShwdWJsaWNJZCk7XG4gICAgICAgIGhhc1N0eWxlID0gIWlzRW1wdHkoc3R5bGUpO1xuICAgICAgICBpZiAoaGFzUHVibGljSWQgJiYgaGFzU3R5bGUgfHwgIWhhc1B1YmxpY0lkICYmICFoYXNTdHlsZSkge1xuICAgICAgICAgIHRocm93IFwiTXVzdCBzdXBwbHkgZWl0aGVyIHN0eWxlIHBhcmFtZXRlcnMgb3IgYSBwdWJsaWNfaWQgd2hlbiBwcm92aWRpbmcgdGV4dCBwYXJhbWV0ZXIgaW4gYSB0ZXh0IG92ZXJsYXkvdW5kZXJsYXksIGJ1dCBub3QgYm90aCFcIjtcbiAgICAgICAgfVxuICAgICAgICByZSA9IC9cXCRcXChbYS16QS1aXVxcdypcXCkvZztcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAvLyAgICAgICAgdGV4dFNvdXJjZSA9IHRleHQucmVwbGFjZShuZXcgUmVnRXhwKFwiWywvXVwiLCAnZycpLCAoYyktPiBcIiUje2MuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKX1cIilcbiAgICAgICAgdGV4dFNvdXJjZSA9IHNtYXJ0RXNjYXBlKHRoaXMub3B0aW9ucy50ZXh0LCAvWyxcXC9dL2cpO1xuICAgICAgICB0ZXh0ID0gXCJcIjtcbiAgICAgICAgd2hpbGUgKHJlcyA9IHJlLmV4ZWModGV4dFNvdXJjZSkpIHtcbiAgICAgICAgICB0ZXh0ICs9IHNtYXJ0RXNjYXBlKHRleHRTb3VyY2Uuc2xpY2Uoc3RhcnQsIHJlcy5pbmRleCkpO1xuICAgICAgICAgIHRleHQgKz0gcmVzWzBdO1xuICAgICAgICAgIHN0YXJ0ID0gcmVzLmluZGV4ICsgcmVzWzBdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ICs9IHNtYXJ0RXNjYXBlKHRleHRTb3VyY2Uuc2xpY2Uoc3RhcnQpKTtcbiAgICAgIH1cbiAgICAgIGNvbXBvbmVudHMgPSBbdGhpcy5vcHRpb25zLnJlc291cmNlVHlwZSwgc3R5bGUsIHB1YmxpY0lkLCB0ZXh0XTtcbiAgICAgIHJldHVybiBjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0KCkoY29tcG9uZW50cykuam9pbihcIjpcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRTdHlsZUlkZW50aWZpZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dFN0eWxlSWRlbnRpZmllcigpIHtcbiAgICAgIC8vIE5vdGU6IGlmIGEgdGV4dC1zdHlsZSBhcmd1bWVudCBpcyBwcm92aWRlZCBhcyBhIHdob2xlLCBpdCBvdmVycmlkZXMgZXZlcnl0aGluZyBlbHNlLCBubyBtaXggYW5kIG1hdGNoLlxuICAgICAgaWYgKCFpc0VtcHR5KHRoaXMub3B0aW9ucy50ZXh0U3R5bGUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGV4dFN0eWxlO1xuICAgICAgfVxuICAgICAgdmFyIGNvbXBvbmVudHM7XG4gICAgICBjb21wb25lbnRzID0gW107XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZvbnRXZWlnaHQgIT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKHRoaXMub3B0aW9ucy5mb250V2VpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9udFN0eWxlICE9PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzLm9wdGlvbnMuZm9udFN0eWxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGV4dERlY29yYXRpb24gIT09IFwibm9uZVwiKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzLm9wdGlvbnMudGV4dERlY29yYXRpb24pO1xuICAgICAgfVxuICAgICAgY29tcG9uZW50cy5wdXNoKHRoaXMub3B0aW9ucy50ZXh0QWxpZ24pO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHJva2UgIT09IFwibm9uZVwiKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzLm9wdGlvbnMuc3Ryb2tlKTtcbiAgICAgIH1cbiAgICAgIGlmICghKGlzRW1wdHkodGhpcy5vcHRpb25zLmxldHRlclNwYWNpbmcpICYmICFpc051bWJlckxpa2UodGhpcy5vcHRpb25zLmxldHRlclNwYWNpbmcpKSkge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goXCJsZXR0ZXJfc3BhY2luZ19cIiArIHRoaXMub3B0aW9ucy5sZXR0ZXJTcGFjaW5nKTtcbiAgICAgIH1cbiAgICAgIGlmICghKGlzRW1wdHkodGhpcy5vcHRpb25zLmxpbmVTcGFjaW5nKSAmJiAhaXNOdW1iZXJMaWtlKHRoaXMub3B0aW9ucy5saW5lU3BhY2luZykpKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChcImxpbmVfc3BhY2luZ19cIiArIHRoaXMub3B0aW9ucy5saW5lU3BhY2luZyk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzRW1wdHkodGhpcy5vcHRpb25zLmZvbnRBbnRpYWxpYXNpbmcpKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChcImFudGlhbGlhc19cIiArIHRoaXMub3B0aW9ucy5mb250QW50aWFsaWFzaW5nKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNFbXB0eSh0aGlzLm9wdGlvbnMuZm9udEhpbnRpbmcpKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChcImhpbnRpbmdfXCIgKyB0aGlzLm9wdGlvbnMuZm9udEhpbnRpbmcpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0VtcHR5KGNvbXBhY3Rfcm9vdF9jb21wYWN0X2RlZmF1bHQoKShjb21wb25lbnRzKSkpIHtcbiAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5vcHRpb25zLmZvbnRGYW1pbHkpKSB7XG4gICAgICAgICAgdGhyb3cgXCJNdXN0IHN1cHBseSBmb250RmFtaWx5LiBcIi5jb25jYXQoY29tcG9uZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5vcHRpb25zLmZvbnRTaXplKSAmJiAhaXNOdW1iZXJMaWtlKHRoaXMub3B0aW9ucy5mb250U2l6ZSkpIHtcbiAgICAgICAgICB0aHJvdyBcIk11c3Qgc3VwcGx5IGZvbnRTaXplLlwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb21wb25lbnRzLnVuc2hpZnQodGhpcy5vcHRpb25zLmZvbnRGYW1pbHksIHRoaXMub3B0aW9ucy5mb250U2l6ZSk7XG4gICAgICBjb21wb25lbnRzID0gY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCgpKGNvbXBvbmVudHMpLmpvaW4oXCJfXCIpO1xuICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfVxuICB9XSk7XG59KGxheWVyX2xheWVyKTtcbjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRleHRsYXllciA9ICh0ZXh0bGF5ZXJfVGV4dExheWVyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2xheWVyL3N1YnRpdGxlc2xheWVyLmpzXG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBzdWJ0aXRsZXNsYXllcl90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgc3VidGl0bGVzbGF5ZXJfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgc3VidGl0bGVzbGF5ZXJfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgc3VidGl0bGVzbGF5ZXJfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIHN1YnRpdGxlc2xheWVyX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBzdWJ0aXRsZXNsYXllcl90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gc3VidGl0bGVzbGF5ZXJfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHN1YnRpdGxlc2xheWVyX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBzdWJ0aXRsZXNsYXllcl90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBzdWJ0aXRsZXNsYXllcl9nZXRQcm90b3R5cGVPZihvKSwgc3VidGl0bGVzbGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBzdWJ0aXRsZXNsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIHN1YnRpdGxlc2xheWVyX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKHN1YnRpdGxlc2xheWVyX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBzdWJ0aXRsZXNsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChzdWJ0aXRsZXNsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9nZXRQcm90b3R5cGVPZihvKSB7IHN1YnRpdGxlc2xheWVyX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBzdWJ0aXRsZXNsYXllcl9nZXRQcm90b3R5cGVPZihvKTsgfVxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgc3VidGl0bGVzbGF5ZXJfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9zZXRQcm90b3R5cGVPZihvLCBwKSB7IHN1YnRpdGxlc2xheWVyX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBzdWJ0aXRsZXNsYXllcl9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgU3VidGl0bGVzTGF5ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UZXh0TGF5ZXIpIHtcbiAgLyoqXG4gICAqIFJlcHJlc2VudCBhIHN1YnRpdGxlcyBsYXllclxuICAgKiBAY29uc3RydWN0b3IgU3VidGl0bGVzTGF5ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBsYXllciBwYXJhbWV0ZXJzXG4gICAqL1xuICBmdW5jdGlvbiBTdWJ0aXRsZXNMYXllcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIHN1YnRpdGxlc2xheWVyX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YnRpdGxlc0xheWVyKTtcbiAgICBfdGhpcyA9IHN1YnRpdGxlc2xheWVyX2NhbGxTdXBlcih0aGlzLCBTdWJ0aXRsZXNMYXllciwgW29wdGlvbnNdKTtcbiAgICBfdGhpcy5vcHRpb25zLnJlc291cmNlVHlwZSA9IFwic3VidGl0bGVzXCI7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHN1YnRpdGxlc2xheWVyX2luaGVyaXRzKFN1YnRpdGxlc0xheWVyLCBfVGV4dExheWVyKTtcbiAgcmV0dXJuIHN1YnRpdGxlc2xheWVyX2NyZWF0ZUNsYXNzKFN1YnRpdGxlc0xheWVyKTtcbn0odGV4dGxheWVyKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHN1YnRpdGxlc2xheWVyID0gKFN1YnRpdGxlc0xheWVyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2xheWVyL2ZldGNobGF5ZXIuanNcbmZ1bmN0aW9uIGZldGNobGF5ZXJfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gZmV0Y2hsYXllcl90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgZmV0Y2hsYXllcl90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIGZldGNobGF5ZXJfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gZmV0Y2hsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZmV0Y2hsYXllcl90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gZmV0Y2hsYXllcl9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGZldGNobGF5ZXJfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGZldGNobGF5ZXJfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIGZldGNobGF5ZXJfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gZmV0Y2hsYXllcl90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gZmV0Y2hsYXllcl90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIGZldGNobGF5ZXJfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBmZXRjaGxheWVyX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBmZXRjaGxheWVyX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBmZXRjaGxheWVyX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gZmV0Y2hsYXllcl9nZXRQcm90b3R5cGVPZihvKSwgZmV0Y2hsYXllcl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIGZldGNobGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBmZXRjaGxheWVyX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG5mdW5jdGlvbiBmZXRjaGxheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoZmV0Y2hsYXllcl90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gZmV0Y2hsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIGZldGNobGF5ZXJfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIGZldGNobGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoZmV0Y2hsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBmZXRjaGxheWVyX2dldFByb3RvdHlwZU9mKG8pIHsgZmV0Y2hsYXllcl9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gZmV0Y2hsYXllcl9nZXRQcm90b3R5cGVPZihvKTsgfVxuZnVuY3Rpb24gZmV0Y2hsYXllcl9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBmZXRjaGxheWVyX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gZmV0Y2hsYXllcl9zZXRQcm90b3R5cGVPZihvLCBwKSB7IGZldGNobGF5ZXJfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIGZldGNobGF5ZXJfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuXG52YXIgZmV0Y2hsYXllcl9GZXRjaExheWVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTGF5ZXIpIHtcbiAgLyoqXG4gICAqIEBjbGFzcyBGZXRjaExheWVyXG4gICAqIEBjbGFzc2Rlc2MgQ3JlYXRlcyBhbiBpbWFnZSBsYXllciB1c2luZyBhIHJlbW90ZSBVUkwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gb3B0aW9ucyAtIGxheWVyIHBhcmFtZXRlcnMgb3IgYSB1cmxcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudXJsIHRoZSB1cmwgb2YgdGhlIGltYWdlIHRvIGZldGNoXG4gICAqL1xuICBmdW5jdGlvbiBGZXRjaExheWVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgZmV0Y2hsYXllcl9jbGFzc0NhbGxDaGVjayh0aGlzLCBGZXRjaExheWVyKTtcbiAgICBfdGhpcyA9IGZldGNobGF5ZXJfY2FsbFN1cGVyKHRoaXMsIEZldGNoTGF5ZXIsIFtvcHRpb25zXSk7XG4gICAgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKG9wdGlvbnMpKSB7XG4gICAgICBfdGhpcy5vcHRpb25zLnVybCA9IG9wdGlvbnM7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLnVybCA6IHZvaWQgMCkge1xuICAgICAgX3RoaXMub3B0aW9ucy51cmwgPSBvcHRpb25zLnVybDtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIGZldGNobGF5ZXJfaW5oZXJpdHMoRmV0Y2hMYXllciwgX0xheWVyKTtcbiAgcmV0dXJuIGZldGNobGF5ZXJfY3JlYXRlQ2xhc3MoRmV0Y2hMYXllciwgW3tcbiAgICBrZXk6IFwidXJsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVybChfdXJsKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudXJsID0gX3VybDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyXG4gICAgICogQGZ1bmN0aW9uIEZldGNoTGF5ZXIjdG9TdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJmZXRjaDpcIi5jb25jYXQoYmFzZTY0RW5jb2RlVVJMKHRoaXMub3B0aW9ucy51cmwpKTtcbiAgICB9XG4gIH1dKTtcbn0obGF5ZXJfbGF5ZXIpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZmV0Y2hsYXllciA9IChmZXRjaGxheWVyX0ZldGNoTGF5ZXIpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcGFyYW1ldGVycy5qc1xuZnVuY3Rpb24gcGFyYW1ldGVyc19jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YobyksIHBhcmFtZXRlcnNfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBwYXJhbWV0ZXJzX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgcGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gcGFyYW1ldGVyc19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKHBhcmFtZXRlcnNfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIHBhcmFtZXRlcnNfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBwYXJhbWV0ZXJzX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBwYXJhbWV0ZXJzX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKHBhcmFtZXRlcnNfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gX2dldCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldC5iaW5kKCk7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YobykgeyBwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKG8pOyB9XG5mdW5jdGlvbiBwYXJhbWV0ZXJzX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIHBhcmFtZXRlcnNfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBwYXJhbWV0ZXJzX3NldFByb3RvdHlwZU9mKG8sIHApIHsgcGFyYW1ldGVyc19zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gcGFyYW1ldGVyc19zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gcGFyYW1ldGVyc190eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBwYXJhbWV0ZXJzX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBwYXJhbWV0ZXJzX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gcGFyYW1ldGVyc19jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBwYXJhbWV0ZXJzX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwYXJhbWV0ZXJzX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgcGFyYW1ldGVyc19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgcGFyYW1ldGVyc19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gcGFyYW1ldGVyc190b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBwYXJhbWV0ZXJzX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBwYXJhbWV0ZXJzX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gcGFyYW1ldGVyc190b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHBhcmFtZXRlcnNfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IHBhcmFtZXRlcnNfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cblxuXG5cblxuXG5cblxuXG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uIHBhcmFtZXRlcnNcbiAqIERlcGVuZHMgb24gJ3V0aWwnLCAndHJhbnNmb3JtYXRpb24nXG4gKi9cbnZhciBwYXJhbWV0ZXJzX1BhcmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzaW5nbGUgcGFyYW1ldGVyLlxuICAgKiBAY2xhc3MgUGFyYW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIGluIHNuYWtlX2Nhc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNob3J0TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIHBhcmFtZXRlci5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgSWYgYSB2YWx1ZSBpcyBub3QgcHJvdmlkZWQsIHRoZSBwYXJhbWV0ZXIgd2lsbCBub3QgYmUgc2VyaWFsaXplZC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3Byb2Nlc3M9VXRpbC5pZGVudGl0eSBdIC0gTWFuaXB1bGF0ZSBvcmlnVmFsdWUgd2hlbiB2YWx1ZSBpcyBjYWxsZWRcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gUGFyYW0obmFtZSwgc2hvcnROYW1lKSB7XG4gICAgdmFyIHByb2Nlc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfZGVmYXVsdC5hO1xuICAgIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFyYW0pO1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgaW4gc25ha2VfY2FzZVxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gUGFyYW0jbmFtZVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBQYXJhbSNzaG9ydE5hbWVcbiAgICAgKi9cbiAgICB0aGlzLnNob3J0TmFtZSA9IHNob3J0TmFtZTtcbiAgICAvKipcbiAgICAgKiBNYW5pcHVsYXRlIG9yaWdWYWx1ZSB3aGVuIHZhbHVlIGlzIGNhbGxlZFxuICAgICAqIEBtZW1iZXIge2Z1bmN0aW9ufSBQYXJhbSNwcm9jZXNzXG4gICAgICovXG4gICAgdGhpcy5wcm9jZXNzID0gcHJvY2VzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSAodW5wcm9jZXNzZWQpIHZhbHVlIGZvciB0aGlzIHBhcmFtZXRlclxuICAgKiBAZnVuY3Rpb24gUGFyYW0jc2V0XG4gICAqIEBwYXJhbSB7Kn0gb3JpZ1ZhbHVlIC0gdGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICogQHJldHVybiB7UGFyYW19IHNlbGYgZm9yIGNoYWluaW5nXG4gICAqL1xuICByZXR1cm4gcGFyYW1ldGVyc19jcmVhdGVDbGFzcyhQYXJhbSwgW3tcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChvcmlnVmFsdWUpIHtcbiAgICAgIHRoaXMub3JpZ1ZhbHVlID0gb3JpZ1ZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAgICogQGZ1bmN0aW9uIFBhcmFtI3NlcmlhbGl6ZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHZhciB2YWwsIHZhbGlkO1xuICAgICAgdmFsID0gdGhpcy52YWx1ZSgpO1xuICAgICAgdmFsaWQgPSBpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkodmFsKSB8fCBpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkodmFsKSB8fCBpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKSh2YWwpID8gIWlzRW1wdHkodmFsKSA6IHZhbCAhPSBudWxsO1xuICAgICAgaWYgKHRoaXMuc2hvcnROYW1lICE9IG51bGwgJiYgdmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuc2hvcnROYW1lLCBcIl9cIikuY29uY2F0KHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwcm9jZXNzZWQgdmFsdWUgb2YgdGhlIHBhcmFtZXRlclxuICAgICAqIEBmdW5jdGlvbiBQYXJhbSN2YWx1ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzcyh0aGlzLm9yaWdWYWx1ZSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwibm9ybV9jb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtX2NvbG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlLnJlcGxhY2UoL14jLywgJ3JnYjonKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYnVpbGRfYXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRfYXJyYXkoYXJnKSB7XG4gICAgICBpZiAoYXJnID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkoYXJnKSkge1xuICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFthcmddO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogQ292ZXJ0IHZhbHVlIHRvIHZpZGVvIGNvZGVjIHN0cmluZy5cbiAgICAqXG4gICAgKiBJZiB0aGUgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCxcbiAgICAqIEBwYXJhbSB7KHN0cmluZ3xPYmplY3QpfSBwYXJhbSAtIHRoZSB2aWRlbyBjb2RlYyBhcyBlaXRoZXIgYSBTdHJpbmcgb3IgYSBIYXNoXG4gICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSB2aWRlbyBjb2RlYyBzdHJpbmcgaW4gdGhlIGZvcm1hdCBjb2RlYzpwcm9maWxlOmxldmVsOmJfZnJhbWVzXG4gICAgKiBAZXhhbXBsZVxuICAgICogdmNfWyA6cHJvZmlsZSA6IFtsZXZlbCA6IFtiX2ZyYW1lc11dXVxuICAgICogb3JcbiAgICAgIHsgY29kZWM6ICdoMjY0JywgcHJvZmlsZTogJ2Jhc2ljJywgbGV2ZWw6ICczLjEnLCBiX2ZyYW1lczogZmFsc2UgfVxuICAgICogQGlnbm9yZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NfdmlkZW9fcGFyYW1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NfdmlkZW9fcGFyYW1zKHBhcmFtKSB7XG4gICAgICB2YXIgdmlkZW87XG4gICAgICBzd2l0Y2ggKHBhcmFtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgICAgIHZpZGVvID0gXCJcIjtcbiAgICAgICAgICBpZiAoJ2NvZGVjJyBpbiBwYXJhbSkge1xuICAgICAgICAgICAgdmlkZW8gPSBwYXJhbS5jb2RlYztcbiAgICAgICAgICAgIGlmICgncHJvZmlsZScgaW4gcGFyYW0pIHtcbiAgICAgICAgICAgICAgdmlkZW8gKz0gXCI6XCIgKyBwYXJhbS5wcm9maWxlO1xuICAgICAgICAgICAgICBpZiAoJ2xldmVsJyBpbiBwYXJhbSkge1xuICAgICAgICAgICAgICAgIHZpZGVvICs9IFwiOlwiICsgcGFyYW0ubGV2ZWw7XG4gICAgICAgICAgICAgICAgaWYgKCdiX2ZyYW1lcycgaW4gcGFyYW0gJiYgcGFyYW0uYl9mcmFtZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICB2aWRlbyArPSBcIjpiZnJhbWVzX25vXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2aWRlbztcbiAgICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xufSgpO1xudmFyIHBhcmFtZXRlcnNfQXJyYXlQYXJhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BhcmFtKSB7XG4gIC8qKlxuICAgKiBBIHBhcmFtZXRlciB0aGF0IHJlcHJlc2VudHMgYW4gYXJyYXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciBpbiBzbmFrZV9jYXNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIElmIGEgdmFsdWUgaXMgbm90IHByb3ZpZGVkLCB0aGUgcGFyYW1ldGVyIHdpbGwgbm90IGJlIHNlcmlhbGl6ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc2VwPScuJ10gLSBUaGUgc2VwYXJhdG9yIHRvIHVzZSB3aGVuIGpvaW5pbmcgdGhlIGFycmF5IGVsZW1lbnRzIHRvZ2V0aGVyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcm9jZXNzPVV0aWwuaWRlbnRpdHkgXSAtIE1hbmlwdWxhdGUgb3JpZ1ZhbHVlIHdoZW4gdmFsdWUgaXMgY2FsbGVkXG4gICAqIEBjbGFzcyBBcnJheVBhcmFtXG4gICAqIEBleHRlbmRzIFBhcmFtXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIEFycmF5UGFyYW0obmFtZSwgc2hvcnROYW1lKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIHZhciBzZXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICcuJztcbiAgICB2YXIgcHJvY2VzcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXJyYXlQYXJhbSk7XG4gICAgX3RoaXMgPSBwYXJhbWV0ZXJzX2NhbGxTdXBlcih0aGlzLCBBcnJheVBhcmFtLCBbbmFtZSwgc2hvcnROYW1lLCBwcm9jZXNzXSk7XG4gICAgX3RoaXMuc2VwID0gc2VwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBwYXJhbWV0ZXJzX2luaGVyaXRzKEFycmF5UGFyYW0sIF9QYXJhbSk7XG4gIHJldHVybiBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKEFycmF5UGFyYW0sIFt7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICBpZiAodGhpcy5zaG9ydE5hbWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgYXJyYXlWYWx1ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgaWYgKGlzRW1wdHkoYXJyYXlWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkoYXJyYXlWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5zaG9ydE5hbWUsIFwiX1wiKS5jb25jYXQoYXJyYXlWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZsYXQgPSBhcnJheVZhbHVlLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKSh0LnNlcmlhbGl6ZSkgPyB0LnNlcmlhbGl6ZSgpIDogdDtcbiAgICAgICAgICB9KS5qb2luKHRoaXMuc2VwKTtcbiAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5zaG9ydE5hbWUsIFwiX1wiKS5jb25jYXQoZmxhdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkodGhpcy5vcmlnVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdWYWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLnByb2Nlc3Modik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzcyh0aGlzLm9yaWdWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQob3JpZ1ZhbHVlKSB7XG4gICAgICBpZiAob3JpZ1ZhbHVlID09IG51bGwgfHwgaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKG9yaWdWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQocGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZihBcnJheVBhcmFtLnByb3RvdHlwZSksIFwic2V0XCIsIHRoaXMpLmNhbGwodGhpcywgb3JpZ1ZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBfZ2V0KHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YoQXJyYXlQYXJhbS5wcm90b3R5cGUpLCBcInNldFwiLCB0aGlzKS5jYWxsKHRoaXMsIFtvcmlnVmFsdWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbn0ocGFyYW1ldGVyc19QYXJhbSk7XG52YXIgcGFyYW1ldGVyc19UcmFuc2Zvcm1hdGlvblBhcmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGFyYW0yKSB7XG4gIC8qKlxuICAgKiBBIHBhcmFtZXRlciB0aGF0IHJlcHJlc2VudHMgYSB0cmFuc2Zvcm1hdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgaW4gc25ha2VfY2FzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3Nob3J0TmFtZT0ndCddIC0gVGhlIG5hbWUgb2YgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgcGFyYW1ldGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc2VwPScuJ10gLSBUaGUgc2VwYXJhdG9yIHRvIHVzZSB3aGVuIGpvaW5pbmcgdGhlIGFycmF5IGVsZW1lbnRzIHRvZ2V0aGVyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcm9jZXNzPVV0aWwuaWRlbnRpdHkgXSAtIE1hbmlwdWxhdGUgb3JpZ1ZhbHVlIHdoZW4gdmFsdWUgaXMgY2FsbGVkXG4gICAqIEBjbGFzcyBUcmFuc2Zvcm1hdGlvblBhcmFtXG4gICAqIEBleHRlbmRzIFBhcmFtXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uUGFyYW0obmFtZSkge1xuICAgIHZhciBfdGhpczM7XG4gICAgdmFyIHNob3J0TmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJ0XCI7XG4gICAgdmFyIHNlcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJy4nO1xuICAgIHZhciBwcm9jZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gICAgcGFyYW1ldGVyc19jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFuc2Zvcm1hdGlvblBhcmFtKTtcbiAgICBfdGhpczMgPSBwYXJhbWV0ZXJzX2NhbGxTdXBlcih0aGlzLCBUcmFuc2Zvcm1hdGlvblBhcmFtLCBbbmFtZSwgc2hvcnROYW1lLCBwcm9jZXNzXSk7XG4gICAgX3RoaXMzLnNlcCA9IHNlcDtcbiAgICByZXR1cm4gX3RoaXMzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHN0cmluZyByZXByZXNlbnRhdGlvbnMgb2YgdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBlaXRoZXIgdGhlIHRyYW5zZm9ybWF0aW9uIGFzIGEgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBzdHJpbmcgcmVwcmVzZW50YXRpb25zLlxuICAgKi9cbiAgcGFyYW1ldGVyc19pbmhlcml0cyhUcmFuc2Zvcm1hdGlvblBhcmFtLCBfUGFyYW0yKTtcbiAgcmV0dXJuIHBhcmFtZXRlcnNfY3JlYXRlQ2xhc3MoVHJhbnNmb3JtYXRpb25QYXJhbSwgW3tcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgdmFyIHZhbCA9IHRoaXMudmFsdWUoKTtcbiAgICAgIGlmIChpc0VtcHR5KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgLy8gdmFsIGlzIGFuIGFycmF5IG9mIHN0cmluZ3Mgc28gam9pbiB0aGVtXG4gICAgICBpZiAoYmFzZXV0aWxfYWxsU3RyaW5ncyh2YWwpKSB7XG4gICAgICAgIHZhciBqb2luZWQgPSB2YWwuam9pbih0aGlzLnNlcCk7IC8vIGNyZWF0ZXMgdDEudDIudDMgaW4gY2FzZSBtdWx0aXBsZSBuYW1lZCB0cmFuc2Zvcm1hdGlvbnMgd2VyZSBjb25maWd1cmVkXG4gICAgICAgIGlmICghaXNFbXB0eShqb2luZWQpKSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSBvcHRpb25zLnRyYW5zZm9ybWF0aW9uIHdhcyBub3Qgc2V0IHdpdGggYW4gZW1wdHkgc3RyaW5nICh2YWwgIT0gWycnXSk7XG4gICAgICAgICAgcmVzdWx0ID0gXCJcIi5jb25jYXQodGhpcy5zaG9ydE5hbWUsIFwiX1wiKS5jb25jYXQoam9pbmVkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29udmVydCB2YWwgdG8gYW4gYXJyYXkgb2Ygc3RyaW5nc1xuICAgICAgICByZXN1bHQgPSB2YWwubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKHQpICYmICFpc0VtcHR5KHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoX3RoaXM0LnNob3J0TmFtZSwgXCJfXCIpLmNvbmNhdCh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKSh0LnNlcmlhbGl6ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0LnNlcmlhbGl6ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCgpKHQpICYmICFpc0VtcHR5KHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHNyY190cmFuc2Zvcm1hdGlvbih0KS5zZXJpYWxpemUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChvcmlnVmFsdWUxKSB7XG4gICAgICB0aGlzLm9yaWdWYWx1ZSA9IG9yaWdWYWx1ZTE7XG4gICAgICBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHRoaXMub3JpZ1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gX2dldChwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKFRyYW5zZm9ybWF0aW9uUGFyYW0ucHJvdG90eXBlKSwgXCJzZXRcIiwgdGhpcykuY2FsbCh0aGlzLCB0aGlzLm9yaWdWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX2dldChwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKFRyYW5zZm9ybWF0aW9uUGFyYW0ucHJvdG90eXBlKSwgXCJzZXRcIiwgdGhpcykuY2FsbCh0aGlzLCBbdGhpcy5vcmlnVmFsdWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbn0ocGFyYW1ldGVyc19QYXJhbSk7XG52YXIgbnVtYmVyX3BhdHRlcm4gPSBcIihbMC05XSopXFxcXC4oWzAtOV0rKXwoWzAtOV0rKVwiO1xudmFyIG9mZnNldF9hbnlfcGF0dGVybiA9IFwiKFwiICsgbnVtYmVyX3BhdHRlcm4gKyBcIikoWyVwUF0pP1wiO1xudmFyIHBhcmFtZXRlcnNfUmFuZ2VQYXJhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BhcmFtMykge1xuICAvKipcbiAgICogQSBwYXJhbWV0ZXIgdGhhdCByZXByZXNlbnRzIGEgcmFuZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIGluIHNuYWtlX2Nhc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNob3J0TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIHBhcmFtZXRlclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBJZiBhIHZhbHVlIGlzIG5vdCBwcm92aWRlZCwgdGhlIHBhcmFtZXRlciB3aWxsIG5vdCBiZSBzZXJpYWxpemVkLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcHJvY2Vzcz1ub3JtX3JhbmdlX3ZhbHVlIF0gLSBNYW5pcHVsYXRlIG9yaWdWYWx1ZSB3aGVuIHZhbHVlIGlzIGNhbGxlZFxuICAgKiBAY2xhc3MgUmFuZ2VQYXJhbVxuICAgKiBAZXh0ZW5kcyBQYXJhbVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBSYW5nZVBhcmFtKG5hbWUsIHNob3J0TmFtZSkge1xuICAgIHZhciBwcm9jZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBSYW5nZVBhcmFtLm5vcm1fcmFuZ2VfdmFsdWU7XG4gICAgcGFyYW1ldGVyc19jbGFzc0NhbGxDaGVjayh0aGlzLCBSYW5nZVBhcmFtKTtcbiAgICByZXR1cm4gcGFyYW1ldGVyc19jYWxsU3VwZXIodGhpcywgUmFuZ2VQYXJhbSwgW25hbWUsIHNob3J0TmFtZSwgcHJvY2Vzc10pO1xuICB9XG4gIHBhcmFtZXRlcnNfaW5oZXJpdHMoUmFuZ2VQYXJhbSwgX1BhcmFtMyk7XG4gIHJldHVybiBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKFJhbmdlUGFyYW0sIG51bGwsIFt7XG4gICAga2V5OiBcIm5vcm1fcmFuZ2VfdmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybV9yYW5nZV92YWx1ZSh2YWx1ZSkge1xuICAgICAgdmFyIG9mZnNldCA9IFN0cmluZyh2YWx1ZSkubWF0Y2gobmV3IFJlZ0V4cCgnXicgKyBvZmZzZXRfYW55X3BhdHRlcm4gKyAnJCcpKTtcbiAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgdmFyIG1vZGlmaWVyID0gb2Zmc2V0WzVdICE9IG51bGwgPyAncCcgOiAnJztcbiAgICAgICAgdmFsdWUgPSAob2Zmc2V0WzFdIHx8IG9mZnNldFs0XSkgKyBtb2RpZmllcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleHByZXNzaW9uLm5vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgfVxuICB9XSk7XG59KHBhcmFtZXRlcnNfUGFyYW0pO1xudmFyIHBhcmFtZXRlcnNfUmF3UGFyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QYXJhbTQpIHtcbiAgZnVuY3Rpb24gUmF3UGFyYW0obmFtZSwgc2hvcnROYW1lKSB7XG4gICAgdmFyIHByb2Nlc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfZGVmYXVsdC5hO1xuICAgIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmF3UGFyYW0pO1xuICAgIHJldHVybiBwYXJhbWV0ZXJzX2NhbGxTdXBlcih0aGlzLCBSYXdQYXJhbSwgW25hbWUsIHNob3J0TmFtZSwgcHJvY2Vzc10pO1xuICB9XG4gIHBhcmFtZXRlcnNfaW5oZXJpdHMoUmF3UGFyYW0sIF9QYXJhbTQpO1xuICByZXR1cm4gcGFyYW1ldGVyc19jcmVhdGVDbGFzcyhSYXdQYXJhbSwgW3tcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlKCk7XG4gICAgfVxuICB9XSk7XG59KHBhcmFtZXRlcnNfUGFyYW0pO1xudmFyIHBhcmFtZXRlcnNfTGF5ZXJQYXJhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BhcmFtNSkge1xuICBmdW5jdGlvbiBMYXllclBhcmFtKCkge1xuICAgIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGF5ZXJQYXJhbSk7XG4gICAgcmV0dXJuIHBhcmFtZXRlcnNfY2FsbFN1cGVyKHRoaXMsIExheWVyUGFyYW0sIGFyZ3VtZW50cyk7XG4gIH1cbiAgcGFyYW1ldGVyc19pbmhlcml0cyhMYXllclBhcmFtLCBfUGFyYW01KTtcbiAgcmV0dXJuIHBhcmFtZXRlcnNfY3JlYXRlQ2xhc3MoTGF5ZXJQYXJhbSwgW3tcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICB2YWx1ZTpcbiAgICAvLyBQYXJzZSBsYXllciBvcHRpb25zXG4gICAgLy8gQHJldHVybiBbc3RyaW5nXSBsYXllciB0cmFuc2Zvcm1hdGlvbiBzdHJpbmdcbiAgICAvLyBAcHJpdmF0ZVxuICAgIGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgaWYgKHRoaXMub3JpZ1ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmICh0aGlzLm9yaWdWYWx1ZSBpbnN0YW5jZW9mIGxheWVyX2xheWVyKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMub3JpZ1ZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkodGhpcy5vcmlnVmFsdWUpKSB7XG4gICAgICAgIHZhciBsYXllck9wdGlvbnMgPSB3aXRoQ2FtZWxDYXNlS2V5cyh0aGlzLm9yaWdWYWx1ZSk7XG4gICAgICAgIGlmIChsYXllck9wdGlvbnMucmVzb3VyY2VUeXBlID09PSBcInRleHRcIiB8fCBsYXllck9wdGlvbnMudGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0ID0gbmV3IHRleHRsYXllcihsYXllck9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGxheWVyT3B0aW9ucy5yZXNvdXJjZVR5cGUgPT09IFwic3VidGl0bGVzXCIpIHtcbiAgICAgICAgICByZXN1bHQgPSBuZXcgc3VidGl0bGVzbGF5ZXIobGF5ZXJPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXllck9wdGlvbnMucmVzb3VyY2VUeXBlID09PSBcImZldGNoXCIgfHwgbGF5ZXJPcHRpb25zLnVybCAhPSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0ID0gbmV3IGZldGNobGF5ZXIobGF5ZXJPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBuZXcgbGF5ZXJfbGF5ZXIobGF5ZXJPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKSh0aGlzLm9yaWdWYWx1ZSkpIHtcbiAgICAgICAgaWYgKC9eZmV0Y2g6LisvLnRlc3QodGhpcy5vcmlnVmFsdWUpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gbmV3IGZldGNobGF5ZXIodGhpcy5vcmlnVmFsdWUuc3Vic3RyKDYpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSB0aGlzLm9yaWdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwidGV4dFN0eWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHRTdHlsZShsYXllcikge1xuICAgICAgcmV0dXJuIG5ldyB0ZXh0bGF5ZXIobGF5ZXIpLnRleHRTdHlsZUlkZW50aWZpZXIoKTtcbiAgICB9XG4gIH1dKTtcbn0ocGFyYW1ldGVyc19QYXJhbSk7XG52YXIgcGFyYW1ldGVyc19FeHByZXNzaW9uUGFyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QYXJhbTYpIHtcbiAgZnVuY3Rpb24gRXhwcmVzc2lvblBhcmFtKCkge1xuICAgIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXhwcmVzc2lvblBhcmFtKTtcbiAgICByZXR1cm4gcGFyYW1ldGVyc19jYWxsU3VwZXIodGhpcywgRXhwcmVzc2lvblBhcmFtLCBhcmd1bWVudHMpO1xuICB9XG4gIHBhcmFtZXRlcnNfaW5oZXJpdHMoRXhwcmVzc2lvblBhcmFtLCBfUGFyYW02KTtcbiAgcmV0dXJuIHBhcmFtZXRlcnNfY3JlYXRlQ2xhc3MoRXhwcmVzc2lvblBhcmFtLCBbe1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgcmV0dXJuIGV4cHJlc3Npb24ubm9ybWFsaXplKF9nZXQocGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZihFeHByZXNzaW9uUGFyYW0ucHJvdG90eXBlKSwgXCJzZXJpYWxpemVcIiwgdGhpcykuY2FsbCh0aGlzKSk7XG4gICAgfVxuICB9XSk7XG59KHBhcmFtZXRlcnNfUGFyYW0pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90cmFuc2Zvcm1hdGlvbi5qc1xuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSB0cmFuc2Zvcm1hdGlvbl9nZXRQcm90b3R5cGVPZihvKSwgdHJhbnNmb3JtYXRpb25fcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCB0cmFuc2Zvcm1hdGlvbl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIHRyYW5zZm9ybWF0aW9uX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKHRyYW5zZm9ybWF0aW9uX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiB0cmFuc2Zvcm1hdGlvbl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuICh0cmFuc2Zvcm1hdGlvbl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9nZXRQcm90b3R5cGVPZihvKSB7IHRyYW5zZm9ybWF0aW9uX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiB0cmFuc2Zvcm1hdGlvbl9nZXRQcm90b3R5cGVPZihvKTsgfVxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25faW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgdHJhbnNmb3JtYXRpb25fc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9zZXRQcm90b3R5cGVPZihvLCBwKSB7IHRyYW5zZm9ybWF0aW9uX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiB0cmFuc2Zvcm1hdGlvbl9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIHRyYW5zZm9ybWF0aW9uX2FycmF5V2l0aEhvbGVzKGFycikgfHwgdHJhbnNmb3JtYXRpb25faXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB0cmFuc2Zvcm1hdGlvbl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IHRyYW5zZm9ybWF0aW9uX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gdHJhbnNmb3JtYXRpb25fYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIHRyYW5zZm9ybWF0aW9uX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25faXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiB0cmFuc2Zvcm1hdGlvbl90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgdHJhbnNmb3JtYXRpb25fdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgdHJhbnNmb3JtYXRpb25fdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgdHJhbnNmb3JtYXRpb25fZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIHRyYW5zZm9ybWF0aW9uX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSB0cmFuc2Zvcm1hdGlvbl90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHJhbnNmb3JtYXRpb25fdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHRyYW5zZm9ybWF0aW9uX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSB0cmFuc2Zvcm1hdGlvbl90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuXG5cblxuXG5cblxuXG4vKipcbiAqIEFzc2lnbiBrZXksIHZhbHVlIHRvIHRhcmdldCwgd2hlbiB2YWx1ZSBpcyBub3QgbnVsbC48YnI+XG4gKiAgIFRoaXMgZnVuY3Rpb24gbXV0YXRlcyB0aGUgdGFyZ2V0IVxuICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCB0aGUgb2JqZWN0IHRvIGFzc2lnbiB0aGUgdmFsdWVzIHRvXG4gKiBAcGFyYW0ge29iamVjdH0gc291cmNlcyBvbmUgb3IgbW9yZSBvYmplY3RzIHRvIGdldCB2YWx1ZXMgZnJvbVxuICogQHJldHVybnMge29iamVjdH0gdGhlIHRhcmdldCBhZnRlciB0aGUgYXNzaWdubWVudFxuICovXG5mdW5jdGlvbiBhc3NpZ25Ob3ROdWxsKHRhcmdldCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc291cmNlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKHNvdXJjZVtrZXldICE9IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtYXRpb25CYXNlXG4gKiBEZXBlbmRzIG9uICdjb25maWd1cmF0aW9uJywgJ3BhcmFtZXRlcnMnLCd1dGlsJ1xuICogQGludGVybmFsXG4gKi9cbnZhciB0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbkJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogVGhlIGJhc2UgY2xhc3MgZm9yIHRyYW5zZm9ybWF0aW9ucy5cbiAgICogTWVtYmVycyBvZiB0aGlzIGNsYXNzIGFyZSBkb2N1bWVudGVkIGFzIGJlbG9uZ2luZyB0byB0aGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBjbGFzcyBmb3IgY29udmVuaWVuY2UuXG4gICAqIEBjbGFzcyBUcmFuc2Zvcm1hdGlvbkJhc2VcbiAgICovXG4gIGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uQmFzZShvcHRpb25zKSB7XG4gICAgdHJhbnNmb3JtYXRpb25fY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNmb3JtYXRpb25CYXNlKTtcbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICB2YXIgcGFyZW50LCB0cmFucztcbiAgICBwYXJlbnQgPSB2b2lkIDA7XG4gICAgdHJhbnMgPSB7fTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gb3B0aW9ucyBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYW4gaWRlbnRpY2FsIFRyYW5zZm9ybWF0aW9uXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI3RvT3B0aW9uc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcgdGhpcyB0cmFuc2Zvcm1hdGlvblxuICAgICAqL1xuICAgIHRoaXMudG9PcHRpb25zID0gZnVuY3Rpb24gKHdpdGhDaGFpbikge1xuICAgICAgdmFyIG9wdCA9IHt9O1xuICAgICAgaWYgKHdpdGhDaGFpbiA9PSBudWxsKSB7XG4gICAgICAgIHdpdGhDaGFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBPYmplY3Qua2V5cyh0cmFucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBvcHRba2V5XSA9IHRyYW5zW2tleV0ub3JpZ1ZhbHVlO1xuICAgICAgfSk7XG4gICAgICBhc3NpZ25Ob3ROdWxsKG9wdCwgdGhpcy5vdGhlck9wdGlvbnMpO1xuICAgICAgaWYgKHdpdGhDaGFpbiAmJiAhaXNFbXB0eSh0aGlzLmNoYWluZWQpKSB7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5jaGFpbmVkLm1hcChmdW5jdGlvbiAodHIpIHtcbiAgICAgICAgICByZXR1cm4gdHIudG9PcHRpb25zKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBsaXN0LnB1c2gob3B0KTtcbiAgICAgICAgb3B0ID0ge307XG4gICAgICAgIGFzc2lnbk5vdE51bGwob3B0LCB0aGlzLm90aGVyT3B0aW9ucyk7XG4gICAgICAgIG9wdC50cmFuc2Zvcm1hdGlvbiA9IGxpc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGEgcGFyZW50IGZvciB0aGlzIG9iamVjdCBmb3IgY2hhaW5pbmcgcHVycG9zZXMuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jc2V0UGFyZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIHRoZSBwYXJlbnQgdG8gYmUgYXNzaWduZWQgdG9cbiAgICAgKiBAcmV0dXJucyB7VHJhbnNmb3JtYXRpb259IFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmcgcHVycG9zZXMuXG4gICAgICovXG4gICAgdGhpcy5zZXRQYXJlbnQgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBwYXJlbnQgPSBvYmplY3Q7XG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5mcm9tT3B0aW9ucyh0eXBlb2Ygb2JqZWN0LnRvT3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiID8gb2JqZWN0LnRvT3B0aW9ucygpIDogdm9pZCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFyZW50IG9mIHRoaXMgb2JqZWN0IGluIHRoZSBjaGFpblxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNnZXRQYXJlbnRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBwYXJlbnQgb2YgdGhpcyBvYmplY3QgaWYgdGhlcmUgaXMgYW55XG4gICAgICovXG4gICAgdGhpcy5nZXRQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH07XG5cbiAgICAvLyBIZWxwZXIgbWV0aG9kcyB0byBjcmVhdGUgcGFyYW1ldGVyIG1ldGhvZHNcbiAgICAvLyBUaGVzZSBtZXRob2RzIGFyZSBkZWZpbmVkIGhlcmUgYmVjYXVzZSB0aGV5IGFjY2VzcyBgdHJhbnNgIHdoaWNoIGlzXG4gICAgLy8gYSBwcml2YXRlIG1lbWJlciBvZiBgVHJhbnNmb3JtYXRpb25CYXNlYFxuXG4gICAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgICB0aGlzLnBhcmFtID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBhYmJyLCBkZWZhdWx0VmFsdWUsIHByb2Nlc3MpIHtcbiAgICAgIGlmIChwcm9jZXNzID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShkZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgICAgcHJvY2VzcyA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzID0gaWRlbnRpdHlfcm9vdF9pZGVudGl0eV9kZWZhdWx0LmE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyYW5zW25hbWVdID0gbmV3IHBhcmFtZXRlcnNfUGFyYW0obmFtZSwgYWJiciwgcHJvY2Vzcykuc2V0KHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgICB0aGlzLnJhd1BhcmFtID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBhYmJyLCBkZWZhdWx0VmFsdWUsIHByb2Nlc3MpIHtcbiAgICAgIHByb2Nlc3MgPSBsYXN0QXJnQ2FsbGJhY2soYXJndW1lbnRzKTtcbiAgICAgIHRyYW5zW25hbWVdID0gbmV3IHBhcmFtZXRlcnNfUmF3UGFyYW0obmFtZSwgYWJiciwgcHJvY2Vzcykuc2V0KHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIEBwcm90ZWN0ZWQgKi9cbiAgICB0aGlzLnJhbmdlUGFyYW0gPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIGFiYnIsIGRlZmF1bHRWYWx1ZSwgcHJvY2Vzcykge1xuICAgICAgcHJvY2VzcyA9IGxhc3RBcmdDYWxsYmFjayhhcmd1bWVudHMpO1xuICAgICAgdHJhbnNbbmFtZV0gPSBuZXcgcGFyYW1ldGVyc19SYW5nZVBhcmFtKG5hbWUsIGFiYnIsIHByb2Nlc3MpLnNldCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBAcHJvdGVjdGVkICovXG4gICAgdGhpcy5hcnJheVBhcmFtID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBhYmJyKSB7XG4gICAgICB2YXIgc2VwID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBcIjpcIjtcbiAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IFtdO1xuICAgICAgdmFyIHByb2Nlc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MgPSBsYXN0QXJnQ2FsbGJhY2soYXJndW1lbnRzKTtcbiAgICAgIHRyYW5zW25hbWVdID0gbmV3IHBhcmFtZXRlcnNfQXJyYXlQYXJhbShuYW1lLCBhYmJyLCBzZXAsIHByb2Nlc3MpLnNldCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBAcHJvdGVjdGVkICovXG4gICAgdGhpcy50cmFuc2Zvcm1hdGlvblBhcmFtID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBhYmJyKSB7XG4gICAgICB2YXIgc2VwID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBcIi5cIjtcbiAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBwcm9jZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzID0gbGFzdEFyZ0NhbGxiYWNrKGFyZ3VtZW50cyk7XG4gICAgICB0cmFuc1tuYW1lXSA9IG5ldyBwYXJhbWV0ZXJzX1RyYW5zZm9ybWF0aW9uUGFyYW0obmFtZSwgYWJiciwgc2VwLCBwcm9jZXNzKS5zZXQodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB0aGlzLmxheWVyUGFyYW0gPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIGFiYnIpIHtcbiAgICAgIHRyYW5zW25hbWVdID0gbmV3IHBhcmFtZXRlcnNfTGF5ZXJQYXJhbShuYW1lLCBhYmJyKS5zZXQodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vIEVuZCBIZWxwZXIgbWV0aG9kc1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI2dldFZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyXG4gICAgICogQHJldHVybiB7Kn0gdGhlIHByb2Nlc3NlZCB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICAgKiBAZGVzY3JpcHRpb24gVXNlIHtAbGluayBnZXR9Lm9yaWdWYWx1ZSBmb3IgdGhlIHZhbHVlIG9yaWdpbmFsbHkgcHJvdmlkZWQgZm9yIHRoZSBwYXJhbWV0ZXJcbiAgICAgKi9cbiAgICB0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRyYW5zW25hbWVdICYmIHRyYW5zW25hbWVdLnZhbHVlKCk7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogdGhpcy5vdGhlck9wdGlvbnNbbmFtZV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBhcmFtZXRlciBvYmplY3QgZm9yIHRoZSBnaXZlbiBwYXJhbWV0ZXIgbmFtZVxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNnZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgdHJhbnNmb3JtYXRpb24gcGFyYW1ldGVyXG4gICAgICogQHJldHVybnMge1BhcmFtfSB0aGUgcGFyYW0gb2JqZWN0IGZvciB0aGUgZ2l2ZW4gbmFtZSwgb3IgdW5kZWZpbmVkXG4gICAgICovXG4gICAgdGhpcy5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIHRyYW5zW25hbWVdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgdHJhbnNmb3JtYXRpb24gb3B0aW9uIGZyb20gdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNyZW1vdmVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBvcHRpb24gdG8gcmVtb3ZlXG4gICAgICogQHJldHVybiB7Kn0gUmV0dXJucyB0aGUgb3B0aW9uIHRoYXQgd2FzIHJlbW92ZWQgb3IgbnVsbCBpZiBubyBvcHRpb24gYnkgdGhhdCBuYW1lIHdhcyBmb3VuZC4gVGhlIHR5cGUgb2YgdGhlXG4gICAgICogICAgICAgICAgICAgIHJldHVybmVkIHZhbHVlIGRlcGVuZHMgb24gdGhlIHZhbHVlLlxuICAgICAqL1xuICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB0ZW1wO1xuICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICBjYXNlIHRyYW5zW25hbWVdID09IG51bGw6XG4gICAgICAgICAgdGVtcCA9IHRyYW5zW25hbWVdO1xuICAgICAgICAgIGRlbGV0ZSB0cmFuc1tuYW1lXTtcbiAgICAgICAgICByZXR1cm4gdGVtcC5vcmlnVmFsdWU7XG4gICAgICAgIGNhc2UgdGhpcy5vdGhlck9wdGlvbnNbbmFtZV0gPT0gbnVsbDpcbiAgICAgICAgICB0ZW1wID0gdGhpcy5vdGhlck9wdGlvbnNbbmFtZV07XG4gICAgICAgICAgZGVsZXRlIHRoaXMub3RoZXJPcHRpb25zW25hbWVdO1xuICAgICAgICAgIHJldHVybiB0ZW1wO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIGFsbCB0aGUga2V5cyAob3B0aW9uIG5hbWVzKSBpbiB0aGUgdHJhbnNmb3JtYXRpb24uXG4gICAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gdGhlIGtleXMgaW4gc25ha2VDYXNlIGZvcm1hdFxuICAgICAqL1xuICAgIHRoaXMua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBrZXk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGtleSBpbiB0cmFucykge1xuICAgICAgICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGtleS5tYXRjaChWQVJfTkFNRV9SRSkgPyBrZXkgOiBzbmFrZUNhc2Uoa2V5KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfSgpLnNvcnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwbGFpbiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYW5zZm9ybWF0aW9uLiBWYWx1ZXMgYXJlIHByb2Nlc3NlZC5cbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jdG9QbGFpbk9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIHRyYW5zZm9ybWF0aW9uIG9wdGlvbnMgYXMgcGxhaW4gb2JqZWN0XG4gICAgICovXG4gICAgdGhpcy50b1BsYWluT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhhc2gsIGtleSwgbGlzdDtcbiAgICAgIGhhc2ggPSB7fTtcbiAgICAgIGZvciAoa2V5IGluIHRyYW5zKSB7XG4gICAgICAgIGhhc2hba2V5XSA9IHRyYW5zW2tleV0udmFsdWUoKTtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKShoYXNoW2tleV0pKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQoKShoYXNoW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzRW1wdHkodGhpcy5jaGFpbmVkKSkge1xuICAgICAgICBsaXN0ID0gdGhpcy5jaGFpbmVkLm1hcChmdW5jdGlvbiAodHIpIHtcbiAgICAgICAgICByZXR1cm4gdHIudG9QbGFpbk9iamVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGlzdC5wdXNoKGhhc2gpO1xuICAgICAgICBoYXNoID0ge1xuICAgICAgICAgIHRyYW5zZm9ybWF0aW9uOiBsaXN0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXBsZXRlIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIGFuZCBjaGFpbiB0byBhIG5ldyBvbmUuXG4gICAgICogSW4gdGhlIFVSTCwgdHJhbnNmb3JtYXRpb25zIGFyZSBjaGFpbmVkIHRvZ2V0aGVyIGJ5IHNsYXNoZXMuXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI2NoYWluXG4gICAgICogQHJldHVybiB7VHJhbnNmb3JtYXRpb259IFJldHVybnMgdGhpcyB0cmFuc2Zvcm1hdGlvbiBmb3IgY2hhaW5pbmdcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciB0ciA9IGNsb3VkaW5hcnkuVHJhbnNmb3JtYXRpb24ubmV3KCk7XG4gICAgICogdHIud2lkdGgoMTApLmNyb3AoJ2ZpdCcpLmNoYWluKCkuYW5nbGUoMTUpLnNlcmlhbGl6ZSgpXG4gICAgICogLy8gcHJvZHVjZXMgXCJjX2ZpdCx3XzEwL2FfMTVcIlxuICAgICAqL1xuICAgIHRoaXMuY2hhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZXMsIHRyO1xuICAgICAgbmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0cmFucyk7XG4gICAgICBpZiAobmFtZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHRyID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy50b09wdGlvbnMoZmFsc2UpKTtcbiAgICAgICAgdGhpcy5yZXNldFRyYW5zZm9ybWF0aW9ucygpO1xuICAgICAgICB0aGlzLmNoYWluZWQucHVzaCh0cik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHRoaXMucmVzZXRUcmFuc2Zvcm1hdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0cmFucyA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB0aGlzLm90aGVyT3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuY2hhaW5lZCA9IFtdO1xuICAgIHRoaXMuZnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgdGhlIHByb3ZpZGVkIG9wdGlvbnMgd2l0aCBvd24ncyBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0ga2V5LXZhbHVlIGxpc3Qgb2Ygb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7VHJhbnNmb3JtYXRpb259IFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICovXG4gIHJldHVybiB0cmFuc2Zvcm1hdGlvbl9jcmVhdGVDbGFzcyhUcmFuc2Zvcm1hdGlvbkJhc2UsIFt7XG4gICAga2V5OiBcImZyb21PcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21PcHRpb25zKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBUcmFuc2Zvcm1hdGlvbkJhc2UpIHtcbiAgICAgICAgdGhpcy5mcm9tVHJhbnNmb3JtYXRpb24ob3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkob3B0aW9ucykgfHwgaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKG9wdGlvbnMpKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uOiBvcHRpb25zXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQoKShvcHRpb25zLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBUcmFuc2Zvcm1hdGlvbkJhc2UgfHwgdmFsdWUgaW5zdGFuY2VvZiBMYXllcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB2YWx1ZS5jbG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEhhbmRsaW5nIG9mIFwiaWZcIiBzdGF0ZW1lbnRzIHByZWNlZGVzIG90aGVyIG9wdGlvbnMgYXMgaXQgY3JlYXRlcyBhIGNoYWluZWQgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgaWYgKG9wdGlvbnNbXCJpZlwiXSkge1xuICAgICAgICAgIHRoaXMuc2V0KFwiaWZcIiwgb3B0aW9uc1tcImlmXCJdKTtcbiAgICAgICAgICBkZWxldGUgb3B0aW9uc1tcImlmXCJdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIG9wdCA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICBpZiAob3B0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChrZXkubWF0Y2goVkFSX05BTUVfUkUpKSB7XG4gICAgICAgICAgICAgIGlmIChrZXkgIT09ICckYXR0cicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldCgndmFyaWFibGUnLCBrZXksIG9wdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgb3B0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcm9tVHJhbnNmb3JtYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVRyYW5zZm9ybWF0aW9uKG90aGVyKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgVHJhbnNmb3JtYXRpb25CYXNlKSB7XG4gICAgICAgIG90aGVyLmtleXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0KGtleSwgb3RoZXIuZ2V0KGtleSkub3JpZ1ZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBwYXJhbWV0ZXIuXG4gICAgICogVGhlIHBhcmFtZXRlciBuYW1lIGBrZXlgIGlzIGNvbnZlcnRlZCB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSB0aGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZXMgLSB0aGUgdmFsdWUgb2YgdGhlIHBhcmFtZXRlclxuICAgICAqIEByZXR1cm5zIHtUcmFuc2Zvcm1hdGlvbn0gUmV0dXJucyB0aGlzIGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoa2V5KSB7XG4gICAgICB2YXIgY2FtZWxLZXk7XG4gICAgICBjYW1lbEtleSA9IGNhbWVsQ2FzZShrZXkpO1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICB2YWx1ZXNbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0KCkodHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24ubWV0aG9kcywgY2FtZWxLZXkpKSB7XG4gICAgICAgIHRoaXNbY2FtZWxLZXldLmFwcGx5KHRoaXMsIHZhbHVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm90aGVyT3B0aW9uc1trZXldID0gdmFsdWVzWzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc0xheWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0xheWVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoXCJvdmVybGF5XCIpIHx8IHRoaXMuZ2V0VmFsdWUoXCJ1bmRlcmxheVwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHJhbnNmb3JtYXRpb24uXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI3NlcmlhbGl6ZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gUmV0dXJucyB0aGUgdHJhbnNmb3JtYXRpb24gYXMgYSBzdHJpbmdcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgdmFyIGlmUGFyYW0sIGosIGxlbiwgcGFyYW1MaXN0LCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHJlZjQsIHJlc3VsdEFycmF5LCB0LCB0cmFuc2Zvcm1hdGlvbkxpc3QsIHRyYW5zZm9ybWF0aW9uU3RyaW5nLCB0cmFuc2Zvcm1hdGlvbnMsIHZhbHVlLCB2YXJpYWJsZXMsIHZhcnM7XG4gICAgICByZXN1bHRBcnJheSA9IHRoaXMuY2hhaW5lZC5tYXAoZnVuY3Rpb24gKHRyKSB7XG4gICAgICAgIHJldHVybiB0ci5zZXJpYWxpemUoKTtcbiAgICAgIH0pO1xuICAgICAgcGFyYW1MaXN0ID0gdGhpcy5rZXlzKCk7XG4gICAgICB0cmFuc2Zvcm1hdGlvbnMgPSAocmVmID0gdGhpcy5nZXQoXCJ0cmFuc2Zvcm1hdGlvblwiKSkgIT0gbnVsbCA/IHJlZi5zZXJpYWxpemUoKSA6IHZvaWQgMDtcbiAgICAgIGlmUGFyYW0gPSAocmVmMSA9IHRoaXMuZ2V0KFwiaWZcIikpICE9IG51bGwgPyByZWYxLnNlcmlhbGl6ZSgpIDogdm9pZCAwO1xuICAgICAgdmFyaWFibGVzID0gcHJvY2Vzc1ZhcigocmVmMiA9IHRoaXMuZ2V0KFwidmFyaWFibGVzXCIpKSAhPSBudWxsID8gcmVmMi52YWx1ZSgpIDogdm9pZCAwKTtcbiAgICAgIHBhcmFtTGlzdCA9IGRpZmZlcmVuY2Vfcm9vdF9kaWZmZXJlbmNlX2RlZmF1bHQoKShwYXJhbUxpc3QsIFtcInRyYW5zZm9ybWF0aW9uXCIsIFwiaWZcIiwgXCJ2YXJpYWJsZXNcIl0pO1xuICAgICAgdmFycyA9IFtdO1xuICAgICAgdHJhbnNmb3JtYXRpb25MaXN0ID0gW107XG4gICAgICBmb3IgKGogPSAwLCBsZW4gPSBwYXJhbUxpc3QubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgdCA9IHBhcmFtTGlzdFtqXTtcbiAgICAgICAgaWYgKHQubWF0Y2goVkFSX05BTUVfUkUpKSB7XG4gICAgICAgICAgdmFycy5wdXNoKHQgKyBcIl9cIiArIGV4cHJlc3Npb24ubm9ybWFsaXplKChyZWYzID0gdGhpcy5nZXQodCkpICE9IG51bGwgPyByZWYzLnZhbHVlKCkgOiB2b2lkIDApKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmFuc2Zvcm1hdGlvbkxpc3QucHVzaCgocmVmNCA9IHRoaXMuZ2V0KHQpKSAhPSBudWxsID8gcmVmNC5zZXJpYWxpemUoKSA6IHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgY2FzZSAhaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkodHJhbnNmb3JtYXRpb25zKTpcbiAgICAgICAgICB0cmFuc2Zvcm1hdGlvbkxpc3QucHVzaCh0cmFuc2Zvcm1hdGlvbnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICFpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkodHJhbnNmb3JtYXRpb25zKTpcbiAgICAgICAgICByZXN1bHRBcnJheSA9IHJlc3VsdEFycmF5LmNvbmNhdCh0cmFuc2Zvcm1hdGlvbnMpO1xuICAgICAgfVxuICAgICAgdHJhbnNmb3JtYXRpb25MaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaywgbGVuMSwgcmVzdWx0cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGsgPSAwLCBsZW4xID0gdHJhbnNmb3JtYXRpb25MaXN0Lmxlbmd0aDsgayA8IGxlbjE7IGsrKykge1xuICAgICAgICAgIHZhbHVlID0gdHJhbnNmb3JtYXRpb25MaXN0W2tdO1xuICAgICAgICAgIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkodmFsdWUpICYmICFpc0VtcHR5KHZhbHVlKSB8fCAhaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHZhbHVlKSAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9KCk7XG4gICAgICB0cmFuc2Zvcm1hdGlvbkxpc3QgPSB2YXJzLnNvcnQoKS5jb25jYXQodmFyaWFibGVzKS5jb25jYXQodHJhbnNmb3JtYXRpb25MaXN0LnNvcnQoKSk7XG4gICAgICBpZiAoaWZQYXJhbSA9PT0gXCJpZl9lbmRcIikge1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbkxpc3QucHVzaChpZlBhcmFtKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW1wdHkoaWZQYXJhbSkpIHtcbiAgICAgICAgdHJhbnNmb3JtYXRpb25MaXN0LnVuc2hpZnQoaWZQYXJhbSk7XG4gICAgICB9XG4gICAgICB0cmFuc2Zvcm1hdGlvblN0cmluZyA9IGNvbXBhY3Rfcm9vdF9jb21wYWN0X2RlZmF1bHQoKSh0cmFuc2Zvcm1hdGlvbkxpc3QpLmpvaW4odGhpcy5wYXJhbV9zZXBhcmF0b3IpO1xuICAgICAgaWYgKCFpc0VtcHR5KHRyYW5zZm9ybWF0aW9uU3RyaW5nKSkge1xuICAgICAgICByZXN1bHRBcnJheS5wdXNoKHRyYW5zZm9ybWF0aW9uU3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0KCkocmVzdWx0QXJyYXkpLmpvaW4odGhpcy50cmFuc19zZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgYSBsaXN0IG9mIGFsbCB0aGUgdmFsaWQgdHJhbnNmb3JtYXRpb24gb3B0aW9uIG5hbWVzXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI2xpc3ROYW1lc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gYSBhcnJheSBvZiBhbGwgdGhlIHZhbGlkIG9wdGlvbiBuYW1lc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRvSHRtbEF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhdHRyaWJ1dGVzIGZvciBhbiBIVE1MIHRhZy5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeS50b0h0bWxBdHRyaWJ1dGVzXG4gICAgICogQHJldHVybiBQbGFpbk9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSHRtbEF0dHJpYnV0ZXMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBhdHRyTmFtZSwgaGVpZ2h0LCBvcHRpb25zLCByZWYyLCByZWYzLCB2YWx1ZSwgd2lkdGg7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgICB2YXIgc25ha2VDYXNlS2V5O1xuICAgICAgT2JqZWN0LmtleXModGhpcy5vdGhlck9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YWx1ZSA9IF90aGlzMi5vdGhlck9wdGlvbnNba2V5XTtcbiAgICAgICAgc25ha2VDYXNlS2V5ID0gc25ha2VDYXNlKGtleSk7XG4gICAgICAgIGlmICghaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0KCkodHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24uUEFSQU1fTkFNRVMsIHNuYWtlQ2FzZUtleSkgJiYgIWluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfZGVmYXVsdCgpKFVSTF9LRVlTLCBzbmFrZUNhc2VLZXkpKSB7XG4gICAgICAgICAgYXR0ck5hbWUgPSAvXmh0bWxfLy50ZXN0KGtleSkgPyBrZXkuc2xpY2UoNSkgOiBrZXk7XG4gICAgICAgICAgb3B0aW9uc1thdHRyTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBjb252ZXJ0IGFsbCBcImh0bWxfa2V5XCIgdG8gXCJrZXlcIiB3aXRoIHRoZSBzYW1lIHZhbHVlXG4gICAgICB0aGlzLmtleXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKC9eaHRtbF8vLnRlc3Qoa2V5KSkge1xuICAgICAgICAgIG9wdGlvbnNbY2FtZWxDYXNlKGtleS5zbGljZSg1KSldID0gX3RoaXMyLmdldFZhbHVlKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCEodGhpcy5oYXNMYXllcigpIHx8IHRoaXMuZ2V0VmFsdWUoXCJhbmdsZVwiKSB8fCBpbmNsdWRlc19yb290X2luY2x1ZGVzX2RlZmF1bHQoKShbXCJmaXRcIiwgXCJsaW1pdFwiLCBcImxmaWxsXCJdLCB0aGlzLmdldFZhbHVlKFwiY3JvcFwiKSkpKSB7XG4gICAgICAgIHdpZHRoID0gKHJlZjIgPSB0aGlzLmdldChcIndpZHRoXCIpKSAhPSBudWxsID8gcmVmMi5vcmlnVmFsdWUgOiB2b2lkIDA7XG4gICAgICAgIGhlaWdodCA9IChyZWYzID0gdGhpcy5nZXQoXCJoZWlnaHRcIikpICE9IG51bGwgPyByZWYzLm9yaWdWYWx1ZSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKHBhcnNlRmxvYXQod2lkdGgpID49IDEuMCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLndpZHRoID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlRmxvYXQoaGVpZ2h0KSA+PSAxLjApIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5oZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9IdG1sXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogRGVsZWdhdGUgdG8gdGhlIHBhcmVudCAodXAgdGhlIGNhbGwgY2hhaW4pIHRvIHByb2R1Y2UgSFRNTFxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiN0b0h0bWxcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEhUTUwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBhcmVudCBpZiBwb3NzaWJsZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHRhZyA9IGNsb3VkaW5hcnkuSW1hZ2VUYWcubmV3KFwic2FtcGxlXCIsIHtjbG91ZF9uYW1lOiBcImRlbW9cIn0pXG4gICAgICogLy8gSW1hZ2VUYWcge25hbWU6IFwiaW1nXCIsIHB1YmxpY0lkOiBcInNhbXBsZVwifVxuICAgICAqIHRhZy50b0h0bWwoKVxuICAgICAqIC8vIDxpbWcgc3JjPVwiaHR0cDovL3Jlcy5jbG91ZGluYXJ5LmNvbS9kZW1vL2ltYWdlL3VwbG9hZC9zYW1wbGVcIj5cbiAgICAgKiB0YWcudHJhbnNmb3JtYXRpb24oKS5jcm9wKFwiZml0XCIpLndpZHRoKDMwMCkudG9IdG1sKClcbiAgICAgKiAvLyA8aW1nIHNyYz1cImh0dHA6Ly9yZXMuY2xvdWRpbmFyeS5jb20vZGVtby9pbWFnZS91cGxvYWQvY19maXQsd18zMDAvc2FtcGxlXCI+XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9IdG1sKCkge1xuICAgICAgdmFyIHJlZjtcbiAgICAgIHJldHVybiAocmVmID0gdGhpcy5nZXRQYXJlbnQoKSkgIT0gbnVsbCA/IHR5cGVvZiByZWYudG9IdG1sID09PSBcImZ1bmN0aW9uXCIgPyByZWYudG9IdG1sKCkgOiB2b2lkIDAgOiB2b2lkIDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMudG9PcHRpb25zKHRydWUpKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJsaXN0TmFtZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdE5hbWVzKCkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uLm1ldGhvZHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVmFsaWRQYXJhbU5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNWYWxpZFBhcmFtTmFtZShuYW1lKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24ubWV0aG9kcy5pbmRleE9mKGNhbWVsQ2FzZShuYW1lKSkgPj0gMDtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbnZhciBWQVJfTkFNRV9SRSA9IC9eXFwkW2EtekEtWjAtOV0rJC87XG50cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbkJhc2UucHJvdG90eXBlLnRyYW5zX3NlcGFyYXRvciA9ICcvJztcbnRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uQmFzZS5wcm90b3R5cGUucGFyYW1fc2VwYXJhdG9yID0gJywnO1xuZnVuY3Rpb24gbGFzdEFyZ0NhbGxiYWNrKGFyZ3MpIHtcbiAgdmFyIGNhbGxiYWNrO1xuICBjYWxsYmFjayA9IGFyZ3MgIT0gbnVsbCA/IGFyZ3NbYXJncy5sZW5ndGggLSAxXSA6IHZvaWQgMDtcbiAgaWYgKGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShjYWxsYmFjaykpIHtcbiAgICByZXR1cm4gY2FsbGJhY2s7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc1Zhcih2YXJBcnJheSkge1xuICB2YXIgaiwgbGVuLCBuYW1lLCByZXN1bHRzLCB2O1xuICBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHZhckFycmF5KSkge1xuICAgIHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGogPSAwLCBsZW4gPSB2YXJBcnJheS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgdmFyIF92YXJBcnJheSRqID0gdHJhbnNmb3JtYXRpb25fc2xpY2VkVG9BcnJheSh2YXJBcnJheVtqXSwgMik7XG4gICAgICBuYW1lID0gX3ZhckFycmF5JGpbMF07XG4gICAgICB2ID0gX3ZhckFycmF5JGpbMV07XG4gICAgICByZXN1bHRzLnB1c2goXCJcIi5jb25jYXQobmFtZSwgXCJfXCIpLmNvbmNhdChleHByZXNzaW9uLm5vcm1hbGl6ZSh2KSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFyQXJyYXk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NDdXN0b21GdW5jdGlvbihfcmVmKSB7XG4gIHZhciBmdW5jdGlvbl90eXBlID0gX3JlZi5mdW5jdGlvbl90eXBlLFxuICAgIHNvdXJjZSA9IF9yZWYuc291cmNlO1xuICBpZiAoZnVuY3Rpb25fdHlwZSA9PT0gJ3JlbW90ZScpIHtcbiAgICByZXR1cm4gW2Z1bmN0aW9uX3R5cGUsIGJ0b2Eoc291cmNlKV0uam9pbihcIjpcIik7XG4gIH0gZWxzZSBpZiAoZnVuY3Rpb25fdHlwZSA9PT0gJ3dhc20nKSB7XG4gICAgcmV0dXJuIFtmdW5jdGlvbl90eXBlLCBzb3VyY2VdLmpvaW4oXCI6XCIpO1xuICB9XG59XG5cbi8qKlxuICogVHJhbnNmb3JtYXRpb24gQ2xhc3MgbWV0aG9kcy5cbiAqIFRoaXMgaXMgYSBsaXN0IG9mIHRoZSBwYXJhbWV0ZXJzIGRlZmluZWQgaW4gVHJhbnNmb3JtYXRpb24uXG4gKiBWYWx1ZXMgYXJlIGNhbWVsQ2FzZWQuXG4gKiBAY29uc3QgVHJhbnNmb3JtYXRpb24ubWV0aG9kc1xuICogQHByaXZhdGVcbiAqIEBpZ25vcmVcbiAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICovXG4vKipcbiAqIFBhcmFtZXRlcnMgdGhhdCBhcmUgZmlsdGVyZWQgb3V0IGJlZm9yZSBwYXNzaW5nIHRoZSBvcHRpb25zIHRvIGFuIEhUTUwgdGFnLlxuICpcbiAqIFRoZSBsaXN0IG9mIHBhcmFtZXRlcnMgaXMgYSBjb21iaW5hdGlvbiBvZiBgVHJhbnNmb3JtYXRpb246Om1ldGhvZHNgIGFuZCBgQ29uZmlndXJhdGlvbjo6Q09ORklHX1BBUkFNU2BcbiAqIEBjb25zdCB7QXJyYXk8c3RyaW5nPn0gVHJhbnNmb3JtYXRpb24uUEFSQU1fTkFNRVNcbiAqIEBwcml2YXRlXG4gKiBAaWdub3JlXG4gKiBAc2VlIHRvSHRtbEF0dHJpYnV0ZXNcbiAqL1xudmFyIHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVHJhbnNmb3JtYXRpb25CYXNlKSB7XG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgc2luZ2xlIHRyYW5zZm9ybWF0aW9uLlxuICAgKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25cbiAgICogQGV4YW1wbGVcbiAgICogdCA9IG5ldyBjbG91ZGluYXJ5LlRyYW5zZm9ybWF0aW9uKCk7XG4gICAqIHQuYW5nbGUoMjApLmNyb3AoXCJzY2FsZVwiKS53aWR0aChcImF1dG9cIik7XG4gICAqXG4gICAqIC8vIG9yXG4gICAqXG4gICAqIHQgPSBuZXcgY2xvdWRpbmFyeS5UcmFuc2Zvcm1hdGlvbigge2FuZ2xlOiAyMCwgY3JvcDogXCJzY2FsZVwiLCB3aWR0aDogXCJhdXRvXCJ9KTtcbiAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiXG4gICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCJcbiAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAqL1xuICBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbihvcHRpb25zKSB7XG4gICAgdHJhbnNmb3JtYXRpb25fY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNmb3JtYXRpb24pO1xuICAgIHJldHVybiB0cmFuc2Zvcm1hdGlvbl9jYWxsU3VwZXIodGhpcywgVHJhbnNmb3JtYXRpb24sIFtvcHRpb25zXSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7VHJhbnNmb3JtYXRpb259XG4gICAqIEBleGFtcGxlIGNsID0gY2xvdWRpbmFyeS5UcmFuc2Zvcm1hdGlvbi5uZXcoIHthbmdsZTogMjAsIGNyb3A6IFwic2NhbGVcIiwgd2lkdGg6IFwiYXV0b1wifSlcbiAgICovXG4gIHRyYW5zZm9ybWF0aW9uX2luaGVyaXRzKFRyYW5zZm9ybWF0aW9uLCBfVHJhbnNmb3JtYXRpb25CYXNlKTtcbiAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uX2NyZWF0ZUNsYXNzKFRyYW5zZm9ybWF0aW9uLCBbe1xuICAgIGtleTogXCJhbmdsZVwiLFxuICAgIHZhbHVlOlxuICAgIC8qXG4gICAgICBUcmFuc2Zvcm1hdGlvbiBQYXJhbWV0ZXJzXG4gICAgKi9cbiAgICBmdW5jdGlvbiBhbmdsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJyYXlQYXJhbSh2YWx1ZSwgXCJhbmdsZVwiLCBcImFcIiwgXCIuXCIsIGV4cHJlc3Npb24ubm9ybWFsaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXVkaW9Db2RlY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdWRpb0NvZGVjKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJhdWRpb19jb2RlY1wiLCBcImFjXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhdWRpb0ZyZXF1ZW5jeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdWRpb0ZyZXF1ZW5jeSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiYXVkaW9fZnJlcXVlbmN5XCIsIFwiYWZcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFzcGVjdFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzcGVjdFJhdGlvKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJhc3BlY3RfcmF0aW9cIiwgXCJhclwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJhY2tncm91bmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmFja2dyb3VuZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiYmFja2dyb3VuZFwiLCBcImJcIiwgcGFyYW1ldGVyc19QYXJhbS5ub3JtX2NvbG9yKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYml0UmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaXRSYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJiaXRfcmF0ZVwiLCBcImJyXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJib3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYm9yZGVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJib3JkZXJcIiwgXCJib1wiLCBmdW5jdGlvbiAoYm9yZGVyKSB7XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkoYm9yZGVyKSkge1xuICAgICAgICAgIGJvcmRlciA9IGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe30sIHtcbiAgICAgICAgICAgIGNvbG9yOiBcImJsYWNrXCIsXG4gICAgICAgICAgICB3aWR0aDogMlxuICAgICAgICAgIH0sIGJvcmRlcik7XG4gICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGJvcmRlci53aWR0aCwgXCJweF9zb2xpZF9cIikuY29uY2F0KHBhcmFtZXRlcnNfUGFyYW0ubm9ybV9jb2xvcihib3JkZXIuY29sb3IpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYm9yZGVyO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29sb3IodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImNvbG9yXCIsIFwiY29cIiwgcGFyYW1ldGVyc19QYXJhbS5ub3JtX2NvbG9yKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29sb3JTcGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb2xvclNwYWNlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJjb2xvcl9zcGFjZVwiLCBcImNzXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcm9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyb3AodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImNyb3BcIiwgXCJjXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjdXN0b21GdW5jdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXN0b21GdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiY3VzdG9tX2Z1bmN0aW9uXCIsIFwiZm5cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJvY2Vzc0N1c3RvbUZ1bmN0aW9uKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjdXN0b21QcmVGdW5jdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXN0b21QcmVGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuZ2V0KCdjdXN0b21fZnVuY3Rpb24nKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yYXdQYXJhbSh2YWx1ZSwgXCJjdXN0b21fZnVuY3Rpb25cIiwgXCJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YWx1ZSA9IHByb2Nlc3NDdXN0b21GdW5jdGlvbih2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IFwiZm5fcHJlOlwiLmNvbmNhdCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWZhdWx0SW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVmYXVsdEltYWdlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJkZWZhdWx0X2ltYWdlXCIsIFwiZFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImRlbGF5XCIsIFwiZGxcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbnNpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVuc2l0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZGVuc2l0eVwiLCBcImRuXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkdXJhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkdXJhdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmFuZ2VQYXJhbSh2YWx1ZSwgXCJkdXJhdGlvblwiLCBcImR1XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcHJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHByKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJkcHJcIiwgXCJkcHJcIiwgZnVuY3Rpb24gKGRwcikge1xuICAgICAgICBkcHIgPSBkcHIudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKGRwciAhPSBudWxsID8gZHByLm1hdGNoKC9eXFxkKyQvKSA6IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBkcHIgKyBcIi4wXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24ubm9ybWFsaXplKGRwcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlZmZlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWZmZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcnJheVBhcmFtKHZhbHVlLCBcImVmZmVjdFwiLCBcImVcIiwgXCI6XCIsIGV4cHJlc3Npb24ubm9ybWFsaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWxzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZWxzZSgpIHtcbiAgICAgIHJldHVybiB0aGlzW1wiaWZcIl0oJ2Vsc2UnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kSWZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kSWYoKSB7XG4gICAgICByZXR1cm4gdGhpc1tcImlmXCJdKCdlbmQnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kT2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZE9mZnNldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmFuZ2VQYXJhbSh2YWx1ZSwgXCJlbmRfb2Zmc2V0XCIsIFwiZW9cIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZhbGxiYWNrQ29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmYWxsYmFja0NvbnRlbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImZhbGxiYWNrX2NvbnRlbnRcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZldGNoRm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZldGNoRm9ybWF0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJmZXRjaF9mb3JtYXRcIiwgXCJmXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJmb3JtYXRcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZsYWdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZsYWdzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcnJheVBhcmFtKHZhbHVlLCBcImZsYWdzXCIsIFwiZmxcIiwgXCIuXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJncmF2aXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdyYXZpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImdyYXZpdHlcIiwgXCJnXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnBzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJmcHNcIiwgXCJmcHNcIiwgZnVuY3Rpb24gKGZwcykge1xuICAgICAgICBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkoZnBzKSkge1xuICAgICAgICAgIHJldHVybiBmcHM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKGZwcykpIHtcbiAgICAgICAgICByZXR1cm4gZnBzLmpvaW4oXCItXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmcHM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGVpZ2h0KHZhbHVlKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImhlaWdodFwiLCBcImhcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMzLmdldFZhbHVlKFwiY3JvcFwiKSB8fCBfdGhpczMuZ2V0VmFsdWUoXCJvdmVybGF5XCIpIHx8IF90aGlzMy5nZXRWYWx1ZShcInVuZGVybGF5XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24ubm9ybWFsaXplKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImh0bWxIZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaHRtbEhlaWdodCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiaHRtbF9oZWlnaHRcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImh0bWxXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBodG1sV2lkdGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImh0bWxfd2lkdGhcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pZigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogXCJcIjtcbiAgICAgIHZhciBpLCBpZlZhbCwgaiwgcmVmLCB0cklmLCB0clJlc3Q7XG4gICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJlbHNlXCI6XG4gICAgICAgICAgdGhpcy5jaGFpbigpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImlmXCIsIFwiaWZcIik7XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICB0aGlzLmNoYWluKCk7XG4gICAgICAgICAgZm9yIChpID0gaiA9IHJlZiA9IHRoaXMuY2hhaW5lZC5sZW5ndGggLSAxOyBqID49IDA7IGkgPSBqICs9IC0xKSB7XG4gICAgICAgICAgICBpZlZhbCA9IHRoaXMuY2hhaW5lZFtpXS5nZXRWYWx1ZShcImlmXCIpO1xuICAgICAgICAgICAgaWYgKGlmVmFsID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpZlZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHRySWYgPSBUcmFuc2Zvcm1hdGlvbltcIm5ld1wiXSgpW1wiaWZcIl0oaWZWYWwpO1xuICAgICAgICAgICAgICB0aGlzLmNoYWluZWRbaV0ucmVtb3ZlKFwiaWZcIik7XG4gICAgICAgICAgICAgIHRyUmVzdCA9IHRoaXMuY2hhaW5lZFtpXTtcbiAgICAgICAgICAgICAgdGhpcy5jaGFpbmVkW2ldID0gVHJhbnNmb3JtYXRpb25bXCJuZXdcIl0oKS50cmFuc2Zvcm1hdGlvbihbdHJJZiwgdHJSZXN0XSk7XG4gICAgICAgICAgICAgIGlmIChpZlZhbCAhPT0gXCJlbHNlXCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJpZlwiLCBcImlmXCIpO1xuICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgcmV0dXJuIGNvbmRpdGlvbltcIm5ld1wiXSgpLnNldFBhcmVudCh0aGlzKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJpZlwiLCBcImlmXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvbltcIm5ld1wiXSh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwia2V5ZnJhbWVJbnRlcnZhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBrZXlmcmFtZUludGVydmFsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJrZXlmcmFtZV9pbnRlcnZhbFwiLCBcImtpXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvY3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2NyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJvY3JcIiwgXCJvY3JcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvZmZzZXQodmFsdWUpIHtcbiAgICAgIHZhciBlbmRfbywgc3RhcnRfbztcbiAgICAgIHZhciBfcmVmMiA9IGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKSh2YWx1ZSAhPSBudWxsID8gdmFsdWUuc3BsaXQgOiB2b2lkIDApID8gdmFsdWUuc3BsaXQoJy4uJykgOiBpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkodmFsdWUpID8gdmFsdWUgOiBbbnVsbCwgbnVsbF07XG4gICAgICB2YXIgX3JlZjMgPSB0cmFuc2Zvcm1hdGlvbl9zbGljZWRUb0FycmF5KF9yZWYyLCAyKTtcbiAgICAgIHN0YXJ0X28gPSBfcmVmM1swXTtcbiAgICAgIGVuZF9vID0gX3JlZjNbMV07XG4gICAgICBpZiAoc3RhcnRfbyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RhcnRPZmZzZXQoc3RhcnRfbyk7XG4gICAgICB9XG4gICAgICBpZiAoZW5kX28gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmRPZmZzZXQoZW5kX28pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvcGFjaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wYWNpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcIm9wYWNpdHlcIiwgXCJvXCIsIGV4cHJlc3Npb24ubm9ybWFsaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3ZlcmxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdmVybGF5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXllclBhcmFtKHZhbHVlLCBcIm92ZXJsYXlcIiwgXCJsXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhZ2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInBhZ2VcIiwgXCJwZ1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3Rlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwicG9zdGVyXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcmVmaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlZml4KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJwcmVmaXhcIiwgXCJwXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJxdWFsaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHF1YWxpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInF1YWxpdHlcIiwgXCJxXCIsIGV4cHJlc3Npb24ubm9ybWFsaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFkaXVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhZGl1cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJyYXlQYXJhbSh2YWx1ZSwgXCJyYWRpdXNcIiwgXCJyXCIsIFwiOlwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJhd1RyYW5zZm9ybWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhd1RyYW5zZm9ybWF0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYXdQYXJhbSh2YWx1ZSwgXCJyYXdfdHJhbnNmb3JtYXRpb25cIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2l6ZSh2YWx1ZSkge1xuICAgICAgdmFyIGhlaWdodCwgd2lkdGg7XG4gICAgICBpZiAoaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKHZhbHVlICE9IG51bGwgPyB2YWx1ZS5zcGxpdCA6IHZvaWQgMCkpIHtcbiAgICAgICAgdmFyIF92YWx1ZSRzcGxpdCA9IHZhbHVlLnNwbGl0KCd4Jyk7XG4gICAgICAgIHZhciBfdmFsdWUkc3BsaXQyID0gdHJhbnNmb3JtYXRpb25fc2xpY2VkVG9BcnJheShfdmFsdWUkc3BsaXQsIDIpO1xuICAgICAgICB3aWR0aCA9IF92YWx1ZSRzcGxpdDJbMF07XG4gICAgICAgIGhlaWdodCA9IF92YWx1ZSRzcGxpdDJbMV07XG4gICAgICAgIHRoaXMud2lkdGgod2lkdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQoaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic291cmNlVHlwZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc291cmNlVHlwZXModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInNvdXJjZV90eXBlc1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic291cmNlVHJhbnNmb3JtYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc291cmNlVHJhbnNmb3JtYXRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInNvdXJjZV90cmFuc2Zvcm1hdGlvblwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRPZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRPZmZzZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhbmdlUGFyYW0odmFsdWUsIFwic3RhcnRfb2Zmc2V0XCIsIFwic29cIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0cmVhbWluZ1Byb2ZpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RyZWFtaW5nUHJvZmlsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwic3RyZWFtaW5nX3Byb2ZpbGVcIiwgXCJzcFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtYXRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uUGFyYW0odmFsdWUsIFwidHJhbnNmb3JtYXRpb25cIiwgXCJ0XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bmRlcmxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmRlcmxheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMubGF5ZXJQYXJhbSh2YWx1ZSwgXCJ1bmRlcmxheVwiLCBcInVcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhcmlhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhcmlhYmxlKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgbmFtZSwgbmFtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhcmlhYmxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YXJpYWJsZXModmFsdWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcnJheVBhcmFtKHZhbHVlcywgXCJ2YXJpYWJsZXNcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZpZGVvQ29kZWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlkZW9Db2RlYyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwidmlkZW9fY29kZWNcIiwgXCJ2Y1wiLCBwYXJhbWV0ZXJzX1BhcmFtLnByb2Nlc3NfdmlkZW9fcGFyYW1zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9TYW1wbGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWRlb1NhbXBsaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJ2aWRlb19zYW1wbGluZ1wiLCBcInZzXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aWR0aCh2YWx1ZSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJ3aWR0aFwiLCBcIndcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXM0LmdldFZhbHVlKFwiY3JvcFwiKSB8fCBfdGhpczQuZ2V0VmFsdWUoXCJvdmVybGF5XCIpIHx8IF90aGlzNC5nZXRWYWx1ZShcInVuZGVybGF5XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24ubm9ybWFsaXplKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24geCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwieFwiLCBcInhcIiwgZXhwcmVzc2lvbi5ub3JtYWxpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInlcIiwgXCJ5XCIsIGV4cHJlc3Npb24ubm9ybWFsaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiem9vbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB6b29tKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJ6b29tXCIsIFwielwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwibmV3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9uZXcob3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1hdGlvbihvcHRpb25zKTtcbiAgICB9XG4gIH1dKTtcbn0odHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb25CYXNlKTtcbi8qKlxuICogVHJhbnNmb3JtYXRpb24gQ2xhc3MgbWV0aG9kcy5cbiAqIFRoaXMgaXMgYSBsaXN0IG9mIHRoZSBwYXJhbWV0ZXJzIGRlZmluZWQgaW4gVHJhbnNmb3JtYXRpb24uXG4gKiBWYWx1ZXMgYXJlIGNhbWVsQ2FzZWQuXG4gKi9cbnRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uLm1ldGhvZHMgPSBbXCJhbmdsZVwiLCBcImF1ZGlvQ29kZWNcIiwgXCJhdWRpb0ZyZXF1ZW5jeVwiLCBcImFzcGVjdFJhdGlvXCIsIFwiYmFja2dyb3VuZFwiLCBcImJpdFJhdGVcIiwgXCJib3JkZXJcIiwgXCJjb2xvclwiLCBcImNvbG9yU3BhY2VcIiwgXCJjcm9wXCIsIFwiY3VzdG9tRnVuY3Rpb25cIiwgXCJjdXN0b21QcmVGdW5jdGlvblwiLCBcImRlZmF1bHRJbWFnZVwiLCBcImRlbGF5XCIsIFwiZGVuc2l0eVwiLCBcImR1cmF0aW9uXCIsIFwiZHByXCIsIFwiZWZmZWN0XCIsIFwiZWxzZVwiLCBcImVuZElmXCIsIFwiZW5kT2Zmc2V0XCIsIFwiZmFsbGJhY2tDb250ZW50XCIsIFwiZmV0Y2hGb3JtYXRcIiwgXCJmb3JtYXRcIiwgXCJmbGFnc1wiLCBcImdyYXZpdHlcIiwgXCJmcHNcIiwgXCJoZWlnaHRcIiwgXCJodG1sSGVpZ2h0XCIsIFwiaHRtbFdpZHRoXCIsIFwiaWZcIiwgXCJrZXlmcmFtZUludGVydmFsXCIsIFwib2NyXCIsIFwib2Zmc2V0XCIsIFwib3BhY2l0eVwiLCBcIm92ZXJsYXlcIiwgXCJwYWdlXCIsIFwicG9zdGVyXCIsIFwicHJlZml4XCIsIFwicXVhbGl0eVwiLCBcInJhZGl1c1wiLCBcInJhd1RyYW5zZm9ybWF0aW9uXCIsIFwic2l6ZVwiLCBcInNvdXJjZVR5cGVzXCIsIFwic291cmNlVHJhbnNmb3JtYXRpb25cIiwgXCJzdGFydE9mZnNldFwiLCBcInN0cmVhbWluZ1Byb2ZpbGVcIiwgXCJ0cmFuc2Zvcm1hdGlvblwiLCBcInVuZGVybGF5XCIsIFwidmFyaWFibGVcIiwgXCJ2YXJpYWJsZXNcIiwgXCJ2aWRlb0NvZGVjXCIsIFwidmlkZW9TYW1wbGluZ1wiLCBcIndpZHRoXCIsIFwieFwiLCBcInlcIiwgXCJ6b29tXCJdO1xuXG4vKipcbiAqIFBhcmFtZXRlcnMgdGhhdCBhcmUgZmlsdGVyZWQgb3V0IGJlZm9yZSBwYXNzaW5nIHRoZSBvcHRpb25zIHRvIGFuIEhUTUwgdGFnLlxuICpcbiAqIFRoZSBsaXN0IG9mIHBhcmFtZXRlcnMgaXMgYSBjb21iaW5hdGlvbiBvZiBgVHJhbnNmb3JtYXRpb246Om1ldGhvZHNgIGFuZCBgQ29uZmlndXJhdGlvbjo6Q09ORklHX1BBUkFNU2BcbiAqL1xudHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24uUEFSQU1fTkFNRVMgPSB0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbi5tZXRob2RzLm1hcChzbmFrZUNhc2UpLmNvbmNhdChzcmNfY29uZmlndXJhdGlvbi5DT05GSUdfUEFSQU1TKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY190cmFuc2Zvcm1hdGlvbiA9ICh0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90YWdzL2h0bWx0YWcuanNcbmZ1bmN0aW9uIGh0bWx0YWdfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gaHRtbHRhZ190eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgaHRtbHRhZ190eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIGh0bWx0YWdfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gaHRtbHRhZ19kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgaHRtbHRhZ190b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gaHRtbHRhZ19jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGh0bWx0YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGh0bWx0YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIGh0bWx0YWdfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gaHRtbHRhZ190b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gaHRtbHRhZ190eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIGh0bWx0YWdfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBodG1sdGFnX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBodG1sdGFnX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG4vKipcbiAqIEdlbmVyaWMgSFRNTCB0YWdcbiAqIERlcGVuZHMgb24gJ3RyYW5zZm9ybWF0aW9uJywgJ3V0aWwnXG4gKi9cblxuXG5cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIEhUTUwgKERPTSkgdGFnXG4gKiBAY29uc3RydWN0b3IgSHRtbFRhZ1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgdGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gW3B1YmxpY0lkXVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBleGFtcGxlIHRhZyA9IG5ldyBIdG1sVGFnKCAnZGl2JywgeyAnd2lkdGgnOiAxMH0pXG4gKi9cbnZhciBodG1sdGFnX0h0bWxUYWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIdG1sVGFnKG5hbWUsIHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgaHRtbHRhZ19jbGFzc0NhbGxDaGVjayh0aGlzLCBIdG1sVGFnKTtcbiAgICB2YXIgdHJhbnNmb3JtYXRpb247XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnB1YmxpY0lkID0gcHVibGljSWQ7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKShwdWJsaWNJZCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHB1YmxpY0lkO1xuICAgICAgICB0aGlzLnB1YmxpY0lkID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuICAgIH1cbiAgICB0cmFuc2Zvcm1hdGlvbiA9IG5ldyBzcmNfdHJhbnNmb3JtYXRpb24ob3B0aW9ucyk7XG4gICAgdHJhbnNmb3JtYXRpb24uc2V0UGFyZW50KHRoaXMpO1xuICAgIHRoaXMudHJhbnNmb3JtYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtYXRpb247XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBjb25zdHJ1Y3RvclxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIEhUTUwgKERPTSkgdGFnXG4gICAqIEBmdW5jdGlvbiBIdG1sVGFnLm5ld1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSB0YWdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwdWJsaWNJZF1cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7SHRtbFRhZ31cbiAgICogQGV4YW1wbGUgdGFnID0gSHRtbFRhZy5uZXcoICdkaXYnLCB7ICd3aWR0aCc6IDEwfSlcbiAgICovXG4gIHJldHVybiBodG1sdGFnX2NyZWF0ZUNsYXNzKEh0bWxUYWcsIFt7XG4gICAga2V5OiBcImh0bWxBdHRyc1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIGNvbWJpbmUga2V5IGFuZCB2YWx1ZSBmcm9tIHRoZSBgYXR0cmAgdG8gZ2VuZXJhdGUgYW4gSFRNTCB0YWcgYXR0cmlidXRlcyBzdHJpbmcuXG4gICAgICogYFRyYW5zZm9ybWF0aW9uOjp0b0h0bWxUYWdPcHRpb25zYCBpcyB1c2VkIHRvIGZpbHRlciBvdXQgdHJhbnNmb3JtYXRpb24gYW5kIGNvbmZpZ3VyYXRpb24ga2V5cy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJzXG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgYXR0cmlidXRlcyBpbiB0aGUgZm9ybWF0IGAna2V5MT1cInZhbHVlMVwiIGtleTI9XCJ2YWx1ZTJcIidgXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGh0bWxBdHRycyhhdHRycykge1xuICAgICAgdmFyIGtleSwgcGFpcnMsIHZhbHVlO1xuICAgICAgcmV0dXJuIHBhaXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0cztcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgICAgIHZhbHVlID0gZXNjYXBlUXVvdGVzKGF0dHJzW2tleV0pO1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGh0bWx0YWdfdG9BdHRyaWJ1dGUoa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH0oKS5zb3J0KCkuam9pbignICcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgb3B0aW9ucyByZWxhdGVkIHRvIHRoaXMgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI2dldE9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgb3B0aW9uc1xuICAgICAqXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPcHRpb25zKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtYXRpb24oKS50b09wdGlvbnMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIG9wdGlvbiBgbmFtZWBcbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNnZXRPcHRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG9wdGlvblxuICAgICAqXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3B0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbigpLmdldFZhbHVlKG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI2F0dHJpYnV0ZXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYXR0cmlidXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVzKCkge1xuICAgICAgLy8gVGhlIGF0dHJpYnV0ZXMgYXJlIGJlIGNvbXB1dGVkIGZyb20gdGhlIG9wdGlvbnMgZXZlcnkgdGltZSB0aGlzIG1ldGhvZCBpcyBpbnZva2VkLlxuICAgICAgdmFyIGh0bWxBdHRyaWJ1dGVzID0gdGhpcy50cmFuc2Zvcm1hdGlvbigpLnRvSHRtbEF0dHJpYnV0ZXMoKTtcbiAgICAgIE9iamVjdC5rZXlzKGh0bWxBdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKShodG1sQXR0cmlidXRlc1trZXldKSkge1xuICAgICAgICAgIGRlbGV0ZSBodG1sQXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChodG1sQXR0cmlidXRlcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIC8vIEN1cnJlbnRseSBIVE1MIGF0dHJpYnV0ZXMgYXJlIGRlZmluZWQgYm90aCBhdCB0aGUgdG9wIGxldmVsIGFuZCB1bmRlciAnYXR0cmlidXRlcydcbiAgICAgICAgbWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0KCkoaHRtbEF0dHJpYnV0ZXMsIGh0bWxBdHRyaWJ1dGVzLmF0dHJpYnV0ZXMpO1xuICAgICAgICBkZWxldGUgaHRtbEF0dHJpYnV0ZXMuYXR0cmlidXRlcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBodG1sQXR0cmlidXRlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSB0YWcgYXR0cmlidXRlIG5hbWVkIGBuYW1lYCB0byBgdmFsdWVgXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjc2V0QXR0clxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0QXR0clwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBdHRyKG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybWF0aW9uKCkuc2V0KFwiaHRtbF9cIi5jb25jYXQobmFtZSksIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIHRhZyBhdHRyaWJ1dGUgYG5hbWVgXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjZ2V0QXR0clxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEF0dHJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXR0cihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzKClbXCJodG1sX1wiLmNvbmNhdChuYW1lKV0gfHwgdGhpcy5hdHRyaWJ1dGVzKClbbmFtZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSB0YWcgYXR0cmlidXRlZCBuYW1lZCBgbmFtZWBcbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNyZW1vdmVBdHRyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlQXR0clwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBdHRyKG5hbWUpIHtcbiAgICAgIHZhciByZWY7XG4gICAgICByZXR1cm4gKHJlZiA9IHRoaXMudHJhbnNmb3JtYXRpb24oKS5yZW1vdmUoXCJodG1sX1wiLmNvbmNhdChuYW1lKSkpICE9IG51bGwgPyByZWYgOiB0aGlzLnRyYW5zZm9ybWF0aW9uKCkucmVtb3ZlKG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI2NvbnRlbnRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGVudCgpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI29wZW5UYWdcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm9wZW5UYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlblRhZygpIHtcbiAgICAgIHZhciB0YWcgPSBcIjxcIiArIHRoaXMubmFtZTtcbiAgICAgIHZhciBodG1sQXR0cnMgPSB0aGlzLmh0bWxBdHRycyh0aGlzLmF0dHJpYnV0ZXMoKSk7XG4gICAgICBpZiAoaHRtbEF0dHJzICYmIGh0bWxBdHRycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRhZyArPSBcIiBcIiArIGh0bWxBdHRycztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWcgKyBcIj5cIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNjbG9zZVRhZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VUYWcoKSB7XG4gICAgICByZXR1cm4gXCI8L1wiLmNvbmNhdCh0aGlzLm5hbWUsIFwiPlwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gSFRNTCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI3RvSHRtbFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgSFRNTCBpbiBzdHJpbmcgZm9ybWF0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidG9IdG1sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSHRtbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wZW5UYWcoKSArIHRoaXMuY29udGVudCgpICsgdGhpcy5jbG9zZVRhZygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBET00gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI3RvRE9NXG4gICAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidG9ET01cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9ET00oKSB7XG4gICAgICB2YXIgZWxlbWVudCwgbmFtZSwgcmVmLCB2YWx1ZTtcbiAgICAgIGlmICghaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudCAhPT0gbnVsbCA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgOiB2b2lkIDApKSB7XG4gICAgICAgIHRocm93IFwiQ2FuJ3QgY3JlYXRlIERPTSBpZiBkb2N1bWVudCBpcyBub3QgcHJlc2VudCFcIjtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMubmFtZSk7XG4gICAgICByZWYgPSB0aGlzLmF0dHJpYnV0ZXMoKTtcbiAgICAgIGZvciAobmFtZSBpbiByZWYpIHtcbiAgICAgICAgdmFsdWUgPSByZWZbbmFtZV07XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcIm5ld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbmV3KG5hbWUsIHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMobmFtZSwgcHVibGljSWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1Jlc3BvbnNpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNSZXNwb25zaXZlKHRhZywgcmVzcG9uc2l2ZUNsYXNzKSB7XG4gICAgICB2YXIgZGF0YVNyYztcbiAgICAgIGRhdGFTcmMgPSBsb2Rhc2hfZ2V0RGF0YSh0YWcsICdzcmMtY2FjaGUnKSB8fCBsb2Rhc2hfZ2V0RGF0YSh0YWcsICdzcmMnKTtcbiAgICAgIHJldHVybiBsb2Rhc2hfaGFzQ2xhc3ModGFnLCByZXNwb25zaXZlQ2xhc3MpICYmIC9cXGJ3X2F1dG9cXGIvLmV4ZWMoZGF0YVNyYyk7XG4gICAgfVxuICB9XSk7XG59KCk7XG47XG5cbi8qKlxuICogUmVwcmVzZW50IHRoZSBnaXZlbiBrZXkgYW5kIHZhbHVlIGFzIGFuIEhUTUwgYXR0cmlidXRlLlxuICogQGZ1bmN0aW9uIHRvQXR0cmlidXRlXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gYXR0cmlidXRlIG5hbWVcbiAqIEBwYXJhbSB7Knxib29sZWFufSB2YWx1ZSAtIHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlLiBJZiB0aGUgdmFsdWUgaXMgYm9vbGVhbiBgdHJ1ZWAsIHJldHVybiB0aGUga2V5IG9ubHkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgYXR0cmlidXRlXG4gKlxuICovXG5mdW5jdGlvbiBodG1sdGFnX3RvQXR0cmlidXRlKGtleSwgdmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICByZXR1cm4ga2V5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChrZXksIFwiPVxcXCJcIikuY29uY2F0KHZhbHVlLCBcIlxcXCJcIik7XG4gIH1cbn1cblxuLyoqXG4gKiBJZiBnaXZlbiB2YWx1ZSBpcyBhIHN0cmluZywgcmVwbGFjZXMgcXVvdGVzIHdpdGggY2hhcmFjdGVyIGVudGl0aWVzICgmIzM0OywgJiMzOTspXG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBjaGFuZ2VcbiAqIEByZXR1cm5zIHsqfSBjaGFuZ2VkIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVF1b3Rlcyh2YWx1ZSkge1xuICByZXR1cm4gaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkodmFsdWUpID8gdmFsdWUucmVwbGFjZSgnXCInLCAnJiMzNDsnKS5yZXBsYWNlKFwiJ1wiLCAnJiMzOTsnKSA6IHZhbHVlO1xufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaHRtbHRhZyA9IChodG1sdGFnX0h0bWxUYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXJsLmpzXG52YXIgX2V4Y2x1ZGVkID0gW1wicGxhY2Vob2xkZXJcIiwgXCJhY2Nlc3NpYmlsaXR5XCJdO1xuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuXG5cblxuXG5cbi8qKlxuICogQWRkcyBwcm90b2NvbCwgaG9zdCwgcGF0aG5hbWUgcHJlZml4ZXMgdG8gZ2l2ZW4gc3RyaW5nXG4gKiBAcGFyYW0gc3RyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBtYWtlVXJsKHN0cikge1xuICB2YXIgcHJlZml4ID0gZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgZG9jdW1lbnQubG9jYXRpb24uaG9zdDtcbiAgaWYgKHN0clswXSA9PT0gJz8nKSB7XG4gICAgcHJlZml4ICs9IGRvY3VtZW50LmxvY2F0aW9uLnBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKHN0clswXSAhPT0gJy8nKSB7XG4gICAgcHJlZml4ICs9IGRvY3VtZW50LmxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgJy8nKTtcbiAgfVxuICByZXR1cm4gcHJlZml4ICsgc3RyO1xufVxuXG4vKipcbiAqIENoZWNrIGlzIGdpdmVuIHN0cmluZyBpcyBhIHVybFxuICogQHBhcmFtIHN0clxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVXJsKHN0cikge1xuICByZXR1cm4gc3RyID8gISFzdHIubWF0Y2goL15odHRwcz86XFwvLykgOiBmYWxzZTtcbn1cblxuLy8gUHJvZHVjZSBhIG51bWJlciBiZXR3ZWVuIDEgYW5kIDUgdG8gYmUgdXNlZCBmb3IgY2RuIHN1YiBkb21haW5zIGRlc2lnbmF0aW9uXG5mdW5jdGlvbiBjZG5TdWJkb21haW5OdW1iZXIocHVibGljSWQpIHtcbiAgcmV0dXJuIHNyY19jcmMzMihwdWJsaWNJZCkgJSA1ICsgMTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIHNpZ25hdHVyZSBmcm9tIG9wdGlvbnMgYW5kIHJldHVybnMgdGhlIHNpZ25hdHVyZVxuICogTWFrZXMgc3VyZSBzaWduYXR1cmUgaXMgZW1wdHkgb3Igb2YgdGhpcyBmb3JtYXQ6IHMtLXNpZ25hdHVyZS0tXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ30gdGhlIGZvcm1hdHRlZCBzaWduYXR1cmVcbiAqL1xuZnVuY3Rpb24gaGFuZGxlU2lnbmF0dXJlKG9wdGlvbnMpIHtcbiAgdmFyIHNpZ25hdHVyZSA9IG9wdGlvbnMuc2lnbmF0dXJlO1xuICB2YXIgaXNGb3JtYXR0ZWQgPSAhc2lnbmF0dXJlIHx8IHNpZ25hdHVyZS5pbmRleE9mKCdzLS0nKSA9PT0gMCAmJiBzaWduYXR1cmUuc3Vic3RyKC0yKSA9PT0gJy0tJztcbiAgZGVsZXRlIG9wdGlvbnMuc2lnbmF0dXJlO1xuICByZXR1cm4gaXNGb3JtYXR0ZWQgPyBzaWduYXR1cmUgOiBcInMtLVwiLmNvbmNhdChzaWduYXR1cmUsIFwiLS1cIik7XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBVUkwgcHJlZml4IGZvciBDbG91ZGluYXJ5IHJlc291cmNlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCB0aGUgcmVzb3VyY2UgcHVibGljIElEXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBhZGRpdGlvbmFsIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNsb3VkX25hbWUgLSB0aGUgY2xvdWQgbmFtZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2RuX3N1YmRvbWFpbj1mYWxzZV0gLSBXaGV0aGVyIHRvIGF1dG9tYXRpY2FsbHkgYnVpbGQgVVJMcyB3aXRoXG4gKiAgbXVsdGlwbGUgQ0ROIHN1Yi1kb21haW5zLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnByaXZhdGVfY2RuXSAtIEJvb2xlYW4gKGRlZmF1bHQ6IGZhbHNlKS4gU2hvdWxkIGJlIHNldCB0byB0cnVlIGZvciBBZHZhbmNlZCBwbGFuJ3MgdXNlcnNcbiAqICB0aGF0IGhhdmUgYSBwcml2YXRlIENETiBkaXN0cmlidXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucHJvdG9jb2w9XCJodHRwOi8vXCJdIC0gdGhlIFVSSSBwcm90b2NvbCB0byB1c2UuIElmIG9wdGlvbnMuc2VjdXJlIGlzIHRydWUsXG4gKiAgdGhlIHZhbHVlIGlzIG92ZXJyaWRkZW4gdG8gXCJodHRwczovL1wiXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2VjdXJlX2Rpc3RyaWJ1dGlvbl0gLSBUaGUgZG9tYWluIG5hbWUgb2YgdGhlIENETiBkaXN0cmlidXRpb24gdG8gdXNlIGZvciBidWlsZGluZyBIVFRQUyBVUkxzLlxuICogIFJlbGV2YW50IG9ubHkgZm9yIEFkdmFuY2VkIHBsYW4ncyB1c2VycyB0aGF0IGhhdmUgYSBwcml2YXRlIENETiBkaXN0cmlidXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY25hbWVdIC0gQ3VzdG9tIGRvbWFpbiBuYW1lIHRvIHVzZSBmb3IgYnVpbGRpbmcgSFRUUCBVUkxzLlxuICogIFJlbGV2YW50IG9ubHkgZm9yIEFkdmFuY2VkIHBsYW4ncyB1c2VycyB0aGF0IGhhdmUgYSBwcml2YXRlIENETiBkaXN0cmlidXRpb24gYW5kIGEgY3VzdG9tIENOQU1FLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVfY2RuX3N1YmRvbWFpbj10cnVlXSAtIFdoZW4gb3B0aW9ucy5zZWN1cmUgaXMgdHJ1ZSBhbmQgdGhpcyBwYXJhbWV0ZXIgaXMgZmFsc2UsXG4gKiAgdGhlIHN1YmRvbWFpbiBpcyBzZXQgdG8gXCJyZXNcIi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlPWZhbHNlXSAtIEZvcmNlIEhUVFBTIFVSTHMgb2YgaW1hZ2VzIGV2ZW4gaWYgZW1iZWRkZWQgaW4gbm9uLXNlY3VyZSBIVFRQIHBhZ2VzLlxuICogIFdoZW4gdGhpcyB2YWx1ZSBpcyB0cnVlLCBvcHRpb25zLnNlY3VyZV9kaXN0cmlidXRpb24gd2lsbCBiZSB1c2VkIGFzIGhvc3QgaWYgcHJvdmlkZWQsIGFuZCBvcHRpb25zLnByb3RvY29sIGlzIHNldFxuICogIHRvIFwiaHR0cHM6Ly9cIi5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBVUkwgcHJlZml4IGZvciB0aGUgcmVzb3VyY2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBoYW5kbGVQcmVmaXgocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuY2xvdWRfbmFtZSAmJiBvcHRpb25zLmNsb3VkX25hbWVbMF0gPT09ICcvJykge1xuICAgIHJldHVybiAnL3JlcycgKyBvcHRpb25zLmNsb3VkX25hbWU7XG4gIH1cbiAgLy8gZGVmYXVsdHNcbiAgdmFyIHByb3RvY29sID0gXCJodHRwOi8vXCI7XG4gIHZhciBjZG5QYXJ0ID0gXCJcIjtcbiAgdmFyIHN1YmRvbWFpbiA9IFwicmVzXCI7XG4gIHZhciBob3N0ID0gXCIuY2xvdWRpbmFyeS5jb21cIjtcbiAgdmFyIHBhdGggPSBcIi9cIiArIG9wdGlvbnMuY2xvdWRfbmFtZTtcbiAgLy8gbW9kaWZpY2F0aW9uc1xuICBpZiAob3B0aW9ucy5wcm90b2NvbCkge1xuICAgIHByb3RvY29sID0gb3B0aW9ucy5wcm90b2NvbCArICcvLyc7XG4gIH1cbiAgaWYgKG9wdGlvbnMucHJpdmF0ZV9jZG4pIHtcbiAgICBjZG5QYXJ0ID0gb3B0aW9ucy5jbG91ZF9uYW1lICsgXCItXCI7XG4gICAgcGF0aCA9IFwiXCI7XG4gIH1cbiAgaWYgKG9wdGlvbnMuY2RuX3N1YmRvbWFpbikge1xuICAgIHN1YmRvbWFpbiA9IFwicmVzLVwiICsgY2RuU3ViZG9tYWluTnVtYmVyKHB1YmxpY0lkKTtcbiAgfVxuICBpZiAob3B0aW9ucy5zZWN1cmUpIHtcbiAgICBwcm90b2NvbCA9IFwiaHR0cHM6Ly9cIjtcbiAgICBpZiAob3B0aW9ucy5zZWN1cmVfY2RuX3N1YmRvbWFpbiA9PT0gZmFsc2UpIHtcbiAgICAgIHN1YmRvbWFpbiA9IFwicmVzXCI7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNlY3VyZV9kaXN0cmlidXRpb24gIT0gbnVsbCAmJiBvcHRpb25zLnNlY3VyZV9kaXN0cmlidXRpb24gIT09IE9MRF9BS0FNQUlfU0hBUkVEX0NETiAmJiBvcHRpb25zLnNlY3VyZV9kaXN0cmlidXRpb24gIT09IFNIQVJFRF9DRE4pIHtcbiAgICAgIGNkblBhcnQgPSBcIlwiO1xuICAgICAgc3ViZG9tYWluID0gXCJcIjtcbiAgICAgIGhvc3QgPSBvcHRpb25zLnNlY3VyZV9kaXN0cmlidXRpb247XG4gICAgfVxuICB9IGVsc2UgaWYgKG9wdGlvbnMuY25hbWUpIHtcbiAgICBwcm90b2NvbCA9IFwiaHR0cDovL1wiO1xuICAgIGNkblBhcnQgPSBcIlwiO1xuICAgIHN1YmRvbWFpbiA9IG9wdGlvbnMuY2RuX3N1YmRvbWFpbiA/ICdhJyArIChzcmNfY3JjMzIocHVibGljSWQpICUgNSArIDEpICsgJy4nIDogJyc7XG4gICAgaG9zdCA9IG9wdGlvbnMuY25hbWU7XG4gIH1cbiAgcmV0dXJuIFtwcm90b2NvbCwgY2RuUGFydCwgc3ViZG9tYWluLCBob3N0LCBwYXRoXS5qb2luKFwiXCIpO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcmVzb3VyY2UgdHlwZSBhbmQgYWN0aW9uIHR5cGUgYmFzZWQgb24gdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb25cbiAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2hhbmRsZVJlc291cmNlVHlwZVxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSByZXNvdXJjZV90eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGU9J3VwbG9hZCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VybF9zdWZmaXhdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2Vfcm9vdF9wYXRoXVxuICogQHBhcmFtIHtib29sZWFufSBbc2hvcnRlbl1cbiAqIEByZXR1cm5zIHtzdHJpbmd9IHJlc291cmNlX3R5cGUvdHlwZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBoYW5kbGVSZXNvdXJjZVR5cGUoX3JlZikge1xuICB2YXIgX3JlZiRyZXNvdXJjZV90eXBlID0gX3JlZi5yZXNvdXJjZV90eXBlLFxuICAgIHJlc291cmNlX3R5cGUgPSBfcmVmJHJlc291cmNlX3R5cGUgPT09IHZvaWQgMCA/IFwiaW1hZ2VcIiA6IF9yZWYkcmVzb3VyY2VfdHlwZSxcbiAgICBfcmVmJHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgdHlwZSA9IF9yZWYkdHlwZSA9PT0gdm9pZCAwID8gXCJ1cGxvYWRcIiA6IF9yZWYkdHlwZSxcbiAgICB1cmxfc3VmZml4ID0gX3JlZi51cmxfc3VmZml4LFxuICAgIHVzZV9yb290X3BhdGggPSBfcmVmLnVzZV9yb290X3BhdGgsXG4gICAgc2hvcnRlbiA9IF9yZWYuc2hvcnRlbjtcbiAgdmFyIG9wdGlvbnMsXG4gICAgcmVzb3VyY2VUeXBlID0gcmVzb3VyY2VfdHlwZTtcbiAgaWYgKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKShyZXNvdXJjZVR5cGUpKSB7XG4gICAgb3B0aW9ucyA9IHJlc291cmNlVHlwZTtcbiAgICByZXNvdXJjZVR5cGUgPSBvcHRpb25zLnJlc291cmNlX3R5cGU7XG4gICAgdHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICBzaG9ydGVuID0gb3B0aW9ucy5zaG9ydGVuO1xuICB9XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICB0eXBlID0gJ3VwbG9hZCc7XG4gIH1cbiAgaWYgKHVybF9zdWZmaXggIT0gbnVsbCkge1xuICAgIHJlc291cmNlVHlwZSA9IFNFT19UWVBFU1tcIlwiLmNvbmNhdChyZXNvdXJjZVR5cGUsIFwiL1wiKS5jb25jYXQodHlwZSldO1xuICAgIHR5cGUgPSBudWxsO1xuICAgIGlmIChyZXNvdXJjZVR5cGUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVVJMIFN1ZmZpeCBvbmx5IHN1cHBvcnRlZCBmb3IgXCIuY29uY2F0KE9iamVjdC5rZXlzKFNFT19UWVBFUykuam9pbignLCAnKSkpO1xuICAgIH1cbiAgfVxuICBpZiAodXNlX3Jvb3RfcGF0aCkge1xuICAgIGlmIChyZXNvdXJjZVR5cGUgPT09ICdpbWFnZScgJiYgdHlwZSA9PT0gJ3VwbG9hZCcgfHwgcmVzb3VyY2VUeXBlID09PSBcImltYWdlc1wiKSB7XG4gICAgICByZXNvdXJjZVR5cGUgPSBudWxsO1xuICAgICAgdHlwZSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvb3QgcGF0aCBvbmx5IHN1cHBvcnRlZCBmb3IgaW1hZ2UvdXBsb2FkXCIpO1xuICAgIH1cbiAgfVxuICBpZiAoc2hvcnRlbiAmJiByZXNvdXJjZVR5cGUgPT09ICdpbWFnZScgJiYgdHlwZSA9PT0gJ3VwbG9hZCcpIHtcbiAgICByZXNvdXJjZVR5cGUgPSAnaXUnO1xuICAgIHR5cGUgPSBudWxsO1xuICB9XG4gIHJldHVybiBbcmVzb3VyY2VUeXBlLCB0eXBlXS5qb2luKFwiL1wiKTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcHVibGljSWRcbiAqIEBwYXJhbSBwdWJsaWNJZFxuICogQHJldHVybnMge3N0cmluZ30gZW5jb2RlZCBwdWJsaWNJZFxuICovXG5mdW5jdGlvbiBlbmNvZGVQdWJsaWNJZChwdWJsaWNJZCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHB1YmxpY0lkKS5yZXBsYWNlKC8lM0EvZywgJzonKS5yZXBsYWNlKC8lMkYvZywgJy8nKTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgYW5kIGZvcm1hdCBwdWJsaWNJZFxuICogQHBhcmFtIHB1YmxpY0lkXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ30gcHVibGljSWRcbiAqL1xuZnVuY3Rpb24gZm9ybWF0UHVibGljSWQocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgaWYgKGlzVXJsKHB1YmxpY0lkKSkge1xuICAgIHB1YmxpY0lkID0gZW5jb2RlUHVibGljSWQocHVibGljSWQpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICAvLyBNYWtlIHN1cmUgcHVibGljSWQgaXMgVVJJIGVuY29kZWQuXG4gICAgICBwdWJsaWNJZCA9IGRlY29kZVVSSUNvbXBvbmVudChwdWJsaWNJZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgcHVibGljSWQgPSBlbmNvZGVQdWJsaWNJZChwdWJsaWNJZCk7XG4gICAgaWYgKG9wdGlvbnMudXJsX3N1ZmZpeCkge1xuICAgICAgcHVibGljSWQgPSBwdWJsaWNJZCArICcvJyArIG9wdGlvbnMudXJsX3N1ZmZpeDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZm9ybWF0KSB7XG4gICAgICBpZiAoIW9wdGlvbnMudHJ1c3RfcHVibGljX2lkKSB7XG4gICAgICAgIHB1YmxpY0lkID0gcHVibGljSWQucmVwbGFjZSgvXFwuKGpwZ3xwbmd8Z2lmfHdlYnApJC8sICcnKTtcbiAgICAgIH1cbiAgICAgIHB1YmxpY0lkID0gcHVibGljSWQgKyAnLicgKyBvcHRpb25zLmZvcm1hdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHB1YmxpY0lkO1xufVxuXG4vKipcbiAqIEdldCBhbnkgZXJyb3Igd2l0aCB1cmwgb3B0aW9uc1xuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGlmIGVycm9yLCBvdGhlcndpc2UgcmV0dXJuIHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZShvcHRpb25zKSB7XG4gIHZhciBjbG91ZF9uYW1lID0gb3B0aW9ucy5jbG91ZF9uYW1lLFxuICAgIHVybF9zdWZmaXggPSBvcHRpb25zLnVybF9zdWZmaXg7XG4gIGlmICghY2xvdWRfbmFtZSkge1xuICAgIHJldHVybiAnVW5rbm93biBjbG91ZF9uYW1lJztcbiAgfVxuICBpZiAodXJsX3N1ZmZpeCAmJiB1cmxfc3VmZml4Lm1hdGNoKC9bXFwuXFwvXS8pKSB7XG4gICAgcmV0dXJuICd1cmxfc3VmZml4IHNob3VsZCBub3QgaW5jbHVkZSAuIG9yIC8nO1xuICB9XG59XG5cbi8qKlxuICogR2V0IHZlcnNpb24gcGFydCBvZiB0aGUgdXJsXG4gKiBAcGFyYW0gcHVibGljSWRcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoYW5kbGVWZXJzaW9uKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gIC8vIGZvcmNlX3ZlcnNpb24gcGFyYW0gbWVhbnMgdG8gbWFrZSBzdXJlIHRoZXJlIGlzIGEgdmVyc2lvbiBpbiB0aGUgdXJsIChEZWZhdWx0IGlzIHRydWUpXG4gIHZhciBpc0ZvcmNlVmVyc2lvbiA9IG9wdGlvbnMuZm9yY2VfdmVyc2lvbiB8fCB0eXBlb2Ygb3B0aW9ucy5mb3JjZV92ZXJzaW9uID09PSAndW5kZWZpbmVkJztcblxuICAvLyBJcyB2ZXJzaW9uIGluY2x1ZGVkIGluIHB1YmxpY0lkIG9yIGluIG9wdGlvbnMsIG9yIHB1YmxpY0lkIGlzIGEgdXJsIChkb2Vzbid0IG5lZWQgdmVyc2lvbilcbiAgdmFyIGlzVmVyc2lvbkV4aXN0ID0gcHVibGljSWQuaW5kZXhPZignLycpIDwgMCB8fCBwdWJsaWNJZC5tYXRjaCgvXnZbMC05XSsvKSB8fCBpc1VybChwdWJsaWNJZCkgfHwgb3B0aW9ucy52ZXJzaW9uO1xuICBpZiAoaXNGb3JjZVZlcnNpb24gJiYgIWlzVmVyc2lvbkV4aXN0KSB7XG4gICAgb3B0aW9ucy52ZXJzaW9uID0gMTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucy52ZXJzaW9uID8gXCJ2XCIuY29uY2F0KG9wdGlvbnMudmVyc2lvbikgOiAnJztcbn1cblxuLyoqXG4gKiBHZXQgZmluYWwgdHJhbnNmb3JtYXRpb24gY29tcG9uZW50IGZvciB1cmwgc3RyaW5nXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaGFuZGxlVHJhbnNmb3JtYXRpb24ob3B0aW9ucykge1xuICB2YXIgX3JlZjIgPSBvcHRpb25zIHx8IHt9LFxuICAgIHBsYWNlaG9sZGVyID0gX3JlZjIucGxhY2Vob2xkZXIsXG4gICAgYWNjZXNzaWJpbGl0eSA9IF9yZWYyLmFjY2Vzc2liaWxpdHksXG4gICAgb3RoZXJPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBfZXhjbHVkZWQpO1xuICB2YXIgcmVzdWx0ID0gbmV3IHNyY190cmFuc2Zvcm1hdGlvbihvdGhlck9wdGlvbnMpO1xuXG4gIC8vIEFwcGVuZCBhY2Nlc3NpYmlsaXR5IHRyYW5zZm9ybWF0aW9uc1xuICBpZiAoYWNjZXNzaWJpbGl0eSAmJiBBQ0NFU1NJQklMSVRZX01PREVTW2FjY2Vzc2liaWxpdHldKSB7XG4gICAgcmVzdWx0LmNoYWluKCkuZWZmZWN0KEFDQ0VTU0lCSUxJVFlfTU9ERVNbYWNjZXNzaWJpbGl0eV0pO1xuICB9XG5cbiAgLy8gQXBwZW5kIHBsYWNlaG9sZGVyIHRyYW5zZm9ybWF0aW9uc1xuICBpZiAocGxhY2Vob2xkZXIpIHtcbiAgICBpZiAocGxhY2Vob2xkZXIgPT09IFwicHJlZG9taW5hbnQtY29sb3JcIiAmJiByZXN1bHQuZ2V0VmFsdWUoJ3dpZHRoJykgJiYgcmVzdWx0LmdldFZhbHVlKCdoZWlnaHQnKSkge1xuICAgICAgcGxhY2Vob2xkZXIgKz0gJy1waXhlbCc7XG4gICAgfVxuICAgIHZhciBwbGFjZWhvbGRlclRyYW5zZm9ybWF0aW9ucyA9IFBMQUNFSE9MREVSX0lNQUdFX01PREVTW3BsYWNlaG9sZGVyXSB8fCBQTEFDRUhPTERFUl9JTUFHRV9NT0RFUy5ibHVyO1xuICAgIHBsYWNlaG9sZGVyVHJhbnNmb3JtYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQuY2hhaW4oKS50cmFuc2Zvcm1hdGlvbih0KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LnNlcmlhbGl6ZSgpO1xufVxuXG4vKipcbiAqIElmIHR5cGUgaXMgJ2ZldGNoJywgdXBkYXRlIHB1YmxpY0lkIHRvIGJlIGEgdXJsXG4gKiBAcGFyYW0gcHVibGljSWRcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBwcmVwYXJlUHVibGljSWQocHVibGljSWQsIF9yZWYzKSB7XG4gIHZhciB0eXBlID0gX3JlZjMudHlwZTtcbiAgcmV0dXJuICFpc1VybChwdWJsaWNJZCkgJiYgdHlwZSA9PT0gJ2ZldGNoJyA/IG1ha2VVcmwocHVibGljSWQpIDogcHVibGljSWQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgdXJsIHN0cmluZ1xuICogQHBhcmFtIHB1YmxpY0lkXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ30gZmluYWwgdXJsXG4gKi9cbmZ1bmN0aW9uIHVybFN0cmluZyhwdWJsaWNJZCwgb3B0aW9ucykge1xuICBpZiAoaXNVcmwocHVibGljSWQpICYmIChvcHRpb25zLnR5cGUgPT09ICd1cGxvYWQnIHx8IG9wdGlvbnMudHlwZSA9PT0gJ2Fzc2V0JykpIHtcbiAgICByZXR1cm4gcHVibGljSWQ7XG4gIH1cbiAgdmFyIHZlcnNpb24gPSBoYW5kbGVWZXJzaW9uKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgdmFyIHRyYW5zZm9ybWF0aW9uU3RyaW5nID0gaGFuZGxlVHJhbnNmb3JtYXRpb24ob3B0aW9ucyk7XG4gIHZhciBwcmVmaXggPSBoYW5kbGVQcmVmaXgocHVibGljSWQsIG9wdGlvbnMpO1xuICB2YXIgc2lnbmF0dXJlID0gaGFuZGxlU2lnbmF0dXJlKG9wdGlvbnMpO1xuICB2YXIgcmVzb3VyY2VUeXBlID0gaGFuZGxlUmVzb3VyY2VUeXBlKG9wdGlvbnMpO1xuICBwdWJsaWNJZCA9IGZvcm1hdFB1YmxpY0lkKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgcmV0dXJuIGNvbXBhY3Rfcm9vdF9jb21wYWN0X2RlZmF1bHQoKShbcHJlZml4LCByZXNvdXJjZVR5cGUsIHNpZ25hdHVyZSwgdHJhbnNmb3JtYXRpb25TdHJpbmcsIHZlcnNpb24sIHB1YmxpY0lkXSkuam9pbignLycpLnJlcGxhY2UoLyhbXjpdKVxcLysvZywgJyQxLycpIC8vIHJlcGxhY2UgJy8vLycgd2l0aCAnLy8nXG4gIC5yZXBsYWNlKCcgJywgJyUyMCcpO1xufVxuXG4vKipcbiAqIE1lcmdlIG9wdGlvbnMgYW5kIGNvbmZpZyB3aXRoIGRlZmF1bHRzXG4gKiB1cGRhdGUgb3B0aW9ucyBmZXRjaF9mb3JtYXQgYWNjb3JkaW5nIHRvICd0eXBlJyBwYXJhbVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBjb25maWdcbiAqIEByZXR1cm5zIHsqfSB1cGRhdGVkIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gcHJlcGFyZU9wdGlvbnMob3B0aW9ucywgY29uZmlnKSB7XG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2Ygc3JjX3RyYW5zZm9ybWF0aW9uKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMudG9PcHRpb25zKCk7XG4gIH1cbiAgb3B0aW9ucyA9IGRlZmF1bHRzKHt9LCBvcHRpb25zLCBjb25maWcsIERFRkFVTFRfSU1BR0VfUEFSQU1TKTtcbiAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ2ZldGNoJykge1xuICAgIG9wdGlvbnMuZmV0Y2hfZm9ybWF0ID0gb3B0aW9ucy5mZXRjaF9mb3JtYXQgfHwgb3B0aW9ucy5mb3JtYXQ7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgVVJMIGZvciBhbnkgYXNzZXQgaW4geW91ciBNZWRpYSBsaWJyYXJ5LlxuICogQGZ1bmN0aW9uIHVybFxuICogQGlnbm9yZVxuICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIHB1YmxpYyBJRCBvZiB0aGUgbWVkaWEgYXNzZXQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycyB0byBpbmNsdWRlIGluIHRoZSBVUkwuXG4gKiBAcGFyYW0ge29iamVjdH0gW2NvbmZpZz17fV0gLSBVUkwgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge3R5cGV9IFtvcHRpb25zLnR5cGU9J3VwbG9hZCddIC0gVGhlIGFzc2V0J3Mgc3RvcmFnZSB0eXBlLlxuICogIEZvciBkZXRhaWxzIG9uIGFsbCBmZXRjaCB0eXBlcywgc2VlXG4gKiA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9ucyNmZXRjaGluZ19pbWFnZXNfZnJvbV9yZW1vdGVfbG9jYXRpb25zXCJcbiAqICB0YXJnZXQ9XCJfYmxhbmtcIj5GZXRjaCB0eXBlczwvYT4uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucmVzb3VyY2VfdHlwZT0naW1hZ2UnXSAtIFRoZSB0eXBlIG9mIGFzc2V0LiA8cD5Qb3NzaWJsZSB2YWx1ZXM6PGJyLz5cbiAqICAtIGBpbWFnZWA8YnIvPlxuICogIC0gYHZpZGVvYDxici8+XG4gKiAgLSBgcmF3YFxuICogQHBhcmFtIHtzaWduYXR1cmV9IFtvcHRpb25zLnNpZ25hdHVyZT0ncy0tMTIzNDU2NzgtLSddIC0gVGhlIHNpZ25hdHVyZSBjb21wb25lbnQgb2YgYVxuICogIHNpZ25lZCBkZWxpdmVyeSBVUkwgb2YgdGhlIGZvcm1hdDogL3MtLVNJR05BVFVSRS0tLy5cbiAqICBGb3IgZGV0YWlscyBvbiBzaWduYXR1cmVzLCBzZWVcbiAqIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc2lnbmF0dXJlc1wiIHRhcmdldD1cIl9ibGFua1wiPlNpZ25hdHVyZXM8L2E+LlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgbWVkaWEgYXNzZXQgVVJMLlxuICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gKiAgQXZhaWxhYmxlIHZpZGVvIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAqL1xuZnVuY3Rpb24gdXJsX3VybChwdWJsaWNJZCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBjb25maWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBpZiAoIXB1YmxpY0lkKSB7XG4gICAgcmV0dXJuIHB1YmxpY0lkO1xuICB9XG4gIG9wdGlvbnMgPSBwcmVwYXJlT3B0aW9ucyhvcHRpb25zLCBjb25maWcpO1xuICBwdWJsaWNJZCA9IHByZXBhcmVQdWJsaWNJZChwdWJsaWNJZCwgb3B0aW9ucyk7XG4gIHZhciBlcnJvciA9IHZhbGlkYXRlKG9wdGlvbnMpO1xuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICB2YXIgcmVzdWx0VXJsID0gdXJsU3RyaW5nKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMudXJsQW5hbHl0aWNzKSB7XG4gICAgdmFyIGFuYWx5dGljc09wdGlvbnMgPSBnZXRBbmFseXRpY3NPcHRpb25zKG9wdGlvbnMpO1xuICAgIHZhciBzZGtBbmFseXRpY3NTaWduYXR1cmUgPSBnZXRTREtBbmFseXRpY3NTaWduYXR1cmUoYW5hbHl0aWNzT3B0aW9ucyk7XG4gICAgLy8gdXJsIG1pZ2h0IGFscmVhZHkgaGF2ZSBhICc/JyBxdWVyeSBwYXJhbVxuICAgIHZhciBhcHBlbmRlciA9ICc/JztcbiAgICBpZiAocmVzdWx0VXJsLmluZGV4T2YoJz8nKSA+PSAwKSB7XG4gICAgICBhcHBlbmRlciA9ICcmJztcbiAgICB9XG4gICAgcmVzdWx0VXJsID0gXCJcIi5jb25jYXQocmVzdWx0VXJsKS5jb25jYXQoYXBwZW5kZXIsIFwiX2E9XCIpLmNvbmNhdChzZGtBbmFseXRpY3NTaWduYXR1cmUpO1xuICB9XG4gIGlmIChvcHRpb25zLmF1dGhfdG9rZW4pIHtcbiAgICB2YXIgX2FwcGVuZGVyID0gcmVzdWx0VXJsLmluZGV4T2YoJz8nKSA+PSAwID8gJyYnIDogJz8nO1xuICAgIHJlc3VsdFVybCA9IFwiXCIuY29uY2F0KHJlc3VsdFVybCkuY29uY2F0KF9hcHBlbmRlciwgXCJfX2NsZF90b2tlbl9fPVwiKS5jb25jYXQob3B0aW9ucy5hdXRoX3Rva2VuKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0VXJsO1xufVxuO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9nZW5lcmF0ZUJyZWFrcG9pbnRzLmpzXG5mdW5jdGlvbiBnZW5lcmF0ZUJyZWFrcG9pbnRzX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBnZW5lcmF0ZUJyZWFrcG9pbnRzX2FycmF5V2l0aEhvbGVzKGFycikgfHwgZ2VuZXJhdGVCcmVha3BvaW50c19pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IGdlbmVyYXRlQnJlYWtwb2ludHNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBnZW5lcmF0ZUJyZWFrcG9pbnRzX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBnZW5lcmF0ZUJyZWFrcG9pbnRzX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gZ2VuZXJhdGVCcmVha3BvaW50c191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGdlbmVyYXRlQnJlYWtwb2ludHNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGdlbmVyYXRlQnJlYWtwb2ludHNfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBnZW5lcmF0ZUJyZWFrcG9pbnRzX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIGdlbmVyYXRlQnJlYWtwb2ludHNfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cbmZ1bmN0aW9uIGdlbmVyYXRlQnJlYWtwb2ludHNfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uLiBHZXRzIG9yIHBvcHVsYXRlcyBzcmNzZXQgYnJlYWtwb2ludHMgdXNpbmcgcHJvdmlkZWQgcGFyYW1ldGVyc1xuICogRWl0aGVyIHRoZSBicmVha3BvaW50cyBvciBtaW5fd2lkdGgsIG1heF93aWR0aCwgbWF4X2ltYWdlcyBtdXN0IGJlIHByb3ZpZGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3NyY3NldH0gc3Jjc2V0IE9wdGlvbnMgd2l0aCBlaXRoZXIgYGJyZWFrcG9pbnRzYCBvciBgbWluX3dpZHRoYCwgYG1heF93aWR0aGAsIGFuZCBgbWF4X2ltYWdlc2BcbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJbXX0gQXJyYXkgb2YgYnJlYWtwb2ludHNcbiAqXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlQnJlYWtwb2ludHMoc3Jjc2V0KSB7XG4gIHZhciBicmVha3BvaW50cyA9IHNyY3NldC5icmVha3BvaW50cyB8fCBbXTtcbiAgaWYgKGJyZWFrcG9pbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBicmVha3BvaW50cztcbiAgfVxuICB2YXIgX21hcCA9IFtzcmNzZXQubWluX3dpZHRoLCBzcmNzZXQubWF4X3dpZHRoLCBzcmNzZXQubWF4X2ltYWdlc10ubWFwKE51bWJlciksXG4gICAgX21hcDIgPSBnZW5lcmF0ZUJyZWFrcG9pbnRzX3NsaWNlZFRvQXJyYXkoX21hcCwgMyksXG4gICAgbWluX3dpZHRoID0gX21hcDJbMF0sXG4gICAgbWF4X3dpZHRoID0gX21hcDJbMV0sXG4gICAgbWF4X2ltYWdlcyA9IF9tYXAyWzJdO1xuICBpZiAoW21pbl93aWR0aCwgbWF4X3dpZHRoLCBtYXhfaW1hZ2VzXS5zb21lKGlzTmFOKSkge1xuICAgIHRocm93ICdFaXRoZXIgKG1pbl93aWR0aCwgbWF4X3dpZHRoLCBtYXhfaW1hZ2VzKSAnICsgJ29yIGJyZWFrcG9pbnRzIG11c3QgYmUgcHJvdmlkZWQgdG8gdGhlIGltYWdlIHNyY3NldCBhdHRyaWJ1dGUnO1xuICB9XG4gIGlmIChtaW5fd2lkdGggPiBtYXhfd2lkdGgpIHtcbiAgICB0aHJvdyAnbWluX3dpZHRoIG11c3QgYmUgbGVzcyB0aGFuIG1heF93aWR0aCc7XG4gIH1cbiAgaWYgKG1heF9pbWFnZXMgPD0gMCkge1xuICAgIHRocm93ICdtYXhfaW1hZ2VzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJztcbiAgfSBlbHNlIGlmIChtYXhfaW1hZ2VzID09PSAxKSB7XG4gICAgbWluX3dpZHRoID0gbWF4X3dpZHRoO1xuICB9XG4gIHZhciBzdGVwU2l6ZSA9IE1hdGguY2VpbCgobWF4X3dpZHRoIC0gbWluX3dpZHRoKSAvIE1hdGgubWF4KG1heF9pbWFnZXMgLSAxLCAxKSk7XG4gIGZvciAodmFyIGN1cnJlbnQgPSBtaW5fd2lkdGg7IGN1cnJlbnQgPCBtYXhfd2lkdGg7IGN1cnJlbnQgKz0gc3RlcFNpemUpIHtcbiAgICBicmVha3BvaW50cy5wdXNoKGN1cnJlbnQpO1xuICB9XG4gIGJyZWFrcG9pbnRzLnB1c2gobWF4X3dpZHRoKTtcbiAgcmV0dXJuIGJyZWFrcG9pbnRzO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9zcmNzZXRVdGlscy5qc1xuXG52YXIgc3Jjc2V0VXRpbHNfaXNFbXB0eSA9IGlzRW1wdHk7XG5cblxuXG5cbi8qKlxuICogT3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSBzcmNzZXQgYXR0cmlidXRlLlxuICogQHR5cGVkZWYge29iamVjdH0gc3Jjc2V0XG4gKiBAcHJvcGVydHkgeyhudW1iZXJbXXxzdHJpbmdbXSl9ICAgW2JyZWFrcG9pbnRzXSBBbiBhcnJheSBvZiBicmVha3BvaW50cy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgICAgICAgICAgICAgICBbbWluX3dpZHRoXSAgIE1pbmltYWwgd2lkdGggb2YgdGhlIHNyY3NldCBpbWFnZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gICAgICAgICAgICAgICAgW21heF93aWR0aF0gICBNYXhpbWFsIHdpZHRoIG9mIHRoZSBzcmNzZXQgaW1hZ2VzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9ICAgICAgICAgICAgICAgIFttYXhfaW1hZ2VzXSAgTnVtYmVyIG9mIHNyY3NldCBpbWFnZXMgdG8gZ2VuZXJhdGUuXG4gKiBAcHJvcGVydHkge29iamVjdHxzdHJpbmd9ICAgICAgICAgW3RyYW5zZm9ybWF0aW9uXSBUaGUgdHJhbnNmb3JtYXRpb24gdG8gdXNlIGluIHRoZSBzcmNzZXQgdXJscy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gICAgICAgICAgICAgICBbc2l6ZXNdIFdoZXRoZXIgdG8gY2FsY3VsYXRlIGFuZCBhZGQgdGhlIHNpemVzIGF0dHJpYnV0ZS5cbiAqL1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbi4gR2VuZXJhdGVzIGEgc2luZ2xlIHNyY3NldCBpdGVtIHVybFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljX2lkICBQdWJsaWMgSUQgb2YgdGhlIHJlc291cmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoICAgICAgV2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBzcmNzZXQgaXRlbS5cbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gdHJhbnNmb3JtYXRpb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICAgIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJlc3VsdGluZyBVUkwgb2YgdGhlIGl0ZW1cbiAqL1xuZnVuY3Rpb24gc2NhbGVkVXJsKHB1YmxpY19pZCwgd2lkdGgsIHRyYW5zZm9ybWF0aW9uKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgdmFyIGNvbmZpZ1BhcmFtcyA9IGV4dHJhY3RVcmxQYXJhbXMob3B0aW9ucyk7XG4gIHRyYW5zZm9ybWF0aW9uID0gdHJhbnNmb3JtYXRpb24gfHwgb3B0aW9ucztcbiAgY29uZmlnUGFyYW1zLnJhd190cmFuc2Zvcm1hdGlvbiA9IG5ldyBzcmNfdHJhbnNmb3JtYXRpb24oW21lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdC5hKHt9LCB0cmFuc2Zvcm1hdGlvbiksIHtcbiAgICBjcm9wOiAnc2NhbGUnLFxuICAgIHdpZHRoOiB3aWR0aFxuICB9XSkudG9TdHJpbmcoKTtcbiAgcmV0dXJuIHVybF91cmwocHVibGljX2lkLCBjb25maWdQYXJhbXMpO1xufVxuXG4vKipcbiAqIElmIGNhY2hlIGlzIGVuYWJsZWQsIGdldCB0aGUgYnJlYWtwb2ludHMgZnJvbSB0aGUgY2FjaGUuIElmIHRoZSB2YWx1ZXMgd2VyZSBub3QgZm91bmQgaW4gdGhlIGNhY2hlLFxuICogb3IgY2FjaGUgaXMgbm90IGVuYWJsZWQsIGdlbmVyYXRlIHRoZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge3NyY3NldH0gc3Jjc2V0IFRoZSBzcmNzZXQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljX2lkXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7KnxBcnJheX1cbiAqL1xuZnVuY3Rpb24gZ2V0T3JHZW5lcmF0ZUJyZWFrcG9pbnRzKHB1YmxpY19pZCkge1xuICB2YXIgc3Jjc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICByZXR1cm4gZ2VuZXJhdGVCcmVha3BvaW50cyhzcmNzZXQpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbi4gR2VuZXJhdGVzIHNyY3NldCBhdHRyaWJ1dGUgdmFsdWUgb2YgdGhlIEhUTUwgaW1nIHRhZ1xuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljX2lkICBQdWJsaWMgSUQgb2YgdGhlIHJlc291cmNlXG4gKiBAcGFyYW0ge251bWJlcltdfSBicmVha3BvaW50cyBBbiBhcnJheSBvZiBicmVha3BvaW50cyAoaW4gcGl4ZWxzKVxuICogQHBhcmFtIHtvYmplY3R9IHRyYW5zZm9ybWF0aW9uIFRoZSB0cmFuc2Zvcm1hdGlvblxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgSW5jbHVkZXMgaHRtbCB0YWcgb3B0aW9ucywgdHJhbnNmb3JtYXRpb24gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfSBSZXN1bHRpbmcgc3Jjc2V0IGF0dHJpYnV0ZSB2YWx1ZVxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVNyY3NldEF0dHJpYnV0ZShwdWJsaWNfaWQsIGJyZWFrcG9pbnRzLCB0cmFuc2Zvcm1hdGlvbiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQuYShvcHRpb25zKTtcbiAgcGF0Y2hGZXRjaEZvcm1hdChvcHRpb25zKTtcbiAgcmV0dXJuIGJyZWFrcG9pbnRzLm1hcChmdW5jdGlvbiAod2lkdGgpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoc2NhbGVkVXJsKHB1YmxpY19pZCwgd2lkdGgsIHRyYW5zZm9ybWF0aW9uLCBvcHRpb25zKSwgXCIgXCIpLmNvbmNhdCh3aWR0aCwgXCJ3XCIpO1xuICB9KS5qb2luKCcsICcpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbi4gR2VuZXJhdGVzIHNpemVzIGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgSFRNTCBpbWcgdGFnXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJbXX0gYnJlYWtwb2ludHMgQW4gYXJyYXkgb2YgYnJlYWtwb2ludHMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJlc3VsdGluZyBzaXplcyBhdHRyaWJ1dGUgdmFsdWVcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVTaXplc0F0dHJpYnV0ZShicmVha3BvaW50cykge1xuICBpZiAoYnJlYWtwb2ludHMgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gYnJlYWtwb2ludHMubWFwKGZ1bmN0aW9uICh3aWR0aCkge1xuICAgIHJldHVybiBcIihtYXgtd2lkdGg6IFwiLmNvbmNhdCh3aWR0aCwgXCJweCkgXCIpLmNvbmNhdCh3aWR0aCwgXCJweFwiKTtcbiAgfSkuam9pbignLCAnKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24uIEdlbmVyYXRlcyBzcmNzZXQgYW5kIHNpemVzIGF0dHJpYnV0ZXMgb2YgdGhlIGltYWdlIHRhZ1xuICpcbiAqIEdlbmVyYXRlZCBhdHRyaWJ1dGVzIGFyZSBhZGRlZCB0byBhdHRyaWJ1dGVzIGFyZ3VtZW50XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICBwdWJsaWNJZCAgVGhlIHB1YmxpYyBJRCBvZiB0aGUgcmVzb3VyY2VcbiAqIEBwYXJhbSB7b2JqZWN0fSAgICBhdHRyaWJ1dGVzIEV4aXN0aW5nIEhUTUwgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7c3Jjc2V0fSAgICBzcmNzZXREYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gICAgb3B0aW9ucyAgICBBZGRpdGlvbmFsIG9wdGlvbnMuXG4gKlxuICogQHJldHVybiBhcnJheSBUaGUgcmVzcG9uc2l2ZSBhdHRyaWJ1dGVzXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VSZXNwb25zaXZlQXR0cmlidXRlcyhwdWJsaWNJZCkge1xuICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBzcmNzZXREYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAvLyBDcmVhdGUgYm90aCBzcmNzZXQgYW5kIHNpemVzIGhlcmUgdG8gYXZvaWQgZmV0Y2hpbmcgYnJlYWtwb2ludHMgdHdpY2VcblxuICB2YXIgcmVzcG9uc2l2ZUF0dHJpYnV0ZXMgPSB7fTtcbiAgaWYgKHNyY3NldFV0aWxzX2lzRW1wdHkoc3Jjc2V0RGF0YSkpIHtcbiAgICByZXR1cm4gcmVzcG9uc2l2ZUF0dHJpYnV0ZXM7XG4gIH1cbiAgdmFyIGdlbmVyYXRlU2l6ZXMgPSAhYXR0cmlidXRlcy5zaXplcyAmJiBzcmNzZXREYXRhLnNpemVzID09PSB0cnVlO1xuICB2YXIgZ2VuZXJhdGVTcmNzZXQgPSAhYXR0cmlidXRlcy5zcmNzZXQ7XG4gIGlmIChnZW5lcmF0ZVNyY3NldCB8fCBnZW5lcmF0ZVNpemVzKSB7XG4gICAgdmFyIGJyZWFrcG9pbnRzID0gZ2V0T3JHZW5lcmF0ZUJyZWFrcG9pbnRzKHB1YmxpY0lkLCBzcmNzZXREYXRhLCBvcHRpb25zKTtcbiAgICBpZiAoZ2VuZXJhdGVTcmNzZXQpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1hdGlvbiA9IHNyY3NldERhdGEudHJhbnNmb3JtYXRpb247XG4gICAgICB2YXIgc3Jjc2V0QXR0ciA9IGdlbmVyYXRlU3Jjc2V0QXR0cmlidXRlKHB1YmxpY0lkLCBicmVha3BvaW50cywgdHJhbnNmb3JtYXRpb24sIG9wdGlvbnMpO1xuICAgICAgaWYgKCFzcmNzZXRVdGlsc19pc0VtcHR5KHNyY3NldEF0dHIpKSB7XG4gICAgICAgIHJlc3BvbnNpdmVBdHRyaWJ1dGVzLnNyY3NldCA9IHNyY3NldEF0dHI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChnZW5lcmF0ZVNpemVzKSB7XG4gICAgICB2YXIgc2l6ZXNBdHRyID0gZ2VuZXJhdGVTaXplc0F0dHJpYnV0ZShicmVha3BvaW50cyk7XG4gICAgICBpZiAoIXNyY3NldFV0aWxzX2lzRW1wdHkoc2l6ZXNBdHRyKSkge1xuICAgICAgICByZXNwb25zaXZlQXR0cmlidXRlcy5zaXplcyA9IHNpemVzQXR0cjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNpdmVBdHRyaWJ1dGVzO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgbWVkaWEgcXVlcnlcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG9wdGlvbnMubWluX3dpZHRoXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG9wdGlvbnMubWF4X3dpZHRoXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGEgbWVkaWEgcXVlcnkgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlTWVkaWFBdHRyKG9wdGlvbnMpIHtcbiAgdmFyIG1lZGlhUXVlcnkgPSBbXTtcbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgIGlmIChvcHRpb25zLm1pbl93aWR0aCAhPSBudWxsKSB7XG4gICAgICBtZWRpYVF1ZXJ5LnB1c2goXCIobWluLXdpZHRoOiBcIi5jb25jYXQob3B0aW9ucy5taW5fd2lkdGgsIFwicHgpXCIpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubWF4X3dpZHRoICE9IG51bGwpIHtcbiAgICAgIG1lZGlhUXVlcnkucHVzaChcIihtYXgtd2lkdGg6IFwiLmNvbmNhdChvcHRpb25zLm1heF93aWR0aCwgXCJweClcIikpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVkaWFRdWVyeS5qb2luKCcgYW5kICcpO1xufVxudmFyIHNyY3NldFVybCA9IHNjYWxlZFVybDtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3RhZ3MvaW1hZ2V0YWcuanNcbmZ1bmN0aW9uIGltYWdldGFnX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIGltYWdldGFnX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBpbWFnZXRhZ190eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIGltYWdldGFnX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIGltYWdldGFnX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBpbWFnZXRhZ190b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gaW1hZ2V0YWdfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBpbWFnZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgaW1hZ2V0YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIGltYWdldGFnX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IGltYWdldGFnX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBpbWFnZXRhZ190eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIGltYWdldGFnX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gaW1hZ2V0YWdfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IGltYWdldGFnX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBpbWFnZXRhZ19jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IGltYWdldGFnX2dldFByb3RvdHlwZU9mKG8pLCBpbWFnZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIGltYWdldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgaW1hZ2V0YWdfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIGltYWdldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoaW1hZ2V0YWdfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIGltYWdldGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gaW1hZ2V0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIGltYWdldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKGltYWdldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIGltYWdldGFnX2dldCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IGltYWdldGFnX2dldCA9IFJlZmxlY3QuZ2V0LmJpbmQoKTsgfSBlbHNlIHsgaW1hZ2V0YWdfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IGltYWdldGFnX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIGltYWdldGFnX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBpbWFnZXRhZ19zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gaW1hZ2V0YWdfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuZnVuY3Rpb24gaW1hZ2V0YWdfZ2V0UHJvdG90eXBlT2YobykgeyBpbWFnZXRhZ19nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gaW1hZ2V0YWdfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIGltYWdldGFnX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIGltYWdldGFnX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gaW1hZ2V0YWdfc2V0UHJvdG90eXBlT2YobywgcCkgeyBpbWFnZXRhZ19zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gaW1hZ2V0YWdfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbi8qKlxuICogSW1hZ2UgVGFnXG4gKiBEZXBlbmRzIG9uICd0YWdzL2h0bWx0YWcnLCAnY2xvdWRpbmFyeSdcbiAqL1xuXG5cblxuXG5cblxuLyoqXG4gKiBDcmVhdGVzIGFuIEhUTUwgKERPTSkgSW1hZ2UgdGFnIHVzaW5nIENsb3VkaW5hcnkgYXMgdGhlIHNvdXJjZS5cbiAqIEBjb25zdHJ1Y3RvciBJbWFnZVRhZ1xuICogQGV4dGVuZHMgSHRtbFRhZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtwdWJsaWNJZF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqL1xudmFyIGltYWdldGFnX0ltYWdlVGFnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSHRtbFRhZykge1xuICBmdW5jdGlvbiBJbWFnZVRhZyhwdWJsaWNJZCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBpbWFnZXRhZ19jbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZVRhZyk7XG4gICAgcmV0dXJuIGltYWdldGFnX2NhbGxTdXBlcih0aGlzLCBJbWFnZVRhZywgW1wiaW1nXCIsIHB1YmxpY0lkLCBvcHRpb25zXSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGltYWdldGFnX2luaGVyaXRzKEltYWdlVGFnLCBfSHRtbFRhZyk7XG4gIHJldHVybiBpbWFnZXRhZ19jcmVhdGVDbGFzcyhJbWFnZVRhZywgW3tcbiAgICBrZXk6IFwiY2xvc2VUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VUYWcoKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICAvKiogQG92ZXJyaWRlICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYXR0cmlidXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVzKCkge1xuICAgICAgdmFyIGF0dHIsIG9wdGlvbnMsIHNyY0F0dHJpYnV0ZTtcbiAgICAgIGF0dHIgPSBpbWFnZXRhZ19nZXQoaW1hZ2V0YWdfZ2V0UHJvdG90eXBlT2YoSW1hZ2VUYWcucHJvdG90eXBlKSwgXCJhdHRyaWJ1dGVzXCIsIHRoaXMpLmNhbGwodGhpcykgfHwge307XG4gICAgICBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuZ2V0T3B0aW9uKCdhdHRyaWJ1dGVzJykgfHwge307XG4gICAgICB2YXIgc3Jjc2V0UGFyYW0gPSB0aGlzLmdldE9wdGlvbignc3Jjc2V0JykgfHwgYXR0cmlidXRlcy5zcmNzZXQ7XG4gICAgICB2YXIgcmVzcG9uc2l2ZUF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgIGlmIChpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKShzcmNzZXRQYXJhbSkpIHtcbiAgICAgICAgcmVzcG9uc2l2ZUF0dHJpYnV0ZXMuc3Jjc2V0ID0gc3Jjc2V0UGFyYW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwb25zaXZlQXR0cmlidXRlcyA9IGdlbmVyYXRlSW1hZ2VSZXNwb25zaXZlQXR0cmlidXRlcyh0aGlzLnB1YmxpY0lkLCBhdHRyaWJ1dGVzLCBzcmNzZXRQYXJhbSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzRW1wdHkocmVzcG9uc2l2ZUF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIGRlbGV0ZSBhdHRyLndpZHRoO1xuICAgICAgICBkZWxldGUgYXR0ci5oZWlnaHQ7XG4gICAgICB9XG4gICAgICBtZXJnZV9yb290X21lcmdlX2RlZmF1bHQoKShhdHRyLCByZXNwb25zaXZlQXR0cmlidXRlcyk7XG4gICAgICBzcmNBdHRyaWJ1dGUgPSBvcHRpb25zLnJlc3BvbnNpdmUgJiYgIW9wdGlvbnMuY2xpZW50X2hpbnRzID8gJ2RhdGEtc3JjJyA6ICdzcmMnO1xuICAgICAgaWYgKGF0dHJbc3JjQXR0cmlidXRlXSA9PSBudWxsKSB7XG4gICAgICAgIGF0dHJbc3JjQXR0cmlidXRlXSA9IHVybF91cmwodGhpcy5wdWJsaWNJZCwgdGhpcy5nZXRPcHRpb25zKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfVxuICB9XSk7XG59KGh0bWx0YWcpO1xuO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaW1hZ2V0YWcgPSAoaW1hZ2V0YWdfSW1hZ2VUYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdGFncy9zb3VyY2V0YWcuanNcbmZ1bmN0aW9uIHNvdXJjZXRhZ190eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBzb3VyY2V0YWdfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIHNvdXJjZXRhZ190eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIHNvdXJjZXRhZ19jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBzb3VyY2V0YWdfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHNvdXJjZXRhZ190b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gc291cmNldGFnX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgc291cmNldGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBzb3VyY2V0YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIHNvdXJjZXRhZ190b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBzb3VyY2V0YWdfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHNvdXJjZXRhZ190eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIHNvdXJjZXRhZ190b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHNvdXJjZXRhZ190eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gc291cmNldGFnX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBzb3VyY2V0YWdfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2YobyksIHNvdXJjZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIHNvdXJjZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIHNvdXJjZXRhZ19nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gc291cmNldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoc291cmNldGFnX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBzb3VyY2V0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBzb3VyY2V0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIHNvdXJjZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChzb3VyY2V0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gc291cmNldGFnX2dldCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IHNvdXJjZXRhZ19nZXQgPSBSZWZsZWN0LmdldC5iaW5kKCk7IH0gZWxzZSB7IHNvdXJjZXRhZ19nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gc291cmNldGFnX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIHNvdXJjZXRhZ19nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gc291cmNldGFnX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuZnVuY3Rpb24gc291cmNldGFnX2dldFByb3RvdHlwZU9mKG8pIHsgc291cmNldGFnX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIHNvdXJjZXRhZ19pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBzb3VyY2V0YWdfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBzb3VyY2V0YWdfc2V0UHJvdG90eXBlT2YobywgcCkgeyBzb3VyY2V0YWdfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIHNvdXJjZXRhZ19zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuLyoqXG4gKiBJbWFnZSBUYWdcbiAqIERlcGVuZHMgb24gJ3RhZ3MvaHRtbHRhZycsICdjbG91ZGluYXJ5J1xuICovXG5cblxuXG5cblxuLyoqXG4gKiBDcmVhdGVzIGFuIEhUTUwgKERPTSkgSW1hZ2UgdGFnIHVzaW5nIENsb3VkaW5hcnkgYXMgdGhlIHNvdXJjZS5cbiAqIEBjb25zdHJ1Y3RvciBTb3VyY2VUYWdcbiAqIEBleHRlbmRzIEh0bWxUYWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHVibGljSWRdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKi9cbnZhciBzb3VyY2V0YWdfU291cmNlVGFnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSHRtbFRhZykge1xuICBmdW5jdGlvbiBTb3VyY2VUYWcocHVibGljSWQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgc291cmNldGFnX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvdXJjZVRhZyk7XG4gICAgcmV0dXJuIHNvdXJjZXRhZ19jYWxsU3VwZXIodGhpcywgU291cmNlVGFnLCBbXCJzb3VyY2VcIiwgcHVibGljSWQsIG9wdGlvbnNdKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgc291cmNldGFnX2luaGVyaXRzKFNvdXJjZVRhZywgX0h0bWxUYWcpO1xuICByZXR1cm4gc291cmNldGFnX2NyZWF0ZUNsYXNzKFNvdXJjZVRhZywgW3tcbiAgICBrZXk6IFwiY2xvc2VUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VUYWcoKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICAvKiogQG92ZXJyaWRlICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYXR0cmlidXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVzKCkge1xuICAgICAgdmFyIHNyY3NldFBhcmFtID0gdGhpcy5nZXRPcHRpb24oJ3NyY3NldCcpO1xuICAgICAgdmFyIGF0dHIgPSBzb3VyY2V0YWdfZ2V0KHNvdXJjZXRhZ19nZXRQcm90b3R5cGVPZihTb3VyY2VUYWcucHJvdG90eXBlKSwgXCJhdHRyaWJ1dGVzXCIsIHRoaXMpLmNhbGwodGhpcykgfHwge307XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgbWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0KCkoYXR0ciwgZ2VuZXJhdGVJbWFnZVJlc3BvbnNpdmVBdHRyaWJ1dGVzKHRoaXMucHVibGljSWQsIGF0dHIsIHNyY3NldFBhcmFtLCBvcHRpb25zKSk7XG4gICAgICBpZiAoIWF0dHIuc3Jjc2V0KSB7XG4gICAgICAgIGF0dHIuc3Jjc2V0ID0gdXJsX3VybCh0aGlzLnB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICghYXR0ci5tZWRpYSAmJiBvcHRpb25zLm1lZGlhKSB7XG4gICAgICAgIGF0dHIubWVkaWEgPSBnZW5lcmF0ZU1lZGlhQXR0cihvcHRpb25zLm1lZGlhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyO1xuICAgIH1cbiAgfV0pO1xufShodG1sdGFnKTtcbjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNvdXJjZXRhZyA9IChzb3VyY2V0YWdfU291cmNlVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3RhZ3MvcGljdHVyZXRhZy5qc1xuZnVuY3Rpb24gcGljdHVyZXRhZ190eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBwaWN0dXJldGFnX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBwaWN0dXJldGFnX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gcGljdHVyZXRhZ19jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBwaWN0dXJldGFnX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwaWN0dXJldGFnX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBwaWN0dXJldGFnX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgcGljdHVyZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgcGljdHVyZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gcGljdHVyZXRhZ190b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBwaWN0dXJldGFnX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBwaWN0dXJldGFnX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gcGljdHVyZXRhZ190b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHBpY3R1cmV0YWdfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IHBpY3R1cmV0YWdfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBwaWN0dXJldGFnX2dldFByb3RvdHlwZU9mKG8pLCBwaWN0dXJldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgcGljdHVyZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIHBpY3R1cmV0YWdfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChwaWN0dXJldGFnX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBwaWN0dXJldGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gcGljdHVyZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gcGljdHVyZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChwaWN0dXJldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfZ2V0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgcGljdHVyZXRhZ19nZXQgPSBSZWZsZWN0LmdldC5iaW5kKCk7IH0gZWxzZSB7IHBpY3R1cmV0YWdfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IHBpY3R1cmV0YWdfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gcGljdHVyZXRhZ19nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gcGljdHVyZXRhZ19zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gcGljdHVyZXRhZ19nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5mdW5jdGlvbiBwaWN0dXJldGFnX2dldFByb3RvdHlwZU9mKG8pIHsgcGljdHVyZXRhZ19nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gcGljdHVyZXRhZ19nZXRQcm90b3R5cGVPZihvKTsgfVxuZnVuY3Rpb24gcGljdHVyZXRhZ19pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBwaWN0dXJldGFnX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gcGljdHVyZXRhZ19zZXRQcm90b3R5cGVPZihvLCBwKSB7IHBpY3R1cmV0YWdfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIHBpY3R1cmV0YWdfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuXG5cblxuXG52YXIgcGljdHVyZXRhZ19QaWN0dXJlVGFnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSHRtbFRhZykge1xuICBmdW5jdGlvbiBQaWN0dXJlVGFnKHB1YmxpY0lkKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgc291cmNlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW107XG4gICAgcGljdHVyZXRhZ19jbGFzc0NhbGxDaGVjayh0aGlzLCBQaWN0dXJlVGFnKTtcbiAgICBfdGhpcyA9IHBpY3R1cmV0YWdfY2FsbFN1cGVyKHRoaXMsIFBpY3R1cmVUYWcsIFsncGljdHVyZScsIHB1YmxpY0lkLCBvcHRpb25zXSk7XG4gICAgX3RoaXMud2lkdGhMaXN0ID0gc291cmNlcztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIHBpY3R1cmV0YWdfaW5oZXJpdHMoUGljdHVyZVRhZywgX0h0bWxUYWcpO1xuICByZXR1cm4gcGljdHVyZXRhZ19jcmVhdGVDbGFzcyhQaWN0dXJlVGFnLCBbe1xuICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRlbnQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLndpZHRoTGlzdC5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIG1pbl93aWR0aCA9IF9yZWYubWluX3dpZHRoLFxuICAgICAgICAgIG1heF93aWR0aCA9IF9yZWYubWF4X3dpZHRoLFxuICAgICAgICAgIHRyYW5zZm9ybWF0aW9uID0gX3JlZi50cmFuc2Zvcm1hdGlvbjtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBfdGhpczIuZ2V0T3B0aW9ucygpO1xuICAgICAgICB2YXIgc291cmNlVHJhbnNmb3JtYXRpb24gPSBuZXcgc3JjX3RyYW5zZm9ybWF0aW9uKG9wdGlvbnMpO1xuICAgICAgICBzb3VyY2VUcmFuc2Zvcm1hdGlvbi5jaGFpbigpLmZyb21PcHRpb25zKHR5cGVvZiB0cmFuc2Zvcm1hdGlvbiA9PT0gJ3N0cmluZycgPyB7XG4gICAgICAgICAgcmF3X3RyYW5zZm9ybWF0aW9uOiB0cmFuc2Zvcm1hdGlvblxuICAgICAgICB9IDogdHJhbnNmb3JtYXRpb24pO1xuICAgICAgICBvcHRpb25zID0gZXh0cmFjdFVybFBhcmFtcyhvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5tZWRpYSA9IHtcbiAgICAgICAgICBtaW5fd2lkdGg6IG1pbl93aWR0aCxcbiAgICAgICAgICBtYXhfd2lkdGg6IG1heF93aWR0aFxuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zLnRyYW5zZm9ybWF0aW9uID0gc291cmNlVHJhbnNmb3JtYXRpb247XG4gICAgICAgIHJldHVybiBuZXcgc291cmNldGFnKF90aGlzMi5wdWJsaWNJZCwgb3B0aW9ucykudG9IdG1sKCk7XG4gICAgICB9KS5qb2luKCcnKSArIG5ldyBpbWFnZXRhZyh0aGlzLnB1YmxpY0lkLCB0aGlzLmdldE9wdGlvbnMoKSkudG9IdG1sKCk7XG4gICAgfVxuXG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICB9LCB7XG4gICAga2V5OiBcImF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlcygpIHtcbiAgICAgIHZhciBhdHRyID0gcGljdHVyZXRhZ19nZXQocGljdHVyZXRhZ19nZXRQcm90b3R5cGVPZihQaWN0dXJlVGFnLnByb3RvdHlwZSksIFwiYXR0cmlidXRlc1wiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgZGVsZXRlIGF0dHIud2lkdGg7XG4gICAgICBkZWxldGUgYXR0ci5oZWlnaHQ7XG4gICAgICByZXR1cm4gYXR0cjtcbiAgICB9XG5cbiAgICAvKiogQG92ZXJyaWRlICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VUYWcoKSB7XG4gICAgICByZXR1cm4gXCI8L1wiICsgdGhpcy5uYW1lICsgXCI+XCI7XG4gICAgfVxuICB9XSk7XG59KGh0bWx0YWcpO1xuO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcGljdHVyZXRhZyA9IChwaWN0dXJldGFnX1BpY3R1cmVUYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdGFncy92aWRlb3RhZy5qc1xuZnVuY3Rpb24gdmlkZW90YWdfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gdmlkZW90YWdfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIHZpZGVvdGFnX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gdmlkZW90YWdfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gdmlkZW90YWdfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHZpZGVvdGFnX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiB2aWRlb3RhZ19jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIHZpZGVvdGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSB2aWRlb3RhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gdmlkZW90YWdfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gdmlkZW90YWdfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHZpZGVvdGFnX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gdmlkZW90YWdfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSB2aWRlb3RhZ190eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gdmlkZW90YWdfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIHZpZGVvdGFnX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gdmlkZW90YWdfZ2V0UHJvdG90eXBlT2YobyksIHZpZGVvdGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgdmlkZW90YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCB2aWRlb3RhZ19nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gdmlkZW90YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmICh2aWRlb3RhZ190eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gdmlkZW90YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiB2aWRlb3RhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gdmlkZW90YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAodmlkZW90YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gdmlkZW90YWdfZ2V0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgdmlkZW90YWdfZ2V0ID0gUmVmbGVjdC5nZXQuYmluZCgpOyB9IGVsc2UgeyB2aWRlb3RhZ19nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gdmlkZW90YWdfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gdmlkZW90YWdfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIHZpZGVvdGFnX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSB2aWRlb3RhZ19nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5mdW5jdGlvbiB2aWRlb3RhZ19nZXRQcm90b3R5cGVPZihvKSB7IHZpZGVvdGFnX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiB2aWRlb3RhZ19nZXRQcm90b3R5cGVPZihvKTsgfVxuZnVuY3Rpb24gdmlkZW90YWdfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgdmlkZW90YWdfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiB2aWRlb3RhZ19zZXRQcm90b3R5cGVPZihvLCBwKSB7IHZpZGVvdGFnX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiB2aWRlb3RhZ19zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuLyoqXG4gKiBWaWRlbyBUYWdcbiAqIERlcGVuZHMgb24gJ3RhZ3MvaHRtbHRhZycsICd1dGlsJywgJ2Nsb3VkaW5hcnknXG4gKi9cblxuXG5cblxuXG52YXIgVklERU9fVEFHX1BBUkFNUyA9IFsnc291cmNlX3R5cGVzJywgJ3NvdXJjZV90cmFuc2Zvcm1hdGlvbicsICdmYWxsYmFja19jb250ZW50JywgJ3Bvc3RlcicsICdzb3VyY2VzJ107XG52YXIgdmlkZW90YWdfREVGQVVMVF9WSURFT19TT1VSQ0VfVFlQRVMgPSBbJ3dlYm0nLCAnbXA0JywgJ29ndiddO1xudmFyIHZpZGVvdGFnX0RFRkFVTFRfUE9TVEVSX09QVElPTlMgPSB7XG4gIGZvcm1hdDogJ2pwZycsXG4gIHJlc291cmNlX3R5cGU6ICd2aWRlbydcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBIVE1MIChET00pIFZpZGVvIHRhZyB1c2luZyBDbG91ZGluYXJ5IGFzIHRoZSBzb3VyY2UuXG4gKiBAY29uc3RydWN0b3IgVmlkZW9UYWdcbiAqIEBleHRlbmRzIEh0bWxUYWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHVibGljSWRdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKi9cbnZhciB2aWRlb3RhZ19WaWRlb1RhZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0h0bWxUYWcpIHtcbiAgZnVuY3Rpb24gVmlkZW9UYWcocHVibGljSWQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmlkZW90YWdfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlkZW9UYWcpO1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucywgREVGQVVMVF9WSURFT19QQVJBTVMpO1xuICAgIHJldHVybiB2aWRlb3RhZ19jYWxsU3VwZXIodGhpcywgVmlkZW9UYWcsIFtcInZpZGVvXCIsIHB1YmxpY0lkLnJlcGxhY2UoL1xcLihtcDR8b2d2fHdlYm0pJC8sICcnKSwgb3B0aW9uc10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdHJhbnNmb3JtYXRpb24gdG8gYXBwbHkgb24gZWFjaCBzb3VyY2VcbiAgICogQGZ1bmN0aW9uIFZpZGVvVGFnI3NldFNvdXJjZVRyYW5zZm9ybWF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBwYWlycyBvZiBzb3VyY2UgdHlwZSBhbmQgc291cmNlIHRyYW5zZm9ybWF0aW9uXG4gICAqIEByZXR1cm5zIHtWaWRlb1RhZ30gUmV0dXJucyB0aGlzIGluc3RhbmNlIGZvciBjaGFpbmluZyBwdXJwb3Nlcy5cbiAgICovXG4gIHZpZGVvdGFnX2luaGVyaXRzKFZpZGVvVGFnLCBfSHRtbFRhZyk7XG4gIHJldHVybiB2aWRlb3RhZ19jcmVhdGVDbGFzcyhWaWRlb1RhZywgW3tcbiAgICBrZXk6IFwic2V0U291cmNlVHJhbnNmb3JtYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U291cmNlVHJhbnNmb3JtYXRpb24odmFsdWUpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtYXRpb24oKS5zb3VyY2VUcmFuc2Zvcm1hdGlvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNvdXJjZSB0eXBlcyB0byBpbmNsdWRlIGluIHRoZSB2aWRlbyB0YWdcbiAgICAgKiBAZnVuY3Rpb24gVmlkZW9UYWcjc2V0U291cmNlVHlwZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGFuIGFycmF5IG9mIHNvdXJjZSB0eXBlc1xuICAgICAqIEByZXR1cm5zIHtWaWRlb1RhZ30gUmV0dXJucyB0aGlzIGluc3RhbmNlIGZvciBjaGFpbmluZyBwdXJwb3Nlcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRTb3VyY2VUeXBlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTb3VyY2VUeXBlcyh2YWx1ZSkge1xuICAgICAgdGhpcy50cmFuc2Zvcm1hdGlvbigpLnNvdXJjZVR5cGVzKHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcG9zdGVyIHRvIGJlIHVzZWQgaW4gdGhlIHZpZGVvIHRhZ1xuICAgICAqIEBmdW5jdGlvbiBWaWRlb1RhZyNzZXRQb3N0ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IHZhbHVlXG4gICAgICogLSBzdHJpbmc6IGEgVVJMIHRvIHVzZSBmb3IgdGhlIHBvc3RlclxuICAgICAqIC0gT2JqZWN0OiB0cmFuc2Zvcm1hdGlvbiBwYXJhbWV0ZXJzIHRvIGFwcGx5IHRvIHRoZSBwb3N0ZXIuIE1heSBvcHRpb25hbGx5IGluY2x1ZGUgYSBwdWJsaWNfaWQgdG8gdXNlIGluc3RlYWQgb2YgdGhlIHZpZGVvIHB1YmxpY19pZC5cbiAgICAgKiBAcmV0dXJucyB7VmlkZW9UYWd9IFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmcgcHVycG9zZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UG9zdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBvc3Rlcih2YWx1ZSkge1xuICAgICAgdGhpcy50cmFuc2Zvcm1hdGlvbigpLnBvc3Rlcih2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNvbnRlbnQgdG8gdXNlIGFzIGZhbGxiYWNrIGluIHRoZSB2aWRlbyB0YWdcbiAgICAgKiBAZnVuY3Rpb24gVmlkZW9UYWcjc2V0RmFsbGJhY2tDb250ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gdGhlIGNvbnRlbnQgdG8gdXNlLCBpbiBIVE1MIGZvcm1hdFxuICAgICAqIEByZXR1cm5zIHtWaWRlb1RhZ30gUmV0dXJucyB0aGlzIGluc3RhbmNlIGZvciBjaGFpbmluZyBwdXJwb3Nlcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRGYWxsYmFja0NvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RmFsbGJhY2tDb250ZW50KHZhbHVlKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybWF0aW9uKCkuZmFsbGJhY2tDb250ZW50KHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRlbnQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIHNvdXJjZVR5cGVzID0gdGhpcy50cmFuc2Zvcm1hdGlvbigpLmdldFZhbHVlKCdzb3VyY2VfdHlwZXMnKTtcbiAgICAgIHZhciBzb3VyY2VUcmFuc2Zvcm1hdGlvbiA9IHRoaXMudHJhbnNmb3JtYXRpb24oKS5nZXRWYWx1ZSgnc291cmNlX3RyYW5zZm9ybWF0aW9uJyk7XG4gICAgICB2YXIgZmFsbGJhY2sgPSB0aGlzLnRyYW5zZm9ybWF0aW9uKCkuZ2V0VmFsdWUoJ2ZhbGxiYWNrX2NvbnRlbnQnKTtcbiAgICAgIHZhciBzb3VyY2VzID0gdGhpcy5nZXRPcHRpb24oJ3NvdXJjZXMnKTtcbiAgICAgIHZhciBpbm5lclRhZ3MgPSBbXTtcbiAgICAgIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkoc291cmNlcykgJiYgIWlzRW1wdHkoc291cmNlcykpIHtcbiAgICAgICAgaW5uZXJUYWdzID0gc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgIHZhciBzcmMgPSB1cmxfdXJsKF90aGlzLnB1YmxpY0lkLCBkZWZhdWx0cyh7fSwgc291cmNlLnRyYW5zZm9ybWF0aW9ucyB8fCB7fSwge1xuICAgICAgICAgICAgcmVzb3VyY2VfdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgICAgIGZvcm1hdDogc291cmNlLnR5cGVcbiAgICAgICAgICB9KSwgX3RoaXMuZ2V0T3B0aW9ucygpKTtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuY3JlYXRlU291cmNlVGFnKHNyYywgc291cmNlLnR5cGUsIHNvdXJjZS5jb2RlY3MpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0VtcHR5KHNvdXJjZVR5cGVzKSkge1xuICAgICAgICAgIHNvdXJjZVR5cGVzID0gdmlkZW90YWdfREVGQVVMVF9WSURFT19TT1VSQ0VfVFlQRVM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShzb3VyY2VUeXBlcykpIHtcbiAgICAgICAgICBpbm5lclRhZ3MgPSBzb3VyY2VUeXBlcy5tYXAoZnVuY3Rpb24gKHNyY1R5cGUpIHtcbiAgICAgICAgICAgIHZhciBzcmMgPSB1cmxfdXJsKF90aGlzLnB1YmxpY0lkLCBkZWZhdWx0cyh7fSwgc291cmNlVHJhbnNmb3JtYXRpb25bc3JjVHlwZV0gfHwge30sIHtcbiAgICAgICAgICAgICAgcmVzb3VyY2VfdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgICAgICAgZm9ybWF0OiBzcmNUeXBlXG4gICAgICAgICAgICB9KSwgX3RoaXMuZ2V0T3B0aW9ucygpKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jcmVhdGVTb3VyY2VUYWcoc3JjLCBzcmNUeXBlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlubmVyVGFncy5qb2luKCcnKSArIGZhbGxiYWNrO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhdHRyaWJ1dGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZXMoKSB7XG4gICAgICB2YXIgc291cmNlVHlwZXMgPSB0aGlzLmdldE9wdGlvbignc291cmNlX3R5cGVzJyk7XG4gICAgICB2YXIgcG9zdGVyID0gdGhpcy5nZXRPcHRpb24oJ3Bvc3RlcicpO1xuICAgICAgaWYgKHBvc3RlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvc3RlciA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKShwb3N0ZXIpKSB7XG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHBvc3Rlci5wdWJsaWNfaWQgIT0gbnVsbCA/IERFRkFVTFRfSU1BR0VfUEFSQU1TIDogdmlkZW90YWdfREVGQVVMVF9QT1NURVJfT1BUSU9OUztcbiAgICAgICAgcG9zdGVyID0gdXJsX3VybChwb3N0ZXIucHVibGljX2lkIHx8IHRoaXMucHVibGljSWQsIGRlZmF1bHRzKHt9LCBwb3N0ZXIsIGRlZmF1bHRPcHRpb25zLCB0aGlzLmdldE9wdGlvbnMoKSkpO1xuICAgICAgfVxuICAgICAgdmFyIGF0dHIgPSB2aWRlb3RhZ19nZXQodmlkZW90YWdfZ2V0UHJvdG90eXBlT2YoVmlkZW9UYWcucHJvdG90eXBlKSwgXCJhdHRyaWJ1dGVzXCIsIHRoaXMpLmNhbGwodGhpcykgfHwge307XG4gICAgICBhdHRyID0gb21pdChhdHRyLCBWSURFT19UQUdfUEFSQU1TKTtcbiAgICAgIHZhciBzb3VyY2VzID0gdGhpcy5nZXRPcHRpb24oJ3NvdXJjZXMnKTtcbiAgICAgIC8vIEluIGNhc2Ugb2YgZW1wdHkgc291cmNlVHlwZXMgLSBmYWxsYmFjayB0byBkZWZhdWx0IHNvdXJjZSB0eXBlcyBpcyB1c2VkLlxuICAgICAgdmFyIGhhc1NvdXJjZVRhZ3MgPSAhaXNFbXB0eShzb3VyY2VzKSB8fCBpc0VtcHR5KHNvdXJjZVR5cGVzKSB8fCBpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkoc291cmNlVHlwZXMpO1xuICAgICAgaWYgKCFoYXNTb3VyY2VUYWdzKSB7XG4gICAgICAgIGF0dHJbXCJzcmNcIl0gPSB1cmxfdXJsKHRoaXMucHVibGljSWQsIHRoaXMuZ2V0T3B0aW9ucygpLCB7XG4gICAgICAgICAgcmVzb3VyY2VfdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgICBmb3JtYXQ6IHNvdXJjZVR5cGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHBvc3RlciAhPSBudWxsKSB7XG4gICAgICAgIGF0dHJbXCJwb3N0ZXJcIl0gPSBwb3N0ZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlU291cmNlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVNvdXJjZVRhZyhzcmMsIHNvdXJjZVR5cGUpIHtcbiAgICAgIHZhciBjb2RlY3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgICB2YXIgbWltZVR5cGUgPSBudWxsO1xuICAgICAgaWYgKCFpc0VtcHR5KHNvdXJjZVR5cGUpKSB7XG4gICAgICAgIHZhciB2aWRlb1R5cGUgPSBzb3VyY2VUeXBlID09PSAnb2d2JyA/ICdvZ2cnIDogc291cmNlVHlwZTtcbiAgICAgICAgbWltZVR5cGUgPSAndmlkZW8vJyArIHZpZGVvVHlwZTtcbiAgICAgICAgaWYgKCFpc0VtcHR5KGNvZGVjcykpIHtcbiAgICAgICAgICB2YXIgY29kZWNzU3RyID0gaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKGNvZGVjcykgPyBjb2RlY3Muam9pbignLCAnKSA6IGNvZGVjcztcbiAgICAgICAgICBtaW1lVHlwZSArPSAnOyBjb2RlY3M9JyArIGNvZGVjc1N0cjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFwiPHNvdXJjZSBcIiArIHRoaXMuaHRtbEF0dHJzKHtcbiAgICAgICAgc3JjOiBzcmMsXG4gICAgICAgIHR5cGU6IG1pbWVUeXBlXG4gICAgICB9KSArIFwiPlwiO1xuICAgIH1cbiAgfV0pO1xufShodG1sdGFnKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHZpZGVvdGFnID0gKHZpZGVvdGFnX1ZpZGVvVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3RhZ3MvY2xpZW50aGludHNtZXRhdGFnLmpzXG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gY2xpZW50aGludHNtZXRhdGFnX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBjbGllbnRoaW50c21ldGF0YWdfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjbGllbnRoaW50c21ldGF0YWdfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGNsaWVudGhpbnRzbWV0YXRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgY2xpZW50aGludHNtZXRhdGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gY2xpZW50aGludHNtZXRhdGFnX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBjbGllbnRoaW50c21ldGF0YWdfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBjbGllbnRoaW50c21ldGF0YWdfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IGNsaWVudGhpbnRzbWV0YXRhZ190eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gY2xpZW50aGludHNtZXRhdGFnX2dldFByb3RvdHlwZU9mKG8pLCBjbGllbnRoaW50c21ldGF0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBjbGllbnRoaW50c21ldGF0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBjbGllbnRoaW50c21ldGF0YWdfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKGNsaWVudGhpbnRzbWV0YXRhZ190eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gY2xpZW50aGludHNtZXRhdGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoY2xpZW50aGludHNtZXRhdGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19nZXRQcm90b3R5cGVPZihvKSB7IGNsaWVudGhpbnRzbWV0YXRhZ19nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gY2xpZW50aGludHNtZXRhdGFnX2dldFByb3RvdHlwZU9mKG8pOyB9XG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgY2xpZW50aGludHNtZXRhdGFnX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX3NldFByb3RvdHlwZU9mKG8sIHApIHsgY2xpZW50aGludHNtZXRhdGFnX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBjbGllbnRoaW50c21ldGF0YWdfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbi8qKlxuICogSW1hZ2UgVGFnXG4gKiBEZXBlbmRzIG9uICd0YWdzL2h0bWx0YWcnLCAnY2xvdWRpbmFyeSdcbiAqL1xuXG5cblxuXG4vKipcbiAqIENyZWF0ZXMgYW4gSFRNTCAoRE9NKSBNZXRhIHRhZyB0aGF0IGVuYWJsZXMgQ2xpZW50LUhpbnRzIGZvciB0aGUgSFRNTCBwYWdlLiA8YnIvPlxuICogIFNlZVxuICogIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vcmVzcG9uc2l2ZV9pbWFnZXMjYXV0b21hdGluZ19yZXNwb25zaXZlX2ltYWdlc193aXRoX2NsaWVudF9oaW50c1wiXG4gKiAgdGFyZ2V0PVwiX25ld1wiPkF1dG9tYXRpbmcgcmVzcG9uc2l2ZSBpbWFnZXMgd2l0aCBDbGllbnQgSGludHM8L2E+IGZvciBtb3JlIGRldGFpbHMuXG4gKiBAY29uc3RydWN0b3IgQ2xpZW50SGludHNNZXRhVGFnXG4gKiBAZXh0ZW5kcyBIdG1sVGFnXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQGV4YW1wbGVcbiAqIHRhZyA9IG5ldyBDbGllbnRIaW50c01ldGFUYWcoKVxuICogLy9yZXR1cm5zOiA8bWV0YSBodHRwLWVxdWl2PVwiQWNjZXB0LUNIXCIgY29udGVudD1cIkRQUiwgVmlld3BvcnQtV2lkdGgsIFdpZHRoXCI+XG4gKi9cbnZhciBjbGllbnRoaW50c21ldGF0YWdfQ2xpZW50SGludHNNZXRhVGFnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSHRtbFRhZykge1xuICBmdW5jdGlvbiBDbGllbnRIaW50c01ldGFUYWcob3B0aW9ucykge1xuICAgIGNsaWVudGhpbnRzbWV0YXRhZ19jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGllbnRIaW50c01ldGFUYWcpO1xuICAgIHJldHVybiBjbGllbnRoaW50c21ldGF0YWdfY2FsbFN1cGVyKHRoaXMsIENsaWVudEhpbnRzTWV0YVRhZywgWydtZXRhJywgdm9pZCAwLCBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgIFwiaHR0cC1lcXVpdlwiOiBcIkFjY2VwdC1DSFwiLFxuICAgICAgY29udGVudDogXCJEUFIsIFZpZXdwb3J0LVdpZHRoLCBXaWR0aFwiXG4gICAgfSwgb3B0aW9ucyldKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgY2xpZW50aGludHNtZXRhdGFnX2luaGVyaXRzKENsaWVudEhpbnRzTWV0YVRhZywgX0h0bWxUYWcpO1xuICByZXR1cm4gY2xpZW50aGludHNtZXRhdGFnX2NyZWF0ZUNsYXNzKENsaWVudEhpbnRzTWV0YVRhZywgW3tcbiAgICBrZXk6IFwiY2xvc2VUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VUYWcoKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gIH1dKTtcbn0oaHRtbHRhZyk7XG47XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjbGllbnRoaW50c21ldGF0YWcgPSAoY2xpZW50aGludHNtZXRhdGFnX0NsaWVudEhpbnRzTWV0YVRhZyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL3BhcnNlL25vcm1hbGl6ZVRvQXJyYXkuanNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXJyYXlfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBub3JtYWxpemVUb0FycmF5X2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgbm9ybWFsaXplVG9BcnJheV9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub3JtYWxpemVUb0FycmF5X3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9ybWFsaXplVG9BcnJheV9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5X25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIG5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIG5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5X2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5X2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gbm9ybWFsaXplVG9BcnJheV9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuXG5cbi8qKlxuICogQGRlc2Mgbm9ybWFsaXplIGVsZW1lbnRzLCBzdXBwb3J0IGEgc2luZ2xlIGVsZW1lbnQsIGFycmF5IG9yIG5vZGVsaXN0LCBhbHdheXMgb3V0cHV0cyBhcnJheVxuICogQHBhcmFtIGVsZW1lbnRzPEhUTUxFbGVtZW50W10+XG4gKiBAcmV0dXJucyB7W119XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXJyYXkoZWxlbWVudHMpIHtcbiAgaWYgKGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShlbGVtZW50cykpIHtcbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH0gZWxzZSBpZiAoZWxlbWVudHMuY29uc3RydWN0b3IubmFtZSA9PT0gXCJOb2RlTGlzdFwiKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVRvQXJyYXlfdG9Db25zdW1hYmxlQXJyYXkoZWxlbWVudHMpOyAvLyBlbnN1cmUgYW4gYXJyYXkgaXMgYWx3YXlzIHJldHVybmVkLCBldmVuIGlmIG5vZGVsaXN0XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkoZWxlbWVudHMpKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZWxlbWVudHMpLCAwKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW2VsZW1lbnRzXTtcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9mZWF0dXJlcy90cmFuc3BhcmVudFZpZGVvL21vdW50Q2xvdWRpbmFyeVZpZGVvVGFnLmpzXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGh0bWxFbENvbnRhaW5lclxuICogQHBhcmFtIHtvYmplY3R9IGNsSW5zdGFuY2UgY2xvdWRpbmFyeSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIFRyYW5zZm9ybWF0aW9uT3B0aW9uc1xuICogQHJldHVybnMgUHJvbWlzZTxIVE1MRWxlbWVudD5cbiAqL1xuZnVuY3Rpb24gbW91bnRDbG91ZGluYXJ5VmlkZW9UYWcoaHRtbEVsQ29udGFpbmVyLCBjbEluc3RhbmNlLCBwdWJsaWNJZCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGh0bWxFbENvbnRhaW5lci5pbm5lckhUTUwgPSBjbEluc3RhbmNlLnZpZGVvVGFnKHB1YmxpY0lkLCBvcHRpb25zKS50b0h0bWwoKTtcblxuICAgIC8vIEFsbCB2aWRlb3MgdW5kZXIgdGhlIGh0bWwgY29udGFpbmVyIG11c3QgaGF2ZSBhIHdpZHRoIG9mIDEwMCUsIG9yIHRoZXkgbWlnaHQgb3ZlcmZsb3cgZnJvbSB0aGUgY29udGFpbmVyXG4gICAgdmFyIGNsb3VkaW5hcnlWaWRlb0VsZW1lbnQgPSBodG1sRWxDb250YWluZXIucXVlcnlTZWxlY3RvcignLmNsZC10cmFuc3BhcmVudC12aWRlbycpO1xuICAgIGNsb3VkaW5hcnlWaWRlb0VsZW1lbnQuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgcmVzb2x2ZShodG1sRWxDb250YWluZXIpO1xuICB9KTtcbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcGFyZW50VmlkZW9fbW91bnRDbG91ZGluYXJ5VmlkZW9UYWcgPSAobW91bnRDbG91ZGluYXJ5VmlkZW9UYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC90cmFuc2Zvcm1hdGlvbnMvYWRkRmxhZy5qc1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gLSBGdW5jdGlvbiB3aWxsIHB1c2ggYSBmbGFnIHRvIGluY29taW5nIG9wdGlvbnNcbiAqIEBwYXJhbSB7e3RyYW5zZm9ybWF0aW9ufSB8IHsuLi50cmFuc2Zvcm1hdGlvbn19IG9wdGlvbnMgLSBUaGVzZSBvcHRpb25zIGFyZSB0aGUgc2FtZSBvcHRpb25zIHByb3ZpZGVkIHRvIGFsbCBvdXIgU0RLIG1ldGhvZHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgV2UgZXhwZWN0IG9wdGlvbnMgdG8gZWl0aGVyIGJlIHRoZSB0cmFuc2Zvcm1hdGlvbiBpdHNlbGYsIG9yIGFuIG9iamVjdCBjb250YWluaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuIGFycmF5IG9mIHRyYW5zZm9ybWF0aW9uc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbGFnXG4gKiBAcmV0dXJucyB0aGUgbXV0YXRlZCBvcHRpb25zIG9iamVjdFxuICovXG5cbmZ1bmN0aW9uIGFkZEZsYWdUb09wdGlvbnMob3B0aW9ucywgZmxhZykge1xuICAvLyBEbyB3ZSBoYXZlIHRyYW5zZm9ybWF0aW9uXG4gIGlmIChvcHRpb25zLnRyYW5zZm9ybWF0aW9uKSB7XG4gICAgb3B0aW9ucy50cmFuc2Zvcm1hdGlvbi5wdXNoKHtcbiAgICAgIGZsYWdzOiBbZmxhZ11cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBubyB0cmFuc2Zvcm1hdGlvblxuICAgIC8vIGVuc3VyZSB0aGUgZmxhZ3MgYXJlIGV4dGVuZGVkXG4gICAgaWYgKCFvcHRpb25zLmZsYWdzKSB7XG4gICAgICBvcHRpb25zLmZsYWdzID0gW107XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbGFncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdGlvbnMuZmxhZ3MgPSBbb3B0aW9ucy5mbGFnc107XG4gICAgfVxuICAgIG9wdGlvbnMuZmxhZ3MucHVzaChmbGFnKTtcbiAgfVxufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgYWRkRmxhZyA9IChhZGRGbGFnVG9PcHRpb25zKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvZmVhdHVyZXMvdHJhbnNwYXJlbnRWaWRlby9lbmZvcmNlT3B0aW9uc0ZvclRyYW5zcGFyZW50VmlkZW8uanNcblxuXG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gRW5mb3JjZSBvcHRpb24gc3RydWN0dXJlLCBzZXRzIGRlZmF1bHRzIGFuZCBlbnN1cmVzIGFscGhhIGZsYWcgZXhpc3RzXG4gKiBAcGFyYW0gb3B0aW9ucyB7VHJhbnNmb3JtYXRpb25PcHRpb25zfVxuICovXG5mdW5jdGlvbiBlbmZvcmNlT3B0aW9uc0ZvclRyYW5zcGFyZW50VmlkZW8ob3B0aW9ucykge1xuICBvcHRpb25zLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgb3B0aW9ucy5tdXRlZCA9IHRydWU7XG4gIG9wdGlvbnMuY29udHJvbHMgPSBmYWxzZTtcbiAgb3B0aW9ucy5tYXhfdGltZW91dF9tcyA9IG9wdGlvbnMubWF4X3RpbWVvdXRfbXMgfHwgREVGQVVMVF9USU1FT1VUX01TO1xuICBvcHRpb25zW1wiY2xhc3NcIl0gPSBvcHRpb25zW1wiY2xhc3NcIl0gfHwgJyc7XG4gIG9wdGlvbnNbXCJjbGFzc1wiXSArPSAnIGNsZC10cmFuc3BhcmVudC12aWRlbyc7XG4gIG9wdGlvbnMuZXh0ZXJuYWxMaWJyYXJpZXMgPSBvcHRpb25zLmV4dGVybmFsTGlicmFyaWVzIHx8IHt9O1xuICBpZiAoIW9wdGlvbnMuZXh0ZXJuYWxMaWJyYXJpZXMuc2VlVGhydSkge1xuICAgIG9wdGlvbnMuZXh0ZXJuYWxMaWJyYXJpZXMuc2VlVGhydSA9IERFRkFVTFRfRVhURVJOQUxfTElCUkFSSUVTLnNlZVRocnU7XG4gIH1cblxuICAvLyBlbnN1cmUgdGhlcmUncyBhbiBhbHBoYSB0cmFuc2Zvcm1hdGlvbiBwcmVzZW50XG4gIC8vIHRoaXMgaXMgYSBub24gZG9jdW1lbnRlZCBpbnRlcm5hbCBmbGFnXG4gIGFkZEZsYWcob3B0aW9ucywgJ2FscGhhJyk7XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BhcmVudFZpZGVvX2VuZm9yY2VPcHRpb25zRm9yVHJhbnNwYXJlbnRWaWRlbyA9IChlbmZvcmNlT3B0aW9uc0ZvclRyYW5zcGFyZW50VmlkZW8pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC94aHIvbG9hZFNjcmlwdC5qc1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gLSBHaXZlbiBhIHN0cmluZyBVUkwsIHRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIHRoZSBzY3JpcHQgYW5kIHJlc29sdmUgdGhlIHByb21pc2UuXG4gKiAgICAgICAgICAgICAgICBUaGUgZnVuY3Rpb24gZG9lc24ndCByZXNvbHZlIGFueSB2YWx1ZSxcbiAqICAgICAgICAgICAgICAgIHRoaXMgaXMgbm90IGEgVU1EIGxvYWRlciB3aGVyZSB5b3UgY2FuIGdldCB5b3VyIGxpYnJhcnkgbmFtZSBiYWNrLlxuICogQHBhcmFtIHNjcmlwdFVSTCB7c3RyaW5nfVxuICogQHBhcmFtIHtudW1iZXJ9IG1heF90aW1lb3V0X21zIC0gVGltZSB0byBlbGFwc2UgYmVmb3JlIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAqIEBwYXJhbSBpc0FscmVhZHlMb2FkZWQge2Jvb2xlYW59IGlmIHRydWUsIHRoZSBsb2FkU2NyaXB0IHJlc29sdmVzIGltbWVkaWF0ZWx5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIGlzIHVzZWQgZm9yIG11bHRpcGxlIGludm9jYXRpb25zIC0gcHJldmVudHMgdGhlIHNjcmlwdCBmcm9tIGJlaW5nIGxvYWRlZCBtdWx0aXBsZSB0aW1lc1xuICogQHJldHVybiB7UHJvbWlzZTxhbnkgfCB7c3RhdHVzOnN0cmluZywgbWVzc2FnZTpzdHJpbmd9Pn1cbiAqL1xuZnVuY3Rpb24gbG9hZFNjcmlwdChzY3JpcHRVUkwsIG1heF90aW1lb3V0X21zLCBpc0FscmVhZHlMb2FkZWQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoaXNBbHJlYWR5TG9hZGVkKSB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzY3JpcHRUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIHNjcmlwdFRhZy5zcmMgPSBzY3JpcHRVUkw7XG4gICAgICB2YXIgdGltZXJJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZWplY3Qoe1xuICAgICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgICBtZXNzYWdlOiBcIlRpbWVvdXQgbG9hZGluZyBzY3JpcHQgXCIuY29uY2F0KHNjcmlwdFVSTClcbiAgICAgICAgfSk7XG4gICAgICB9LCBtYXhfdGltZW91dF9tcyk7IC8vIDEwIHNlY29uZHMgZm9yIHRpbWVvdXRcblxuICAgICAgc2NyaXB0VGFnLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklEKTsgLy8gY2xlYXIgdGltZW91dCByZWplY3QgZXJyb3JcbiAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogXCJFcnJvciBsb2FkaW5nIFwiLmNvbmNhdChzY3JpcHRVUkwpXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHNjcmlwdFRhZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklEKTsgLy8gY2xlYXIgdGltZW91dCByZWplY3QgZXJyb3JcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0VGFnKTtcbiAgICB9XG4gIH0pO1xufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgeGhyX2xvYWRTY3JpcHQgPSAobG9hZFNjcmlwdCk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL3hoci9nZXRCbG9iRnJvbVVSTC5qc1xuLyoqXG4gKiBSZWplY3Qgb24gdGltZW91dFxuICogQHBhcmFtIG1heFRpbWVvdXRNU1xuICogQHBhcmFtIHJlamVjdFxuICogQHJldHVybnMge251bWJlcn0gdGltZXJJRFxuICovXG5mdW5jdGlvbiByZWplY3RPblRpbWVvdXQobWF4VGltZW91dE1TLCByZWplY3QpIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHJlamVjdCh7XG4gICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICBtZXNzYWdlOiAnVGltZW91dCBsb2FkaW5nIEJsb2IgVVJMJ1xuICAgIH0pO1xuICB9LCBtYXhUaW1lb3V0TVMpO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBDb252ZXJ0cyBhIFVSTCB0byBhIEJMT0IgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsVG9Mb2FkXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4X3RpbWVvdXRfbXMgLSBUaW1lIHRvIGVsYXBzZSBiZWZvcmUgcHJvbWlzZSBpcyByZWplY3RlZFxuICogQHJldHVybiB7UHJvbWlzZTx7XG4gKiAgIHN0YXR1czogJ3N1Y2Nlc3MnIHwgJ2Vycm9yJ1xuICogICBtZXNzYWdlPzogc3RyaW5nLFxuICogICAgcGF5bG9hZDoge1xuICogICAgICB1cmw6IHN0cmluZ1xuICogICAgfVxuICogfT59XG4gKi9cbmZ1bmN0aW9uIGdldEJsb2JGcm9tVVJMKHVybFRvTG9hZCwgbWF4VGltZW91dE1TKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHRpbWVySUQgPSByZWplY3RPblRpbWVvdXQobWF4VGltZW91dE1TLCByZWplY3QpO1xuXG4gICAgLy8gSWYgZmV0Y2ggZXhpc3RzLCB1c2UgaXQgdG8gZmV0Y2ggYmxvYiwgb3RoZXJ3aXNlIHVzZSBYSFIuXG4gICAgLy8gWEhSIGNhdXNlcyBpc3N1ZXMgb24gc2FmYXJpIDE0LjEgc28gd2UgcHJlZmVyIGZldGNoXG4gICAgdmFyIGZldGNoQmxvYiA9IHR5cGVvZiBmZXRjaCAhPT0gJ3VuZGVmaW5lZCcgJiYgZmV0Y2ggPyBsb2FkVXJsVXNpbmdGZXRjaCA6IGxvYWRVcmxVc2luZ1hocjtcbiAgICBmZXRjaEJsb2IodXJsVG9Mb2FkKS50aGVuKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICByZXNvbHZlKHtcbiAgICAgICAgc3RhdHVzOiAnc3VjY2VzcycsXG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBibG9iVVJMOiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgcmVqZWN0KHtcbiAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICBtZXNzYWdlOiAnRXJyb3IgbG9hZGluZyBCbG9iIFVSTCdcbiAgICAgIH0pO1xuICAgIH0pW1wiZmluYWxseVwiXShmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDbGVhciB0aGUgdGltZW91dCB0aW1lciBvbiBmYWlsIG9yIHN1Y2Nlc3MuXG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJRCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFVzZSBmZXRjaCBmdW5jdGlvbiB0byBmZXRjaCBmaWxlXG4gKiBAcGFyYW0gdXJsVG9Mb2FkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx1bmtub3duPn1cbiAqL1xuZnVuY3Rpb24gbG9hZFVybFVzaW5nRmV0Y2godXJsVG9Mb2FkKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZmV0Y2godXJsVG9Mb2FkKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgcmVzcG9uc2UuYmxvYigpLnRoZW4oZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgICAgcmVzb2x2ZShibG9iKTtcbiAgICAgIH0pO1xuICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgcmVqZWN0KCdlcnJvcicpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBVc2UgWEhSIHRvIGZldGNoIGZpbGVcbiAqIEBwYXJhbSB1cmxUb0xvYWRcbiAqIEByZXR1cm5zIHtQcm9taXNlPHVua25vd24+fVxuICovXG5mdW5jdGlvbiBsb2FkVXJsVXNpbmdYaHIodXJsVG9Mb2FkKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgcmVzb2x2ZSh4aHIucmVzcG9uc2UpO1xuICAgIH07XG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZWplY3QoJ2Vycm9yJyk7XG4gICAgfTtcbiAgICB4aHIub3BlbignR0VUJywgdXJsVG9Mb2FkLCB0cnVlKTtcbiAgICB4aHIuc2VuZCgpO1xuICB9KTtcbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHhocl9nZXRCbG9iRnJvbVVSTCA9IChnZXRCbG9iRnJvbVVSTCk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2ZlYXR1cmVzL3RyYW5zcGFyZW50VmlkZW8vY3JlYXRlSGlkZGVuVmlkZW9UYWcuanNcbi8qKlxuICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBoaWRkZW4gSFRNTFZpZGVvRWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQgdmlkZW9PcHRpb25zXG4gKiBAcGFyYW0ge3thdXRvcGxheSwgcGxheXNpbmxpbmUsIGxvb3AsIG11dGVkLCBwb3N0ZXIsIGJsb2JVUkwsIHZpZGVvVVJMIH19IHZpZGVvT3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSB2aWRlb09wdGlvbnMuYXV0b3BsYXkgLSBhdXRvcGxheXMgdGhlIHZpZGVvIGlmIHRydWVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWRlb09wdGlvbnMuYmxvYlVSTCAtIHRoZSBibG9iVVJMIHRvIHNldCBhcyB2aWRlby5zcmNcbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWRlb09wdGlvbnMudmlkZW9VUkwgLSB0aGUgb3JpZ2luYWwgdmlkZW9VUkwgdGhlIHVzZXIgY3JlYXRlZCAod2l0aCB0cmFuc2Zvcm1hdGlvbnMpXG4gKiBAcmV0dXJuIHtIVE1MVmlkZW9FbGVtZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGVIaWRkZW5WaWRlb1RhZyh2aWRlb09wdGlvbnMpIHtcbiAgdmFyIGF1dG9wbGF5ID0gdmlkZW9PcHRpb25zLmF1dG9wbGF5LFxuICAgIHBsYXlzaW5saW5lID0gdmlkZW9PcHRpb25zLnBsYXlzaW5saW5lLFxuICAgIGxvb3AgPSB2aWRlb09wdGlvbnMubG9vcCxcbiAgICBtdXRlZCA9IHZpZGVvT3B0aW9ucy5tdXRlZCxcbiAgICBwb3N0ZXIgPSB2aWRlb09wdGlvbnMucG9zdGVyLFxuICAgIGJsb2JVUkwgPSB2aWRlb09wdGlvbnMuYmxvYlVSTCxcbiAgICB2aWRlb1VSTCA9IHZpZGVvT3B0aW9ucy52aWRlb1VSTDtcbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgZWwuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICBlbC5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGVsLnggPSAwO1xuICBlbC55ID0gMDtcbiAgZWwuc3JjID0gYmxvYlVSTDtcbiAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLXZpZGVvLXVybCcsIHZpZGVvVVJMKTsgLy8gZm9yIGRlYnVnZ2luZy90ZXN0aW5nXG5cbiAgYXV0b3BsYXkgJiYgZWwuc2V0QXR0cmlidXRlKCdhdXRvcGxheScsIGF1dG9wbGF5KTtcbiAgcGxheXNpbmxpbmUgJiYgZWwuc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsIHBsYXlzaW5saW5lKTtcbiAgbG9vcCAmJiBlbC5zZXRBdHRyaWJ1dGUoJ2xvb3AnLCBsb29wKTtcbiAgbXV0ZWQgJiYgZWwuc2V0QXR0cmlidXRlKCdtdXRlZCcsIG11dGVkKTtcbiAgbXV0ZWQgJiYgKGVsLm11dGVkID0gbXV0ZWQpOyAvLyB0aGlzIGlzIGFsc28gbmVlZGVkIGZvciBhdXRvcGxheSwgb24gdG9wIG9mIHNldEF0dHJpYnV0ZVxuICBwb3N0ZXIgJiYgZWwuc2V0QXR0cmlidXRlKCdwb3N0ZXInLCBwb3N0ZXIpO1xuXG4gIC8vIEZyZWUgbWVtb3J5IGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUgbG9hZGluZy5cbiAgZWwub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVSTCk7XG4gIH07XG4gIHJldHVybiBlbDtcbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcGFyZW50VmlkZW9fY3JlYXRlSGlkZGVuVmlkZW9UYWcgPSAoY3JlYXRlSGlkZGVuVmlkZW9UYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9mZWF0dXJlcy90cmFuc3BhcmVudFZpZGVvL2luc3RhbnRpYXRlU2VlVGhydS5qc1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGEgbmV3IGluc3RhbmMgZW9mIHNlZVRocnUgKHNlZVRocnUuY3JlYXRlKCkpIGFuZCByZXR1cm5zIGEgcHJvbWlzZSBvZiB0aGUgc2VlVGhydSBpbnN0YW5jZVxuICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50fSB2aWRlb0VsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhfdGltZW91dF9tcyAtIFRpbWUgdG8gZWxhcHNlIGJlZm9yZSBwcm9taXNlIGlzIHJlamVjdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gY3VzdG9tQ2xhc3MgLSBBIGNsYXNzbmFtZSB0byBiZSBhZGRlZCB0byB0aGUgY2FudmFzIGVsZW1lbnQgY3JlYXRlZCBieSBzZWVUaHJ1XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGF1dG9QbGF5XG4gKiBAcmV0dXJuIHtQcm9taXNlPGFueT59IFNlZVRocnUgaW5zdGFuY2Ugb3IgcmVqZWN0aW9uIGVycm9yXG4gKi9cbmZ1bmN0aW9uIGluc3RhbnRpYXRlU2VlVGhydSh2aWRlb0VsZW1lbnQsIG1heF90aW1lb3V0X21zLCBjdXN0b21DbGFzcywgYXV0b1BsYXkpIHtcbiAgdmFyIF93aW5kb3cgPSB3aW5kb3csXG4gICAgc2VlVGhydSA9IF93aW5kb3cuc2VlVGhydSxcbiAgICBzZXRUaW1lb3V0ID0gX3dpbmRvdy5zZXRUaW1lb3V0LFxuICAgIGNsZWFyVGltZW91dCA9IF93aW5kb3cuY2xlYXJUaW1lb3V0O1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciB0aW1lcklEID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZWplY3Qoe1xuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6ICdUaW1lb3V0IGluc3RhbnRpYXRpbmcgc2VlVGhydSBpbnN0YW5jZSdcbiAgICAgIH0pO1xuICAgIH0sIG1heF90aW1lb3V0X21zKTtcbiAgICBpZiAoc2VlVGhydSkge1xuICAgICAgdmFyIHNlZVRocnVJbnN0YW5jZSA9IHNlZVRocnUuY3JlYXRlKHZpZGVvRWxlbWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjbGVhciB0aW1lb3V0IHJlamVjdCBlcnJvclxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJRCk7XG5cbiAgICAgICAgLy8gZm9yY2UgY29udGFpbmVyIHdpZHRoLCBlbHNlIHRoZSBjYW52YXMgY2FuIG92ZXJmbG93IG91dFxuICAgICAgICB2YXIgY2FudmFzRWxlbWVudCA9IHNlZVRocnVJbnN0YW5jZS5nZXRDYW52YXMoKTtcbiAgICAgICAgY2FudmFzRWxlbWVudC5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgY2FudmFzRWxlbWVudC5jbGFzc05hbWUgKz0gJyAnICsgY3VzdG9tQ2xhc3M7XG5cbiAgICAgICAgLy8gc3RhcnQgdGhlIHZpZGVvIGlmIGF1dG9wbGF5IGlzIHNldFxuICAgICAgICBpZiAoYXV0b1BsYXkpIHtcbiAgICAgICAgICBzZWVUaHJ1SW5zdGFuY2UucGxheSgpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoc2VlVGhydUluc3RhbmNlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWplY3Qoe1xuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6ICdFcnJvciBpbnN0YW50aWF0aW5nIHNlZVRocnUgaW5zdGFuY2UnXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwYXJlbnRWaWRlb19pbnN0YW50aWF0ZVNlZVRocnUgPSAoaW5zdGFudGlhdGVTZWVUaHJ1KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvZmVhdHVyZXMvdHJhbnNwYXJlbnRWaWRlby9tb3VudFNlZVRocnVDYW52YXNUYWcuanNcblxuXG5cblxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBodG1sRWxDb250YWluZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSB2aWRlb1VSTFxuICogQHBhcmFtIHtUcmFuc2Zvcm1hdGlvbk9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAqL1xuZnVuY3Rpb24gbW91bnRTZWVUaHJ1Q2FudmFzVGFnKGh0bWxFbENvbnRhaW5lciwgdmlkZW9VUkwsIG9wdGlvbnMpIHtcbiAgdmFyIHBvc3RlciA9IG9wdGlvbnMucG9zdGVyLFxuICAgIGF1dG9wbGF5ID0gb3B0aW9ucy5hdXRvcGxheSxcbiAgICBwbGF5c2lubGluZSA9IG9wdGlvbnMucGxheXNpbmxpbmUsXG4gICAgbG9vcCA9IG9wdGlvbnMubG9vcCxcbiAgICBtdXRlZCA9IG9wdGlvbnMubXV0ZWQ7XG4gIHZpZGVvVVJMID0gdmlkZW9VUkwgKyAnLm1wNCc7IC8vIHNlZVRocnUgYWx3YXlzIHVzZXMgbXA0XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgeGhyX2xvYWRTY3JpcHQob3B0aW9ucy5leHRlcm5hbExpYnJhcmllcy5zZWVUaHJ1LCBvcHRpb25zLm1heF90aW1lb3V0X21zLCB3aW5kb3cuc2VlVGhydSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICB4aHJfZ2V0QmxvYkZyb21VUkwodmlkZW9VUkwsIG9wdGlvbnMubWF4X3RpbWVvdXRfbXMpLnRoZW4oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIHBheWxvYWQgPSBfcmVmLnBheWxvYWQ7XG4gICAgICAgIHZhciB2aWRlb0VsZW1lbnQgPSB0cmFuc3BhcmVudFZpZGVvX2NyZWF0ZUhpZGRlblZpZGVvVGFnKHtcbiAgICAgICAgICBibG9iVVJMOiBwYXlsb2FkLmJsb2JVUkwsXG4gICAgICAgICAgdmlkZW9VUkw6IHZpZGVvVVJMLFxuICAgICAgICAgIC8vIGZvciBkZWJ1Z2dpbmcvdGVzdGluZ1xuICAgICAgICAgIHBvc3RlcjogcG9zdGVyLFxuICAgICAgICAgIGF1dG9wbGF5OiBhdXRvcGxheSxcbiAgICAgICAgICBwbGF5c2lubGluZTogcGxheXNpbmxpbmUsXG4gICAgICAgICAgbG9vcDogbG9vcCxcbiAgICAgICAgICBtdXRlZDogbXV0ZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGh0bWxFbENvbnRhaW5lci5hcHBlbmRDaGlsZCh2aWRlb0VsZW1lbnQpO1xuICAgICAgICB0cmFuc3BhcmVudFZpZGVvX2luc3RhbnRpYXRlU2VlVGhydSh2aWRlb0VsZW1lbnQsIG9wdGlvbnMubWF4X3RpbWVvdXRfbXMsIG9wdGlvbnNbXCJjbGFzc1wiXSwgb3B0aW9ucy5hdXRvcGxheSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZShodG1sRWxDb250YWluZXIpO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY2F0Y2ggZm9yIGdldEJsb2JGcm9tVVJMKClcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSBfcmVmMi5zdGF0dXMsXG4gICAgICAgICAgbWVzc2FnZSA9IF9yZWYyLm1lc3NhZ2U7XG4gICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLy8gY2F0Y2ggZm9yIGxvYWRTY3JpcHQoKVxuICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICB2YXIgc3RhdHVzID0gX3JlZjMuc3RhdHVzLFxuICAgICAgICBtZXNzYWdlID0gX3JlZjMubWVzc2FnZTtcbiAgICAgIHJlamVjdCh7XG4gICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BhcmVudFZpZGVvX21vdW50U2VlVGhydUNhbnZhc1RhZyA9IChtb3VudFNlZVRocnVDYW52YXNUYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9mZWF0dXJlcy90cmFuc3BhcmVudFZpZGVvL2NoZWNrU3VwcG9ydEZvclRyYW5zcGFyZW5jeS5qc1xuLyoqXG4gKiBAcmV0dXJuIHtQcm9taXNlPGJvb2xlYW4+fSAtIFdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHJhbnNwYXJlbnQgdmlkZW9zIG9yIG5vdFxuICovXG5cbmZ1bmN0aW9uIGNoZWNrU3VwcG9ydEZvclRyYW5zcGFyZW5jeSgpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAvLyBSZXNvbHZlIGVhcmx5IGZvciBzYWZhcmkuXG4gICAgLy8gQ3VycmVudGx5ICgyOSBEZWNlbWJlciAyMDIxKSBTYWZhcmkgY2FuIHBsYXkgd2VibS92cDksXG4gICAgLy8gYnV0IGl0IGRvZXMgbm90IHN1cHBvcnQgdHJhbnNwYXJlbnQgdmlkZW8gaW4gdGhlIGZvcm1hdCB3ZSdyZSBvdXRwdXR0aW5nXG4gICAgaWYgKGlzU2FmYXJpKCkpIHtcbiAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgICB2YXIgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgIHZhciBjYW5QbGF5ID0gdmlkZW8uY2FuUGxheVR5cGUgJiYgdmlkZW8uY2FuUGxheVR5cGUoJ3ZpZGVvL3dlYm07IGNvZGVjcz1cInZwOVwiJyk7XG4gICAgcmVzb2x2ZShjYW5QbGF5ID09PSAnbWF5YmUnIHx8IGNhblBsYXkgPT09ICdwcm9iYWJseScpO1xuICB9KTtcbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcGFyZW50VmlkZW9fY2hlY2tTdXBwb3J0Rm9yVHJhbnNwYXJlbmN5ID0gKGNoZWNrU3VwcG9ydEZvclRyYW5zcGFyZW5jeSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jbG91ZGluYXJ5LmpzXG5mdW5jdGlvbiBjbG91ZGluYXJ5X3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIGNsb3VkaW5hcnlfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIGNsb3VkaW5hcnlfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBjbG91ZGluYXJ5X2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIGNsb3VkaW5hcnlfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNsb3VkaW5hcnlfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIGNsb3VkaW5hcnlfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBjbG91ZGluYXJ5X2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBjbG91ZGluYXJ5X2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBjbG91ZGluYXJ5X3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IGNsb3VkaW5hcnlfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IGNsb3VkaW5hcnlfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBjbG91ZGluYXJ5X3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gY2xvdWRpbmFyeV90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gY2xvdWRpbmFyeV90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuXG52YXIgYXBwbHlCcmVha3BvaW50cywgY2xvc2VzdEFib3ZlLCBkZWZhdWx0QnJlYWtwb2ludHMsIGNsb3VkaW5hcnlfZmluZENvbnRhaW5lcldpZHRoLCBjbG91ZGluYXJ5X21heFdpZHRoLCB1cGRhdGVEcHI7XG5cblxuXG5cblxuXG5cblxuXG5cbi8vXG5cblxuXG5cblxuZGVmYXVsdEJyZWFrcG9pbnRzID0gZnVuY3Rpb24gZGVmYXVsdEJyZWFrcG9pbnRzKHdpZHRoKSB7XG4gIHZhciBzdGVwcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTAwO1xuICByZXR1cm4gc3RlcHMgKiBNYXRoLmNlaWwod2lkdGggLyBzdGVwcyk7XG59O1xuY2xvc2VzdEFib3ZlID0gZnVuY3Rpb24gY2xvc2VzdEFib3ZlKGxpc3QsIHZhbHVlKSB7XG4gIHZhciBpO1xuICBpID0gbGlzdC5sZW5ndGggLSAyO1xuICB3aGlsZSAoaSA+PSAwICYmIGxpc3RbaV0gPj0gdmFsdWUpIHtcbiAgICBpLS07XG4gIH1cbiAgcmV0dXJuIGxpc3RbaSArIDFdO1xufTtcbmFwcGx5QnJlYWtwb2ludHMgPSBmdW5jdGlvbiBhcHBseUJyZWFrcG9pbnRzKHRhZywgd2lkdGgsIHN0ZXBzLCBvcHRpb25zKSB7XG4gIHZhciByZWYsIHJlZjEsIHJlZjIsIHJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzO1xuICByZXNwb25zaXZlX3VzZV9icmVha3BvaW50cyA9IChyZWYgPSAocmVmMSA9IChyZWYyID0gb3B0aW9uc1sncmVzcG9uc2l2ZV91c2VfYnJlYWtwb2ludHMnXSkgIT0gbnVsbCA/IHJlZjIgOiBvcHRpb25zWydyZXNwb25zaXZlX3VzZV9zdG9wcG9pbnRzJ10pICE9IG51bGwgPyByZWYxIDogdGhpcy5jb25maWcoJ3Jlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzJykpICE9IG51bGwgPyByZWYgOiB0aGlzLmNvbmZpZygncmVzcG9uc2l2ZV91c2Vfc3RvcHBvaW50cycpO1xuICBpZiAoIXJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzIHx8IHJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzID09PSAncmVzaXplJyAmJiAhb3B0aW9ucy5yZXNpemluZykge1xuICAgIHJldHVybiB3aWR0aDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5jYWxjX2JyZWFrcG9pbnQodGFnLCB3aWR0aCwgc3RlcHMpO1xuICB9XG59O1xuY2xvdWRpbmFyeV9maW5kQ29udGFpbmVyV2lkdGggPSBmdW5jdGlvbiBmaW5kQ29udGFpbmVyV2lkdGgoZWxlbWVudCkge1xuICB2YXIgY29udGFpbmVyV2lkdGgsIHN0eWxlO1xuICBjb250YWluZXJXaWR0aCA9IDA7XG4gIHdoaWxlICgoZWxlbWVudCA9IGVsZW1lbnQgIT0gbnVsbCA/IGVsZW1lbnQucGFyZW50Tm9kZSA6IHZvaWQgMCkgaW5zdGFuY2VvZiBFbGVtZW50ICYmICFjb250YWluZXJXaWR0aCkge1xuICAgIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgaWYgKCEvXmlubGluZS8udGVzdChzdHlsZS5kaXNwbGF5KSkge1xuICAgICAgY29udGFpbmVyV2lkdGggPSBsb2Rhc2hfd2lkdGgoZWxlbWVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb250YWluZXJXaWR0aDtcbn07XG51cGRhdGVEcHIgPSBmdW5jdGlvbiB1cGRhdGVEcHIoZGF0YVNyYywgcm91bmREcHIpIHtcbiAgcmV0dXJuIGRhdGFTcmMucmVwbGFjZSgvXFxiZHByXygxXFwuMHxhdXRvKVxcYi9nLCAnZHByXycgKyB0aGlzLmRldmljZV9waXhlbF9yYXRpbyhyb3VuZERwcikpO1xufTtcbmNsb3VkaW5hcnlfbWF4V2lkdGggPSBmdW5jdGlvbiBtYXhXaWR0aChyZXF1aXJlZFdpZHRoLCB0YWcpIHtcbiAgdmFyIGltYWdlV2lkdGg7XG4gIGltYWdlV2lkdGggPSBsb2Rhc2hfZ2V0RGF0YSh0YWcsICd3aWR0aCcpIHx8IDA7XG4gIGlmIChyZXF1aXJlZFdpZHRoID4gaW1hZ2VXaWR0aCkge1xuICAgIGltYWdlV2lkdGggPSByZXF1aXJlZFdpZHRoO1xuICAgIGxvZGFzaF9zZXREYXRhKHRhZywgJ3dpZHRoJywgcmVxdWlyZWRXaWR0aCk7XG4gIH1cbiAgcmV0dXJuIGltYWdlV2lkdGg7XG59O1xudmFyIGNsb3VkaW5hcnlfQ2xvdWRpbmFyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IENsb3VkaW5hcnkgaW5zdGFuY2UuXG4gICAqIEBjbGFzcyBDbG91ZGluYXJ5XG4gICAqIEBjbGFzc2Rlc2MgTWFpbiBjbGFzcyBmb3IgYWNjZXNzaW5nIENsb3VkaW5hcnkgZnVuY3Rpb25hbGl0eS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBBIHtAbGluayBDb25maWd1cmF0aW9ufSBvYmplY3QgZm9yIGdsb2JhbGx5IGNvbmZpZ3VyaW5nIENsb3VkaW5hcnkgYWNjb3VudCBzZXR0aW5ncy5cbiAgICogQGV4YW1wbGU8YnIvPlxuICAgKiAgdmFyIGNsID0gbmV3IGNsb3VkaW5hcnkuQ2xvdWRpbmFyeSggeyBjbG91ZF9uYW1lOiBcIm15Y2xvdWRcIn0pOzxici8+XG4gICAqICB2YXIgaW1nVGFnID0gY2wuaW1hZ2UoXCJteVBpY0lEXCIpO1xuICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAqICBBdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgKi9cbiAgZnVuY3Rpb24gQ2xvdWRpbmFyeShvcHRpb25zKSB7XG4gICAgY2xvdWRpbmFyeV9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbG91ZGluYXJ5KTtcbiAgICB2YXIgY29uZmlndXJhdGlvbjtcbiAgICB0aGlzLmRldmljZVBpeGVsUmF0aW9DYWNoZSA9IHt9O1xuICAgIHRoaXMucmVzcG9uc2l2ZUNvbmZpZyA9IHt9O1xuICAgIHRoaXMucmVzcG9uc2l2ZVJlc2l6ZUluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgY29uZmlndXJhdGlvbiA9IG5ldyBzcmNfY29uZmlndXJhdGlvbihvcHRpb25zKTtcbiAgICAvLyBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgIHRoaXMuY29uZmlnID0gZnVuY3Rpb24gKG5ld0NvbmZpZywgbmV3VmFsdWUpIHtcbiAgICAgIHJldHVybiBjb25maWd1cmF0aW9uLmNvbmZpZyhuZXdDb25maWcsIG5ld1ZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVzZSBcXDxtZXRhXFw+IHRhZ3MgaW4gdGhlIGRvY3VtZW50IHRvIGNvbmZpZ3VyZSB0aGlzIGBjbG91ZGluYXJ5YCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJuIFRoaXMge0Nsb3VkaW5hcnl9IGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICB0aGlzLmZyb21Eb2N1bWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbmZpZ3VyYXRpb24uZnJvbURvY3VtZW50KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVzZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdG8gY29uZmlndXJlIHRoaXMgYGNsb3VkaW5hcnlgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm4gVGhpcyB7Q2xvdWRpbmFyeX0gaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHRoaXMuZnJvbUVudmlyb25tZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29uZmlndXJhdGlvbi5mcm9tRW52aXJvbm1lbnQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBtZXRob2QgdGhhdCBpbnZva2VzIGJvdGgge0BsaW5rIENvbmZpZ3VyYXRpb24jZnJvbUVudmlyb25tZW50fGZyb21FbnZpcm9ubWVudCgpfVxuICAgICAqICAoTm9kZS5qcyBlbnZpcm9ubWVudCBvbmx5KSBhbmQge0BsaW5rIENvbmZpZ3VyYXRpb24jZnJvbURvY3VtZW50fGZyb21Eb2N1bWVudCgpfS5cbiAgICAgKiAgSXQgZmlyc3QgdHJpZXMgdG8gcmV0cmlldmUgdGhlIGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUuXG4gICAgICogIElmIG5vdCBhdmFpbGFibGUsIGl0IHRyaWVzIGZyb20gdGhlIGRvY3VtZW50IG1ldGEgdGFncy5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNpbml0XG4gICAgICogQHNlZSBDb25maWd1cmF0aW9uI2luaXRcbiAgICAgKiBAcmV0dXJuIFRoaXMge0Nsb3VkaW5hcnl9IGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25maWd1cmF0aW9uLmluaXQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7Q2xvdWRpbmFyeX1cbiAgICogQGV4YW1wbGUgY2wgPSBjbG91ZGluYXJ5LkNsb3VkaW5hcnkubmV3KCB7IGNsb3VkX25hbWU6IFwibXljbG91ZFwifSlcbiAgICovXG4gIHJldHVybiBjbG91ZGluYXJ5X2NyZWF0ZUNsYXNzKENsb3VkaW5hcnksIFt7XG4gICAga2V5OiBcInVybFwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIFVSTCBmb3IgYW55IGFzc2V0IGluIHlvdXIgTWVkaWEgbGlicmFyeS5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN1cmxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgcHVibGljIElEIG9mIHRoZSBtZWRpYSBhc3NldC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycyB0byBpbmNsdWRlIGluIHRoZSBVUkwuXG4gICAgICogQHBhcmFtIHt0eXBlfSBbb3B0aW9ucy50eXBlPSd1cGxvYWQnXSAtIFRoZSBhc3NldCdzIHN0b3JhZ2UgdHlwZS5cbiAgICAgKiAgRm9yIGRldGFpbHMgb24gYWxsIGZldGNoIHR5cGVzLCBzZWVcbiAgICAgKiA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9ucyNmZXRjaGluZ19pbWFnZXNfZnJvbV9yZW1vdGVfbG9jYXRpb25zXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+RmV0Y2ggdHlwZXM8L2E+LlxuICAgICAqIEBwYXJhbSB7cmVzb3VyY2VUeXBlfSBbb3B0aW9ucy5yZXNvdXJjZV90eXBlPSdpbWFnZSddIC0gVGhlIHR5cGUgb2YgYXNzZXQuIFBvc3NpYmxlIHZhbHVlczo8YnIvPlxuICAgICAqICAtIGBpbWFnZWA8YnIvPlxuICAgICAqICAtIGB2aWRlb2A8YnIvPlxuICAgICAqICAtIGByYXdgXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgbWVkaWEgYXNzZXQgVVJMLlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICovXG4gICAgZnVuY3Rpb24gdXJsKHB1YmxpY0lkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICByZXR1cm4gdXJsX3VybChwdWJsaWNJZCwgb3B0aW9ucywgdGhpcy5jb25maWcoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdmlkZW8gYXNzZXQgVVJMLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3ZpZGVvX3VybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBwdWJsaWMgSUQgb2YgdGhlIHZpZGVvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgaW4gdGhlIFVSTC5cbiAgICAgKiBAcGFyYW0ge3R5cGV9IFtvcHRpb25zLnR5cGU9J3VwbG9hZCddIC0gVGhlIGFzc2V0J3Mgc3RvcmFnZSB0eXBlLlxuICAgICAqICBGb3IgZGV0YWlscyBvbiBhbGwgZmV0Y2ggdHlwZXMsIHNlZVxuICAgICAqICA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9ucyNmZXRjaGluZ19pbWFnZXNfZnJvbV9yZW1vdGVfbG9jYXRpb25zXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+RmV0Y2ggdHlwZXM8L2E+LlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZpZGVvIFVSTC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIHZpZGVvIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ2aWRlb191cmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlkZW9fdXJsKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICAgIHJlc291cmNlX3R5cGU6ICd2aWRlbydcbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMudXJsKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBVUkwgZm9yIGFuIGltYWdlIGludGVuZGVkIHRvIGJlIHVzZWQgYXMgYSB0aHVtYm5haWwgZm9yIHRoZSBzcGVjaWZpZWQgdmlkZW8uXG4gICAgICogIElkZW50aWNhbCB0byB7QGxpbmsgQ2xvdWRpbmFyeSN1cmx8dXJsfSwgZXhjZXB0IHRoYXQgdGhlIGByZXNvdXJjZV90eXBlYCBpcyBgdmlkZW9gXG4gICAgICogIGFuZCB0aGUgZGVmYXVsdCBgZm9ybWF0YCBpcyBganBnYC5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN2aWRlb190aHVtYm5haWxfdXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdmlkZW8gZnJvbSB3aGljaCB5b3Ugd2FudCB0byBnZW5lcmF0ZSBhIHRodW1ibmFpbCBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIGltYWdlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycyB0byBhcHBseSB0byB0aGUgdGh1bWJuYWlsLlxuICAgICAqIEluIGFkZGl0aW9uIHRvIHN0YW5kYXJkIGltYWdlIHRyYW5zZm9ybWF0aW9ucywgeW91IGNhbiBhbHNvIHVzZSB0aGUgYHN0YXJ0X29mZnNldGAgdHJhbnNmb3JtYXRpb24gcGFyYW1ldGVyXG4gICAgICogdG8gaW5zdHJ1Y3QgQ2xvdWRpbmFyeSB0byBnZW5lcmF0ZSB0aGUgdGh1bWJuYWlsIGZyb20gYSBmcmFtZSBvdGhlciB0aGFuIHRoZSBtaWRkbGUgZnJhbWUgb2YgdGhlIHZpZGVvLlxuICAgICAqIEZvciBkZXRhaWxzLCBzZWVcbiAgICAgKiA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX21hbmlwdWxhdGlvbl9hbmRfZGVsaXZlcnkjZ2VuZXJhdGluZ192aWRlb190aHVtYm5haWxzXCJcbiAgICAgKiB0YXJnZXQ9XCJfYmxhbmtcIj5HZW5lcmF0aW5nIHZpZGVvIHRodW1ibmFpbHM8L2E+IGluIHRoZSBDbG91ZGluYXJ5IGRvY3VtZW50YXRpb24uXG4gICAgICogQHBhcmFtIHt0eXBlfSBbb3B0aW9ucy50eXBlPSd1cGxvYWQnXSAtIFRoZSBhc3NldCdzIHN0b3JhZ2UgdHlwZS5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVUkwgb2YgdGhlIHZpZGVvIHRodW1ibmFpbCBpbWFnZS5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9fdGh1bWJuYWlsX3VybFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWRlb190aHVtYm5haWxfdXJsKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7fSwgREVGQVVMVF9QT1NURVJfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy51cmwocHVibGljSWQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3BlY2lmaWVkIHRyYW5zZm9ybWF0aW9uIG9wdGlvbnMuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdHJhbnNmb3JtYXRpb25fc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0cmFuc2Zvcm1hdGlvbiBzdHJpbmcuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi92aWRlb190cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIHZpZGVvIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc2Zvcm1hdGlvbl9zdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fc3RyaW5nKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgc3JjX3RyYW5zZm9ybWF0aW9uKG9wdGlvbnMpLnNlcmlhbGl6ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbiBpbWFnZSB0YWcuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgcHVibGljIElEIG9mIHRoZSBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMsIHtAbGluayBDb25maWd1cmF0aW9ufSBwYXJhbWV0ZXJzLFxuICAgICAqICBhbmQgc3RhbmRhcmQgSFRNTCAmbHQ7aW1nJmd0OyB0YWcgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgaW1hZ2UgdGFnLlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEFuIGltYWdlIHRhZyBET00gZWxlbWVudC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW1hZ2UocHVibGljSWQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBjbGllbnRfaGludHMsIGltZywgcmVmO1xuICAgICAgaW1nID0gdGhpcy5pbWFnZVRhZyhwdWJsaWNJZCwgb3B0aW9ucyk7XG4gICAgICBjbGllbnRfaGludHMgPSAocmVmID0gb3B0aW9ucy5jbGllbnRfaGludHMgIT0gbnVsbCA/IG9wdGlvbnMuY2xpZW50X2hpbnRzIDogdGhpcy5jb25maWcoJ2NsaWVudF9oaW50cycpKSAhPSBudWxsID8gcmVmIDogZmFsc2U7XG4gICAgICBpZiAob3B0aW9ucy5zcmMgPT0gbnVsbCAmJiAhY2xpZW50X2hpbnRzKSB7XG4gICAgICAgIC8vIHNyYyBtdXN0IGJlIHJlbW92ZWQgYmVmb3JlIGNyZWF0aW5nIHRoZSBET00gZWxlbWVudCB0byBhdm9pZCBsb2FkaW5nIHRoZSBpbWFnZVxuICAgICAgICBpbWcuc2V0QXR0cihcInNyY1wiLCAnJyk7XG4gICAgICB9XG4gICAgICBpbWcgPSBpbWcudG9ET00oKTtcbiAgICAgIGlmICghY2xpZW50X2hpbnRzKSB7XG4gICAgICAgIC8vIGNhY2hlIHRoZSBpbWFnZSBzcmNcbiAgICAgICAgbG9kYXNoX3NldERhdGEoaW1nLCAnc3JjLWNhY2hlJywgdGhpcy51cmwocHVibGljSWQsIG9wdGlvbnMpKTtcbiAgICAgICAgLy8gc2V0IGltYWdlIHNyYyB0YWtpbmcgcmVzcG9uc2l2ZW5lc3MgaW4gYWNjb3VudFxuICAgICAgICB0aGlzLmNsb3VkaW5hcnlfdXBkYXRlKGltZywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW1nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW1hZ2VUYWcgaW5zdGFuY2UgdXNpbmcgdGhlIGNvbmZpZ3VyYXRpb24gZGVmaW5lZCBmb3IgdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjaW1hZ2VUYWdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgcHVibGljIElEIG9mIHRoZSBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SW1hZ2VUYWd9IEFuIEltYWdlVGFnIGluc3RhbmNlIHRoYXQgaXMgYXR0YWNoZWQgKGNoYWluZWQpIHRvIHRoaXMgQ2xvdWRpbmFyeSBpbnN0YW5jZS5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW1hZ2VUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW1hZ2VUYWcocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB0YWc7XG4gICAgICB0YWcgPSBuZXcgaW1hZ2V0YWcocHVibGljSWQsIHRoaXMuY29uZmlnKCkpO1xuICAgICAgdGFnLnRyYW5zZm9ybWF0aW9uKCkuZnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgUGljdHVyZVRhZyBpbnN0YW5jZSwgY29uZmlndXJlZCB1c2luZyB0aGlzIGBjbG91ZGluYXJ5YCBpbnN0YW5jZS5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNQaWN0dXJlVGFnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gdGhlIHB1YmxpYyBJRCBvZiB0aGUgcmVzb3VyY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGFkZGl0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBuZXcgSW1hZ2VUYWcgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHNvdXJjZXMgLSB0aGUgc291cmNlcyBkZWZpbml0aW9uc1xuICAgICAqIEByZXR1cm4ge1BpY3R1cmVUYWd9IEEgUGljdHVyZVRhZyB0aGF0IGlzIGF0dGFjaGVkIChjaGFpbmVkKSB0byB0aGlzIENsb3VkaW5hcnkgaW5zdGFuY2VcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwaWN0dXJlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBpY3R1cmVUYWcocHVibGljSWQsIG9wdGlvbnMsIHNvdXJjZXMpIHtcbiAgICAgIHZhciB0YWc7XG4gICAgICB0YWcgPSBuZXcgcGljdHVyZXRhZyhwdWJsaWNJZCwgdGhpcy5jb25maWcoKSwgc291cmNlcyk7XG4gICAgICB0YWcudHJhbnNmb3JtYXRpb24oKS5mcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTb3VyY2VUYWcgaW5zdGFuY2UsIGNvbmZpZ3VyZWQgdXNpbmcgdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjU291cmNlVGFnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gdGhlIHB1YmxpYyBJRCBvZiB0aGUgcmVzb3VyY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBhZGRpdGlvbmFsIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgbmV3IGluc3RhbmNlLlxuICAgICAqIEByZXR1cm4ge1NvdXJjZVRhZ30gQSBTb3VyY2VUYWcgdGhhdCBpcyBhdHRhY2hlZCAoY2hhaW5lZCkgdG8gdGhpcyBDbG91ZGluYXJ5IGluc3RhbmNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic291cmNlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvdXJjZVRhZyhwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgdmFyIHRhZztcbiAgICAgIHRhZyA9IG5ldyBzb3VyY2V0YWcocHVibGljSWQsIHRoaXMuY29uZmlnKCkpO1xuICAgICAgdGFnLnRyYW5zZm9ybWF0aW9uKCkuZnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHZpZGVvIHRodW1ibmFpbCBVUkwgZnJvbSB0aGUgc3BlY2lmaWVkIHJlbW90ZSB2aWRlbyBhbmQgaW5jbHVkZXMgaXQgaW4gYW4gaW1hZ2UgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3ZpZGVvX3RodW1ibmFpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdmlkZW8gZnJvbSB0aGUgcmVsZXZhbnQgdmlkZW8gc2l0ZS5cbiAgICAgKiAgQWRkaXRpb25hbGx5LCBlaXRoZXIgYXBwZW5kIHRoZSBpbWFnZSBleHRlbnNpb24gdHlwZSB0byB0aGUgaWRlbnRpZmllciB2YWx1ZSBvciBzZXRcbiAgICAgKiAgdGhlIGltYWdlIGRlbGl2ZXJ5IGZvcm1hdCBpbiB0aGUgJ29wdGlvbnMnIHBhcmFtZXRlciB1c2luZyB0aGUgJ2Zvcm1hdCcgdHJhbnNmb3JtYXRpb24gb3B0aW9uLlxuICAgICAqICBGb3IgZXhhbXBsZSwgYSBZb3VUdWJlIHZpZGVvIG1pZ2h0IGhhdmUgdGhlIGlkZW50aWZpZXI6ICdvLXVybmxhSnBPQS5qcGcnLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzIHRvIGFwcGx5LlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEFuIEhUTUwgaW1hZ2UgdGFnIGVsZW1lbnRcbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9fdGh1bWJuYWlsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZGVvX3RodW1ibmFpbChwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2UocHVibGljSWQsIG1lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdCgpKHt9LCBERUZBVUxUX1BPU1RFUl9PUFRJT05TLCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIGZhY2Vib29rIHByb2ZpbGUgaW1hZ2UgYW5kIGRlbGl2ZXJzIGl0IGluIGFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2ZhY2Vib29rX3Byb2ZpbGVfaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgRmFjZWJvb2sgbnVtZXJpYyBJRC4gQWRkaXRpb25hbGx5LCBlaXRoZXIgYXBwZW5kIHRoZSBpbWFnZSBleHRlbnNpb24gdHlwZVxuICAgICAqICB0byB0aGUgSUQgb3Igc2V0IHRoZSBpbWFnZSBkZWxpdmVyeSBmb3JtYXQgaW4gdGhlICdvcHRpb25zJyBwYXJhbWV0ZXIgdXNpbmcgdGhlICdmb3JtYXQnIHRyYW5zZm9ybWF0aW9uIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gQW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZhY2Vib29rX3Byb2ZpbGVfaW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFjZWJvb2tfcHJvZmlsZV9pbWFnZShwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2UocHVibGljSWQsIGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe1xuICAgICAgICB0eXBlOiAnZmFjZWJvb2snXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIFR3aXR0ZXIgcHJvZmlsZSBpbWFnZSBieSBJRCBhbmQgZGVsaXZlcnMgaXQgaW4gYW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdHdpdHRlcl9wcm9maWxlX2ltYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIFR3aXR0ZXIgbnVtZXJpYyBJRC4gQWRkaXRpb25hbGx5LCBlaXRoZXIgYXBwZW5kIHRoZSBpbWFnZSBleHRlbnNpb24gdHlwZVxuICAgICAqICB0byB0aGUgSUQgb3Igc2V0IHRoZSBpbWFnZSBkZWxpdmVyeSBmb3JtYXQgaW4gdGhlICdvcHRpb25zJyBwYXJhbWV0ZXIgdXNpbmcgdGhlICdmb3JtYXQnIHRyYW5zZm9ybWF0aW9uIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gQW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInR3aXR0ZXJfcHJvZmlsZV9pbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0d2l0dGVyX3Byb2ZpbGVfaW1hZ2UocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlKHB1YmxpY0lkLCBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgICAgdHlwZTogJ3R3aXR0ZXInXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIFR3aXR0ZXIgcHJvZmlsZSBpbWFnZSBieSBuYW1lIGFuZCBkZWxpdmVycyBpdCBpbiBhbiBpbWFnZSB0YWcgZWxlbWVudC5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN0d2l0dGVyX25hbWVfcHJvZmlsZV9pbWFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBUd2l0dGVyIHNjcmVlbiBuYW1lLiBBZGRpdGlvbmFsbHksIGVpdGhlciBhcHBlbmQgdGhlIGltYWdlIGV4dGVuc2lvbiB0eXBlXG4gICAgICogIHRvIHRoZSBzY3JlZW4gbmFtZSBvciBzZXQgdGhlIGltYWdlIGRlbGl2ZXJ5IGZvcm1hdCBpbiB0aGUgJ29wdGlvbnMnIHBhcmFtZXRlciB1c2luZyB0aGUgJ2Zvcm1hdCcgdHJhbnNmb3JtYXRpb24gb3B0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzLCB7QGxpbmsgQ29uZmlndXJhdGlvbn0gcGFyYW1ldGVycyxcbiAgICAgKiAgYW5kIHN0YW5kYXJkIEhUTUwgJmx0O2ltZyZndDsgdGFnIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGltYWdlIHRhZy5cbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBBbiBpbWFnZSB0YWcgZWxlbWVudC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidHdpdHRlcl9uYW1lX3Byb2ZpbGVfaW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHdpdHRlcl9uYW1lX3Byb2ZpbGVfaW1hZ2UocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlKHB1YmxpY0lkLCBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgICAgdHlwZTogJ3R3aXR0ZXJfbmFtZSdcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGEgR3JhdmF0YXIgcHJvZmlsZSBpbWFnZSBhbmQgZGVsaXZlcnMgaXQgaW4gYW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjZ3JhdmF0YXJfaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgY2FsY3VsYXRlZCBoYXNoIGZvciB0aGUgR3JhdmF0YXIgZW1haWwgYWRkcmVzcy5cbiAgICAgKiAgQWRkaXRpb25hbGx5LCBlaXRoZXIgYXBwZW5kIHRoZSBpbWFnZSBleHRlbnNpb24gdHlwZSB0byB0aGUgc2NyZWVuIG5hbWUgb3Igc2V0IHRoZSBpbWFnZSBkZWxpdmVyeSBmb3JtYXRcbiAgICAgKiAgaW4gdGhlICdvcHRpb25zJyBwYXJhbWV0ZXIgdXNpbmcgdGhlICdmb3JtYXQnIHRyYW5zZm9ybWF0aW9uIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gQW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdyYXZhdGFyX2ltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdyYXZhdGFyX2ltYWdlKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWFnZShwdWJsaWNJZCwgYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICAgIHR5cGU6ICdncmF2YXRhcidcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGFuIGltYWdlIGZyb20gYSByZW1vdGUgVVJMIGFuZCBkZWxpdmVycyBpdCBpbiBhbiBpbWFnZSB0YWcgZWxlbWVudC5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNmZXRjaF9pbWFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBmdWxsIFVSTCBvZiB0aGUgaW1hZ2UgdG8gZmV0Y2gsIGluY2x1ZGluZyB0aGUgZXh0ZW5zaW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzLCB7QGxpbmsgQ29uZmlndXJhdGlvbn0gcGFyYW1ldGVycyxcbiAgICAgKiAgYW5kIHN0YW5kYXJkIEhUTUwgJmx0O2ltZyZndDsgdGFnIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGltYWdlIHRhZy5cbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBBbiBpbWFnZSB0YWcgZWxlbWVudC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZmV0Y2hfaW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmV0Y2hfaW1hZ2UocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlKHB1YmxpY0lkLCBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgICAgdHlwZTogJ2ZldGNoJ1xuICAgICAgfSwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHZpZGVvIHRhZy5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN2aWRlb1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBwdWJsaWMgSUQgb2YgdGhlIHZpZGVvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzLCB7QGxpbmsgQ29uZmlndXJhdGlvbn0gcGFyYW1ldGVycyxcbiAgICAgKiAgYW5kIHN0YW5kYXJkIEhUTUwgJmx0O2ltZyZndDsgdGFnIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGltYWdlIHRhZy5cbiAgICAgKiBAcmV0dXJuIHtIVE1MVmlkZW9FbGVtZW50fSBBIHZpZGVvIHRhZyBET00gZWxlbWVudC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlkZW8ocHVibGljSWQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHJldHVybiB0aGlzLnZpZGVvVGFnKHB1YmxpY0lkLCBvcHRpb25zKS50b0h0bWwoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFZpZGVvVGFnIGluc3RhbmNlIHVzaW5nIHRoZSBjb25maWd1cmF0aW9uIGRlZmluZWQgZm9yIHRoaXMgYGNsb3VkaW5hcnlgIGluc3RhbmNlLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3ZpZGVvVGFnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIHB1YmxpYyBJRCBvZiB0aGUgdmlkZW8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzLCB7QGxpbmsgQ29uZmlndXJhdGlvbn0gcGFyYW1ldGVycyxcbiAgICAgKiAgYW5kIHN0YW5kYXJkIEhUTUwgJmx0O2ltZyZndDsgdGFnIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGltYWdlIHRhZy5cbiAgICAgKiBAcmV0dXJuIHtWaWRlb1RhZ30gQSBWaWRlb1RhZyB0aGF0IGlzIGF0dGFjaGVkIChjaGFpbmVkKSB0byB0aGlzIGBjbG91ZGluYXJ5YCBpbnN0YW5jZS5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9UYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlkZW9UYWcocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucywgdGhpcy5jb25maWcoKSk7XG4gICAgICByZXR1cm4gbmV3IHZpZGVvdGFnKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBzcHJpdGUgUE5HIGltYWdlIHRoYXQgY29udGFpbnMgYWxsIGltYWdlcyB3aXRoIHRoZSBzcGVjaWZpZWQgdGFnIGFuZCB0aGUgY29ycmVzcG9uZGluZyBjc3MgZmlsZS5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNzcHJpdGVfY3NzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIHRhZyBvbiB3aGljaCB0byBiYXNlIHRoZSBzcHJpdGUgaW1hZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMgdG8gaW5jbHVkZSBpbiB0aGUgVVJMLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVSTCBvZiB0aGUgZ2VuZXJhdGVkIENTUyBmaWxlLiBUaGUgc3ByaXRlIGltYWdlIGhhcyB0aGUgc2FtZSBVUkwsIGJ1dCB3aXRoIGEgUE5HIGV4dGVuc2lvbi5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc3ByaXRlX2dlbmVyYXRpb25cIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgU3ByaXRlIGdlbmVyYXRpb248L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNwcml0ZV9jc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3ByaXRlX2NzcyhwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe1xuICAgICAgICB0eXBlOiAnc3ByaXRlJ1xuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICBpZiAoIXB1YmxpY0lkLm1hdGNoKC8uY3NzJC8pKSB7XG4gICAgICAgIG9wdGlvbnMuZm9ybWF0ID0gJ2Nzcyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy51cmwocHVibGljSWQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHJlc3BvbnNpdmUgaW1hZ2UgYmVoYXZpb3IgZm9yIGFsbCBpbWFnZSB0YWdzIHdpdGggdGhlICdjbGQtcmVzcG9uc2l2ZSdcbiAgICAgKiAgKG9yIG90aGVyIGRlZmluZWQge0BsaW5rIENsb3VkaW5hcnkjcmVzcG9uc2l2ZXxyZXNwb25zaXZlfSBjbGFzcykuPGJyLz5cbiAgICAgKiAgVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGludm9rZWQgYWZ0ZXIgdGhlIHBhZ2UgaGFzIGxvYWRlZC48YnIvPlxuICAgICAqICA8Yj5Ob3RlPC9iPjogQ2FsbHMge0BsaW5rIENsb3VkaW5hcnkjY2xvdWRpbmFyeV91cGRhdGV8Y2xvdWRpbmFyeV91cGRhdGV9IHRvIG1vZGlmeSBpbWFnZSB0YWdzLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3Jlc3BvbnNpdmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZXNwb25zaXZlX2NsYXNzPSdjbGQtcmVzcG9uc2l2ZSddIC0gQW4gYWx0ZXJuYXRpdmUgY2xhc3NcbiAgICAgKiAgdG8gbG9jYXRlIHRoZSByZWxldmFudCAmbHQ7aW1nJmd0OyB0YWdzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXNwb25zaXZlX2RlYm91bmNlPTEwMF0gLSBUaGUgZGVib3VuY2UgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Jvb3RzdHJhcD10cnVlXSBJZiB0cnVlLCBwcm9jZXNzZXMgdGhlICZsdDtpbWcmZ3Q7IHRhZ3MgYnkgY2FsbGluZ1xuICAgICAqICB7QGxpbmsgQ2xvdWRpbmFyeSNjbG91ZGluYXJ5X3VwZGF0ZXxjbG91ZGluYXJ5X3VwZGF0ZX0uIFdoZW4gZmFsc2UsIHRoZSB0YWdzIGFyZSBwcm9jZXNzZWRcbiAgICAgKiAgb25seSBhZnRlciBhIHJlc2l6ZSBldmVudC5cbiAgICAgKiBAc2VlIHtAbGluayBDbG91ZGluYXJ5I2Nsb3VkaW5hcnlfdXBkYXRlfGNsb3VkaW5hcnlfdXBkYXRlfSBmb3IgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vcmVzcG9uc2l2ZV9pbWFnZXMjYXV0b21hdGluZ19yZXNwb25zaXZlX2ltYWdlc193aXRoX2phdmFzY3JpcHRcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdXRvbWF0aW5nIHJlc3BvbnNpdmUgaW1hZ2VzIHdpdGggSmF2YVNjcmlwdDwvYT5cbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gdGhhdCB3aGVuIGNhbGxlZCwgcmVtb3ZlcyB0aGUgcmVzaXplIEV2ZW50TGlzdGVuZXIgYWRkZWQgYnkgdGhpcyBmdW5jdGlvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlc3BvbnNpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzcG9uc2l2ZShvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGJvb3RzdHJhcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHZhciByZWYsIHJlZjEsIHJlZjIsIHJlc3BvbnNpdmVDbGFzcywgcmVzcG9uc2l2ZVJlc2l6ZSwgdGltZW91dDtcbiAgICAgIHRoaXMucmVzcG9uc2l2ZUNvbmZpZyA9IG1lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdCgpKHRoaXMucmVzcG9uc2l2ZUNvbmZpZyB8fCB7fSwgb3B0aW9ucyk7XG4gICAgICByZXNwb25zaXZlQ2xhc3MgPSAocmVmID0gdGhpcy5yZXNwb25zaXZlQ29uZmlnLnJlc3BvbnNpdmVfY2xhc3MpICE9IG51bGwgPyByZWYgOiB0aGlzLmNvbmZpZygncmVzcG9uc2l2ZV9jbGFzcycpO1xuICAgICAgaWYgKGJvb3RzdHJhcCkge1xuICAgICAgICB0aGlzLmNsb3VkaW5hcnlfdXBkYXRlKFwiaW1nLlwiLmNvbmNhdChyZXNwb25zaXZlQ2xhc3MsIFwiLCBpbWcuY2xkLWhpZHBpXCIpLCB0aGlzLnJlc3BvbnNpdmVDb25maWcpO1xuICAgICAgfVxuICAgICAgcmVzcG9uc2l2ZVJlc2l6ZSA9IChyZWYxID0gKHJlZjIgPSB0aGlzLnJlc3BvbnNpdmVDb25maWcucmVzcG9uc2l2ZV9yZXNpemUpICE9IG51bGwgPyByZWYyIDogdGhpcy5jb25maWcoJ3Jlc3BvbnNpdmVfcmVzaXplJykpICE9IG51bGwgPyByZWYxIDogdHJ1ZTtcbiAgICAgIGlmIChyZXNwb25zaXZlUmVzaXplICYmICF0aGlzLnJlc3BvbnNpdmVSZXNpemVJbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLnJlc3BvbnNpdmVDb25maWcucmVzaXppbmcgPSB0aGlzLnJlc3BvbnNpdmVSZXNpemVJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB2YXIgbWFrZVJlc3BvbnNpdmUgPSBmdW5jdGlvbiBtYWtlUmVzcG9uc2l2ZSgpIHtcbiAgICAgICAgICB2YXIgZGVib3VuY2UsIHJlZjMsIHJlZjQsIHJlc2V0LCBydW4sIHdhaXQsIHdhaXRGdW5jO1xuICAgICAgICAgIGRlYm91bmNlID0gKHJlZjMgPSAocmVmNCA9IF90aGlzLnJlc3BvbnNpdmVDb25maWcucmVzcG9uc2l2ZV9kZWJvdW5jZSkgIT0gbnVsbCA/IHJlZjQgOiBfdGhpcy5jb25maWcoJ3Jlc3BvbnNpdmVfZGVib3VuY2UnKSkgIT0gbnVsbCA/IHJlZjMgOiAxMDA7XG4gICAgICAgICAgcmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBydW4gPSBmdW5jdGlvbiBydW4oKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY2xvdWRpbmFyeV91cGRhdGUoXCJpbWcuXCIuY29uY2F0KHJlc3BvbnNpdmVDbGFzcyksIF90aGlzLnJlc3BvbnNpdmVDb25maWcpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgd2FpdEZ1bmMgPSBmdW5jdGlvbiB3YWl0RnVuYygpIHtcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gcnVuKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3YWl0ID0gZnVuY3Rpb24gd2FpdCgpIHtcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCh3YWl0RnVuYywgZGVib3VuY2UpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGRlYm91bmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2FpdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcnVuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgbWFrZVJlc3BvbnNpdmUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgbWFrZVJlc3BvbnNpdmUpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2NhbGNfYnJlYWtwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNhbGNfYnJlYWtwb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjX2JyZWFrcG9pbnQoZWxlbWVudCwgd2lkdGgsIHN0ZXBzKSB7XG4gICAgICB2YXIgYnJlYWtwb2ludHMgPSBsb2Rhc2hfZ2V0RGF0YShlbGVtZW50LCAnYnJlYWtwb2ludHMnKSB8fCBsb2Rhc2hfZ2V0RGF0YShlbGVtZW50LCAnc3RvcHBvaW50cycpIHx8IHRoaXMuY29uZmlnKCdicmVha3BvaW50cycpIHx8IHRoaXMuY29uZmlnKCdzdG9wcG9pbnRzJykgfHwgZGVmYXVsdEJyZWFrcG9pbnRzO1xuICAgICAgaWYgKGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShicmVha3BvaW50cykpIHtcbiAgICAgICAgcmV0dXJuIGJyZWFrcG9pbnRzKHdpZHRoLCBzdGVwcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkoYnJlYWtwb2ludHMpKSB7XG4gICAgICAgICAgYnJlYWtwb2ludHMgPSBicmVha3BvaW50cy5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChwb2ludCk7XG4gICAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9zZXN0QWJvdmUoYnJlYWtwb2ludHMsIHdpZHRoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNjYWxjX3N0b3Bwb2ludFxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgY2FsY19icmVha3BvaW50fSBpbnN0ZWFkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNhbGNfc3RvcHBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNfc3RvcHBvaW50KGVsZW1lbnQsIHdpZHRoLCBzdGVwcykge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsY19icmVha3BvaW50KGVsZW1lbnQsIHdpZHRoLCBzdGVwcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjZGV2aWNlX3BpeGVsX3JhdGlvXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZXZpY2VfcGl4ZWxfcmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV2aWNlX3BpeGVsX3JhdGlvKHJvdW5kRHByKSB7XG4gICAgICByb3VuZERwciA9IHJvdW5kRHByID09IG51bGwgPyB0cnVlIDogcm91bmREcHI7XG4gICAgICB2YXIgZHByID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9PSBudWxsID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiB2b2lkIDApIHx8IDE7XG4gICAgICBpZiAocm91bmREcHIpIHtcbiAgICAgICAgZHByID0gTWF0aC5jZWlsKGRwcik7XG4gICAgICB9XG4gICAgICBpZiAoZHByIDw9IDAgfHwgZHByID09PSAwIC8gMCkge1xuICAgICAgICBkcHIgPSAxO1xuICAgICAgfVxuICAgICAgdmFyIGRwclN0cmluZyA9IGRwci50b1N0cmluZygpO1xuICAgICAgaWYgKGRwclN0cmluZy5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgICAgZHByU3RyaW5nICs9ICcuMCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZHByU3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQXBwbGllcyByZXNwb25zaXZlbmVzcyB0byBhbGwgPGNvZGU+Jmx0O2ltZyZndDs8L2NvZGU+IHRhZ3MgdW5kZXIgZWFjaCByZWxldmFudCBub2RlXG4gICAgKiAgKHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdGFnIGNvbnRhaW5zIHRoZSB7QGxpbmsgQ2xvdWRpbmFyeSNyZXNwb25zaXZlfHJlc3BvbnNpdmV9IGNsYXNzKS5cbiAgICAqIEBwYXJhbSB7RWxlbWVudFtdfSBub2RlcyBUaGUgcGFyZW50IG5vZGVzIHdoZXJlIHlvdSB3YW50IHRvIHNlYXJjaCBmb3IgJmx0O2ltZyZndDsgdGFncy5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIHtAbGluayBDbG91ZGluYXJ5I2Nsb3VkaW5hcnlfdXBkYXRlfGNsb3VkaW5hcnlfdXBkYXRlfSBvcHRpb25zIHRvIGFwcGx5LlxuICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiXG4gICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3Byb2Nlc3NJbWFnZVRhZ3NcbiAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NJbWFnZVRhZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0ltYWdlVGFncyhub2Rlcywgb3B0aW9ucykge1xuICAgICAgaWYgKGlzRW1wdHkobm9kZXMpKSB7XG4gICAgICAgIC8vIHNpbWlsYXIgdG8gYCQuZm4uY2xvdWRpbmFyeWBcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gZGVmYXVsdHMoe30sIG9wdGlvbnMgfHwge30sIHRoaXMuY29uZmlnKCkpO1xuICAgICAgdmFyIGltYWdlcyA9IG5vZGVzLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gL15pbWckL2kudGVzdChub2RlLnRhZ05hbWUpO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBpbWdPcHRpb25zID0gYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICAgICAgd2lkdGg6IG5vZGUuZ2V0QXR0cmlidXRlKCd3aWR0aCcpLFxuICAgICAgICAgIGhlaWdodDogbm9kZS5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpLFxuICAgICAgICAgIHNyYzogbm9kZS5nZXRBdHRyaWJ1dGUoJ3NyYycpXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YXIgcHVibGljSWQgPSBpbWdPcHRpb25zWydzb3VyY2UnXSB8fCBpbWdPcHRpb25zWydzcmMnXTtcbiAgICAgICAgZGVsZXRlIGltZ09wdGlvbnNbJ3NvdXJjZSddO1xuICAgICAgICBkZWxldGUgaW1nT3B0aW9uc1snc3JjJ107XG4gICAgICAgIHZhciBhdHRyID0gbmV3IHNyY190cmFuc2Zvcm1hdGlvbihpbWdPcHRpb25zKS50b0h0bWxBdHRyaWJ1dGVzKCk7XG4gICAgICAgIGxvZGFzaF9zZXREYXRhKG5vZGUsICdzcmMtY2FjaGUnLCB1cmxfdXJsKHB1YmxpY0lkLCBpbWdPcHRpb25zKSk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGF0dHIud2lkdGgpO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYXR0ci5oZWlnaHQpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jbG91ZGluYXJ5X3VwZGF0ZShpbWFnZXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBVcGRhdGVzIHRoZSBkcHIgKGZvciBgZHByX2F1dG9gKSBhbmQgcmVzcG9uc2l2ZSAoZm9yIGB3X2F1dG9gKSBmaWVsZHMgYWNjb3JkaW5nIHRvXG4gICAgKiAgdGhlIGN1cnJlbnQgY29udGFpbmVyIHNpemUgYW5kIHRoZSBkZXZpY2UgcGl4ZWwgcmF0aW8uPGJyLz5cbiAgICAqICA8Yj5Ob3RlPC9iPjpgd19hdXRvYCBpcyB1cGRhdGVkIG9ubHkgZm9yIGltYWdlcyBtYXJrZWQgd2l0aCB0aGUgYGNsZC1yZXNwb25zaXZlYFxuICAgICogIChvciBvdGhlciBkZWZpbmVkIHtAbGluayBDbG91ZGluYXJ5I3Jlc3BvbnNpdmV8cmVzcG9uc2l2ZX0pIGNsYXNzLlxuICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjY2xvdWRpbmFyeV91cGRhdGVcbiAgICAqIEBwYXJhbSB7KEFycmF5fHN0cmluZ3xOb2RlTGlzdCl9IGVsZW1lbnRzIC0gVGhlIEhUTUwgaW1hZ2UgZWxlbWVudHMgdG8gbW9kaWZ5LlxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbnxzdHJpbmd9IFtvcHRpb25zLnJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzPXRydWVdXG4gICAgKiBQb3NzaWJsZSB2YWx1ZXM6PGJyLz5cbiAgICAqICAtIGB0cnVlYDogQWx3YXlzIHVzZSBicmVha3BvaW50cyBmb3Igd2lkdGguPGJyLz5cbiAgICAqICAtIGByZXNpemVgOiBVc2UgZXhhY3Qgd2lkdGggb24gZmlyc3QgcmVuZGVyIGFuZCBicmVha3BvaW50cyBvbiByZXNpemUuPGJyLz5cbiAgICAqICAtIGBmYWxzZWA6IEFsd2F5cyB1c2UgZXhhY3Qgd2lkdGguXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlc3BvbnNpdmVdIC0gSWYgYHRydWVgLCBlbmFibGUgcmVzcG9uc2l2ZSBvbiBhbGwgc3BlY2lmaWVkIGVsZW1lbnRzLlxuICAgICogIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gZGVmaW5lIHNwZWNpZmljIEhUTUwgZWxlbWVudHMgdG8gbW9kaWZ5IGJ5IGFkZGluZyB0aGUgYGNsZC1yZXNwb25zaXZlYFxuICAgICogIChvciBvdGhlciBjdXN0b20tZGVmaW5lZCB7QGxpbmsgQ2xvdWRpbmFyeSNyZXNwb25zaXZlfHJlc3BvbnNpdmVfY2xhc3N9KSBjbGFzcyB0byB0aG9zZSBlbGVtZW50cy5cbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVzcG9uc2l2ZV9wcmVzZXJ2ZV9oZWlnaHRdIC0gSWYgYHRydWVgLCBvcmlnaW5hbCBjc3MgaGVpZ2h0IGlzIHByZXNlcnZlZC5cbiAgICAqICBTaG91bGQgYmUgdXNlZCBvbmx5IGlmIHRoZSB0cmFuc2Zvcm1hdGlvbiBzdXBwb3J0cyBkaWZmZXJlbnQgYXNwZWN0IHJhdGlvcy5cbiAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsb3VkaW5hcnlfdXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3VkaW5hcnlfdXBkYXRlKGVsZW1lbnRzLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBjb250YWluZXJXaWR0aCwgZGF0YVNyYywgbWF0Y2gsIHJlZjQsIHJlcXVpcmVkV2lkdGg7XG4gICAgICBpZiAoZWxlbWVudHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIHZhciByZXNwb25zaXZlID0gb3B0aW9ucy5yZXNwb25zaXZlICE9IG51bGwgPyBvcHRpb25zLnJlc3BvbnNpdmUgOiB0aGlzLmNvbmZpZygncmVzcG9uc2l2ZScpO1xuICAgICAgZWxlbWVudHMgPSBub3JtYWxpemVUb0FycmF5KGVsZW1lbnRzKTtcbiAgICAgIHZhciByZXNwb25zaXZlQ2xhc3M7XG4gICAgICBpZiAodGhpcy5yZXNwb25zaXZlQ29uZmlnICYmIHRoaXMucmVzcG9uc2l2ZUNvbmZpZy5yZXNwb25zaXZlX2NsYXNzICE9IG51bGwpIHtcbiAgICAgICAgcmVzcG9uc2l2ZUNsYXNzID0gdGhpcy5yZXNwb25zaXZlQ29uZmlnLnJlc3BvbnNpdmVfY2xhc3M7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVzcG9uc2l2ZV9jbGFzcyAhPSBudWxsKSB7XG4gICAgICAgIHJlc3BvbnNpdmVDbGFzcyA9IG9wdGlvbnMucmVzcG9uc2l2ZV9jbGFzcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3BvbnNpdmVDbGFzcyA9IHRoaXMuY29uZmlnKCdyZXNwb25zaXZlX2NsYXNzJyk7XG4gICAgICB9XG4gICAgICB2YXIgcm91bmREcHIgPSBvcHRpb25zLnJvdW5kX2RwciAhPSBudWxsID8gb3B0aW9ucy5yb3VuZF9kcHIgOiB0aGlzLmNvbmZpZygncm91bmRfZHByJyk7XG4gICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgaWYgKC9pbWcvaS50ZXN0KHRhZy50YWdOYW1lKSkge1xuICAgICAgICAgIHZhciBzZXRVcmwgPSB0cnVlO1xuICAgICAgICAgIGlmIChyZXNwb25zaXZlKSB7XG4gICAgICAgICAgICBsb2Rhc2hfYWRkQ2xhc3ModGFnLCByZXNwb25zaXZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhU3JjID0gbG9kYXNoX2dldERhdGEodGFnLCAnc3JjLWNhY2hlJykgfHwgbG9kYXNoX2dldERhdGEodGFnLCAnc3JjJyk7XG4gICAgICAgICAgaWYgKCFpc0VtcHR5KGRhdGFTcmMpKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgZHByIGFjY29yZGluZyB0byB0aGUgZGV2aWNlJ3MgZGV2aWNlUGl4ZWxSYXRpb1xuICAgICAgICAgICAgZGF0YVNyYyA9IHVwZGF0ZURwci5jYWxsKF90aGlzMiwgZGF0YVNyYywgcm91bmREcHIpO1xuICAgICAgICAgICAgaWYgKGh0bWx0YWcuaXNSZXNwb25zaXZlKHRhZywgcmVzcG9uc2l2ZUNsYXNzKSkge1xuICAgICAgICAgICAgICBjb250YWluZXJXaWR0aCA9IGNsb3VkaW5hcnlfZmluZENvbnRhaW5lcldpZHRoKHRhZyk7XG4gICAgICAgICAgICAgIGlmIChjb250YWluZXJXaWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICgvd19hdXRvOmJyZWFrcG9pbnRzLy50ZXN0KGRhdGFTcmMpKSB7XG4gICAgICAgICAgICAgICAgICByZXF1aXJlZFdpZHRoID0gY2xvdWRpbmFyeV9tYXhXaWR0aChjb250YWluZXJXaWR0aCwgdGFnKTtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTcmMgPSBkYXRhU3JjLnJlcGxhY2UoL3dfYXV0bzpicmVha3BvaW50cyhbXzAtOV0qKSg6WzAtOV0rKT8vLCBcIndfYXV0bzpicmVha3BvaW50cyQxOlwiLmNvbmNhdChyZXF1aXJlZFdpZHRoKSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRVcmwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbWF0Y2ggPSAvd19hdXRvKDooXFxkKykpPy8uZXhlYyhkYXRhU3JjKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFdpZHRoID0gYXBwbHlCcmVha3BvaW50cy5jYWxsKF90aGlzMiwgdGFnLCBjb250YWluZXJXaWR0aCwgbWF0Y2hbMl0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFdpZHRoID0gY2xvdWRpbmFyeV9tYXhXaWR0aChyZXF1aXJlZFdpZHRoLCB0YWcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWlyZWRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGFTcmMgPSBkYXRhU3JjLnJlcGxhY2UoL3dfYXV0b1teLFxcL10qL2csIFwid19cIi5jb25jYXQocmVxdWlyZWRXaWR0aCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHNldFVybCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZGFzaF9yZW1vdmVBdHRyaWJ1dGUodGFnLCAnd2lkdGgnKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMucmVzcG9uc2l2ZV9wcmVzZXJ2ZV9oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgIGxvZGFzaF9yZW1vdmVBdHRyaWJ1dGUodGFnLCAnaGVpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENvbnRhaW5lciBkb2Vzbid0IGtub3cgdGhlIHNpemUgeWV0IC0gdXN1YWxseSBiZWNhdXNlIHRoZSBpbWFnZSBpcyBoaWRkZW4gb3Igb3V0c2lkZSB0aGUgRE9NLlxuICAgICAgICAgICAgICAgIHNldFVybCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaXNMYXp5TG9hZGluZyA9IG9wdGlvbnMubG9hZGluZyA9PT0gJ2xhenknICYmICFfdGhpczIuaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZCgpICYmIF90aGlzMi5pc0xhenlMb2FkU3VwcG9ydGVkKCkgJiYgIWVsZW1lbnRzWzBdLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgICBpZiAoc2V0VXJsIHx8IGlzTGF6eUxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgLy8gSWYgZGF0YS13aWR0aCBleGlzdHMsIHNldCB3aWR0aCB0byBiZSBkYXRhLXdpZHRoXG4gICAgICAgICAgICAgIF90aGlzMi5zZXRBdHRyaWJ1dGVJZkV4aXN0cyhlbGVtZW50c1swXSwgJ3dpZHRoJywgJ2RhdGEtd2lkdGgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXRVcmwgJiYgIWlzTGF6eUxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgbG9kYXNoX3NldEF0dHJpYnV0ZSh0YWcsICdzcmMnLCBkYXRhU3JjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBlbGVtZW50W3RvQXR0cmlidXRlXSA9IGVsZW1lbnRbZnJvbUF0dHJpYnV0ZV0gaWYgZWxlbWVudFtmcm9tQXR0cmlidXRlXSBpcyBzZXRcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB0b0F0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSBmcm9tQXR0cmlidXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0QXR0cmlidXRlSWZFeGlzdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXR0cmlidXRlSWZFeGlzdHMoZWxlbWVudCwgdG9BdHRyaWJ1dGUsIGZyb21BdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVWYWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGZyb21BdHRyaWJ1dGUpO1xuICAgICAgaWYgKGF0dHJpYnV0ZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgbG9kYXNoX3NldEF0dHJpYnV0ZShlbGVtZW50LCB0b0F0dHJpYnV0ZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBJbnRlcnNlY3Rpb24gT2JzZXJ2ZXIgQVBJIGlzIHN1cHBvcnRlZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImlzTGF6eUxvYWRTdXBwb3J0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNMYXp5TG9hZFN1cHBvcnRlZCgpIHtcbiAgICAgIHJldHVybiB3aW5kb3cgJiYgJ0ludGVyc2VjdGlvbk9ic2VydmVyJyBpbiB3aW5kb3c7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHVzaW5nIENocm9tZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZCgpIHtcbiAgICAgIHJldHVybiAnbG9hZGluZycgaW4gSFRNTEltYWdlRWxlbWVudC5wcm90b3R5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gb2JqZWN0LCBpbml0aWFsaXplZCB3aXRoIHRoZSBzcGVjaWZpZWQgb3B0aW9ucywgZm9yIGNoYWluaW5nIHB1cnBvc2VzLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3RyYW5zZm9ybWF0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gb3B0aW9ucyB0byBhcHBseS5cbiAgICAgKiBAcmV0dXJuIHtUcmFuc2Zvcm1hdGlvbn1cbiAgICAgKiBAc2VlIFRyYW5zZm9ybWF0aW9uXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi92aWRlb190cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIHZpZGVvIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gc3JjX3RyYW5zZm9ybWF0aW9uW1wibmV3XCJdKHRoaXMuY29uZmlnKCkpLmZyb21PcHRpb25zKG9wdGlvbnMpLnNldFBhcmVudCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiB3aWxsIGFwcGVuZCBhIFRyYW5zcGFyZW50VmlkZW8gZWxlbWVudCB0byB0aGUgaHRtbEVsQ29udGFpbmVyIHBhc3NlZCB0byBpdC5cbiAgICAgKiAgICAgICAgICAgICAgVHJhbnNwYXJlbnRWaWRlbyBjYW4gZWl0aGVyIGJlIGFuIEhUTUwgVmlkZW8gdGFnLCBvciBhbiBIVE1MIENhbnZhcyBUYWcuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaHRtbEVsQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgVGhlIHtAbGluayBUcmFuc3BhcmVudFZpZGVvT3B0aW9uc30gb3B0aW9ucyB0byBhcHBseSAtIEV4dGVuZHMgVHJhbnNmb3JtYXRpb25PcHRpb25zXG4gICAgICogICAgICAgICAgICAgICAgIG9wdGlvbnMucGxheXNpbmxpbmUgICAgLSBIVE1MIFZpZGVvIFRhZydzIG5hdGl2ZSBwbGF5c2lubGluZSAtIHBhc3NlZCB0byB2aWRlbyBlbGVtZW50LlxuICAgICAqICAgICAgICAgICAgICAgICBvcHRpb25zLnBvc3RlciAgICAgICAgIC0gSFRNTCBWaWRlbyBUYWcncyBuYXRpdmUgcG9zdGVyIC0gcGFzc2VkIHRvIHZpZGVvIGVsZW1lbnQuXG4gICAgICogICAgICAgICAgICAgICAgIG9wdGlvbnMubG9vcCAgICAgICAgICAgLSBIVE1MIFZpZGVvIFRhZydzIG5hdGl2ZSBsb29wIC0gcGFzc2VkIHRvIHZpZGVvIGVsZW1lbnQuXG4gICAgICogICAgICAgICAgICAgICAgIG9wdGlvbnM/LmV4dGVybmFsTGlicmFyaWVzID0geyBba2V5OiBzdHJpbmddOiBzdHJpbmd9IC0gbWFwIG9mIGV4dGVybmFsIGxpYnJhcmllcyB0byBiZSBsb2FkZWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPEhUTUxFbGVtZW50IHwge3N0YXR1czpzdHJpbmcsIG1lc3NhZ2U6c3RyaW5nfT59XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5qZWN0VHJhbnNwYXJlbnRWaWRlb0VsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5qZWN0VHJhbnNwYXJlbnRWaWRlb0VsZW1lbnQoaHRtbEVsQ29udGFpbmVyLCBwdWJsaWNJZCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBpZiAoIWh0bWxFbENvbnRhaW5lcikge1xuICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiAnRXhwZWN0aW5nIGh0bWxFbENvbnRhaW5lciB0byBiZSBIVE1MRWxlbWVudCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc3BhcmVudFZpZGVvX2VuZm9yY2VPcHRpb25zRm9yVHJhbnNwYXJlbnRWaWRlbyhvcHRpb25zKTtcbiAgICAgICAgdmFyIHZpZGVvVVJMID0gX3RoaXMzLnZpZGVvX3VybChwdWJsaWNJZCwgb3B0aW9ucyk7XG4gICAgICAgIHRyYW5zcGFyZW50VmlkZW9fY2hlY2tTdXBwb3J0Rm9yVHJhbnNwYXJlbmN5KCkudGhlbihmdW5jdGlvbiAoaXNOYXRpdmVseVRyYW5zcGFyZW50KSB7XG4gICAgICAgICAgdmFyIG1vdW50UHJvbWlzZTtcbiAgICAgICAgICBpZiAoaXNOYXRpdmVseVRyYW5zcGFyZW50KSB7XG4gICAgICAgICAgICBtb3VudFByb21pc2UgPSB0cmFuc3BhcmVudFZpZGVvX21vdW50Q2xvdWRpbmFyeVZpZGVvVGFnKGh0bWxFbENvbnRhaW5lciwgX3RoaXMzLCBwdWJsaWNJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXNvbHZlKGh0bWxFbENvbnRhaW5lcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vdW50UHJvbWlzZSA9IHRyYW5zcGFyZW50VmlkZW9fbW91bnRTZWVUaHJ1Q2FudmFzVGFnKGh0bWxFbENvbnRhaW5lciwgdmlkZW9VUkwsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb3VudFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlKGh0bWxFbENvbnRhaW5lcik7XG4gICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgICAgdmFyIHN0YXR1cyA9IF9yZWYuc3RhdHVzLFxuICAgICAgICAgICAgICBtZXNzYWdlID0gX3JlZi5tZXNzYWdlO1xuICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gY2F0Y2ggZm9yIGNoZWNrU3VwcG9ydEZvclRyYW5zcGFyZW5jeSgpXG4gICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgdmFyIHN0YXR1cyA9IF9yZWYyLnN0YXR1cyxcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBfcmVmMi5tZXNzYWdlO1xuICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJuZXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25ldyhvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMob3B0aW9ucyk7XG4gICAgfVxuICB9XSk7XG59KCk7XG5hc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKGNsb3VkaW5hcnlfQ2xvdWRpbmFyeSwgY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjbG91ZGluYXJ5ID0gKGNsb3VkaW5hcnlfQ2xvdWRpbmFyeSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9uYW1lc3BhY2UvY2xvdWRpbmFyeS1jb3JlLmpzXG4vKipcbiAqIENyZWF0ZXMgdGhlIG5hbWVzcGFjZSBmb3IgQ2xvdWRpbmFyeVxuICovXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2xvdWRpbmFyeV9jb3JlID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBDbGllbnRIaW50c01ldGFUYWc6IGNsaWVudGhpbnRzbWV0YXRhZyxcbiAgQ2xvdWRpbmFyeTogY2xvdWRpbmFyeSxcbiAgQ29uZGl0aW9uOiBjb25kaXRpb24sXG4gIENvbmZpZ3VyYXRpb246IHNyY19jb25maWd1cmF0aW9uLFxuICBjcmMzMjogc3JjX2NyYzMyLFxuICBFeHByZXNzaW9uOiBleHByZXNzaW9uLFxuICBGZXRjaExheWVyOiBmZXRjaGxheWVyLFxuICBIdG1sVGFnOiBodG1sdGFnLFxuICBJbWFnZVRhZzogaW1hZ2V0YWcsXG4gIExheWVyOiBsYXllcl9sYXllcixcbiAgUGljdHVyZVRhZzogcGljdHVyZXRhZyxcbiAgU3VidGl0bGVzTGF5ZXI6IHN1YnRpdGxlc2xheWVyLFxuICBUZXh0TGF5ZXI6IHRleHRsYXllcixcbiAgVHJhbnNmb3JtYXRpb246IHNyY190cmFuc2Zvcm1hdGlvbixcbiAgdXRmOF9lbmNvZGU6IHNyY191dGY4X2VuY29kZSxcbiAgVXRpbDogbG9kYXNoX25hbWVzcGFjZU9iamVjdCxcbiAgVmlkZW9UYWc6IHZpZGVvdGFnXG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvYXNzaWduXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfYXNzaWduX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9jbG9uZURlZXBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9jbG9uZURlZXBfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2NvbXBhY3RcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9jb21wYWN0X187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9kaWZmZXJlbmNlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfZGlmZmVyZW5jZV9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvZnVuY3Rpb25zXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfZnVuY3Rpb25zX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9pZGVudGl0eVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lkZW50aXR5X187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9pbmNsdWRlc1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2luY2x1ZGVzX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9pc0FycmF5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNBcnJheV9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvaXNFbGVtZW50XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNFbGVtZW50X187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9pc0Z1bmN0aW9uXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNGdW5jdGlvbl9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzUGxhaW5PYmplY3RfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2lzU3RyaW5nXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNTdHJpbmdfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL21lcmdlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfbWVyZ2VfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL3RyaW1cIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF90cmltX187XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIH0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbG91ZGluYXJ5LWNvcmUuanMubWFwIl0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2Fzc2lnbl9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfY2xvbmVEZWVwX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9jb21wYWN0X18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9kaWZmZXJlbmNlX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9mdW5jdGlvbnNfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lkZW50aXR5X18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pbmNsdWRlc19fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNBcnJheV9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNFbGVtZW50X18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc0Z1bmN0aW9uX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc1BsYWluT2JqZWN0X18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc1N0cmluZ19fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfbWVyZ2VfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX3RyaW1fXyIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaSIsImwiLCJjYWxsIiwibSIsImMiLCJkIiwibmFtZSIsImdldHRlciIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJyIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsInQiLCJtb2RlIiwiX19lc01vZHVsZSIsIm5zIiwiY3JlYXRlIiwia2V5IiwiYmluZCIsIm4iLCJnZXREZWZhdWx0IiwiZ2V0TW9kdWxlRXhwb3J0cyIsIm9iamVjdCIsInByb3BlcnR5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsIl9fd2VicGFja19leHBvcnRzX18iLCJjbGllbnRoaW50c21ldGF0YWciLCJjbG91ZGluYXJ5IiwiY29uZGl0aW9uIiwic3JjX2NvbmZpZ3VyYXRpb24iLCJzcmNfY3JjMzIiLCJleHByZXNzaW9uIiwiZmV0Y2hsYXllciIsImh0bWx0YWciLCJpbWFnZXRhZyIsImxheWVyX2xheWVyIiwicGljdHVyZXRhZyIsInN1YnRpdGxlc2xheWVyIiwidGV4dGxheWVyIiwic3JjX3RyYW5zZm9ybWF0aW9uIiwic3JjX3V0ZjhfZW5jb2RlIiwibG9kYXNoX25hbWVzcGFjZU9iamVjdCIsInZpZGVvdGFnIiwiY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCIsIlZFUlNJT04iLCJDRl9TSEFSRURfQ0ROIiwiT0xEX0FLQU1BSV9TSEFSRURfQ0ROIiwiQUtBTUFJX1NIQVJFRF9DRE4iLCJTSEFSRURfQ0ROIiwiREVGQVVMVF9USU1FT1VUX01TIiwiREVGQVVMVF9QT1NURVJfT1BUSU9OUyIsIkRFRkFVTFRfVklERU9fU09VUkNFX1RZUEVTIiwiU0VPX1RZUEVTIiwiREVGQVVMVF9JTUFHRV9QQVJBTVMiLCJERUZBVUxUX1ZJREVPX1BBUkFNUyIsIkRFRkFVTFRfVklERU9fU09VUkNFUyIsIkRFRkFVTFRfRVhURVJOQUxfTElCUkFSSUVTIiwiUExBQ0VIT0xERVJfSU1BR0VfTU9ERVMiLCJBQ0NFU1NJQklMSVRZX01PREVTIiwiVVJMX0tFWVMiLCJnZXRTREtBbmFseXRpY3NTaWduYXR1cmUiLCJnZXRBbmFseXRpY3NPcHRpb25zIiwiYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQiLCJhIiwiY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQiLCJjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0IiwiZGlmZmVyZW5jZV9yb290X2RpZmZlcmVuY2VfZGVmYXVsdCIsImZ1bmN0aW9uc19yb290X2Z1bmN0aW9uc19kZWZhdWx0IiwiaWRlbnRpdHlfcm9vdF9pZGVudGl0eV9kZWZhdWx0IiwiaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0IiwiaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCIsImlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQiLCJpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQiLCJtZXJnZV9yb290X21lcmdlX2RlZmF1bHQiLCJpc0ludGVyc2VjdGlvbk9ic2VydmVyU3VwcG9ydGVkIiwiaXNOYXRpdmVMYXp5TG9hZFN1cHBvcnRlZCIsImRldGVjdEludGVyc2VjdGlvbiIsIm9taXQiLCJiYXNldXRpbF9hbGxTdHJpbmdzIiwid2l0aG91dCIsImlzTnVtYmVyTGlrZSIsInNtYXJ0RXNjYXBlIiwiZGVmYXVsdHMiLCJvYmplY3RQcm90byIsIm9ialRvU3RyaW5nIiwiaXNPYmplY3QiLCJmdW5jVGFnIiwicmVXb3JkcyIsImNhbWVsQ2FzZSIsInNuYWtlQ2FzZSIsImNvbnZlcnRLZXlzIiwid2l0aENhbWVsQ2FzZUtleXMiLCJ3aXRoU25ha2VDYXNlS2V5cyIsImJhc2U2NEVuY29kZSIsImJhc2U2NEVuY29kZVVSTCIsImV4dHJhY3RVcmxQYXJhbXMiLCJwYXRjaEZldGNoRm9ybWF0Iiwib3B0aW9uQ29uc3VtZSIsImlzRW1wdHkiLCJpc0FuZHJvaWQiLCJpc0VkZ2UiLCJpc0Nocm9tZSIsImlzU2FmYXJpIiwiaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50X2RlZmF1bHQiLCJpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0IiwidHJpbV9yb290X3RyaW1fZGVmYXVsdCIsImxvZGFzaF9nZXREYXRhIiwibG9kYXNoX3NldERhdGEiLCJsb2Rhc2hfZ2V0QXR0cmlidXRlIiwibG9kYXNoX3NldEF0dHJpYnV0ZSIsImxvZGFzaF9yZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGVzIiwibG9kYXNoX2hhc0NsYXNzIiwibG9kYXNoX2FkZENsYXNzIiwiZ2V0U3R5bGVzIiwiY3NzRXhwYW5kIiwiZG9tU3R5bGUiLCJjdXJDU1MiLCJjc3NWYWx1ZSIsImF1Z21lbnRXaWR0aE9ySGVpZ2h0IiwiZ2V0V2lkdGhPckhlaWdodCIsImxvZGFzaF93aWR0aCIsInV0ZjhfZW5jb2RlIiwiYXJnU3RyaW5nIiwiYzEiLCJlbmMiLCJlbmQiLCJzdGFydCIsInN0cmluZyIsInN0cmluZ2wiLCJ1dGZ0ZXh0IiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInNsaWNlIiwiY3JjMzIiLCJzdHIiLCJjcmMiLCJpVG9wIiwidGFibGUiLCJ4IiwieSIsInN1YnN0ciIsInN0cmluZ1BhZCIsInRhcmdldExlbmd0aCIsInBhZFN0cmluZyIsInJlcGVhdFN0cmluZ051bVRpbWVzIiwidGltZXMiLCJyZXBlYXRlZFN0cmluZyIsIl90b0NvbnN1bWFibGVBcnJheSIsImFyciIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJUeXBlRXJyb3IiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsInRvU3RyaW5nIiwiY29uc3RydWN0b3IiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwiaXRlciIsIml0ZXJhdG9yIiwiaXNBcnJheSIsImxlbiIsImFycjIiLCJjaGFycyIsImJhc2U2NE1hcF9udW0iLCJtYXAiLCJmb3JFYWNoIiwiX2NoYXIiLCJiYXNlNjRNYXAiLCJyZXZlcnNlVmVyc2lvbiIsInNlbVZlciIsInNwbGl0IiwiRXJyb3IiLCJyZXZlcnNlIiwic2VnbWVudCIsImpvaW4iLCJlbmNvZGVWZXJzaW9uIiwic3RyUmVzdWx0IiwicGFydHMiLCJwYWRkZWRTdHJpbmdMZW5ndGgiLCJwYWRkZWRSZXZlcnNlZFNlbXZlciIsIm51bSIsInBhcnNlSW50IiwicGFkZGVkQmluYXJ5IiwibWF0Y2giLCJiaXRTdHJpbmciLCJhbmFseXRpY3NPcHRpb25zIiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwidHdvUGFydFZlcnNpb24iLCJyZW1vdmVQYXRjaEZyb21TZW12ZXIiLCJ0ZWNoVmVyc2lvbiIsImVuY29kZWRTREtWZXJzaW9uIiwic2RrU2VtdmVyIiwiZW5jb2RlZFRlY2hWZXJzaW9uIiwiZmVhdHVyZUNvZGUiLCJmZWF0dXJlIiwiU0RLQ29kZSIsInNka0NvZGUiLCJhbGdvVmVyc2lvbiIsImNvbmNhdCIsImUiLCJzZW1WZXJTdHIiLCJvcHRpb25zIiwidXJsQW5hbHl0aWNzIiwiYWNjZXNzaWJpbGl0eSIsImxvYWRpbmciLCJyZXNwb25zaXZlIiwicGxhY2Vob2xkZXIiLCJhc3NpZ25fcm9vdF9hc3NpZ25fIiwiY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwXyIsImNvbXBhY3Rfcm9vdF9jb21wYWN0XyIsImRpZmZlcmVuY2Vfcm9vdF9kaWZmZXJlbmNlXyIsImZ1bmN0aW9uc19yb290X2Z1bmN0aW9uc18iLCJpZGVudGl0eV9yb290X2lkZW50aXR5XyIsImluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfIiwiaXNBcnJheV9yb290X2lzQXJyYXlfIiwiaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfIiwiaXNTdHJpbmdfcm9vdF9pc1N0cmluZ18iLCJtZXJnZV9yb290X21lcmdlXyIsImlzRWxlbWVudF9yb290X2lzRWxlbWVudF8iLCJpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl8iLCJ0cmltX3Jvb3RfdHJpbV8iLCJfdHlwZW9mIiwid2luZG93IiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJIVE1MSW1hZ2VFbGVtZW50IiwiZWwiLCJvbkludGVyc2VjdCIsIm9ic2VydmVyIiwiZW50cmllcyIsImVudHJ5IiwiaXNJbnRlcnNlY3RpbmciLCJ1bm9ic2VydmUiLCJ0YXJnZXQiLCJ0aHJlc2hvbGQiLCJvYnNlcnZlIiwiZm9ybWF0IiwicmVzb3VyY2VfdHlwZSIsInRyYW5zZm9ybWF0aW9uIiwidHlwZSIsImZhbGxiYWNrX2NvbnRlbnQiLCJzb3VyY2VfdHJhbnNmb3JtYXRpb24iLCJzb3VyY2VfdHlwZXMiLCJjb2RlY3MiLCJ0cmFuc2Zvcm1hdGlvbnMiLCJ2aWRlb19jb2RlYyIsInNlZVRocnUiLCJlZmZlY3QiLCJxdWFsaXR5IiwiZmV0Y2hfZm9ybWF0Iiwid2lkdGgiLCJhc3BlY3RfcmF0aW8iLCJjcm9wIiwiYmFja2dyb3VuZCIsImhlaWdodCIsImdyYXZpdHkiLCJ2YXJpYWJsZXMiLCJkYXJrbW9kZSIsImJyaWdodG1vZGUiLCJtb25vY2hyb21lIiwiY29sb3JibGluZCIsImJhc2V1dGlsX3R5cGVvZiIsIm9iaiIsImtleXMiLCJzcmNLZXlzIiwiZmlsdGVyIiwiZmlsdGVyZWQiLCJhbGxTdHJpbmdzIiwibGlzdCIsImV2ZXJ5IiwiYXJyYXkiLCJpdGVtIiwidiIsImlzTmFOIiwicGFyc2VGbG9hdCIsInVuc2FmZSIsInJlcGxhY2UiLCJ0b1VwcGVyQ2FzZSIsImRlc3RpbmF0aW9uIiwiX2xlbiIsInNvdXJjZXMiLCJfa2V5IiwicmVkdWNlIiwiZGVzdCIsInNvdXJjZSIsImlzRnVuY3Rpb24iLCJsb3dlciIsInVwcGVyIiwiUmVnRXhwIiwid29yZHMiLCJ3b3JkIiwiY2hhckF0IiwidG9Mb2NhbGVVcHBlckNhc2UiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsImNvbnZlcnRlciIsInJlc3VsdCIsImJ0b2EiLCJCdWZmZXIiLCJpbnB1dCIsInVybCIsImRlY29kZVVSSSIsImVuY29kZVVSSSIsIm9wdGlvbl9uYW1lIiwiZGVmYXVsdF92YWx1ZSIsInNpemUiLCJnZXRVc2VyQWdlbnQiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJub2RlQ29udGFpbnMiLCJnZXREYXRhIiwiZWxlbWVudCIsImdldEF0dHJpYnV0ZSIsImdldEF0dHIiLCJkYXRhIiwialF1ZXJ5IiwiZm4iLCJzZXREYXRhIiwic2V0QXR0cmlidXRlIiwic2V0QXR0ciIsImF0dHIiLCJyZW1vdmVBdHRyaWJ1dGUiLCJhdHRyaWJ1dGVzIiwicmVzdWx0cyIsInB1c2giLCJoYXNDbGFzcyIsImNsYXNzTmFtZSIsImFkZENsYXNzIiwiZWxlbSIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsIm9wZW5lciIsImdldENvbXB1dGVkU3R5bGUiLCJiIiwiYWRvd24iLCJidXAiLCJub2RlVHlwZSIsImRvY3VtZW50RWxlbWVudCIsInBhcmVudE5vZGUiLCJjb250YWlucyIsInN0eWxlIiwiY29tcHV0ZWQiLCJtYXhXaWR0aCIsIm1pbldpZHRoIiwicmV0Iiwicm1hcmdpbiIsImdldFByb3BlcnR5VmFsdWUiLCJybnVtbm9ucHgiLCJjb252ZXJ0Iiwic3R5bGVzIiwidmFsIiwiZXh0cmEiLCJpc0JvcmRlckJveCIsInNpZGUiLCJzaWRlcyIsInBudW0iLCJ2YWx1ZUlzQm9yZGVyQm94Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJleHByZXNzaW9uX3R5cGVvZiIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJvcGVydHlLZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsIk51bWJlciIsIkV4cHJlc3Npb24iLCJleHByZXNzaW9uU3RyIiwiZXhwcmVzc2lvbnMiLCJub3JtYWxpemUiLCJzZXJpYWxpemUiLCJnZXRQYXJlbnQiLCJwYXJlbnQiLCJzZXRQYXJlbnQiLCJwcmVkaWNhdGUiLCJvcGVyYXRvciIsIk9QRVJBVE9SUyIsImFuZCIsIm9yIiwidGhlbiIsImFzcGVjdFJhdGlvIiwicGFnZUNvdW50IiwiZmFjZUNvdW50IiwiX3ZhbHVlIiwiX25ldyIsIm9wZXJhdG9ycyIsIm9wZXJhdG9yc1BhdHRlcm4iLCJvcGVyYXRvcnNSZXBsYWNlUkUiLCJwcmVkZWZpbmVkVmFyc1BhdHRlcm4iLCJQUkVERUZJTkVEX1ZBUlMiLCJ1c2VyVmFyaWFibGVQYXR0ZXJuIiwidmFyaWFibGVzUmVwbGFjZVJFIiwidmFyaWFibGUiLCJpbml0aWFsV2lkdGgiLCJpbml0aWFsSGVpZ2h0IiwiaW5pdGlhbEFzcGVjdFJhdGlvIiwiY3VycmVudFBhZ2UiLCJ0YWdzIiwicGFnZVgiLCJwYWdlWSIsIkJPVU5EUlkiLCJjb25kaXRpb25fdHlwZW9mIiwiY29uZGl0aW9uX2NsYXNzQ2FsbENoZWNrIiwiY29uZGl0aW9uX2RlZmluZVByb3BlcnRpZXMiLCJjb25kaXRpb25fdG9Qcm9wZXJ0eUtleSIsImNvbmRpdGlvbl9jcmVhdGVDbGFzcyIsImNvbmRpdGlvbl90b1ByaW1pdGl2ZSIsIl9jYWxsU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJSZWZsZWN0IiwiY29uc3RydWN0IiwiYXBwbHkiLCJzZWxmIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiQm9vbGVhbiIsInZhbHVlT2YiLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiX3NldFByb3RvdHlwZU9mIiwiQ29uZGl0aW9uIiwiX0V4cHJlc3Npb24iLCJjb25kaXRpb25TdHIiLCJkdXJhdGlvbiIsImluaXRpYWxEdXJhdGlvbiIsImNvbmZpZ3VyYXRpb25fdHlwZW9mIiwiX3NsaWNlZFRvQXJyYXkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJjb25maWd1cmF0aW9uX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsImNvbmZpZ3VyYXRpb25fYXJyYXlMaWtlVG9BcnJheSIsInUiLCJmIiwibmV4dCIsImRvbmUiLCJjb25maWd1cmF0aW9uX2NsYXNzQ2FsbENoZWNrIiwiY29uZmlndXJhdGlvbl9kZWZpbmVQcm9wZXJ0aWVzIiwiY29uZmlndXJhdGlvbl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhdGlvbl9jcmVhdGVDbGFzcyIsImNvbmZpZ3VyYXRpb25fdG9QcmltaXRpdmUiLCJjb25maWd1cmF0aW9uX0NvbmZpZ3VyYXRpb24iLCJDb25maWd1cmF0aW9uIiwiY29uZmlndXJhdGlvbiIsIkRFRkFVTFRfQ09ORklHVVJBVElPTl9QQVJBTVMiLCJpbml0IiwiZnJvbUVudmlyb25tZW50IiwiZnJvbURvY3VtZW50Iiwic2V0IiwibWVyZ2UiLCJjb25maWciLCJtZXRhX2VsZW1lbnRzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiX3RoaXMiLCJjbG91ZGluYXJ5X3VybCIsInF1ZXJ5IiwidXJpIiwidXJpUmVnZXgiLCJwcm9jZXNzIiwiZW52IiwiQ0xPVURJTkFSWV9VUkwiLCJleGVjIiwiX3ZhbHVlJHNwbGl0IiwiX3ZhbHVlJHNwbGl0MiIsImsiLCJuZXdfY29uZmlnIiwibmV3X3ZhbHVlIiwidG9PcHRpb25zIiwicmVzcG9uc2l2ZV9jbGFzcyIsInJlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzIiwicm91bmRfZHByIiwic2VjdXJlIiwibG9jYXRpb24iLCJwcm90b2NvbCIsIkNPTkZJR19QQVJBTVMiLCJsYXllcl90eXBlb2YiLCJsYXllcl9jbGFzc0NhbGxDaGVjayIsImxheWVyX2RlZmluZVByb3BlcnRpZXMiLCJsYXllcl90b1Byb3BlcnR5S2V5IiwibGF5ZXJfY3JlYXRlQ2xhc3MiLCJsYXllcl90b1ByaW1pdGl2ZSIsImxheWVyX0xheWVyIiwiTGF5ZXIiLCJyZWYiLCJyZXNvdXJjZVR5cGUiLCJwdWJsaWNJZCIsImdldFB1YmxpY0lkIiwiZ2V0RnVsbFB1YmxpY0lkIiwiY29tcG9uZW50cyIsImNsb25lIiwidGV4dGxheWVyX3R5cGVvZiIsInRleHRsYXllcl9jbGFzc0NhbGxDaGVjayIsInRleHRsYXllcl9kZWZpbmVQcm9wZXJ0aWVzIiwidGV4dGxheWVyX3RvUHJvcGVydHlLZXkiLCJ0ZXh0bGF5ZXJfY3JlYXRlQ2xhc3MiLCJ0ZXh0bGF5ZXJfdG9QcmltaXRpdmUiLCJ0ZXh0bGF5ZXJfY2FsbFN1cGVyIiwidGV4dGxheWVyX2dldFByb3RvdHlwZU9mIiwidGV4dGxheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJ0ZXh0bGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwidGV4dGxheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInRleHRsYXllcl9pbmhlcml0cyIsInRleHRsYXllcl9zZXRQcm90b3R5cGVPZiIsInRleHRsYXllcl9UZXh0TGF5ZXIiLCJfTGF5ZXIiLCJUZXh0TGF5ZXIiLCJfcmVzb3VyY2VUeXBlIiwiX3R5cGUiLCJfZm9ybWF0IiwiZm9udEZhbWlseSIsIl9mb250RmFtaWx5IiwiZm9udFNpemUiLCJfZm9udFNpemUiLCJmb250V2VpZ2h0IiwiX2ZvbnRXZWlnaHQiLCJmb250U3R5bGUiLCJfZm9udFN0eWxlIiwidGV4dERlY29yYXRpb24iLCJfdGV4dERlY29yYXRpb24iLCJ0ZXh0QWxpZ24iLCJfdGV4dEFsaWduIiwic3Ryb2tlIiwiX3N0cm9rZSIsImxldHRlclNwYWNpbmciLCJfbGV0dGVyU3BhY2luZyIsImxpbmVTcGFjaW5nIiwiX2xpbmVTcGFjaW5nIiwiZm9udEhpbnRpbmciLCJfZm9udEhpbnRpbmciLCJmb250QW50aWFsaWFzaW5nIiwiX2ZvbnRBbnRpYWxpYXNpbmciLCJ0ZXh0IiwiX3RleHQiLCJ0ZXh0U3R5bGUiLCJfdGV4dFN0eWxlIiwiaGFzUHVibGljSWQiLCJoYXNTdHlsZSIsInJlIiwicmVzIiwidGV4dFNvdXJjZSIsInRleHRTdHlsZUlkZW50aWZpZXIiLCJpbmRleCIsInVuc2hpZnQiLCJzdWJ0aXRsZXNsYXllcl90eXBlb2YiLCJzdWJ0aXRsZXNsYXllcl9kZWZpbmVQcm9wZXJ0aWVzIiwic3VidGl0bGVzbGF5ZXJfdG9Qcm9wZXJ0eUtleSIsInN1YnRpdGxlc2xheWVyX2NyZWF0ZUNsYXNzIiwic3VidGl0bGVzbGF5ZXJfdG9QcmltaXRpdmUiLCJzdWJ0aXRsZXNsYXllcl9jbGFzc0NhbGxDaGVjayIsInN1YnRpdGxlc2xheWVyX2NhbGxTdXBlciIsInN1YnRpdGxlc2xheWVyX2dldFByb3RvdHlwZU9mIiwic3VidGl0bGVzbGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInN1YnRpdGxlc2xheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsInN1YnRpdGxlc2xheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInN1YnRpdGxlc2xheWVyX2luaGVyaXRzIiwic3VidGl0bGVzbGF5ZXJfc2V0UHJvdG90eXBlT2YiLCJTdWJ0aXRsZXNMYXllciIsIl9UZXh0TGF5ZXIiLCJmZXRjaGxheWVyX3R5cGVvZiIsImZldGNobGF5ZXJfY2xhc3NDYWxsQ2hlY2siLCJmZXRjaGxheWVyX2RlZmluZVByb3BlcnRpZXMiLCJmZXRjaGxheWVyX3RvUHJvcGVydHlLZXkiLCJmZXRjaGxheWVyX2NyZWF0ZUNsYXNzIiwiZmV0Y2hsYXllcl90b1ByaW1pdGl2ZSIsImZldGNobGF5ZXJfY2FsbFN1cGVyIiwiZmV0Y2hsYXllcl9nZXRQcm90b3R5cGVPZiIsImZldGNobGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsImZldGNobGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiZmV0Y2hsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJmZXRjaGxheWVyX2luaGVyaXRzIiwiZmV0Y2hsYXllcl9zZXRQcm90b3R5cGVPZiIsImZldGNobGF5ZXJfRmV0Y2hMYXllciIsIkZldGNoTGF5ZXIiLCJfdXJsIiwicGFyYW1ldGVyc19jYWxsU3VwZXIiLCJwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mIiwicGFyYW1ldGVyc19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwicGFyYW1ldGVyc19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJwYXJhbWV0ZXJzX3R5cGVvZiIsInBhcmFtZXRlcnNfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiX2dldCIsInJlY2VpdmVyIiwiYmFzZSIsIl9zdXBlclByb3BCYXNlIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInBhcmFtZXRlcnNfaW5oZXJpdHMiLCJwYXJhbWV0ZXJzX3NldFByb3RvdHlwZU9mIiwicGFyYW1ldGVyc19jbGFzc0NhbGxDaGVjayIsInBhcmFtZXRlcnNfZGVmaW5lUHJvcGVydGllcyIsInBhcmFtZXRlcnNfdG9Qcm9wZXJ0eUtleSIsInBhcmFtZXRlcnNfY3JlYXRlQ2xhc3MiLCJwYXJhbWV0ZXJzX3RvUHJpbWl0aXZlIiwicGFyYW1ldGVyc19QYXJhbSIsIlBhcmFtIiwic2hvcnROYW1lIiwib3JpZ1ZhbHVlIiwidmFsaWQiLCJub3JtX2NvbG9yIiwiYnVpbGRfYXJyYXkiLCJhcmciLCJwcm9jZXNzX3ZpZGVvX3BhcmFtcyIsInBhcmFtIiwidmlkZW8iLCJjb2RlYyIsInByb2ZpbGUiLCJsZXZlbCIsImJfZnJhbWVzIiwicGFyYW1ldGVyc19BcnJheVBhcmFtIiwiX1BhcmFtIiwiQXJyYXlQYXJhbSIsInNlcCIsImFycmF5VmFsdWUiLCJmbGF0IiwiX3RoaXMyIiwicGFyYW1ldGVyc19UcmFuc2Zvcm1hdGlvblBhcmFtIiwiX1BhcmFtMiIsIlRyYW5zZm9ybWF0aW9uUGFyYW0iLCJfdGhpczMiLCJfdGhpczQiLCJqb2luZWQiLCJvcmlnVmFsdWUxIiwibnVtYmVyX3BhdHRlcm4iLCJvZmZzZXRfYW55X3BhdHRlcm4iLCJwYXJhbWV0ZXJzX1JhbmdlUGFyYW0iLCJfUGFyYW0zIiwiUmFuZ2VQYXJhbSIsIm5vcm1fcmFuZ2VfdmFsdWUiLCJvZmZzZXQiLCJtb2RpZmllciIsInBhcmFtZXRlcnNfUmF3UGFyYW0iLCJfUGFyYW00IiwiUmF3UGFyYW0iLCJwYXJhbWV0ZXJzX0xheWVyUGFyYW0iLCJfUGFyYW01IiwiTGF5ZXJQYXJhbSIsImxheWVyT3B0aW9ucyIsImxheWVyIiwicGFyYW1ldGVyc19FeHByZXNzaW9uUGFyYW0iLCJfUGFyYW02IiwiRXhwcmVzc2lvblBhcmFtIiwidHJhbnNmb3JtYXRpb25fY2FsbFN1cGVyIiwidHJhbnNmb3JtYXRpb25fZ2V0UHJvdG90eXBlT2YiLCJ0cmFuc2Zvcm1hdGlvbl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwidHJhbnNmb3JtYXRpb25faXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwidHJhbnNmb3JtYXRpb25fdHlwZW9mIiwidHJhbnNmb3JtYXRpb25fYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwidHJhbnNmb3JtYXRpb25faW5oZXJpdHMiLCJ0cmFuc2Zvcm1hdGlvbl9zZXRQcm90b3R5cGVPZiIsInRyYW5zZm9ybWF0aW9uX3NsaWNlZFRvQXJyYXkiLCJ0cmFuc2Zvcm1hdGlvbl9hcnJheVdpdGhIb2xlcyIsInRyYW5zZm9ybWF0aW9uX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwidHJhbnNmb3JtYXRpb25fdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJ0cmFuc2Zvcm1hdGlvbl9ub25JdGVyYWJsZVJlc3QiLCJ0cmFuc2Zvcm1hdGlvbl9hcnJheUxpa2VUb0FycmF5IiwidHJhbnNmb3JtYXRpb25fY2xhc3NDYWxsQ2hlY2siLCJ0cmFuc2Zvcm1hdGlvbl9kZWZpbmVQcm9wZXJ0aWVzIiwidHJhbnNmb3JtYXRpb25fdG9Qcm9wZXJ0eUtleSIsInRyYW5zZm9ybWF0aW9uX2NyZWF0ZUNsYXNzIiwidHJhbnNmb3JtYXRpb25fdG9QcmltaXRpdmUiLCJhc3NpZ25Ob3ROdWxsIiwidHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb25CYXNlIiwiVHJhbnNmb3JtYXRpb25CYXNlIiwidHJhbnMiLCJ3aXRoQ2hhaW4iLCJvcHQiLCJvdGhlck9wdGlvbnMiLCJjaGFpbmVkIiwidHIiLCJmcm9tT3B0aW9ucyIsImFiYnIiLCJkZWZhdWx0VmFsdWUiLCJyYXdQYXJhbSIsImxhc3RBcmdDYWxsYmFjayIsInJhbmdlUGFyYW0iLCJhcnJheVBhcmFtIiwidHJhbnNmb3JtYXRpb25QYXJhbSIsImxheWVyUGFyYW0iLCJnZXRWYWx1ZSIsInJlbW92ZSIsInRlbXAiLCJWQVJfTkFNRV9SRSIsInNvcnQiLCJ0b1BsYWluT2JqZWN0IiwiaGFzaCIsImNoYWluIiwibmFtZXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwicmVzZXRUcmFuc2Zvcm1hdGlvbnMiLCJmcm9tVHJhbnNmb3JtYXRpb24iLCJvdGhlciIsImNhbWVsS2V5IiwiX2xlbjIiLCJ2YWx1ZXMiLCJfa2V5MiIsInRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uIiwibWV0aG9kcyIsImhhc0xheWVyIiwiaWZQYXJhbSIsImoiLCJwYXJhbUxpc3QiLCJyZWYxIiwicmVmMiIsInJlZjMiLCJyZWY0IiwicmVzdWx0QXJyYXkiLCJ0cmFuc2Zvcm1hdGlvbkxpc3QiLCJ0cmFuc2Zvcm1hdGlvblN0cmluZyIsInZhcnMiLCJwcm9jZXNzVmFyIiwibGVuMSIsInBhcmFtX3NlcGFyYXRvciIsInRyYW5zX3NlcGFyYXRvciIsInRvSHRtbEF0dHJpYnV0ZXMiLCJhdHRyTmFtZSIsInNuYWtlQ2FzZUtleSIsIlBBUkFNX05BTUVTIiwidG9IdG1sIiwibGlzdE5hbWVzIiwiaXNWYWxpZFBhcmFtTmFtZSIsImluZGV4T2YiLCJhcmdzIiwiY2FsbGJhY2siLCJ2YXJBcnJheSIsIl92YXJBcnJheSRqIiwicHJvY2Vzc0N1c3RvbUZ1bmN0aW9uIiwiX3JlZiIsImZ1bmN0aW9uX3R5cGUiLCJfVHJhbnNmb3JtYXRpb25CYXNlIiwiVHJhbnNmb3JtYXRpb24iLCJhbmdsZSIsImF1ZGlvQ29kZWMiLCJhdWRpb0ZyZXF1ZW5jeSIsImJpdFJhdGUiLCJib3JkZXIiLCJjb2xvciIsImNvbG9yU3BhY2UiLCJjdXN0b21GdW5jdGlvbiIsImN1c3RvbVByZUZ1bmN0aW9uIiwiZGVmYXVsdEltYWdlIiwiZGVsYXkiLCJkZW5zaXR5IiwiZHByIiwiX2Vsc2UiLCJlbmRJZiIsImVuZE9mZnNldCIsImZhbGxiYWNrQ29udGVudCIsImZldGNoRm9ybWF0IiwiZmxhZ3MiLCJmcHMiLCJodG1sSGVpZ2h0IiwiaHRtbFdpZHRoIiwiX2lmIiwiaWZWYWwiLCJ0cklmIiwidHJSZXN0Iiwia2V5ZnJhbWVJbnRlcnZhbCIsIm9jciIsImVuZF9vIiwic3RhcnRfbyIsIl9yZWYyIiwiX3JlZjMiLCJzdGFydE9mZnNldCIsIm9wYWNpdHkiLCJvdmVybGF5IiwicGFnZSIsInBvc3RlciIsInByZWZpeCIsInJhZGl1cyIsInJhd1RyYW5zZm9ybWF0aW9uIiwic291cmNlVHlwZXMiLCJzb3VyY2VUcmFuc2Zvcm1hdGlvbiIsInN0cmVhbWluZ1Byb2ZpbGUiLCJ1bmRlcmxheSIsInZpZGVvQ29kZWMiLCJ2aWRlb1NhbXBsaW5nIiwiem9vbSIsImh0bWx0YWdfdHlwZW9mIiwiaHRtbHRhZ19jbGFzc0NhbGxDaGVjayIsImh0bWx0YWdfZGVmaW5lUHJvcGVydGllcyIsImh0bWx0YWdfdG9Qcm9wZXJ0eUtleSIsImh0bWx0YWdfY3JlYXRlQ2xhc3MiLCJodG1sdGFnX3RvUHJpbWl0aXZlIiwiaHRtbHRhZ19IdG1sVGFnIiwiSHRtbFRhZyIsImh0bWxBdHRycyIsImF0dHJzIiwicGFpcnMiLCJlc2NhcGVRdW90ZXMiLCJodG1sdGFnX3RvQXR0cmlidXRlIiwiZ2V0T3B0aW9ucyIsImdldE9wdGlvbiIsImh0bWxBdHRyaWJ1dGVzIiwicmVtb3ZlQXR0ciIsImNvbnRlbnQiLCJvcGVuVGFnIiwidGFnIiwiY2xvc2VUYWciLCJ0b0RPTSIsImNyZWF0ZUVsZW1lbnQiLCJpc1Jlc3BvbnNpdmUiLCJyZXNwb25zaXZlQ2xhc3MiLCJkYXRhU3JjIiwiX2V4Y2x1ZGVkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInNvdXJjZVN5bWJvbEtleXMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInNvdXJjZUtleXMiLCJtYWtlVXJsIiwiaG9zdCIsInBhdGhuYW1lIiwiaXNVcmwiLCJjZG5TdWJkb21haW5OdW1iZXIiLCJoYW5kbGVTaWduYXR1cmUiLCJzaWduYXR1cmUiLCJpc0Zvcm1hdHRlZCIsImhhbmRsZVByZWZpeCIsImNsb3VkX25hbWUiLCJjZG5QYXJ0Iiwic3ViZG9tYWluIiwicGF0aCIsInByaXZhdGVfY2RuIiwiY2RuX3N1YmRvbWFpbiIsInNlY3VyZV9jZG5fc3ViZG9tYWluIiwic2VjdXJlX2Rpc3RyaWJ1dGlvbiIsImNuYW1lIiwiaGFuZGxlUmVzb3VyY2VUeXBlIiwiX3JlZiRyZXNvdXJjZV90eXBlIiwiX3JlZiR0eXBlIiwidXJsX3N1ZmZpeCIsInVzZV9yb290X3BhdGgiLCJzaG9ydGVuIiwiZW5jb2RlUHVibGljSWQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJmb3JtYXRQdWJsaWNJZCIsImRlY29kZVVSSUNvbXBvbmVudCIsImVycm9yIiwidHJ1c3RfcHVibGljX2lkIiwidmFsaWRhdGUiLCJoYW5kbGVWZXJzaW9uIiwiaXNGb3JjZVZlcnNpb24iLCJmb3JjZV92ZXJzaW9uIiwiaXNWZXJzaW9uRXhpc3QiLCJ2ZXJzaW9uIiwiaGFuZGxlVHJhbnNmb3JtYXRpb24iLCJwbGFjZWhvbGRlclRyYW5zZm9ybWF0aW9ucyIsImJsdXIiLCJwcmVwYXJlUHVibGljSWQiLCJ1cmxTdHJpbmciLCJwcmVwYXJlT3B0aW9ucyIsInVybF91cmwiLCJyZXN1bHRVcmwiLCJzZGtBbmFseXRpY3NTaWduYXR1cmUiLCJhcHBlbmRlciIsImF1dGhfdG9rZW4iLCJfYXBwZW5kZXIiLCJnZW5lcmF0ZUJyZWFrcG9pbnRzX3NsaWNlZFRvQXJyYXkiLCJnZW5lcmF0ZUJyZWFrcG9pbnRzX2FycmF5V2l0aEhvbGVzIiwiZ2VuZXJhdGVCcmVha3BvaW50c19pdGVyYWJsZVRvQXJyYXlMaW1pdCIsImdlbmVyYXRlQnJlYWtwb2ludHNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJnZW5lcmF0ZUJyZWFrcG9pbnRzX25vbkl0ZXJhYmxlUmVzdCIsImdlbmVyYXRlQnJlYWtwb2ludHNfYXJyYXlMaWtlVG9BcnJheSIsImdlbmVyYXRlQnJlYWtwb2ludHMiLCJzcmNzZXQiLCJicmVha3BvaW50cyIsIl9tYXAiLCJtaW5fd2lkdGgiLCJtYXhfd2lkdGgiLCJtYXhfaW1hZ2VzIiwiX21hcDIiLCJzb21lIiwic3RlcFNpemUiLCJNYXRoIiwiY2VpbCIsIm1heCIsImN1cnJlbnQiLCJzcmNzZXRVdGlsc19pc0VtcHR5Iiwic2NhbGVkVXJsIiwicHVibGljX2lkIiwiY29uZmlnUGFyYW1zIiwicmF3X3RyYW5zZm9ybWF0aW9uIiwiZ2V0T3JHZW5lcmF0ZUJyZWFrcG9pbnRzIiwiZ2VuZXJhdGVTcmNzZXRBdHRyaWJ1dGUiLCJnZW5lcmF0ZVNpemVzQXR0cmlidXRlIiwiZ2VuZXJhdGVJbWFnZVJlc3BvbnNpdmVBdHRyaWJ1dGVzIiwic3Jjc2V0RGF0YSIsInJlc3BvbnNpdmVBdHRyaWJ1dGVzIiwiZ2VuZXJhdGVTaXplcyIsInNpemVzIiwiZ2VuZXJhdGVTcmNzZXQiLCJzcmNzZXRBdHRyIiwic2l6ZXNBdHRyIiwiZ2VuZXJhdGVNZWRpYUF0dHIiLCJtZWRpYVF1ZXJ5Iiwic3Jjc2V0VXJsIiwiaW1hZ2V0YWdfdHlwZW9mIiwiaW1hZ2V0YWdfY2xhc3NDYWxsQ2hlY2siLCJpbWFnZXRhZ19kZWZpbmVQcm9wZXJ0aWVzIiwiaW1hZ2V0YWdfdG9Qcm9wZXJ0eUtleSIsImltYWdldGFnX2NyZWF0ZUNsYXNzIiwiaW1hZ2V0YWdfdG9QcmltaXRpdmUiLCJpbWFnZXRhZ19jYWxsU3VwZXIiLCJpbWFnZXRhZ19nZXRQcm90b3R5cGVPZiIsImltYWdldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJpbWFnZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJpbWFnZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJpbWFnZXRhZ19nZXQiLCJpbWFnZXRhZ19zdXBlclByb3BCYXNlIiwiaW1hZ2V0YWdfaW5oZXJpdHMiLCJpbWFnZXRhZ19zZXRQcm90b3R5cGVPZiIsImltYWdldGFnX0ltYWdlVGFnIiwiX0h0bWxUYWciLCJJbWFnZVRhZyIsInNyY0F0dHJpYnV0ZSIsInNyY3NldFBhcmFtIiwiY2xpZW50X2hpbnRzIiwic291cmNldGFnX3R5cGVvZiIsInNvdXJjZXRhZ19jbGFzc0NhbGxDaGVjayIsInNvdXJjZXRhZ19kZWZpbmVQcm9wZXJ0aWVzIiwic291cmNldGFnX3RvUHJvcGVydHlLZXkiLCJzb3VyY2V0YWdfY3JlYXRlQ2xhc3MiLCJzb3VyY2V0YWdfdG9QcmltaXRpdmUiLCJzb3VyY2V0YWdfY2FsbFN1cGVyIiwic291cmNldGFnX2dldFByb3RvdHlwZU9mIiwic291cmNldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJzb3VyY2V0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0Iiwic291cmNldGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNvdXJjZXRhZ19nZXQiLCJzb3VyY2V0YWdfc3VwZXJQcm9wQmFzZSIsInNvdXJjZXRhZ19pbmhlcml0cyIsInNvdXJjZXRhZ19zZXRQcm90b3R5cGVPZiIsInNvdXJjZXRhZ19Tb3VyY2VUYWciLCJTb3VyY2VUYWciLCJtZWRpYSIsInNvdXJjZXRhZyIsInBpY3R1cmV0YWdfdHlwZW9mIiwicGljdHVyZXRhZ19jbGFzc0NhbGxDaGVjayIsInBpY3R1cmV0YWdfZGVmaW5lUHJvcGVydGllcyIsInBpY3R1cmV0YWdfdG9Qcm9wZXJ0eUtleSIsInBpY3R1cmV0YWdfY3JlYXRlQ2xhc3MiLCJwaWN0dXJldGFnX3RvUHJpbWl0aXZlIiwicGljdHVyZXRhZ19jYWxsU3VwZXIiLCJwaWN0dXJldGFnX2dldFByb3RvdHlwZU9mIiwicGljdHVyZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwicGljdHVyZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJwaWN0dXJldGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInBpY3R1cmV0YWdfZ2V0IiwicGljdHVyZXRhZ19zdXBlclByb3BCYXNlIiwicGljdHVyZXRhZ19pbmhlcml0cyIsInBpY3R1cmV0YWdfc2V0UHJvdG90eXBlT2YiLCJwaWN0dXJldGFnX1BpY3R1cmVUYWciLCJQaWN0dXJlVGFnIiwid2lkdGhMaXN0IiwidmlkZW90YWdfdHlwZW9mIiwidmlkZW90YWdfY2xhc3NDYWxsQ2hlY2siLCJ2aWRlb3RhZ19kZWZpbmVQcm9wZXJ0aWVzIiwidmlkZW90YWdfdG9Qcm9wZXJ0eUtleSIsInZpZGVvdGFnX2NyZWF0ZUNsYXNzIiwidmlkZW90YWdfdG9QcmltaXRpdmUiLCJ2aWRlb3RhZ19jYWxsU3VwZXIiLCJ2aWRlb3RhZ19nZXRQcm90b3R5cGVPZiIsInZpZGVvdGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJ2aWRlb3RhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJ2aWRlb3RhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJ2aWRlb3RhZ19nZXQiLCJ2aWRlb3RhZ19zdXBlclByb3BCYXNlIiwidmlkZW90YWdfaW5oZXJpdHMiLCJ2aWRlb3RhZ19zZXRQcm90b3R5cGVPZiIsIlZJREVPX1RBR19QQVJBTVMiLCJ2aWRlb3RhZ19ERUZBVUxUX1ZJREVPX1NPVVJDRV9UWVBFUyIsInZpZGVvdGFnX0RFRkFVTFRfUE9TVEVSX09QVElPTlMiLCJ2aWRlb3RhZ19WaWRlb1RhZyIsIlZpZGVvVGFnIiwic2V0U291cmNlVHJhbnNmb3JtYXRpb24iLCJzZXRTb3VyY2VUeXBlcyIsInNldFBvc3RlciIsInNldEZhbGxiYWNrQ29udGVudCIsImZhbGxiYWNrIiwiaW5uZXJUYWdzIiwic3JjIiwiY3JlYXRlU291cmNlVGFnIiwic3JjVHlwZSIsImRlZmF1bHRPcHRpb25zIiwiaGFzU291cmNlVGFncyIsInNvdXJjZVR5cGUiLCJtaW1lVHlwZSIsInZpZGVvVHlwZSIsImNvZGVjc1N0ciIsImNsaWVudGhpbnRzbWV0YXRhZ190eXBlb2YiLCJjbGllbnRoaW50c21ldGF0YWdfY2xhc3NDYWxsQ2hlY2siLCJjbGllbnRoaW50c21ldGF0YWdfZGVmaW5lUHJvcGVydGllcyIsImNsaWVudGhpbnRzbWV0YXRhZ190b1Byb3BlcnR5S2V5IiwiY2xpZW50aGludHNtZXRhdGFnX2NyZWF0ZUNsYXNzIiwiY2xpZW50aGludHNtZXRhdGFnX3RvUHJpbWl0aXZlIiwiY2xpZW50aGludHNtZXRhdGFnX2NhbGxTdXBlciIsImNsaWVudGhpbnRzbWV0YXRhZ19nZXRQcm90b3R5cGVPZiIsImNsaWVudGhpbnRzbWV0YXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiY2xpZW50aGludHNtZXRhdGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsImNsaWVudGhpbnRzbWV0YXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJjbGllbnRoaW50c21ldGF0YWdfaW5oZXJpdHMiLCJjbGllbnRoaW50c21ldGF0YWdfc2V0UHJvdG90eXBlT2YiLCJjbGllbnRoaW50c21ldGF0YWdfQ2xpZW50SGludHNNZXRhVGFnIiwiQ2xpZW50SGludHNNZXRhVGFnIiwibm9ybWFsaXplVG9BcnJheV90b0NvbnN1bWFibGVBcnJheSIsIm5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlXaXRob3V0SG9sZXMiLCJub3JtYWxpemVUb0FycmF5X2l0ZXJhYmxlVG9BcnJheSIsIm5vcm1hbGl6ZVRvQXJyYXlfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJub3JtYWxpemVUb0FycmF5X25vbkl0ZXJhYmxlU3ByZWFkIiwibm9ybWFsaXplVG9BcnJheV9hcnJheUxpa2VUb0FycmF5Iiwibm9ybWFsaXplVG9BcnJheSIsImVsZW1lbnRzIiwibW91bnRDbG91ZGluYXJ5VmlkZW9UYWciLCJodG1sRWxDb250YWluZXIiLCJjbEluc3RhbmNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJpbm5lckhUTUwiLCJ2aWRlb1RhZyIsImNsb3VkaW5hcnlWaWRlb0VsZW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwidHJhbnNwYXJlbnRWaWRlb19tb3VudENsb3VkaW5hcnlWaWRlb1RhZyIsImFkZEZsYWdUb09wdGlvbnMiLCJmbGFnIiwiYWRkRmxhZyIsImVuZm9yY2VPcHRpb25zRm9yVHJhbnNwYXJlbnRWaWRlbyIsImF1dG9wbGF5IiwibXV0ZWQiLCJjb250cm9scyIsIm1heF90aW1lb3V0X21zIiwiZXh0ZXJuYWxMaWJyYXJpZXMiLCJ0cmFuc3BhcmVudFZpZGVvX2VuZm9yY2VPcHRpb25zRm9yVHJhbnNwYXJlbnRWaWRlbyIsImxvYWRTY3JpcHQiLCJzY3JpcHRVUkwiLCJpc0FscmVhZHlMb2FkZWQiLCJzY3JpcHRUYWciLCJ0aW1lcklEIiwic2V0VGltZW91dCIsInN0YXR1cyIsIm1lc3NhZ2UiLCJvbmVycm9yIiwiY2xlYXJUaW1lb3V0Iiwib25sb2FkIiwiaGVhZCIsImFwcGVuZENoaWxkIiwieGhyX2xvYWRTY3JpcHQiLCJyZWplY3RPblRpbWVvdXQiLCJtYXhUaW1lb3V0TVMiLCJnZXRCbG9iRnJvbVVSTCIsInVybFRvTG9hZCIsImZldGNoQmxvYiIsImZldGNoIiwibG9hZFVybFVzaW5nRmV0Y2giLCJsb2FkVXJsVXNpbmdYaHIiLCJibG9iIiwicGF5bG9hZCIsImJsb2JVUkwiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJyZXNwb25zZSIsInhociIsIlhNTEh0dHBSZXF1ZXN0IiwicmVzcG9uc2VUeXBlIiwib3BlbiIsInNlbmQiLCJ4aHJfZ2V0QmxvYkZyb21VUkwiLCJjcmVhdGVIaWRkZW5WaWRlb1RhZyIsInZpZGVvT3B0aW9ucyIsInBsYXlzaW5saW5lIiwibG9vcCIsInZpZGVvVVJMIiwidmlzaWJpbGl0eSIsInBvc2l0aW9uIiwicmV2b2tlT2JqZWN0VVJMIiwidHJhbnNwYXJlbnRWaWRlb19jcmVhdGVIaWRkZW5WaWRlb1RhZyIsImluc3RhbnRpYXRlU2VlVGhydSIsInZpZGVvRWxlbWVudCIsImN1c3RvbUNsYXNzIiwiYXV0b1BsYXkiLCJfd2luZG93Iiwic2VlVGhydUluc3RhbmNlIiwicmVhZHkiLCJjYW52YXNFbGVtZW50IiwiZ2V0Q2FudmFzIiwicGxheSIsInRyYW5zcGFyZW50VmlkZW9faW5zdGFudGlhdGVTZWVUaHJ1IiwibW91bnRTZWVUaHJ1Q2FudmFzVGFnIiwiZXJyIiwidHJhbnNwYXJlbnRWaWRlb19tb3VudFNlZVRocnVDYW52YXNUYWciLCJjaGVja1N1cHBvcnRGb3JUcmFuc3BhcmVuY3kiLCJjYW5QbGF5IiwiY2FuUGxheVR5cGUiLCJ0cmFuc3BhcmVudFZpZGVvX2NoZWNrU3VwcG9ydEZvclRyYW5zcGFyZW5jeSIsImNsb3VkaW5hcnlfdHlwZW9mIiwiY2xvdWRpbmFyeV9jbGFzc0NhbGxDaGVjayIsImNsb3VkaW5hcnlfZGVmaW5lUHJvcGVydGllcyIsImNsb3VkaW5hcnlfdG9Qcm9wZXJ0eUtleSIsImNsb3VkaW5hcnlfY3JlYXRlQ2xhc3MiLCJjbG91ZGluYXJ5X3RvUHJpbWl0aXZlIiwiYXBwbHlCcmVha3BvaW50cyIsImNsb3Nlc3RBYm92ZSIsImRlZmF1bHRCcmVha3BvaW50cyIsImNsb3VkaW5hcnlfZmluZENvbnRhaW5lcldpZHRoIiwiY2xvdWRpbmFyeV9tYXhXaWR0aCIsInVwZGF0ZURwciIsInN0ZXBzIiwicmVzaXppbmciLCJjYWxjX2JyZWFrcG9pbnQiLCJmaW5kQ29udGFpbmVyV2lkdGgiLCJjb250YWluZXJXaWR0aCIsIkVsZW1lbnQiLCJkaXNwbGF5Iiwicm91bmREcHIiLCJkZXZpY2VfcGl4ZWxfcmF0aW8iLCJyZXF1aXJlZFdpZHRoIiwiaW1hZ2VXaWR0aCIsImNsb3VkaW5hcnlfQ2xvdWRpbmFyeSIsIkNsb3VkaW5hcnkiLCJkZXZpY2VQaXhlbFJhdGlvQ2FjaGUiLCJyZXNwb25zaXZlQ29uZmlnIiwicmVzcG9uc2l2ZVJlc2l6ZUluaXRpYWxpemVkIiwibmV3Q29uZmlnIiwibmV3VmFsdWUiLCJ2aWRlb191cmwiLCJ2aWRlb190aHVtYm5haWxfdXJsIiwidHJhbnNmb3JtYXRpb25fc3RyaW5nIiwiaW1hZ2UiLCJpbWciLCJpbWFnZVRhZyIsImNsb3VkaW5hcnlfdXBkYXRlIiwicGljdHVyZVRhZyIsInNvdXJjZVRhZyIsInZpZGVvX3RodW1ibmFpbCIsImZhY2Vib29rX3Byb2ZpbGVfaW1hZ2UiLCJ0d2l0dGVyX3Byb2ZpbGVfaW1hZ2UiLCJ0d2l0dGVyX25hbWVfcHJvZmlsZV9pbWFnZSIsImdyYXZhdGFyX2ltYWdlIiwiZmV0Y2hfaW1hZ2UiLCJzcHJpdGVfY3NzIiwiYm9vdHN0cmFwIiwicmVzcG9uc2l2ZVJlc2l6ZSIsInRpbWVvdXQiLCJyZXNwb25zaXZlX3Jlc2l6ZSIsIm1ha2VSZXNwb25zaXZlIiwiZGVib3VuY2UiLCJyZXNldCIsInJ1biIsIndhaXQiLCJ3YWl0RnVuYyIsInJlc3BvbnNpdmVfZGVib3VuY2UiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInBvaW50IiwiY2FsY19zdG9wcG9pbnQiLCJkZXZpY2VQaXhlbFJhdGlvIiwiZHByU3RyaW5nIiwicHJvY2Vzc0ltYWdlVGFncyIsIm5vZGVzIiwiaW1hZ2VzIiwibm9kZSIsInRhZ05hbWUiLCJpbWdPcHRpb25zIiwic2V0VXJsIiwicmVzcG9uc2l2ZV9wcmVzZXJ2ZV9oZWlnaHQiLCJpc0xhenlMb2FkaW5nIiwiaXNMYXp5TG9hZFN1cHBvcnRlZCIsInNldEF0dHJpYnV0ZUlmRXhpc3RzIiwidG9BdHRyaWJ1dGUiLCJmcm9tQXR0cmlidXRlIiwiYXR0cmlidXRlVmFsdWUiLCJpbmplY3RUcmFuc3BhcmVudFZpZGVvRWxlbWVudCIsImlzTmF0aXZlbHlUcmFuc3BhcmVudCIsIm1vdW50UHJvbWlzZSIsImNsb3VkaW5hcnlfY29yZSIsIlV0aWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/cloudinary-core/cloudinary-core.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/cloudinary-core/cloudinary-core.js":
/*!*********************************************************!*\
  !*** ./node_modules/cloudinary-core/cloudinary-core.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n   * cloudinary-core.js\n   * Cloudinary's JavaScript library - Version 2.13.1\n   * Copyright Cloudinary\n   * see https://github.com/cloudinary/cloudinary_js\n   *\n   */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! lodash/assign */ \"lodash/assign\"), __webpack_require__(/*! lodash/cloneDeep */ \"lodash/cloneDeep\"), __webpack_require__(/*! lodash/compact */ \"lodash/compact\"), __webpack_require__(/*! lodash/difference */ \"lodash/difference\"), __webpack_require__(/*! lodash/functions */ \"lodash/functions\"), __webpack_require__(/*! lodash/identity */ \"lodash/identity\"), __webpack_require__(/*! lodash/includes */ \"lodash/includes\"), __webpack_require__(/*! lodash/isArray */ \"lodash/isArray\"), __webpack_require__(/*! lodash/isElement */ \"lodash/isElement\"), __webpack_require__(/*! lodash/isFunction */ \"lodash/isFunction\"), __webpack_require__(/*! lodash/isPlainObject */ \"lodash/isPlainObject\"), __webpack_require__(/*! lodash/isString */ \"lodash/isString\"), __webpack_require__(/*! lodash/merge */ \"lodash/merge\"), __webpack_require__(/*! lodash/trim */ \"lodash/trim\"));\n    else {}\n})(void 0, function(__WEBPACK_EXTERNAL_MODULE_lodash_assign__, __WEBPACK_EXTERNAL_MODULE_lodash_cloneDeep__, __WEBPACK_EXTERNAL_MODULE_lodash_compact__, __WEBPACK_EXTERNAL_MODULE_lodash_difference__, __WEBPACK_EXTERNAL_MODULE_lodash_functions__, __WEBPACK_EXTERNAL_MODULE_lodash_identity__, __WEBPACK_EXTERNAL_MODULE_lodash_includes__, __WEBPACK_EXTERNAL_MODULE_lodash_isArray__, __WEBPACK_EXTERNAL_MODULE_lodash_isElement__, __WEBPACK_EXTERNAL_MODULE_lodash_isFunction__, __WEBPACK_EXTERNAL_MODULE_lodash_isPlainObject__, __WEBPACK_EXTERNAL_MODULE_lodash_isString__, __WEBPACK_EXTERNAL_MODULE_lodash_merge__, __WEBPACK_EXTERNAL_MODULE_lodash_trim__) {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_2864__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_2864__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_2864__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_2864__.c = installedModules;\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_2864__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_2864__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    enumerable: true,\n                    get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // define __esModule on exports\n        /******/ __nested_webpack_require_2864__.r = function(exports1) {\n            /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                    value: \"Module\"\n                });\n            /******/ }\n            /******/ Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n        /******/ };\n        /******/ /******/ // create a fake namespace object\n        /******/ // mode & 1: value is a module id, require it\n        /******/ // mode & 2: merge all properties of value into the ns\n        /******/ // mode & 4: return value when already ns object\n        /******/ // mode & 8|1: behave like require\n        /******/ __nested_webpack_require_2864__.t = function(value, mode) {\n            /******/ if (mode & 1) value = __nested_webpack_require_2864__(value);\n            /******/ if (mode & 8) return value;\n            /******/ if (mode & 4 && typeof value === \"object\" && value && value.__esModule) return value;\n            /******/ var ns = Object.create(null);\n            /******/ __nested_webpack_require_2864__.r(ns);\n            /******/ Object.defineProperty(ns, \"default\", {\n                enumerable: true,\n                value: value\n            });\n            /******/ if (mode & 2 && typeof value != \"string\") for(var key in value)__nested_webpack_require_2864__.d(ns, key, (function(key) {\n                return value[key];\n            }).bind(null, key));\n            /******/ return ns;\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_2864__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_2864__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_2864__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_2864__.p = \"\";\n        /******/ /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_2864__(__nested_webpack_require_2864__.s = \"./src/namespace/cloudinary-core.js\");\n    /******/ }({\n        /***/ \"./src/namespace/cloudinary-core.js\": /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_7160__) {\n            \"use strict\";\n            // ESM COMPAT FLAG\n            __nested_webpack_require_7160__.r(__nested_webpack_exports__);\n            // EXPORTS\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"ClientHintsMetaTag\", function() {\n                return /* reexport */ clienthintsmetatag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Cloudinary\", function() {\n                return /* reexport */ cloudinary;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Condition\", function() {\n                return /* reexport */ condition;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Configuration\", function() {\n                return /* reexport */ src_configuration;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"crc32\", function() {\n                return /* reexport */ src_crc32;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Expression\", function() {\n                return /* reexport */ expression;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"FetchLayer\", function() {\n                return /* reexport */ fetchlayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"HtmlTag\", function() {\n                return /* reexport */ htmltag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"ImageTag\", function() {\n                return /* reexport */ imagetag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Layer\", function() {\n                return /* reexport */ layer_layer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"PictureTag\", function() {\n                return /* reexport */ picturetag;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"SubtitlesLayer\", function() {\n                return /* reexport */ subtitleslayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"TextLayer\", function() {\n                return /* reexport */ textlayer;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Transformation\", function() {\n                return /* reexport */ src_transformation;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"utf8_encode\", function() {\n                return /* reexport */ src_utf8_encode;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"Util\", function() {\n                return /* reexport */ lodash_namespaceObject;\n            });\n            __nested_webpack_require_7160__.d(__nested_webpack_exports__, \"VideoTag\", function() {\n                return /* reexport */ videotag;\n            });\n            // NAMESPACE OBJECT: ./src/constants.js\n            var constants_namespaceObject = {};\n            __nested_webpack_require_7160__.r(constants_namespaceObject);\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"VERSION\", function() {\n                return VERSION;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"CF_SHARED_CDN\", function() {\n                return CF_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"OLD_AKAMAI_SHARED_CDN\", function() {\n                return OLD_AKAMAI_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"AKAMAI_SHARED_CDN\", function() {\n                return AKAMAI_SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"SHARED_CDN\", function() {\n                return SHARED_CDN;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_TIMEOUT_MS\", function() {\n                return DEFAULT_TIMEOUT_MS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_POSTER_OPTIONS\", function() {\n                return DEFAULT_POSTER_OPTIONS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_SOURCE_TYPES\", function() {\n                return DEFAULT_VIDEO_SOURCE_TYPES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"SEO_TYPES\", function() {\n                return SEO_TYPES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_IMAGE_PARAMS\", function() {\n                return DEFAULT_IMAGE_PARAMS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_PARAMS\", function() {\n                return DEFAULT_VIDEO_PARAMS;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_VIDEO_SOURCES\", function() {\n                return DEFAULT_VIDEO_SOURCES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"DEFAULT_EXTERNAL_LIBRARIES\", function() {\n                return DEFAULT_EXTERNAL_LIBRARIES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"PLACEHOLDER_IMAGE_MODES\", function() {\n                return PLACEHOLDER_IMAGE_MODES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"ACCESSIBILITY_MODES\", function() {\n                return ACCESSIBILITY_MODES;\n            });\n            __nested_webpack_require_7160__.d(constants_namespaceObject, \"URL_KEYS\", function() {\n                return URL_KEYS;\n            });\n            // NAMESPACE OBJECT: ./src/util/lodash.js\n            var lodash_namespaceObject = {};\n            __nested_webpack_require_7160__.r(lodash_namespaceObject);\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getSDKAnalyticsSignature\", function() {\n                return getSDKAnalyticsSignature;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getAnalyticsOptions\", function() {\n                return getAnalyticsOptions;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"assign\", function() {\n                return assign_root_assign_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cloneDeep\", function() {\n                return cloneDeep_root_cloneDeep_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"compact\", function() {\n                return compact_root_compact_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"difference\", function() {\n                return difference_root_difference_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"functions\", function() {\n                return functions_root_functions_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"identity\", function() {\n                return identity_root_identity_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"includes\", function() {\n                return includes_root_includes_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isArray\", function() {\n                return isArray_root_isArray_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isPlainObject\", function() {\n                return isPlainObject_root_isPlainObject_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isString\", function() {\n                return isString_root_isString_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"merge\", function() {\n                return merge_root_merge_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"contains\", function() {\n                return includes_root_includes_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isIntersectionObserverSupported\", function() {\n                return isIntersectionObserverSupported;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isNativeLazyLoadSupported\", function() {\n                return isNativeLazyLoadSupported;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"detectIntersection\", function() {\n                return detectIntersection;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"omit\", function() {\n                return omit;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"allStrings\", function() {\n                return baseutil_allStrings;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"without\", function() {\n                return without;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isNumberLike\", function() {\n                return isNumberLike;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"smartEscape\", function() {\n                return smartEscape;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"defaults\", function() {\n                return defaults;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"objectProto\", function() {\n                return objectProto;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"objToString\", function() {\n                return objToString;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isObject\", function() {\n                return isObject;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"funcTag\", function() {\n                return funcTag;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"reWords\", function() {\n                return reWords;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"camelCase\", function() {\n                return camelCase;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"snakeCase\", function() {\n                return snakeCase;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"convertKeys\", function() {\n                return convertKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"withCamelCaseKeys\", function() {\n                return withCamelCaseKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"withSnakeCaseKeys\", function() {\n                return withSnakeCaseKeys;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"base64Encode\", function() {\n                return base64Encode;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"base64EncodeURL\", function() {\n                return base64EncodeURL;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"extractUrlParams\", function() {\n                return extractUrlParams;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"patchFetchFormat\", function() {\n                return patchFetchFormat;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"optionConsume\", function() {\n                return optionConsume;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isEmpty\", function() {\n                return isEmpty;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isAndroid\", function() {\n                return isAndroid;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isEdge\", function() {\n                return isEdge;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isChrome\", function() {\n                return isChrome;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isSafari\", function() {\n                return isSafari;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isElement\", function() {\n                return isElement_root_isElement_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"isFunction\", function() {\n                return isFunction_root_isFunction_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"trim\", function() {\n                return trim_root_trim_default.a;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getData\", function() {\n                return lodash_getData;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setData\", function() {\n                return lodash_setData;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getAttribute\", function() {\n                return lodash_getAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setAttribute\", function() {\n                return lodash_setAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"removeAttribute\", function() {\n                return lodash_removeAttribute;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"setAttributes\", function() {\n                return setAttributes;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"hasClass\", function() {\n                return lodash_hasClass;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"addClass\", function() {\n                return lodash_addClass;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getStyles\", function() {\n                return getStyles;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cssExpand\", function() {\n                return cssExpand;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"domStyle\", function() {\n                return domStyle;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"curCSS\", function() {\n                return curCSS;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"cssValue\", function() {\n                return cssValue;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"augmentWidthOrHeight\", function() {\n                return augmentWidthOrHeight;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"getWidthOrHeight\", function() {\n                return getWidthOrHeight;\n            });\n            __nested_webpack_require_7160__.d(lodash_namespaceObject, \"width\", function() {\n                return lodash_width;\n            });\n            // CONCATENATED MODULE: ./src/utf8_encode.js\n            /**\n * UTF8 encoder\n * @private\n */ var utf8_encode;\n            /* harmony default export */ var src_utf8_encode = utf8_encode = function utf8_encode(argString) {\n                var c1, enc, end, n, start, string, stringl, utftext;\n                // http://kevin.vanzonneveld.net\n                // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)\n                // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n                // +   improved by: sowberry\n                // +    tweaked by: Jack\n                // +   bugfixed by: Onno Marsman\n                // +   improved by: Yves Sucaet\n                // +   bugfixed by: Onno Marsman\n                // +   bugfixed by: Ulrich\n                // +   bugfixed by: Rafal Kukawski\n                // +   improved by: kirilloid\n                // *     example 1: utf8_encode('Kevin van Zonneveld');\n                // *     returns 1: 'Kevin van Zonneveld'\n                if (argString === null || typeof argString === \"undefined\") {\n                    return \"\";\n                }\n                string = argString + \"\";\n                // .replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n                utftext = \"\";\n                start = void 0;\n                end = void 0;\n                stringl = 0;\n                start = end = 0;\n                stringl = string.length;\n                n = 0;\n                while(n < stringl){\n                    c1 = string.charCodeAt(n);\n                    enc = null;\n                    if (c1 < 128) {\n                        end++;\n                    } else if (c1 > 127 && c1 < 2048) {\n                        enc = String.fromCharCode(c1 >> 6 | 192, c1 & 63 | 128);\n                    } else {\n                        enc = String.fromCharCode(c1 >> 12 | 224, c1 >> 6 & 63 | 128, c1 & 63 | 128);\n                    }\n                    if (enc !== null) {\n                        if (end > start) {\n                            utftext += string.slice(start, end);\n                        }\n                        utftext += enc;\n                        start = end = n + 1;\n                    }\n                    n++;\n                }\n                if (end > start) {\n                    utftext += string.slice(start, stringl);\n                }\n                return utftext;\n            };\n            // CONCATENATED MODULE: ./src/crc32.js\n            /**\n * CRC32 calculator\n * Depends on 'utf8_encode'\n * @private\n * @param {string} str - The string to calculate the CRC32 for.\n * @return {number}\n */ function crc32(str) {\n                var crc, i, iTop, table, x, y;\n                // http://kevin.vanzonneveld.net\n                // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)\n                // +   improved by: T0bsn\n                // +   improved by: http://stackoverflow.com/questions/2647935/javascript-crc32-function-and-php-crc32-not-matching\n                // -    depends on: utf8_encode\n                // *     example 1: crc32('Kevin van Zonneveld');\n                // *     returns 1: 1249991249\n                str = src_utf8_encode(str);\n                table = \"00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D\";\n                crc = 0;\n                x = 0;\n                y = 0;\n                crc = crc ^ -1;\n                i = 0;\n                iTop = str.length;\n                while(i < iTop){\n                    y = (crc ^ str.charCodeAt(i)) & 0xFF;\n                    x = \"0x\" + table.substr(y * 9, 8);\n                    crc = crc >>> 8 ^ x;\n                    i++;\n                }\n                crc = crc ^ -1;\n                //convert to unsigned 32-bit int if needed\n                if (crc < 0) {\n                    crc += 4294967296;\n                }\n                return crc;\n            }\n            /* harmony default export */ var src_crc32 = crc32;\n            // CONCATENATED MODULE: ./src/sdkAnalytics/stringPad.js\n            function stringPad(value, targetLength, padString) {\n                targetLength = targetLength >> 0; //truncate if number or convert non-number to 0;\n                padString = String(typeof padString !== \"undefined\" ? padString : \" \");\n                if (value.length > targetLength) {\n                    return String(value);\n                } else {\n                    targetLength = targetLength - value.length;\n                    if (targetLength > padString.length) {\n                        padString += repeatStringNumTimes(padString, targetLength / padString.length);\n                    }\n                    return padString.slice(0, targetLength) + String(value);\n                }\n            }\n            function repeatStringNumTimes(string, times) {\n                var repeatedString = \"\";\n                while(times > 0){\n                    repeatedString += string;\n                    times--;\n                }\n                return repeatedString;\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/base64Map.js\n            function _toConsumableArray(arr) {\n                return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n            }\n            function _nonIterableSpread() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function _unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n            }\n            function _iterableToArray(iter) {\n                if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n            }\n            function _arrayWithoutHoles(arr) {\n                if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n            }\n            function _arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n                return arr2;\n            }\n            var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n            var base64Map_num = 0;\n            var map = {};\n            _toConsumableArray(chars).forEach(function(_char) {\n                var key = base64Map_num.toString(2);\n                key = stringPad(key, 6, \"0\");\n                map[key] = _char;\n                base64Map_num++;\n            });\n            /**\n * Map of six-bit binary codes to Base64 characters\n */ /* harmony default export */ var base64Map = map;\n            // CONCATENATED MODULE: ./src/sdkAnalytics/reverseVersion.js\n            /**\n * @description A semVer like string, x.y.z or x.y is allowed\n *              Reverses the version positions, x.y.z turns to z.y.x\n *              Pads each segment with '0' so they have length of 2\n *              Example: 1.2.3 -> 03.02.01\n * @param {string} semVer Input can be either x.y.z or x.y\n * @return {string} in the form of zz.yy.xx (\n */ function reverseVersion(semVer) {\n                if (semVer.split(\".\").length < 2) {\n                    throw new Error(\"invalid semVer, must have at least two segments\");\n                }\n                // Split by '.', reverse, create new array with padded values and concat it together\n                return semVer.split(\".\").reverse().map(function(segment) {\n                    return stringPad(segment, 2, \"0\");\n                }).join(\".\");\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/encodeVersion.js\n            /**\n * @description Encodes a semVer-like version string\n * @param {string} semVer Input can be either x.y.z or x.y\n * @return {string} A string built from 3 characters of the base64 table that encode the semVer\n */ function encodeVersion(semVer) {\n                var strResult = \"\";\n                // support x.y or x.y.z by using 'parts' as a variable\n                var parts = semVer.split(\".\").length;\n                var paddedStringLength = parts * 6; // we pad to either 12 or 18 characters\n                // reverse (but don't mirror) the version. 1.5.15 -> 15.5.1\n                // Pad to two spaces, 15.5.1 -> 15.05.01\n                var paddedReversedSemver = reverseVersion(semVer);\n                // turn 15.05.01 to a string '150501' then to a number 150501\n                var num = parseInt(paddedReversedSemver.split(\".\").join(\"\"));\n                // Represent as binary, add left padding to 12 or 18 characters.\n                // 150,501 -> 100100101111100101\n                var paddedBinary = num.toString(2);\n                paddedBinary = stringPad(paddedBinary, paddedStringLength, \"0\");\n                // Stop in case an invalid version number was provided\n                // paddedBinary must be built from sections of 6 bits\n                if (paddedBinary.length % 6 !== 0) {\n                    throw \"Version must be smaller than 43.21.26)\";\n                }\n                // turn every 6 bits into a character using the base64Map\n                paddedBinary.match(/.{1,6}/g).forEach(function(bitString) {\n                    // console.log(bitString);\n                    strResult += base64Map[bitString];\n                });\n                return strResult;\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/getSDKAnalyticsSignature.js\n            /**\n * @description Gets the SDK signature by encoding the SDK version and tech version\n * @param {{\n *    [techVersion]:string,\n *    [sdkSemver]: string,\n *    [sdkCode]: string,\n *    [feature]: string\n * }} analyticsOptions\n * @return {string} sdkAnalyticsSignature\n */ function getSDKAnalyticsSignature() {\n                var analyticsOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                try {\n                    var twoPartVersion = removePatchFromSemver(analyticsOptions.techVersion);\n                    var encodedSDKVersion = encodeVersion(analyticsOptions.sdkSemver);\n                    var encodedTechVersion = encodeVersion(twoPartVersion);\n                    var featureCode = analyticsOptions.feature;\n                    var SDKCode = analyticsOptions.sdkCode;\n                    var algoVersion = \"A\"; // The algo version is determined here, it should not be an argument\n                    return \"\".concat(algoVersion).concat(SDKCode).concat(encodedSDKVersion).concat(encodedTechVersion).concat(featureCode);\n                } catch (e) {\n                    // Either SDK or Node versions were unparsable\n                    return \"E\";\n                }\n            }\n            /**\n * @description Removes patch version from the semver if it exists\n *              Turns x.y.z OR x.y into x.y\n * @param {'x.y.z' || 'x.y' || string} semVerStr\n */ function removePatchFromSemver(semVerStr) {\n                var parts = semVerStr.split(\".\");\n                return \"\".concat(parts[0], \".\").concat(parts[1]);\n            }\n            // CONCATENATED MODULE: ./src/sdkAnalytics/getAnalyticsOptions.js\n            /**\n * @description Gets the analyticsOptions from options- should include sdkSemver, techVersion, sdkCode, and feature\n * @param options\n * @returns {{sdkSemver: (string), sdkCode, feature: string, techVersion: (string)} || {}}\n */ function getAnalyticsOptions(options) {\n                var analyticsOptions = {\n                    sdkSemver: options.sdkSemver,\n                    techVersion: options.techVersion,\n                    sdkCode: options.sdkCode,\n                    feature: \"0\"\n                };\n                if (options.urlAnalytics) {\n                    if (options.accessibility) {\n                        analyticsOptions.feature = \"D\";\n                    }\n                    if (options.loading === \"lazy\") {\n                        analyticsOptions.feature = \"C\";\n                    }\n                    if (options.responsive) {\n                        analyticsOptions.feature = \"A\";\n                    }\n                    if (options.placeholder) {\n                        analyticsOptions.feature = \"B\";\n                    }\n                    return analyticsOptions;\n                } else {\n                    return {};\n                }\n            }\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/assign\",\"commonjs2\":\"lodash/assign\",\"amd\":\"lodash/assign\",\"root\":[\"_\",\"assign\"]}\n            var assign_root_assign_ = __nested_webpack_require_7160__(\"lodash/assign\");\n            var assign_root_assign_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(assign_root_assign_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/cloneDeep\",\"commonjs2\":\"lodash/cloneDeep\",\"amd\":\"lodash/cloneDeep\",\"root\":[\"_\",\"cloneDeep\"]}\n            var cloneDeep_root_cloneDeep_ = __nested_webpack_require_7160__(\"lodash/cloneDeep\");\n            var cloneDeep_root_cloneDeep_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(cloneDeep_root_cloneDeep_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/compact\",\"commonjs2\":\"lodash/compact\",\"amd\":\"lodash/compact\",\"root\":[\"_\",\"compact\"]}\n            var compact_root_compact_ = __nested_webpack_require_7160__(\"lodash/compact\");\n            var compact_root_compact_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(compact_root_compact_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/difference\",\"commonjs2\":\"lodash/difference\",\"amd\":\"lodash/difference\",\"root\":[\"_\",\"difference\"]}\n            var difference_root_difference_ = __nested_webpack_require_7160__(\"lodash/difference\");\n            var difference_root_difference_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(difference_root_difference_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/functions\",\"commonjs2\":\"lodash/functions\",\"amd\":\"lodash/functions\",\"root\":[\"_\",\"functions\"]}\n            var functions_root_functions_ = __nested_webpack_require_7160__(\"lodash/functions\");\n            var functions_root_functions_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(functions_root_functions_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/identity\",\"commonjs2\":\"lodash/identity\",\"amd\":\"lodash/identity\",\"root\":[\"_\",\"identity\"]}\n            var identity_root_identity_ = __nested_webpack_require_7160__(\"lodash/identity\");\n            var identity_root_identity_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(identity_root_identity_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/includes\",\"commonjs2\":\"lodash/includes\",\"amd\":\"lodash/includes\",\"root\":[\"_\",\"includes\"]}\n            var includes_root_includes_ = __nested_webpack_require_7160__(\"lodash/includes\");\n            var includes_root_includes_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(includes_root_includes_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isArray\",\"commonjs2\":\"lodash/isArray\",\"amd\":\"lodash/isArray\",\"root\":[\"_\",\"isArray\"]}\n            var isArray_root_isArray_ = __nested_webpack_require_7160__(\"lodash/isArray\");\n            var isArray_root_isArray_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isArray_root_isArray_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isPlainObject\",\"commonjs2\":\"lodash/isPlainObject\",\"amd\":\"lodash/isPlainObject\",\"root\":[\"_\",\"isPlainObject\"]}\n            var isPlainObject_root_isPlainObject_ = __nested_webpack_require_7160__(\"lodash/isPlainObject\");\n            var isPlainObject_root_isPlainObject_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isPlainObject_root_isPlainObject_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isString\",\"commonjs2\":\"lodash/isString\",\"amd\":\"lodash/isString\",\"root\":[\"_\",\"isString\"]}\n            var isString_root_isString_ = __nested_webpack_require_7160__(\"lodash/isString\");\n            var isString_root_isString_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isString_root_isString_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/merge\",\"commonjs2\":\"lodash/merge\",\"amd\":\"lodash/merge\",\"root\":[\"_\",\"merge\"]}\n            var merge_root_merge_ = __nested_webpack_require_7160__(\"lodash/merge\");\n            var merge_root_merge_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(merge_root_merge_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isElement\",\"commonjs2\":\"lodash/isElement\",\"amd\":\"lodash/isElement\",\"root\":[\"_\",\"isElement\"]}\n            var isElement_root_isElement_ = __nested_webpack_require_7160__(\"lodash/isElement\");\n            var isElement_root_isElement_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isElement_root_isElement_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/isFunction\",\"commonjs2\":\"lodash/isFunction\",\"amd\":\"lodash/isFunction\",\"root\":[\"_\",\"isFunction\"]}\n            var isFunction_root_isFunction_ = __nested_webpack_require_7160__(\"lodash/isFunction\");\n            var isFunction_root_isFunction_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(isFunction_root_isFunction_);\n            // EXTERNAL MODULE: external {\"commonjs\":\"lodash/trim\",\"commonjs2\":\"lodash/trim\",\"amd\":\"lodash/trim\",\"root\":[\"_\",\"trim\"]}\n            var trim_root_trim_ = __nested_webpack_require_7160__(\"lodash/trim\");\n            var trim_root_trim_default = /*#__PURE__*/ __nested_webpack_require_7160__.n(trim_root_trim_);\n            // CONCATENATED MODULE: ./src/util/lazyLoad.js\n            function _typeof(o) {\n                \"@babel/helpers - typeof\";\n                return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, _typeof(o);\n            }\n            /*\n * Includes utility methods for lazy loading media\n */ /**\n * Check if IntersectionObserver is supported\n * @return {boolean} true if window.IntersectionObserver is defined\n */ function isIntersectionObserverSupported() {\n                // Check that 'IntersectionObserver' property is defined on window\n                return  false && 0;\n            }\n            /**\n * Check if native lazy loading is supported\n * @return {boolean} true if 'loading' property is defined for HTMLImageElement\n */ function isNativeLazyLoadSupported() {\n                return (typeof HTMLImageElement === \"undefined\" ? \"undefined\" : _typeof(HTMLImageElement)) === \"object\" && HTMLImageElement.prototype.loading;\n            }\n            /**\n * Calls onIntersect() when intersection is detected, or when\n * no native lazy loading or when IntersectionObserver isn't supported.\n * @param {Element} el - the element to observe\n * @param {function} onIntersect - called when the given element is in view\n */ function detectIntersection(el, onIntersect) {\n                try {\n                    if (isNativeLazyLoadSupported() || !isIntersectionObserverSupported()) {\n                        // Return if there's no need or possibility to detect intersection\n                        onIntersect();\n                        return;\n                    }\n                    // Detect intersection with given element using IntersectionObserver\n                    var observer = new IntersectionObserver(function(entries) {\n                        entries.forEach(function(entry) {\n                            if (entry.isIntersecting) {\n                                onIntersect();\n                                observer.unobserve(entry.target);\n                            }\n                        });\n                    }, {\n                        threshold: [\n                            0,\n                            0.01\n                        ]\n                    });\n                    observer.observe(el);\n                } catch (e) {\n                    onIntersect();\n                }\n            }\n            // CONCATENATED MODULE: ./src/constants.js\n            var VERSION = \"2.5.0\";\n            var CF_SHARED_CDN = \"d3jpl91pxevbkh.cloudfront.net\";\n            var OLD_AKAMAI_SHARED_CDN = \"cloudinary-a.akamaihd.net\";\n            var AKAMAI_SHARED_CDN = \"res.cloudinary.com\";\n            var SHARED_CDN = AKAMAI_SHARED_CDN;\n            var DEFAULT_TIMEOUT_MS = 10000;\n            var DEFAULT_POSTER_OPTIONS = {\n                format: \"jpg\",\n                resource_type: \"video\"\n            };\n            var DEFAULT_VIDEO_SOURCE_TYPES = [\n                \"webm\",\n                \"mp4\",\n                \"ogv\"\n            ];\n            var SEO_TYPES = {\n                \"image/upload\": \"images\",\n                \"image/private\": \"private_images\",\n                \"image/authenticated\": \"authenticated_images\",\n                \"raw/upload\": \"files\",\n                \"video/upload\": \"videos\"\n            };\n            /**\n* @const {Object} Cloudinary.DEFAULT_IMAGE_PARAMS\n* Defaults values for image parameters.\n*\n* (Previously defined using option_consume() )\n */ var DEFAULT_IMAGE_PARAMS = {\n                resource_type: \"image\",\n                transformation: [],\n                type: \"upload\"\n            };\n            /**\n* Defaults values for video parameters.\n* @const {Object} Cloudinary.DEFAULT_VIDEO_PARAMS\n* (Previously defined using option_consume() )\n */ var DEFAULT_VIDEO_PARAMS = {\n                fallback_content: \"\",\n                resource_type: \"video\",\n                source_transformation: {},\n                source_types: DEFAULT_VIDEO_SOURCE_TYPES,\n                transformation: [],\n                type: \"upload\"\n            };\n            /**\n * Recommended sources for video tag\n * @const {Object} Cloudinary.DEFAULT_VIDEO_SOURCES\n */ var DEFAULT_VIDEO_SOURCES = [\n                {\n                    type: \"mp4\",\n                    codecs: \"hev1\",\n                    transformations: {\n                        video_codec: \"h265\"\n                    }\n                },\n                {\n                    type: \"webm\",\n                    codecs: \"vp9\",\n                    transformations: {\n                        video_codec: \"vp9\"\n                    }\n                },\n                {\n                    type: \"mp4\",\n                    transformations: {\n                        video_codec: \"auto\"\n                    }\n                },\n                {\n                    type: \"webm\",\n                    transformations: {\n                        video_codec: \"auto\"\n                    }\n                }\n            ];\n            var DEFAULT_EXTERNAL_LIBRARIES = {\n                seeThru: \"https://unpkg.com/seethru@4/dist/seeThru.min.js\"\n            };\n            /**\n * Predefined placeholder transformations\n * @const {Object} Cloudinary.PLACEHOLDER_IMAGE_MODES\n */ var PLACEHOLDER_IMAGE_MODES = {\n                \"blur\": [\n                    {\n                        effect: \"blur:2000\",\n                        quality: 1,\n                        fetch_format: \"auto\"\n                    }\n                ],\n                // Default\n                \"pixelate\": [\n                    {\n                        effect: \"pixelate\",\n                        quality: 1,\n                        fetch_format: \"auto\"\n                    }\n                ],\n                // Generates a pixel size image which color is the predominant color of the original image.\n                \"predominant-color-pixel\": [\n                    {\n                        width: \"iw_div_2\",\n                        aspect_ratio: 1,\n                        crop: \"pad\",\n                        background: \"auto\"\n                    },\n                    {\n                        crop: \"crop\",\n                        width: 1,\n                        height: 1,\n                        gravity: \"north_east\"\n                    },\n                    {\n                        fetch_format: \"auto\",\n                        quality: \"auto\"\n                    }\n                ],\n                // Generates an image which color is the predominant color of the original image.\n                \"predominant-color\": [\n                    {\n                        variables: [\n                            [\n                                \"$currWidth\",\n                                \"w\"\n                            ],\n                            [\n                                \"$currHeight\",\n                                \"h\"\n                            ]\n                        ]\n                    },\n                    {\n                        width: \"iw_div_2\",\n                        aspect_ratio: 1,\n                        crop: \"pad\",\n                        background: \"auto\"\n                    },\n                    {\n                        crop: \"crop\",\n                        width: 10,\n                        height: 10,\n                        gravity: \"north_east\"\n                    },\n                    {\n                        width: \"$currWidth\",\n                        height: \"$currHeight\",\n                        crop: \"fill\"\n                    },\n                    {\n                        fetch_format: \"auto\",\n                        quality: \"auto\"\n                    }\n                ],\n                \"vectorize\": [\n                    {\n                        effect: \"vectorize:3:0.1\",\n                        fetch_format: \"svg\"\n                    }\n                ]\n            };\n            /**\n * Predefined accessibility transformations\n * @const {Object} Cloudinary.ACCESSIBILITY_MODES\n */ var ACCESSIBILITY_MODES = {\n                darkmode: \"tint:75:black\",\n                brightmode: \"tint:50:white\",\n                monochrome: \"grayscale\",\n                colorblind: \"assist_colorblind\"\n            };\n            /**\n * A list of keys used by the url() function.\n * @private\n */ var URL_KEYS = [\n                \"accessibility\",\n                \"api_secret\",\n                \"auth_token\",\n                \"cdn_subdomain\",\n                \"cloud_name\",\n                \"cname\",\n                \"format\",\n                \"placeholder\",\n                \"private_cdn\",\n                \"resource_type\",\n                \"secure\",\n                \"secure_cdn_subdomain\",\n                \"secure_distribution\",\n                \"shorten\",\n                \"sign_url\",\n                \"signature\",\n                \"ssl_detected\",\n                \"type\",\n                \"url_suffix\",\n                \"use_root_path\",\n                \"version\"\n            ];\n            /**\n * The resource storage type\n * @typedef type\n * @enum {string}\n * @property  {string} 'upload' A resource uploaded directly to Cloudinary\n * @property  {string} 'fetch' A resource fetched by Cloudinary from a 3rd party storage\n * @property  {string} 'private'\n * @property  {string} 'authenticated'\n * @property  {string} 'sprite'\n * @property  {string} 'facebook'\n * @property  {string} 'twitter'\n * @property  {string} 'youtube'\n * @property  {string} 'vimeo'\n *\n */ /**\n * The resource type\n * @typedef resourceType\n * @enum {string}\n * @property {string} 'image' An image file\n * @property {string} 'video' A video file\n * @property {string} 'raw'   A raw file\n */ // CONCATENATED MODULE: ./src/util/baseutil.js\n            function baseutil_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return baseutil_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, baseutil_typeof(o);\n            }\n            /*\n * Includes common utility methods and shims\n */ function omit(obj, keys) {\n                obj = obj || {};\n                var srcKeys = Object.keys(obj).filter(function(key) {\n                    return !includes_root_includes_default()(keys, key);\n                });\n                var filtered = {};\n                srcKeys.forEach(function(key) {\n                    return filtered[key] = obj[key];\n                });\n                return filtered;\n            }\n            /**\n * Return true if all items in list are strings\n * @function Util.allString\n * @param {Array} list - an array of items\n */ var baseutil_allStrings = function allStrings(list) {\n                return list.length && list.every(isString_root_isString_default.a);\n            };\n            /**\n* Creates a new array without the given item.\n* @function Util.without\n* @param {Array} array - original array\n* @param {*} item - the item to exclude from the new array\n* @return {Array} a new array made of the original array's items except for `item`\n */ var without = function without(array, item) {\n                return array.filter(function(v) {\n                    return v !== item;\n                });\n            };\n            /**\n* Return true is value is a number or a string representation of a number.\n* @function Util.isNumberLike\n* @param {*} value\n* @returns {boolean} true if value is a number\n* @example\n*    Util.isNumber(0) // true\n*    Util.isNumber(\"1.3\") // true\n*    Util.isNumber(\"\") // false\n*    Util.isNumber(undefined) // false\n */ var isNumberLike = function isNumberLike(value) {\n                return value != null && !isNaN(parseFloat(value));\n            };\n            /**\n * Escape all characters matching unsafe in the given string\n * @function Util.smartEscape\n * @param {string} string - source string to escape\n * @param {RegExp} unsafe - characters that must be escaped\n * @return {string} escaped string\n */ var smartEscape = function smartEscape(string) {\n                var unsafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /([^a-zA-Z0-9_.\\-\\/:]+)/g;\n                return string.replace(unsafe, function(match) {\n                    return match.split(\"\").map(function(c) {\n                        return \"%\" + c.charCodeAt(0).toString(16).toUpperCase();\n                    }).join(\"\");\n                });\n            };\n            /**\n * Assign values from sources if they are not defined in the destination.\n * Once a value is set it does not change\n * @function Util.defaults\n * @param {Object} destination - the object to assign defaults to\n * @param {...Object} source - the source object(s) to assign defaults from\n * @return {Object} destination after it was modified\n */ var defaults = function defaults(destination) {\n                for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    sources[_key - 1] = arguments[_key];\n                }\n                return sources.reduce(function(dest, source) {\n                    var key, value;\n                    for(key in source){\n                        value = source[key];\n                        if (dest[key] === void 0) {\n                            dest[key] = value;\n                        }\n                    }\n                    return dest;\n                }, destination);\n            };\n            /*********** lodash functions */ var objectProto = Object.prototype;\n            /**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */ var objToString = objectProto.toString;\n            /**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n#isObject({});\n * // => true\n *\n#isObject([1, 2, 3]);\n * // => true\n *\n#isObject(1);\n * // => false\n */ var isObject = function isObject(value) {\n                var type;\n                // Avoid a V8 JIT bug in Chrome 19-20.\n                // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n                type = baseutil_typeof(value);\n                return !!value && (type === \"object\" || type === \"function\");\n            };\n            var funcTag = \"[object Function]\";\n            /**\n* Checks if `value` is classified as a `Function` object.\n* @function Util.isFunction\n* @param {*} value The value to check.\n* @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n* @example\n*\n* function Foo(){};\n* isFunction(Foo);\n* // => true\n*\n* isFunction(/abc/);\n* // => false\n */ var isFunction = function isFunction(value) {\n                // The use of `Object#toString` avoids issues with the `typeof` operator\n                // in older versions of Chrome and Safari which return 'function' for regexes\n                // and Safari 8 which returns 'object' for typed array constructors.\n                return isObject(value) && objToString.call(value) === funcTag;\n            };\n            /*********** lodash functions */ /** Used to match words to create compound words. */ var reWords = function() {\n                var lower, upper;\n                upper = \"[A-Z]\";\n                lower = \"[a-z]+\";\n                return RegExp(upper + \"+(?=\" + upper + lower + \")|\" + upper + \"?\" + lower + \"|\" + upper + \"+|[0-9]+\", \"g\");\n            }();\n            /**\n* Convert string to camelCase\n* @function Util.camelCase\n* @param {string} source - the string to convert\n* @return {string} in camelCase format\n */ var camelCase = function camelCase(source) {\n                var words = source.match(reWords);\n                words = words.map(function(word) {\n                    return word.charAt(0).toLocaleUpperCase() + word.slice(1).toLocaleLowerCase();\n                });\n                words[0] = words[0].toLocaleLowerCase();\n                return words.join(\"\");\n            };\n            /**\n * Convert string to snake_case\n * @function Util.snakeCase\n * @param {string} source - the string to convert\n * @return {string} in snake_case format\n */ var snakeCase = function snakeCase(source) {\n                var words = source.match(reWords);\n                words = words.map(function(word) {\n                    return word.toLocaleLowerCase();\n                });\n                return words.join(\"_\");\n            };\n            /**\n * Creates a new object from source, with the keys transformed using the converter.\n * @param {object} source\n * @param {function|null} converter\n * @returns {object}\n */ var convertKeys = function convertKeys(source, converter) {\n                var result, value;\n                result = {};\n                for(var key in source){\n                    value = source[key];\n                    if (converter) {\n                        key = converter(key);\n                    }\n                    if (!isEmpty(key)) {\n                        result[key] = value;\n                    }\n                }\n                return result;\n            };\n            /**\n * Create a copy of the source object with all keys in camelCase\n * @function Util.withCamelCaseKeys\n * @param {Object} value - the object to copy\n * @return {Object} a new object\n */ var withCamelCaseKeys = function withCamelCaseKeys(source) {\n                return convertKeys(source, camelCase);\n            };\n            /**\n * Create a copy of the source object with all keys in snake_case\n * @function Util.withSnakeCaseKeys\n * @param {Object} value - the object to copy\n * @return {Object} a new object\n */ var withSnakeCaseKeys = function withSnakeCaseKeys(source) {\n                return convertKeys(source, snakeCase);\n            };\n            // Browser\n            // Node.js\n            var base64Encode = typeof btoa !== \"undefined\" && isFunction(btoa) ? btoa : typeof Buffer !== \"undefined\" && isFunction(Buffer) ? function(input) {\n                if (!(input instanceof Buffer)) {\n                    input = new Buffer.from(String(input), \"binary\");\n                }\n                return input.toString(\"base64\");\n            } : function(input) {\n                throw new Error(\"No base64 encoding function found\");\n            };\n            /**\n* Returns the Base64-decoded version of url.<br>\n* This method delegates to `btoa` if present. Otherwise it tries `Buffer`.\n* @function Util.base64EncodeURL\n* @param {string} url - the url to encode. the value is URIdecoded and then re-encoded before converting to base64 representation\n* @return {string} the base64 representation of the URL\n */ var base64EncodeURL = function base64EncodeURL(url) {\n                try {\n                    url = decodeURI(url);\n                } finally{\n                    url = encodeURI(url);\n                }\n                return base64Encode(url);\n            };\n            /**\n * Create a new object with only URL parameters\n * @param {object} options The source object\n * @return {Object} An object containing only URL parameters\n */ function extractUrlParams(options) {\n                return URL_KEYS.reduce(function(obj, key) {\n                    if (options[key] != null) {\n                        obj[key] = options[key];\n                    }\n                    return obj;\n                }, {});\n            }\n            /**\n * Handle the format parameter for fetch urls\n * @private\n * @param options url and transformation options. This argument may be changed by the function!\n */ function patchFetchFormat(options) {\n                if (options == null) {\n                    options = {};\n                }\n                if (options.type === \"fetch\") {\n                    if (options.fetch_format == null) {\n                        options.fetch_format = optionConsume(options, \"format\");\n                    }\n                }\n            }\n            /**\n * Deletes `option_name` from `options` and return the value if present.\n * If `options` doesn't contain `option_name` the default value is returned.\n * @param {Object} options a collection\n * @param {String} option_name the name (key) of the desired value\n * @param {*} [default_value] the value to return is option_name is missing\n */ function optionConsume(options, option_name, default_value) {\n                var result = options[option_name];\n                delete options[option_name];\n                if (result != null) {\n                    return result;\n                } else {\n                    return default_value;\n                }\n            }\n            /**\n * Returns true if value is empty:\n * <ul>\n *   <li>value is null or undefined</li>\n *   <li>value is an array or string of length 0</li>\n *   <li>value is an object with no keys</li>\n * </ul>\n * @function Util.isEmpty\n * @param value\n * @returns {boolean} true if value is empty\n */ function isEmpty(value) {\n                if (value == null) {\n                    return true;\n                }\n                if (typeof value.length == \"number\") {\n                    return value.length === 0;\n                }\n                if (typeof value.size == \"number\") {\n                    return value.size === 0;\n                }\n                if (baseutil_typeof(value) == \"object\") {\n                    for(var key in value){\n                        if (value.hasOwnProperty(key)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                return true;\n            }\n            // CONCATENATED MODULE: ./src/util/browser.js\n            /**\n * Based on video.js implementation:\n * https://github.com/videojs/video.js/blob/4238f5c1d88890547153e7e1de7bd0d1d8e0b236/src/js/utils/browser.js\n */ /**\n* Retrieve from the navigator the user agent property.\n* @returns user agent property.\n*/ function getUserAgent() {\n                return navigator && navigator.userAgent || \"\";\n            }\n            /**\n * Detect if current browser is any Android\n * @returns true if current browser is Android, false otherwise.\n */ function isAndroid() {\n                var userAgent = getUserAgent();\n                return /Android/i.test(userAgent);\n            }\n            /**\n * Detect if current browser is any Edge\n * @returns true if current browser is Edge, false otherwise.\n */ function isEdge() {\n                var userAgent = getUserAgent();\n                return /Edg/i.test(userAgent);\n            }\n            /**\n * Detect if current browser is chrome.\n * @returns true if current browser is Chrome, false otherwise.\n */ function isChrome() {\n                var userAgent = getUserAgent();\n                return !isEdge() && (/Chrome/i.test(userAgent) || /CriOS/i.test(userAgent));\n            }\n            /**\n * Detect if current browser is Safari.\n * @returns true if current browser is Safari, false otherwise.\n */ function isSafari() {\n                // User agents for other browsers might include \"Safari\" so we must exclude them.\n                // For example - this is the chrome user agent on windows 10:\n                // Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36\n                var userAgent = getUserAgent();\n                return /Safari/i.test(userAgent) && !isChrome() && !isAndroid() && !isEdge();\n            }\n            // CONCATENATED MODULE: ./src/util/lodash.js\n            var nodeContains;\n            /*\n * Includes utility methods and lodash / jQuery shims\n */ /**\n * Get data from the DOM element.\n *\n * This method will use jQuery's `data()` method if it is available, otherwise it will get the `data-` attribute\n * @param {Element} element - the element to get the data from\n * @param {string} name - the name of the data item\n * @returns the value associated with the `name`\n * @function Util.getData\n */ var lodash_getData = function getData(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.getAttribute):\n                        return element.getAttribute(\"data-\".concat(name));\n                    case !isFunction_root_isFunction_default()(element.getAttr):\n                        return element.getAttr(\"data-\".concat(name));\n                    case !isFunction_root_isFunction_default()(element.data):\n                        return element.data(name);\n                    case !(isFunction_root_isFunction_default()(typeof jQuery !== \"undefined\" && jQuery.fn && jQuery.fn.data) && isElement_root_isElement_default()(element)):\n                        return jQuery(element).data(name);\n                }\n            };\n            /**\n * Set data in the DOM element.\n *\n * This method will use jQuery's `data()` method if it is available, otherwise it will set the `data-` attribute\n * @function Util.setData\n * @param {Element} element - the element to set the data in\n * @param {string} name - the name of the data item\n * @param {*} value - the value to be set\n *\n */ var lodash_setData = function setData(element, name, value) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.setAttribute):\n                        return element.setAttribute(\"data-\".concat(name), value);\n                    case !isFunction_root_isFunction_default()(element.setAttr):\n                        return element.setAttr(\"data-\".concat(name), value);\n                    case !isFunction_root_isFunction_default()(element.data):\n                        return element.data(name, value);\n                    case !(isFunction_root_isFunction_default()(typeof jQuery !== \"undefined\" && jQuery.fn && jQuery.fn.data) && isElement_root_isElement_default()(element)):\n                        return jQuery(element).data(name, value);\n                }\n            };\n            /**\n * Get attribute from the DOM element.\n *\n * @function Util.getAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n * @returns {*} the value of the attribute\n *\n */ var lodash_getAttribute = function getAttribute(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.getAttribute):\n                        return element.getAttribute(name);\n                    case !isFunction_root_isFunction_default()(element.attr):\n                        return element.attr(name);\n                    case !isFunction_root_isFunction_default()(element.getAttr):\n                        return element.getAttr(name);\n                }\n            };\n            /**\n * Set attribute in the DOM element.\n *\n * @function Util.setAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n * @param {*} value - the value to be set\n */ var lodash_setAttribute = function setAttribute(element, name, value) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.setAttribute):\n                        return element.setAttribute(name, value);\n                    case !isFunction_root_isFunction_default()(element.attr):\n                        return element.attr(name, value);\n                    case !isFunction_root_isFunction_default()(element.setAttr):\n                        return element.setAttr(name, value);\n                }\n            };\n            /**\n * Remove an attribute in the DOM element.\n *\n * @function Util.removeAttribute\n * @param {Element} element - the element to set the attribute for\n * @param {string} name - the name of the attribute\n */ var lodash_removeAttribute = function removeAttribute(element, name) {\n                switch(false){\n                    case !(element == null):\n                        return void 0;\n                    case !isFunction_root_isFunction_default()(element.removeAttribute):\n                        return element.removeAttribute(name);\n                    default:\n                        return lodash_setAttribute(element, void 0);\n                }\n            };\n            /**\n * Set a group of attributes to the element\n * @function Util.setAttributes\n * @param {Element} element - the element to set the attributes for\n * @param {Object} attributes - a hash of attribute names and values\n */ var setAttributes = function setAttributes(element, attributes) {\n                var name, results, value;\n                results = [];\n                for(name in attributes){\n                    value = attributes[name];\n                    if (value != null) {\n                        results.push(lodash_setAttribute(element, name, value));\n                    } else {\n                        results.push(lodash_removeAttribute(element, name));\n                    }\n                }\n                return results;\n            };\n            /**\n * Checks if element has a css class\n * @function Util.hasClass\n * @param {Element} element - the element to check\n * @param {string} name - the class name\n @returns {boolean} true if the element has the class\n */ var lodash_hasClass = function hasClass(element, name) {\n                if (isElement_root_isElement_default()(element)) {\n                    return element.className.match(new RegExp(\"\\\\b\".concat(name, \"\\\\b\")));\n                }\n            };\n            /**\n * Add class to the element\n * @function Util.addClass\n * @param {Element} element - the element\n * @param {string} name - the class name to add\n */ var lodash_addClass = function addClass(element, name) {\n                if (!element.className.match(new RegExp(\"\\\\b\".concat(name, \"\\\\b\")))) {\n                    return element.className = trim_root_trim_default()(\"\".concat(element.className, \" \").concat(name));\n                }\n            };\n            // The following code is taken from jQuery\n            var getStyles = function getStyles(elem) {\n                // Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n                // IE throws on elements created in popups\n                // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n                if (elem.ownerDocument.defaultView.opener) {\n                    return elem.ownerDocument.defaultView.getComputedStyle(elem, null);\n                }\n                return window.getComputedStyle(elem, null);\n            };\n            var cssExpand = [\n                \"Top\",\n                \"Right\",\n                \"Bottom\",\n                \"Left\"\n            ];\n            nodeContains = function nodeContains(a, b) {\n                var adown, bup;\n                adown = a.nodeType === 9 ? a.documentElement : a;\n                bup = b && b.parentNode;\n                return a === bup || !!(bup && bup.nodeType === 1 && adown.contains(bup));\n            };\n            // Truncated version of jQuery.style(elem, name)\n            var domStyle = function domStyle(elem, name) {\n                if (!(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style)) {\n                    return elem.style[name];\n                }\n            };\n            var curCSS = function curCSS(elem, name, computed) {\n                var maxWidth, minWidth, ret, rmargin, style, width;\n                rmargin = /^margin/;\n                width = void 0;\n                minWidth = void 0;\n                maxWidth = void 0;\n                ret = void 0;\n                style = elem.style;\n                computed = computed || getStyles(elem);\n                if (computed) {\n                    // Support: IE9\n                    // getPropertyValue is only needed for .css('filter') (#12537)\n                    ret = computed.getPropertyValue(name) || computed[name];\n                }\n                if (computed) {\n                    if (ret === \"\" && !nodeContains(elem.ownerDocument, elem)) {\n                        ret = domStyle(elem, name);\n                    }\n                    // Support: iOS < 6\n                    // A tribute to the \"awesome hack by Dean Edwards\"\n                    // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n                    // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n                    if (rnumnonpx.test(ret) && rmargin.test(name)) {\n                        // Remember the original values\n                        width = style.width;\n                        minWidth = style.minWidth;\n                        maxWidth = style.maxWidth;\n                        // Put in the new values to get a computed value out\n                        style.minWidth = style.maxWidth = style.width = ret;\n                        ret = computed.width;\n                        // Revert the changed values\n                        style.width = width;\n                        style.minWidth = minWidth;\n                        style.maxWidth = maxWidth;\n                    }\n                }\n                // Support: IE\n                // IE returns zIndex value as an integer.\n                if (ret !== undefined) {\n                    return ret + \"\";\n                } else {\n                    return ret;\n                }\n            };\n            var cssValue = function cssValue(elem, name, convert, styles) {\n                var val;\n                val = curCSS(elem, name, styles);\n                if (convert) {\n                    return parseFloat(val);\n                } else {\n                    return val;\n                }\n            };\n            var augmentWidthOrHeight = function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {\n                var i, len, side, sides, val;\n                // If we already have the right measurement, avoid augmentation\n                // Otherwise initialize for horizontal or vertical properties\n                if (extra === (isBorderBox ? \"border\" : \"content\")) {\n                    return 0;\n                } else {\n                    sides = name === \"width\" ? [\n                        \"Right\",\n                        \"Left\"\n                    ] : [\n                        \"Top\",\n                        \"Bottom\"\n                    ];\n                    val = 0;\n                    for(i = 0, len = sides.length; i < len; i++){\n                        side = sides[i];\n                        if (extra === \"margin\") {\n                            // Both box models exclude margin, so add it if we want it\n                            val += cssValue(elem, extra + side, true, styles);\n                        }\n                        if (isBorderBox) {\n                            if (extra === \"content\") {\n                                // border-box includes padding, so remove it if we want content\n                                val -= cssValue(elem, \"padding\".concat(side), true, styles);\n                            }\n                            if (extra !== \"margin\") {\n                                // At this point, extra isn't border nor margin, so remove border\n                                val -= cssValue(elem, \"border\".concat(side, \"Width\"), true, styles);\n                            }\n                        } else {\n                            // At this point, extra isn't content, so add padding\n                            val += cssValue(elem, \"padding\".concat(side), true, styles);\n                            if (extra !== \"padding\") {\n                                // At this point, extra isn't content nor padding, so add border\n                                val += cssValue(elem, \"border\".concat(side, \"Width\"), true, styles);\n                            }\n                        }\n                    }\n                    return val;\n                }\n            };\n            var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n            var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n            var getWidthOrHeight = function getWidthOrHeight(elem, name, extra) {\n                var isBorderBox, styles, val, valueIsBorderBox;\n                // Start with offset property, which is equivalent to the border-box value\n                valueIsBorderBox = true;\n                val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight;\n                styles = getStyles(elem);\n                isBorderBox = cssValue(elem, \"boxSizing\", false, styles) === \"border-box\";\n                // Some non-html elements return undefined for offsetWidth, so check for null/undefined\n                // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n                // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n                if (val <= 0 || val == null) {\n                    // Fall back to computed then uncomputed css if necessary\n                    val = curCSS(elem, name, styles);\n                    if (val < 0 || val == null) {\n                        val = elem.style[name];\n                    }\n                    if (rnumnonpx.test(val)) {\n                        // Computed unit is not pixels. Stop here and return.\n                        return val;\n                    }\n                    // Check for style in case a browser which returns unreliable values\n                    // for getComputedStyle silently falls back to the reliable elem.style\n                    //    valueIsBorderBox = isBorderBox and (support.boxSizingReliable() or val is elem.style[name])\n                    valueIsBorderBox = isBorderBox && val === elem.style[name];\n                    // Normalize \"\", auto, and prepare for extra\n                    val = parseFloat(val) || 0;\n                }\n                // Use the active box-sizing model to add/subtract irrelevant styles\n                return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles);\n            };\n            var lodash_width = function width(element) {\n                return getWidthOrHeight(element, \"width\", \"content\");\n            };\n            /**\n * @class Util\n */ /**\n * Returns true if item is a string\n * @function Util.isString\n * @param item\n * @returns {boolean} true if item is a string\n */ /**\n * Returns true if item is empty:\n * <ul>\n *   <li>item is null or undefined</li>\n *   <li>item is an array or string of length 0</li>\n *   <li>item is an object with no keys</li>\n * </ul>\n * @function Util.isEmpty\n * @param item\n * @returns {boolean} true if item is empty\n */ /**\n * Assign source properties to destination.\n * If the property is an object it is assigned as a whole, overriding the destination object.\n * @function Util.assign\n * @param {Object} destination - the object to assign to\n */ /**\n * Recursively assign source properties to destination\n * @function Util.merge\n * @param {Object} destination - the object to assign to\n * @param {...Object} [sources] The source objects.\n */ /**\n * Create a new copy of the given object, including all internal objects.\n * @function Util.cloneDeep\n * @param {Object} value - the object to clone\n * @return {Object} a new deep copy of the object\n */ /**\n * Creates a new array from the parameter with \"falsey\" values removed\n * @function Util.compact\n * @param {Array} array - the array to remove values from\n * @return {Array} a new array without falsey values\n */ /**\n * Check if a given item is included in the given array\n * @function Util.contains\n * @param {Array} array - the array to search in\n * @param {*} item - the item to search for\n * @return {boolean} true if the item is included in the array\n */ /**\n * Returns values in the given array that are not included in the other array\n * @function Util.difference\n * @param {Array} arr - the array to select from\n * @param {Array} values - values to filter from arr\n * @return {Array} the filtered values\n */ /**\n * Returns a list of all the function names in obj\n * @function Util.functions\n * @param {Object} object - the object to inspect\n * @return {Array} a list of functions of object\n */ /**\n * Returns the provided value. This functions is used as a default predicate function.\n * @function Util.identity\n * @param {*} value\n * @return {*} the provided value\n */ /**\n * Remove leading or trailing spaces from text\n * @function Util.trim\n * @param {string} text\n * @return {string} the `text` without leading or trailing spaces\n */ // CONCATENATED MODULE: ./src/expression.js\n            function expression_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return expression_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, expression_typeof(o);\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function _createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) _defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function _toPropertyKey(t) {\n                var i = _toPrimitive(t, \"string\");\n                return \"symbol\" == expression_typeof(i) ? i : i + \"\";\n            }\n            function _toPrimitive(t, r) {\n                if (\"object\" != expression_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != expression_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            /**\n * Represents a transformation expression.\n * @param {string} expressionStr - An expression in string format.\n * @class Expression\n * Normally this class is not instantiated directly\n */ var Expression = /*#__PURE__*/ function() {\n                function Expression(expressionStr) {\n                    _classCallCheck(this, Expression);\n                    /**\n     * @protected\n     * @inner Expression-expressions\n     */ this.expressions = [];\n                    if (expressionStr != null) {\n                        this.expressions.push(Expression.normalize(expressionStr));\n                    }\n                }\n                /**\n   * Convenience constructor method\n   * @function Expression.new\n   */ return _createClass(Expression, [\n                    {\n                        key: \"serialize\",\n                        value: /**\n     * Serialize the expression\n     * @return {string} the expression as a string\n     */ function serialize() {\n                            return Expression.normalize(this.expressions.join(\"_\"));\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return this.serialize();\n                        }\n                    },\n                    {\n                        key: \"getParent\",\n                        value: function getParent() {\n                            return this.parent;\n                        }\n                    },\n                    {\n                        key: \"setParent\",\n                        value: function setParent(parent) {\n                            this.parent = parent;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"predicate\",\n                        value: function predicate(name, operator, value) {\n                            if (Expression.OPERATORS[operator] != null) {\n                                operator = Expression.OPERATORS[operator];\n                            }\n                            this.expressions.push(\"\".concat(name, \"_\").concat(operator, \"_\").concat(value));\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"and\",\n                        value: function and() {\n                            this.expressions.push(\"and\");\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"or\",\n                        value: function or() {\n                            this.expressions.push(\"or\");\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"then\",\n                        value: function then() {\n                            return this.getParent()[\"if\"](this.toString());\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height(operator, value) {\n                            return this.predicate(\"h\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(operator, value) {\n                            return this.predicate(\"w\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(operator, value) {\n                            return this.predicate(\"ar\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount(operator, value) {\n                            return this.predicate(\"pc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount(operator, value) {\n                            return this.predicate(\"fc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value(_value) {\n                            this.expressions.push(_value);\n                            return this;\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(expressionStr) {\n                            return new this(expressionStr);\n                        }\n                    },\n                    {\n                        key: \"normalize\",\n                        value: function normalize(expression) {\n                            if (expression == null) {\n                                return expression;\n                            }\n                            expression = String(expression);\n                            var operators = \"\\\\|\\\\||>=|<=|&&|!=|>|=|<|/|-|\\\\+|\\\\*|\\\\^\";\n                            // operators\n                            var operatorsPattern = \"((\" + operators + \")(?=[ _]))\";\n                            var operatorsReplaceRE = new RegExp(operatorsPattern, \"g\");\n                            expression = expression.replace(operatorsReplaceRE, function(match) {\n                                return Expression.OPERATORS[match];\n                            });\n                            // predefined variables\n                            // The :${v} part is to prevent normalization of vars with a preceding colon (such as :duration),\n                            // It won't be found in PREDEFINED_VARS and so won't be normalized.\n                            // It is done like this because ie11 does not support regex lookbehind\n                            var predefinedVarsPattern = \"(\" + Object.keys(Expression.PREDEFINED_VARS).map(function(v) {\n                                return \":\".concat(v, \"|\").concat(v);\n                            }).join(\"|\") + \")\";\n                            var userVariablePattern = \"(\\\\$_*[^_ ]+)\";\n                            var variablesReplaceRE = new RegExp(\"\".concat(userVariablePattern, \"|\").concat(predefinedVarsPattern), \"g\");\n                            expression = expression.replace(variablesReplaceRE, function(match) {\n                                return Expression.PREDEFINED_VARS[match] || match;\n                            });\n                            return expression.replace(/[ _]+/g, \"_\");\n                        }\n                    },\n                    {\n                        key: \"variable\",\n                        value: function variable(name, value) {\n                            return new this(name).value(value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width() {\n                            return new this(\"width\");\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height() {\n                            return new this(\"height\");\n                        }\n                    },\n                    {\n                        key: \"initialWidth\",\n                        value: function initialWidth() {\n                            return new this(\"initialWidth\");\n                        }\n                    },\n                    {\n                        key: \"initialHeight\",\n                        value: function initialHeight() {\n                            return new this(\"initialHeight\");\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio() {\n                            return new this(\"aspectRatio\");\n                        }\n                    },\n                    {\n                        key: \"initialAspectRatio\",\n                        value: function initialAspectRatio() {\n                            return new this(\"initialAspectRatio\");\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount() {\n                            return new this(\"pageCount\");\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount() {\n                            return new this(\"faceCount\");\n                        }\n                    },\n                    {\n                        key: \"currentPage\",\n                        value: function currentPage() {\n                            return new this(\"currentPage\");\n                        }\n                    },\n                    {\n                        key: \"tags\",\n                        value: function tags() {\n                            return new this(\"tags\");\n                        }\n                    },\n                    {\n                        key: \"pageX\",\n                        value: function pageX() {\n                            return new this(\"pageX\");\n                        }\n                    },\n                    {\n                        key: \"pageY\",\n                        value: function pageY() {\n                            return new this(\"pageY\");\n                        }\n                    }\n                ]);\n            }();\n            /**\n * @internal\n */ Expression.OPERATORS = {\n                \"=\": \"eq\",\n                \"!=\": \"ne\",\n                \"<\": \"lt\",\n                \">\": \"gt\",\n                \"<=\": \"lte\",\n                \">=\": \"gte\",\n                \"&&\": \"and\",\n                \"||\": \"or\",\n                \"*\": \"mul\",\n                \"/\": \"div\",\n                \"+\": \"add\",\n                \"-\": \"sub\",\n                \"^\": \"pow\"\n            };\n            /**\n * @internal\n */ Expression.PREDEFINED_VARS = {\n                \"aspect_ratio\": \"ar\",\n                \"aspectRatio\": \"ar\",\n                \"current_page\": \"cp\",\n                \"currentPage\": \"cp\",\n                \"duration\": \"du\",\n                \"face_count\": \"fc\",\n                \"faceCount\": \"fc\",\n                \"height\": \"h\",\n                \"initial_aspect_ratio\": \"iar\",\n                \"initial_duration\": \"idu\",\n                \"initial_height\": \"ih\",\n                \"initial_width\": \"iw\",\n                \"initialAspectRatio\": \"iar\",\n                \"initialDuration\": \"idu\",\n                \"initialHeight\": \"ih\",\n                \"initialWidth\": \"iw\",\n                \"page_count\": \"pc\",\n                \"page_x\": \"px\",\n                \"page_y\": \"py\",\n                \"pageCount\": \"pc\",\n                \"pageX\": \"px\",\n                \"pageY\": \"py\",\n                \"tags\": \"tags\",\n                \"width\": \"w\"\n            };\n            /**\n * @internal\n */ Expression.BOUNDRY = \"[ _]+\";\n            /* harmony default export */ var expression = Expression;\n            // CONCATENATED MODULE: ./src/condition.js\n            function condition_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return condition_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, condition_typeof(o);\n            }\n            function condition_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function condition_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, condition_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function condition_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) condition_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) condition_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function condition_toPropertyKey(t) {\n                var i = condition_toPrimitive(t, \"string\");\n                return \"symbol\" == condition_typeof(i) ? i : i + \"\";\n            }\n            function condition_toPrimitive(t, r) {\n                if (\"object\" != condition_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != condition_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function _callSuper(t, o, e) {\n                return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function _possibleConstructorReturn(self, call) {\n                if (call && (condition_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return _assertThisInitialized(self);\n            }\n            function _assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function _isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function _getPrototypeOf(o) {\n                _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return _getPrototypeOf(o);\n            }\n            function _inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) _setPrototypeOf(subClass, superClass);\n            }\n            function _setPrototypeOf(o, p) {\n                _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return _setPrototypeOf(o, p);\n            }\n            /**\n * Represents a transformation condition.\n * @param {string} conditionStr - a condition in string format\n * @class Condition\n * @example\n * // normally this class is not instantiated directly\n * var tr = cloudinary.Transformation.new()\n *    .if().width( \">\", 1000).and().aspectRatio(\"<\", \"3:4\").then()\n *      .width(1000)\n *      .crop(\"scale\")\n *    .else()\n *      .width(500)\n *      .crop(\"scale\")\n *\n * var tr = cloudinary.Transformation.new()\n *    .if(\"w > 1000 and aspectRatio < 3:4\")\n *      .width(1000)\n *      .crop(\"scale\")\n *    .else()\n *      .width(500)\n *      .crop(\"scale\")\n *\n */ var Condition = /*#__PURE__*/ function(_Expression) {\n                function Condition(conditionStr) {\n                    condition_classCallCheck(this, Condition);\n                    return _callSuper(this, Condition, [\n                        conditionStr\n                    ]);\n                }\n                /**\n   * @function Condition#height\n   * @param {string} operator the comparison operator (e.g. \"<\", \"lt\")\n   * @param {string|number} value the right hand side value\n   * @return {Condition} this condition\n   */ _inherits(Condition, _Expression);\n                return condition_createClass(Condition, [\n                    {\n                        key: \"height\",\n                        value: function height(operator, value) {\n                            return this.predicate(\"h\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(operator, value) {\n                            return this.predicate(\"w\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(operator, value) {\n                            return this.predicate(\"ar\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"pageCount\",\n                        value: function pageCount(operator, value) {\n                            return this.predicate(\"pc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"faceCount\",\n                        value: function faceCount(operator, value) {\n                            return this.predicate(\"fc\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"duration\",\n                        value: function duration(operator, value) {\n                            return this.predicate(\"du\", operator, value);\n                        }\n                    },\n                    {\n                        key: \"initialDuration\",\n                        value: function initialDuration(operator, value) {\n                            return this.predicate(\"idu\", operator, value);\n                        }\n                    }\n                ]);\n            }(expression);\n            /* harmony default export */ var condition = Condition;\n            // CONCATENATED MODULE: ./src/configuration.js\n            function configuration_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return configuration_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, configuration_typeof(o);\n            }\n            function _slicedToArray(arr, i) {\n                return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || configuration_unsupportedIterableToArray(arr, i) || _nonIterableRest();\n            }\n            function _nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function configuration_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return configuration_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return configuration_arrayLikeToArray(o, minLen);\n            }\n            function configuration_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n                return arr2;\n            }\n            function _iterableToArrayLimit(r, l) {\n                var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n                if (null != t) {\n                    var e, n, i, u, a = [], f = !0, o = !1;\n                    try {\n                        if (i = (t = t.call(r)).next, 0 === l) {\n                            if (Object(t) !== t) return;\n                            f = !1;\n                        } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n                    } catch (r) {\n                        o = !0, n = r;\n                    } finally{\n                        try {\n                            if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n                        } finally{\n                            if (o) throw n;\n                        }\n                    }\n                    return a;\n                }\n            }\n            function _arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            function configuration_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function configuration_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, configuration_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function configuration_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) configuration_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) configuration_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function configuration_toPropertyKey(t) {\n                var i = configuration_toPrimitive(t, \"string\");\n                return \"symbol\" == configuration_typeof(i) ? i : i + \"\";\n            }\n            function configuration_toPrimitive(t, r) {\n                if (\"object\" != configuration_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != configuration_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            /**\n * Class for defining account configuration options.\n * Depends on 'utils'\n */ /**\n * Class for defining account configuration options.\n * @constructor Configuration\n * @param {Object} options - The account configuration parameters to set.\n * @see <a href=\"https://cloudinary.com/documentation/solution_overview#configuration_parameters\"\n *  target=\"_new\">Available configuration options</a>\n */ var configuration_Configuration = /*#__PURE__*/ function() {\n                function Configuration(options) {\n                    configuration_classCallCheck(this, Configuration);\n                    this.configuration = options == null ? {} : cloneDeep_root_cloneDeep_default()(options);\n                    defaults(this.configuration, DEFAULT_CONFIGURATION_PARAMS);\n                }\n                /**\n   * Initializes the configuration. This method is a convenience method that invokes both\n   *  {@link Configuration#fromEnvironment|fromEnvironment()} (Node.js environment only)\n   *  and {@link Configuration#fromDocument|fromDocument()}.\n   *  It first tries to retrieve the configuration from the environment variable.\n   *  If not available, it tries from the document meta tags.\n   * @function Configuration#init\n   * @return {Configuration} returns `this` for chaining\n   * @see fromDocument\n   * @see fromEnvironment\n   */ return configuration_createClass(Configuration, [\n                    {\n                        key: \"init\",\n                        value: function init() {\n                            this.fromEnvironment();\n                            this.fromDocument();\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(name, value) {\n                            this.configuration[name] = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"get\",\n                        value: function get(name) {\n                            return this.configuration[name];\n                        }\n                    },\n                    {\n                        key: \"merge\",\n                        value: function merge(config) {\n                            assign_root_assign_default()(this.configuration, cloneDeep_root_cloneDeep_default()(config));\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromDocument\",\n                        value: function fromDocument() {\n                            var el, i, len, meta_elements;\n                            meta_elements = typeof document !== \"undefined\" && document !== null ? document.querySelectorAll('meta[name^=\"cloudinary_\"]') : void 0;\n                            if (meta_elements) {\n                                for(i = 0, len = meta_elements.length; i < len; i++){\n                                    el = meta_elements[i];\n                                    this.configuration[el.getAttribute(\"name\").replace(\"cloudinary_\", \"\")] = el.getAttribute(\"content\");\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromEnvironment\",\n                        value: function fromEnvironment() {\n                            var _this = this;\n                            var cloudinary_url, query, uri, uriRegex;\n                            if (typeof process !== \"undefined\" && process !== null && process.env && process.env.CLOUDINARY_URL) {\n                                cloudinary_url = process.env.CLOUDINARY_URL;\n                                uriRegex = /cloudinary:\\/\\/(?:(\\w+)(?:\\:([\\w-]+))?@)?([\\w\\.-]+)(?:\\/([^?]*))?(?:\\?(.+))?/;\n                                uri = uriRegex.exec(cloudinary_url);\n                                if (uri) {\n                                    if (uri[3] != null) {\n                                        this.configuration[\"cloud_name\"] = uri[3];\n                                    }\n                                    if (uri[1] != null) {\n                                        this.configuration[\"api_key\"] = uri[1];\n                                    }\n                                    if (uri[2] != null) {\n                                        this.configuration[\"api_secret\"] = uri[2];\n                                    }\n                                    if (uri[4] != null) {\n                                        this.configuration[\"private_cdn\"] = uri[4] != null;\n                                    }\n                                    if (uri[4] != null) {\n                                        this.configuration[\"secure_distribution\"] = uri[4];\n                                    }\n                                    query = uri[5];\n                                    if (query != null) {\n                                        query.split(\"&\").forEach(function(value) {\n                                            var _value$split = value.split(\"=\"), _value$split2 = _slicedToArray(_value$split, 2), k = _value$split2[0], v = _value$split2[1];\n                                            if (v == null) {\n                                                v = true;\n                                            }\n                                            _this.configuration[k] = v;\n                                        });\n                                    }\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"config\",\n                        value: function config(new_config, new_value) {\n                            switch(false){\n                                case new_value === void 0:\n                                    this.set(new_config, new_value);\n                                    return this.configuration;\n                                case !isString_root_isString_default()(new_config):\n                                    return this.get(new_config);\n                                case !isPlainObject_root_isPlainObject_default()(new_config):\n                                    this.merge(new_config);\n                                    return this.configuration;\n                                default:\n                                    // Backward compatibility - return the internal object\n                                    return this.configuration;\n                            }\n                        }\n                    },\n                    {\n                        key: \"toOptions\",\n                        value: function toOptions() {\n                            return cloneDeep_root_cloneDeep_default()(this.configuration);\n                        }\n                    }\n                ]);\n            }();\n            var DEFAULT_CONFIGURATION_PARAMS = {\n                responsive_class: \"cld-responsive\",\n                responsive_use_breakpoints: true,\n                round_dpr: true,\n                secure: ( false ? 0 : void 0) === \"https:\"\n            };\n            configuration_Configuration.CONFIG_PARAMS = [\n                \"api_key\",\n                \"api_secret\",\n                \"callback\",\n                \"cdn_subdomain\",\n                \"cloud_name\",\n                \"cname\",\n                \"private_cdn\",\n                \"protocol\",\n                \"resource_type\",\n                \"responsive\",\n                \"responsive_class\",\n                \"responsive_use_breakpoints\",\n                \"responsive_width\",\n                \"round_dpr\",\n                \"secure\",\n                \"secure_cdn_subdomain\",\n                \"secure_distribution\",\n                \"shorten\",\n                \"type\",\n                \"upload_preset\",\n                \"url_suffix\",\n                \"use_root_path\",\n                \"version\",\n                \"externalLibraries\",\n                \"max_timeout_ms\"\n            ];\n            /* harmony default export */ var src_configuration = configuration_Configuration;\n            // CONCATENATED MODULE: ./src/layer/layer.js\n            function layer_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return layer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, layer_typeof(o);\n            }\n            function layer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function layer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, layer_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function layer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) layer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) layer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function layer_toPropertyKey(t) {\n                var i = layer_toPrimitive(t, \"string\");\n                return \"symbol\" == layer_typeof(i) ? i : i + \"\";\n            }\n            function layer_toPrimitive(t, r) {\n                if (\"object\" != layer_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != layer_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            var layer_Layer = /*#__PURE__*/ function() {\n                /**\n   * Layer\n   * @constructor Layer\n   * @param {Object} options - layer parameters\n   */ function Layer1(options) {\n                    var _this = this;\n                    layer_classCallCheck(this, Layer1);\n                    this.options = {};\n                    if (options != null) {\n                        [\n                            \"resourceType\",\n                            \"type\",\n                            \"publicId\",\n                            \"format\"\n                        ].forEach(function(key) {\n                            var ref;\n                            return _this.options[key] = (ref = options[key]) != null ? ref : options[snakeCase(key)];\n                        });\n                    }\n                }\n                return layer_createClass(Layer1, [\n                    {\n                        key: \"resourceType\",\n                        value: function resourceType(value) {\n                            this.options.resourceType = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"type\",\n                        value: function type(value) {\n                            this.options.type = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"publicId\",\n                        value: function publicId(value) {\n                            this.options.publicId = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"getPublicId\",\n                        value: function getPublicId() {\n                            var ref;\n                            return (ref = this.options.publicId) != null ? ref.replace(/\\//g, \":\") : void 0;\n                        }\n                    },\n                    {\n                        key: \"getFullPublicId\",\n                        value: function getFullPublicId() {\n                            if (this.options.format != null) {\n                                return this.getPublicId() + \".\" + this.options.format;\n                            } else {\n                                return this.getPublicId();\n                            }\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(value) {\n                            this.options.format = value;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            var components;\n                            components = [];\n                            if (this.options.publicId == null) {\n                                throw \"Must supply publicId\";\n                            }\n                            if (!(this.options.resourceType === \"image\")) {\n                                components.push(this.options.resourceType);\n                            }\n                            if (!(this.options.type === \"upload\")) {\n                                components.push(this.options.type);\n                            }\n                            components.push(this.getFullPublicId());\n                            return compact_root_compact_default()(components).join(\":\");\n                        }\n                    },\n                    {\n                        key: \"clone\",\n                        value: function clone() {\n                            return new this.constructor(this.options);\n                        }\n                    }\n                ]);\n            }();\n            /* harmony default export */ var layer_layer = layer_Layer;\n            // CONCATENATED MODULE: ./src/layer/textlayer.js\n            function textlayer_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return textlayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, textlayer_typeof(o);\n            }\n            function textlayer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function textlayer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, textlayer_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function textlayer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) textlayer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) textlayer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function textlayer_toPropertyKey(t) {\n                var i = textlayer_toPrimitive(t, \"string\");\n                return \"symbol\" == textlayer_typeof(i) ? i : i + \"\";\n            }\n            function textlayer_toPrimitive(t, r) {\n                if (\"object\" != textlayer_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != textlayer_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function textlayer_callSuper(t, o, e) {\n                return o = textlayer_getPrototypeOf(o), textlayer_possibleConstructorReturn(t, textlayer_isNativeReflectConstruct() ? Reflect.construct(o, e || [], textlayer_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function textlayer_possibleConstructorReturn(self, call) {\n                if (call && (textlayer_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return textlayer_assertThisInitialized(self);\n            }\n            function textlayer_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function textlayer_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (textlayer_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function textlayer_getPrototypeOf(o) {\n                textlayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return textlayer_getPrototypeOf(o);\n            }\n            function textlayer_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) textlayer_setPrototypeOf(subClass, superClass);\n            }\n            function textlayer_setPrototypeOf(o, p) {\n                textlayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return textlayer_setPrototypeOf(o, p);\n            }\n            var textlayer_TextLayer = /*#__PURE__*/ function(_Layer) {\n                /**\n   * @constructor TextLayer\n   * @param {Object} options - layer parameters\n   */ function TextLayer(options) {\n                    var _this;\n                    textlayer_classCallCheck(this, TextLayer);\n                    var keys;\n                    _this = textlayer_callSuper(this, TextLayer, [\n                        options\n                    ]);\n                    keys = [\n                        \"resourceType\",\n                        \"resourceType\",\n                        \"fontFamily\",\n                        \"fontSize\",\n                        \"fontWeight\",\n                        \"fontStyle\",\n                        \"textDecoration\",\n                        \"textAlign\",\n                        \"stroke\",\n                        \"letterSpacing\",\n                        \"lineSpacing\",\n                        \"fontHinting\",\n                        \"fontAntialiasing\",\n                        \"text\",\n                        \"textStyle\"\n                    ];\n                    if (options != null) {\n                        keys.forEach(function(key) {\n                            var ref;\n                            return _this.options[key] = (ref = options[key]) != null ? ref : options[snakeCase(key)];\n                        });\n                    }\n                    _this.options.resourceType = \"text\";\n                    return _this;\n                }\n                textlayer_inherits(TextLayer, _Layer);\n                return textlayer_createClass(TextLayer, [\n                    {\n                        key: \"resourceType\",\n                        value: function resourceType(_resourceType) {\n                            throw \"Cannot modify resourceType for text layers\";\n                        }\n                    },\n                    {\n                        key: \"type\",\n                        value: function type(_type) {\n                            throw \"Cannot modify type for text layers\";\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(_format) {\n                            throw \"Cannot modify format for text layers\";\n                        }\n                    },\n                    {\n                        key: \"fontFamily\",\n                        value: function fontFamily(_fontFamily) {\n                            this.options.fontFamily = _fontFamily;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontSize\",\n                        value: function fontSize(_fontSize) {\n                            this.options.fontSize = _fontSize;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontWeight\",\n                        value: function fontWeight(_fontWeight) {\n                            this.options.fontWeight = _fontWeight;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontStyle\",\n                        value: function fontStyle(_fontStyle) {\n                            this.options.fontStyle = _fontStyle;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textDecoration\",\n                        value: function textDecoration(_textDecoration) {\n                            this.options.textDecoration = _textDecoration;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textAlign\",\n                        value: function textAlign(_textAlign) {\n                            this.options.textAlign = _textAlign;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"stroke\",\n                        value: function stroke(_stroke) {\n                            this.options.stroke = _stroke;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"letterSpacing\",\n                        value: function letterSpacing(_letterSpacing) {\n                            this.options.letterSpacing = _letterSpacing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"lineSpacing\",\n                        value: function lineSpacing(_lineSpacing) {\n                            this.options.lineSpacing = _lineSpacing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontHinting\",\n                        value: function fontHinting(_fontHinting) {\n                            this.options.fontHinting = _fontHinting;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fontAntialiasing\",\n                        value: function fontAntialiasing(_fontAntialiasing) {\n                            this.options.fontAntialiasing = _fontAntialiasing;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"text\",\n                        value: function text(_text) {\n                            this.options.text = _text;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"textStyle\",\n                        value: function textStyle(_textStyle) {\n                            this.options.textStyle = _textStyle;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            var components, hasPublicId, hasStyle, publicId, re, res, start, style, text, textSource;\n                            style = this.textStyleIdentifier();\n                            if (this.options.publicId != null) {\n                                publicId = this.getFullPublicId();\n                            }\n                            if (this.options.text != null) {\n                                hasPublicId = !isEmpty(publicId);\n                                hasStyle = !isEmpty(style);\n                                if (hasPublicId && hasStyle || !hasPublicId && !hasStyle) {\n                                    throw \"Must supply either style parameters or a public_id when providing text parameter in a text overlay/underlay, but not both!\";\n                                }\n                                re = /\\$\\([a-zA-Z]\\w*\\)/g;\n                                start = 0;\n                                //        textSource = text.replace(new RegExp(\"[,/]\", 'g'), (c)-> \"%#{c.charCodeAt(0).toString(16).toUpperCase()}\")\n                                textSource = smartEscape(this.options.text, /[,\\/]/g);\n                                text = \"\";\n                                while(res = re.exec(textSource)){\n                                    text += smartEscape(textSource.slice(start, res.index));\n                                    text += res[0];\n                                    start = res.index + res[0].length;\n                                }\n                                text += smartEscape(textSource.slice(start));\n                            }\n                            components = [\n                                this.options.resourceType,\n                                style,\n                                publicId,\n                                text\n                            ];\n                            return compact_root_compact_default()(components).join(\":\");\n                        }\n                    },\n                    {\n                        key: \"textStyleIdentifier\",\n                        value: function textStyleIdentifier() {\n                            // Note: if a text-style argument is provided as a whole, it overrides everything else, no mix and match.\n                            if (!isEmpty(this.options.textStyle)) {\n                                return this.options.textStyle;\n                            }\n                            var components;\n                            components = [];\n                            if (this.options.fontWeight !== \"normal\") {\n                                components.push(this.options.fontWeight);\n                            }\n                            if (this.options.fontStyle !== \"normal\") {\n                                components.push(this.options.fontStyle);\n                            }\n                            if (this.options.textDecoration !== \"none\") {\n                                components.push(this.options.textDecoration);\n                            }\n                            components.push(this.options.textAlign);\n                            if (this.options.stroke !== \"none\") {\n                                components.push(this.options.stroke);\n                            }\n                            if (!(isEmpty(this.options.letterSpacing) && !isNumberLike(this.options.letterSpacing))) {\n                                components.push(\"letter_spacing_\" + this.options.letterSpacing);\n                            }\n                            if (!(isEmpty(this.options.lineSpacing) && !isNumberLike(this.options.lineSpacing))) {\n                                components.push(\"line_spacing_\" + this.options.lineSpacing);\n                            }\n                            if (!isEmpty(this.options.fontAntialiasing)) {\n                                components.push(\"antialias_\" + this.options.fontAntialiasing);\n                            }\n                            if (!isEmpty(this.options.fontHinting)) {\n                                components.push(\"hinting_\" + this.options.fontHinting);\n                            }\n                            if (!isEmpty(compact_root_compact_default()(components))) {\n                                if (isEmpty(this.options.fontFamily)) {\n                                    throw \"Must supply fontFamily. \".concat(components);\n                                }\n                                if (isEmpty(this.options.fontSize) && !isNumberLike(this.options.fontSize)) {\n                                    throw \"Must supply fontSize.\";\n                                }\n                            }\n                            components.unshift(this.options.fontFamily, this.options.fontSize);\n                            components = compact_root_compact_default()(components).join(\"_\");\n                            return components;\n                        }\n                    }\n                ]);\n            }(layer_layer);\n            ;\n            /* harmony default export */ var textlayer = textlayer_TextLayer;\n            // CONCATENATED MODULE: ./src/layer/subtitleslayer.js\n            function subtitleslayer_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return subtitleslayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, subtitleslayer_typeof(o);\n            }\n            function subtitleslayer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, subtitleslayer_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function subtitleslayer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) subtitleslayer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) subtitleslayer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function subtitleslayer_toPropertyKey(t) {\n                var i = subtitleslayer_toPrimitive(t, \"string\");\n                return \"symbol\" == subtitleslayer_typeof(i) ? i : i + \"\";\n            }\n            function subtitleslayer_toPrimitive(t, r) {\n                if (\"object\" != subtitleslayer_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != subtitleslayer_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function subtitleslayer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function subtitleslayer_callSuper(t, o, e) {\n                return o = subtitleslayer_getPrototypeOf(o), subtitleslayer_possibleConstructorReturn(t, subtitleslayer_isNativeReflectConstruct() ? Reflect.construct(o, e || [], subtitleslayer_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function subtitleslayer_possibleConstructorReturn(self, call) {\n                if (call && (subtitleslayer_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return subtitleslayer_assertThisInitialized(self);\n            }\n            function subtitleslayer_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function subtitleslayer_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (subtitleslayer_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function subtitleslayer_getPrototypeOf(o) {\n                subtitleslayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return subtitleslayer_getPrototypeOf(o);\n            }\n            function subtitleslayer_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) subtitleslayer_setPrototypeOf(subClass, superClass);\n            }\n            function subtitleslayer_setPrototypeOf(o, p) {\n                subtitleslayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return subtitleslayer_setPrototypeOf(o, p);\n            }\n            var SubtitlesLayer = /*#__PURE__*/ function(_TextLayer) {\n                /**\n   * Represent a subtitles layer\n   * @constructor SubtitlesLayer\n   * @param {Object} options - layer parameters\n   */ function SubtitlesLayer(options) {\n                    var _this;\n                    subtitleslayer_classCallCheck(this, SubtitlesLayer);\n                    _this = subtitleslayer_callSuper(this, SubtitlesLayer, [\n                        options\n                    ]);\n                    _this.options.resourceType = \"subtitles\";\n                    return _this;\n                }\n                subtitleslayer_inherits(SubtitlesLayer, _TextLayer);\n                return subtitleslayer_createClass(SubtitlesLayer);\n            }(textlayer);\n            /* harmony default export */ var subtitleslayer = SubtitlesLayer;\n            // CONCATENATED MODULE: ./src/layer/fetchlayer.js\n            function fetchlayer_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return fetchlayer_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, fetchlayer_typeof(o);\n            }\n            function fetchlayer_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function fetchlayer_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, fetchlayer_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function fetchlayer_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) fetchlayer_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) fetchlayer_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function fetchlayer_toPropertyKey(t) {\n                var i = fetchlayer_toPrimitive(t, \"string\");\n                return \"symbol\" == fetchlayer_typeof(i) ? i : i + \"\";\n            }\n            function fetchlayer_toPrimitive(t, r) {\n                if (\"object\" != fetchlayer_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != fetchlayer_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function fetchlayer_callSuper(t, o, e) {\n                return o = fetchlayer_getPrototypeOf(o), fetchlayer_possibleConstructorReturn(t, fetchlayer_isNativeReflectConstruct() ? Reflect.construct(o, e || [], fetchlayer_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function fetchlayer_possibleConstructorReturn(self, call) {\n                if (call && (fetchlayer_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return fetchlayer_assertThisInitialized(self);\n            }\n            function fetchlayer_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function fetchlayer_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (fetchlayer_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function fetchlayer_getPrototypeOf(o) {\n                fetchlayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return fetchlayer_getPrototypeOf(o);\n            }\n            function fetchlayer_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) fetchlayer_setPrototypeOf(subClass, superClass);\n            }\n            function fetchlayer_setPrototypeOf(o, p) {\n                fetchlayer_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return fetchlayer_setPrototypeOf(o, p);\n            }\n            var fetchlayer_FetchLayer = /*#__PURE__*/ function(_Layer) {\n                /**\n   * @class FetchLayer\n   * @classdesc Creates an image layer using a remote URL.\n   * @param {Object|string} options - layer parameters or a url\n   * @param {string} options.url the url of the image to fetch\n   */ function FetchLayer(options) {\n                    var _this;\n                    fetchlayer_classCallCheck(this, FetchLayer);\n                    _this = fetchlayer_callSuper(this, FetchLayer, [\n                        options\n                    ]);\n                    if (isString_root_isString_default()(options)) {\n                        _this.options.url = options;\n                    } else if (options != null ? options.url : void 0) {\n                        _this.options.url = options.url;\n                    }\n                    return _this;\n                }\n                fetchlayer_inherits(FetchLayer, _Layer);\n                return fetchlayer_createClass(FetchLayer, [\n                    {\n                        key: \"url\",\n                        value: function url(_url) {\n                            this.options.url = _url;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return \"fetch:\".concat(base64EncodeURL(this.options.url));\n                        }\n                    }\n                ]);\n            }(layer_layer);\n            /* harmony default export */ var fetchlayer = fetchlayer_FetchLayer;\n            // CONCATENATED MODULE: ./src/parameters.js\n            function parameters_callSuper(t, o, e) {\n                return o = parameters_getPrototypeOf(o), parameters_possibleConstructorReturn(t, parameters_isNativeReflectConstruct() ? Reflect.construct(o, e || [], parameters_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function parameters_possibleConstructorReturn(self, call) {\n                if (call && (parameters_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return parameters_assertThisInitialized(self);\n            }\n            function parameters_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function parameters_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (parameters_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function _get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    _get = Reflect.get.bind();\n                } else {\n                    _get = function _get(target, property, receiver) {\n                        var base = _superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return _get.apply(this, arguments);\n            }\n            function _superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = parameters_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function parameters_getPrototypeOf(o) {\n                parameters_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return parameters_getPrototypeOf(o);\n            }\n            function parameters_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) parameters_setPrototypeOf(subClass, superClass);\n            }\n            function parameters_setPrototypeOf(o, p) {\n                parameters_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return parameters_setPrototypeOf(o, p);\n            }\n            function parameters_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return parameters_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, parameters_typeof(o);\n            }\n            function parameters_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function parameters_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, parameters_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function parameters_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) parameters_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) parameters_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function parameters_toPropertyKey(t) {\n                var i = parameters_toPrimitive(t, \"string\");\n                return \"symbol\" == parameters_typeof(i) ? i : i + \"\";\n            }\n            function parameters_toPrimitive(t, r) {\n                if (\"object\" != parameters_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != parameters_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            /**\n * Transformation parameters\n * Depends on 'util', 'transformation'\n */ var parameters_Param = /*#__PURE__*/ function() {\n                /**\n   * Represents a single parameter.\n   * @class Param\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter.\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @ignore\n   */ function Param(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity_root_identity_default.a;\n                    parameters_classCallCheck(this, Param);\n                    /**\n     * The name of the parameter in snake_case\n     * @member {string} Param#name\n     */ this.name = name;\n                    /**\n     * The name of the serialized form of the parameter\n     * @member {string} Param#shortName\n     */ this.shortName = shortName;\n                    /**\n     * Manipulate origValue when value is called\n     * @member {function} Param#process\n     */ this.process = process1;\n                }\n                /**\n   * Set a (unprocessed) value for this parameter\n   * @function Param#set\n   * @param {*} origValue - the value of the parameter\n   * @return {Param} self for chaining\n   */ return parameters_createClass(Param, [\n                    {\n                        key: \"set\",\n                        value: function set(origValue) {\n                            this.origValue = origValue;\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var val, valid;\n                            val = this.value();\n                            valid = isArray_root_isArray_default()(val) || isPlainObject_root_isPlainObject_default()(val) || isString_root_isString_default()(val) ? !isEmpty(val) : val != null;\n                            if (this.shortName != null && valid) {\n                                return \"\".concat(this.shortName, \"_\").concat(val);\n                            } else {\n                                return \"\";\n                            }\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            return this.process(this.origValue);\n                        }\n                    }\n                ], [\n                    {\n                        key: \"norm_color\",\n                        value: function norm_color(value) {\n                            return value != null ? value.replace(/^#/, \"rgb:\") : void 0;\n                        }\n                    },\n                    {\n                        key: \"build_array\",\n                        value: function build_array(arg) {\n                            if (arg == null) {\n                                return [];\n                            } else if (isArray_root_isArray_default()(arg)) {\n                                return arg;\n                            } else {\n                                return [\n                                    arg\n                                ];\n                            }\n                        }\n                    },\n                    {\n                        key: \"process_video_params\",\n                        value: function process_video_params(param) {\n                            var video;\n                            switch(param.constructor){\n                                case Object:\n                                    video = \"\";\n                                    if (\"codec\" in param) {\n                                        video = param.codec;\n                                        if (\"profile\" in param) {\n                                            video += \":\" + param.profile;\n                                            if (\"level\" in param) {\n                                                video += \":\" + param.level;\n                                                if (\"b_frames\" in param && param.b_frames === false) {\n                                                    video += \":bframes_no\";\n                                                }\n                                            }\n                                        }\n                                    }\n                                    return video;\n                                case String:\n                                    return param;\n                                default:\n                                    return null;\n                            }\n                        }\n                    }\n                ]);\n            }();\n            var parameters_ArrayParam = /*#__PURE__*/ function(_Param) {\n                /**\n   * A parameter that represents an array.\n   * @param {string} name - The name of the parameter in snake_case.\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class ArrayParam\n   * @extends Param\n   * @ignore\n   */ function ArrayParam(name, shortName) {\n                    var _this;\n                    var sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n                    var process1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n                    parameters_classCallCheck(this, ArrayParam);\n                    _this = parameters_callSuper(this, ArrayParam, [\n                        name,\n                        shortName,\n                        process1\n                    ]);\n                    _this.sep = sep;\n                    return _this;\n                }\n                parameters_inherits(ArrayParam, _Param);\n                return parameters_createClass(ArrayParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            if (this.shortName != null) {\n                                var arrayValue = this.value();\n                                if (isEmpty(arrayValue)) {\n                                    return \"\";\n                                } else if (isString_root_isString_default()(arrayValue)) {\n                                    return \"\".concat(this.shortName, \"_\").concat(arrayValue);\n                                } else {\n                                    var flat = arrayValue.map(function(t) {\n                                        return isFunction_root_isFunction_default()(t.serialize) ? t.serialize() : t;\n                                    }).join(this.sep);\n                                    return \"\".concat(this.shortName, \"_\").concat(flat);\n                                }\n                            } else {\n                                return \"\";\n                            }\n                        }\n                    },\n                    {\n                        key: \"value\",\n                        value: function value() {\n                            var _this2 = this;\n                            if (isArray_root_isArray_default()(this.origValue)) {\n                                return this.origValue.map(function(v) {\n                                    return _this2.process(v);\n                                });\n                            } else {\n                                return this.process(this.origValue);\n                            }\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(origValue) {\n                            if (origValue == null || isArray_root_isArray_default()(origValue)) {\n                                return _get(parameters_getPrototypeOf(ArrayParam.prototype), \"set\", this).call(this, origValue);\n                            } else {\n                                return _get(parameters_getPrototypeOf(ArrayParam.prototype), \"set\", this).call(this, [\n                                    origValue\n                                ]);\n                            }\n                        }\n                    }\n                ]);\n            }(parameters_Param);\n            var parameters_TransformationParam = /*#__PURE__*/ function(_Param2) {\n                /**\n   * A parameter that represents a transformation\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} [shortName='t'] - The name of the serialized form of the parameter\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class TransformationParam\n   * @extends Param\n   * @ignore\n   */ function TransformationParam(name) {\n                    var _this3;\n                    var shortName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"t\";\n                    var sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n                    var process1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n                    parameters_classCallCheck(this, TransformationParam);\n                    _this3 = parameters_callSuper(this, TransformationParam, [\n                        name,\n                        shortName,\n                        process1\n                    ]);\n                    _this3.sep = sep;\n                    return _this3;\n                }\n                /**\n   * Generate string representations of the transformation.\n   * @returns {*} Returns either the transformation as a string, or an array of string representations.\n   */ parameters_inherits(TransformationParam, _Param2);\n                return parameters_createClass(TransformationParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var _this4 = this;\n                            var result = \"\";\n                            var val = this.value();\n                            if (isEmpty(val)) {\n                                return result;\n                            }\n                            // val is an array of strings so join them\n                            if (baseutil_allStrings(val)) {\n                                var joined = val.join(this.sep); // creates t1.t2.t3 in case multiple named transformations were configured\n                                if (!isEmpty(joined)) {\n                                    // in case options.transformation was not set with an empty string (val != ['']);\n                                    result = \"\".concat(this.shortName, \"_\").concat(joined);\n                                }\n                            } else {\n                                // Convert val to an array of strings\n                                result = val.map(function(t) {\n                                    if (isString_root_isString_default()(t) && !isEmpty(t)) {\n                                        return \"\".concat(_this4.shortName, \"_\").concat(t);\n                                    }\n                                    if (isFunction_root_isFunction_default()(t.serialize)) {\n                                        return t.serialize();\n                                    }\n                                    if (isPlainObject_root_isPlainObject_default()(t) && !isEmpty(t)) {\n                                        return new src_transformation(t).serialize();\n                                    }\n                                    return undefined;\n                                }).filter(function(t) {\n                                    return t;\n                                });\n                            }\n                            return result;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(origValue1) {\n                            this.origValue = origValue1;\n                            if (isArray_root_isArray_default()(this.origValue)) {\n                                return _get(parameters_getPrototypeOf(TransformationParam.prototype), \"set\", this).call(this, this.origValue);\n                            } else {\n                                return _get(parameters_getPrototypeOf(TransformationParam.prototype), \"set\", this).call(this, [\n                                    this.origValue\n                                ]);\n                            }\n                        }\n                    }\n                ]);\n            }(parameters_Param);\n            var number_pattern = \"([0-9]*)\\\\.([0-9]+)|([0-9]+)\";\n            var offset_any_pattern = \"(\" + number_pattern + \")([%pP])?\";\n            var parameters_RangeParam = /*#__PURE__*/ function(_Param3) {\n                /**\n   * A parameter that represents a range\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=norm_range_value ] - Manipulate origValue when value is called\n   * @class RangeParam\n   * @extends Param\n   * @ignore\n   */ function RangeParam(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : RangeParam.norm_range_value;\n                    parameters_classCallCheck(this, RangeParam);\n                    return parameters_callSuper(this, RangeParam, [\n                        name,\n                        shortName,\n                        process1\n                    ]);\n                }\n                parameters_inherits(RangeParam, _Param3);\n                return parameters_createClass(RangeParam, null, [\n                    {\n                        key: \"norm_range_value\",\n                        value: function norm_range_value(value) {\n                            var offset = String(value).match(new RegExp(\"^\" + offset_any_pattern + \"$\"));\n                            if (offset) {\n                                var modifier = offset[5] != null ? \"p\" : \"\";\n                                value = (offset[1] || offset[4]) + modifier;\n                            }\n                            return expression.normalize(value);\n                        }\n                    }\n                ]);\n            }(parameters_Param);\n            var parameters_RawParam = /*#__PURE__*/ function(_Param4) {\n                function RawParam(name, shortName) {\n                    var process1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity_root_identity_default.a;\n                    parameters_classCallCheck(this, RawParam);\n                    return parameters_callSuper(this, RawParam, [\n                        name,\n                        shortName,\n                        process1\n                    ]);\n                }\n                parameters_inherits(RawParam, _Param4);\n                return parameters_createClass(RawParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            return this.value();\n                        }\n                    }\n                ]);\n            }(parameters_Param);\n            var parameters_LayerParam = /*#__PURE__*/ function(_Param5) {\n                function LayerParam() {\n                    parameters_classCallCheck(this, LayerParam);\n                    return parameters_callSuper(this, LayerParam, arguments);\n                }\n                parameters_inherits(LayerParam, _Param5);\n                return parameters_createClass(LayerParam, [\n                    {\n                        key: \"value\",\n                        value: // Parse layer options\n                        // @return [string] layer transformation string\n                        // @private\n                        function value() {\n                            if (this.origValue == null) {\n                                return \"\";\n                            }\n                            var result;\n                            if (this.origValue instanceof layer_layer) {\n                                result = this.origValue;\n                            } else if (isPlainObject_root_isPlainObject_default()(this.origValue)) {\n                                var layerOptions = withCamelCaseKeys(this.origValue);\n                                if (layerOptions.resourceType === \"text\" || layerOptions.text != null) {\n                                    result = new textlayer(layerOptions);\n                                } else if (layerOptions.resourceType === \"subtitles\") {\n                                    result = new subtitleslayer(layerOptions);\n                                } else if (layerOptions.resourceType === \"fetch\" || layerOptions.url != null) {\n                                    result = new fetchlayer(layerOptions);\n                                } else {\n                                    result = new layer_layer(layerOptions);\n                                }\n                            } else if (isString_root_isString_default()(this.origValue)) {\n                                if (/^fetch:.+/.test(this.origValue)) {\n                                    result = new fetchlayer(this.origValue.substr(6));\n                                } else {\n                                    result = this.origValue;\n                                }\n                            } else {\n                                result = \"\";\n                            }\n                            return result.toString();\n                        }\n                    }\n                ], [\n                    {\n                        key: \"textStyle\",\n                        value: function textStyle(layer) {\n                            return new textlayer(layer).textStyleIdentifier();\n                        }\n                    }\n                ]);\n            }(parameters_Param);\n            var parameters_ExpressionParam = /*#__PURE__*/ function(_Param6) {\n                function ExpressionParam() {\n                    parameters_classCallCheck(this, ExpressionParam);\n                    return parameters_callSuper(this, ExpressionParam, arguments);\n                }\n                parameters_inherits(ExpressionParam, _Param6);\n                return parameters_createClass(ExpressionParam, [\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            return expression.normalize(_get(parameters_getPrototypeOf(ExpressionParam.prototype), \"serialize\", this).call(this));\n                        }\n                    }\n                ]);\n            }(parameters_Param);\n            // CONCATENATED MODULE: ./src/transformation.js\n            function transformation_callSuper(t, o, e) {\n                return o = transformation_getPrototypeOf(o), transformation_possibleConstructorReturn(t, transformation_isNativeReflectConstruct() ? Reflect.construct(o, e || [], transformation_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function transformation_possibleConstructorReturn(self, call) {\n                if (call && (transformation_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return transformation_assertThisInitialized(self);\n            }\n            function transformation_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function transformation_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (transformation_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function transformation_getPrototypeOf(o) {\n                transformation_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return transformation_getPrototypeOf(o);\n            }\n            function transformation_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) transformation_setPrototypeOf(subClass, superClass);\n            }\n            function transformation_setPrototypeOf(o, p) {\n                transformation_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return transformation_setPrototypeOf(o, p);\n            }\n            function transformation_slicedToArray(arr, i) {\n                return transformation_arrayWithHoles(arr) || transformation_iterableToArrayLimit(arr, i) || transformation_unsupportedIterableToArray(arr, i) || transformation_nonIterableRest();\n            }\n            function transformation_nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function transformation_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return transformation_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return transformation_arrayLikeToArray(o, minLen);\n            }\n            function transformation_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n                return arr2;\n            }\n            function transformation_iterableToArrayLimit(r, l) {\n                var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n                if (null != t) {\n                    var e, n, i, u, a = [], f = !0, o = !1;\n                    try {\n                        if (i = (t = t.call(r)).next, 0 === l) {\n                            if (Object(t) !== t) return;\n                            f = !1;\n                        } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n                    } catch (r) {\n                        o = !0, n = r;\n                    } finally{\n                        try {\n                            if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n                        } finally{\n                            if (o) throw n;\n                        }\n                    }\n                    return a;\n                }\n            }\n            function transformation_arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            function transformation_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return transformation_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, transformation_typeof(o);\n            }\n            function transformation_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function transformation_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, transformation_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function transformation_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) transformation_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) transformation_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function transformation_toPropertyKey(t) {\n                var i = transformation_toPrimitive(t, \"string\");\n                return \"symbol\" == transformation_typeof(i) ? i : i + \"\";\n            }\n            function transformation_toPrimitive(t, r) {\n                if (\"object\" != transformation_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != transformation_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            /**\n * Assign key, value to target, when value is not null.<br>\n *   This function mutates the target!\n * @param {object} target the object to assign the values to\n * @param {object} sources one or more objects to get values from\n * @returns {object} the target after the assignment\n */ function assignNotNull(target) {\n                for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    sources[_key - 1] = arguments[_key];\n                }\n                sources.forEach(function(source) {\n                    Object.keys(source).forEach(function(key) {\n                        if (source[key] != null) {\n                            target[key] = source[key];\n                        }\n                    });\n                });\n                return target;\n            }\n            /**\n * TransformationBase\n * Depends on 'configuration', 'parameters','util'\n * @internal\n */ var transformation_TransformationBase = /*#__PURE__*/ function() {\n                /**\n   * The base class for transformations.\n   * Members of this class are documented as belonging to the {@link Transformation} class for convenience.\n   * @class TransformationBase\n   */ function TransformationBase(options) {\n                    transformation_classCallCheck(this, TransformationBase);\n                    /** @private */ /** @private */ var parent, trans;\n                    parent = void 0;\n                    trans = {};\n                    /**\n     * Return an options object that can be used to create an identical Transformation\n     * @function Transformation#toOptions\n     * @return {Object} Returns a plain object representing this transformation\n     */ this.toOptions = function(withChain) {\n                        var opt = {};\n                        if (withChain == null) {\n                            withChain = true;\n                        }\n                        Object.keys(trans).forEach(function(key) {\n                            return opt[key] = trans[key].origValue;\n                        });\n                        assignNotNull(opt, this.otherOptions);\n                        if (withChain && !isEmpty(this.chained)) {\n                            var list = this.chained.map(function(tr) {\n                                return tr.toOptions();\n                            });\n                            list.push(opt);\n                            opt = {};\n                            assignNotNull(opt, this.otherOptions);\n                            opt.transformation = list;\n                        }\n                        return opt;\n                    };\n                    /**\n     * Set a parent for this object for chaining purposes.\n     *\n     * @function Transformation#setParent\n     * @param {Object} object - the parent to be assigned to\n     * @returns {Transformation} Returns this instance for chaining purposes.\n     */ this.setParent = function(object) {\n                        parent = object;\n                        if (object != null) {\n                            this.fromOptions(typeof object.toOptions === \"function\" ? object.toOptions() : void 0);\n                        }\n                        return this;\n                    };\n                    /**\n     * Returns the parent of this object in the chain\n     * @function Transformation#getParent\n     * @protected\n     * @return {Object} Returns the parent of this object if there is any\n     */ this.getParent = function() {\n                        return parent;\n                    };\n                    // Helper methods to create parameter methods\n                    // These methods are defined here because they access `trans` which is\n                    // a private member of `TransformationBase`\n                    /** @protected */ this.param = function(value, name, abbr, defaultValue, process1) {\n                        if (process1 == null) {\n                            if (isFunction_root_isFunction_default()(defaultValue)) {\n                                process1 = defaultValue;\n                            } else {\n                                process1 = identity_root_identity_default.a;\n                            }\n                        }\n                        trans[name] = new parameters_Param(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.rawParam = function(value, name, abbr, defaultValue, process1) {\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_RawParam(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.rangeParam = function(value, name, abbr, defaultValue, process1) {\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_RangeParam(name, abbr, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.arrayParam = function(value, name, abbr) {\n                        var sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \":\";\n                        var defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n                        var process1 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_ArrayParam(name, abbr, sep, process1).set(value);\n                        return this;\n                    };\n                    /** @protected */ this.transformationParam = function(value, name, abbr) {\n                        var sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \".\";\n                        var defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n                        var process1 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n                        process1 = lastArgCallback(arguments);\n                        trans[name] = new parameters_TransformationParam(name, abbr, sep, process1).set(value);\n                        return this;\n                    };\n                    this.layerParam = function(value, name, abbr) {\n                        trans[name] = new parameters_LayerParam(name, abbr).set(value);\n                        return this;\n                    };\n                    // End Helper methods\n                    /**\n     * Get the value associated with the given name.\n     * @function Transformation#getValue\n     * @param {string} name - the name of the parameter\n     * @return {*} the processed value associated with the given name\n     * @description Use {@link get}.origValue for the value originally provided for the parameter\n     */ this.getValue = function(name) {\n                        var value = trans[name] && trans[name].value();\n                        return value != null ? value : this.otherOptions[name];\n                    };\n                    /**\n     * Get the parameter object for the given parameter name\n     * @function Transformation#get\n     * @param {string} name the name of the transformation parameter\n     * @returns {Param} the param object for the given name, or undefined\n     */ this.get = function(name) {\n                        return trans[name];\n                    };\n                    /**\n     * Remove a transformation option from the transformation.\n     * @function Transformation#remove\n     * @param {string} name - the name of the option to remove\n     * @return {*} Returns the option that was removed or null if no option by that name was found. The type of the\n     *              returned value depends on the value.\n     */ this.remove = function(name) {\n                        var temp;\n                        switch(false){\n                            case trans[name] == null:\n                                temp = trans[name];\n                                delete trans[name];\n                                return temp.origValue;\n                            case this.otherOptions[name] == null:\n                                temp = this.otherOptions[name];\n                                delete this.otherOptions[name];\n                                return temp;\n                            default:\n                                return null;\n                        }\n                    };\n                    /**\n     * Return an array of all the keys (option names) in the transformation.\n     * @return {Array<string>} the keys in snakeCase format\n     */ this.keys = function() {\n                        var key;\n                        return (function() {\n                            var results;\n                            results = [];\n                            for(key in trans){\n                                if (key != null) {\n                                    results.push(key.match(VAR_NAME_RE) ? key : snakeCase(key));\n                                }\n                            }\n                            return results;\n                        })().sort();\n                    };\n                    /**\n     * Returns a plain object representation of the transformation. Values are processed.\n     * @function Transformation#toPlainObject\n     * @return {Object} the transformation options as plain object\n     */ this.toPlainObject = function() {\n                        var hash, key, list;\n                        hash = {};\n                        for(key in trans){\n                            hash[key] = trans[key].value();\n                            if (isPlainObject_root_isPlainObject_default()(hash[key])) {\n                                hash[key] = cloneDeep_root_cloneDeep_default()(hash[key]);\n                            }\n                        }\n                        if (!isEmpty(this.chained)) {\n                            list = this.chained.map(function(tr) {\n                                return tr.toPlainObject();\n                            });\n                            list.push(hash);\n                            hash = {\n                                transformation: list\n                            };\n                        }\n                        return hash;\n                    };\n                    /**\n     * Complete the current transformation and chain to a new one.\n     * In the URL, transformations are chained together by slashes.\n     * @function Transformation#chain\n     * @return {Transformation} Returns this transformation for chaining\n     * @example\n     * var tr = cloudinary.Transformation.new();\n     * tr.width(10).crop('fit').chain().angle(15).serialize()\n     * // produces \"c_fit,w_10/a_15\"\n     */ this.chain = function() {\n                        var names, tr;\n                        names = Object.getOwnPropertyNames(trans);\n                        if (names.length !== 0) {\n                            tr = new this.constructor(this.toOptions(false));\n                            this.resetTransformations();\n                            this.chained.push(tr);\n                        }\n                        return this;\n                    };\n                    this.resetTransformations = function() {\n                        trans = {};\n                        return this;\n                    };\n                    this.otherOptions = {};\n                    this.chained = [];\n                    this.fromOptions(options);\n                }\n                /**\n   * Merge the provided options with own's options\n   * @param {Object} [options={}] key-value list of options\n   * @returns {Transformation} Returns this instance for chaining\n   */ return transformation_createClass(TransformationBase, [\n                    {\n                        key: \"fromOptions\",\n                        value: function fromOptions() {\n                            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                            if (options instanceof TransformationBase) {\n                                this.fromTransformation(options);\n                            } else {\n                                if (isString_root_isString_default()(options) || isArray_root_isArray_default()(options)) {\n                                    options = {\n                                        transformation: options\n                                    };\n                                }\n                                options = cloneDeep_root_cloneDeep_default()(options, function(value) {\n                                    if (value instanceof TransformationBase || value instanceof Layer) {\n                                        return new value.clone();\n                                    }\n                                });\n                                // Handling of \"if\" statements precedes other options as it creates a chained transformation\n                                if (options[\"if\"]) {\n                                    this.set(\"if\", options[\"if\"]);\n                                    delete options[\"if\"];\n                                }\n                                for(var key in options){\n                                    var opt = options[key];\n                                    if (opt != null) {\n                                        if (key.match(VAR_NAME_RE)) {\n                                            if (key !== \"$attr\") {\n                                                this.set(\"variable\", key, opt);\n                                            }\n                                        } else {\n                                            this.set(key, opt);\n                                        }\n                                    }\n                                }\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"fromTransformation\",\n                        value: function fromTransformation(other) {\n                            var _this = this;\n                            if (other instanceof TransformationBase) {\n                                other.keys().forEach(function(key) {\n                                    return _this.set(key, other.get(key).origValue);\n                                });\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"set\",\n                        value: function set(key) {\n                            var camelKey;\n                            camelKey = camelCase(key);\n                            for(var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                                values[_key2 - 1] = arguments[_key2];\n                            }\n                            if (includes_root_includes_default()(transformation_Transformation.methods, camelKey)) {\n                                this[camelKey].apply(this, values);\n                            } else {\n                                this.otherOptions[key] = values[0];\n                            }\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"hasLayer\",\n                        value: function hasLayer() {\n                            return this.getValue(\"overlay\") || this.getValue(\"underlay\");\n                        }\n                    },\n                    {\n                        key: \"serialize\",\n                        value: function serialize() {\n                            var ifParam, j, len, paramList, ref, ref1, ref2, ref3, ref4, resultArray, t, transformationList, transformationString, transformations, value, variables, vars;\n                            resultArray = this.chained.map(function(tr) {\n                                return tr.serialize();\n                            });\n                            paramList = this.keys();\n                            transformations = (ref = this.get(\"transformation\")) != null ? ref.serialize() : void 0;\n                            ifParam = (ref1 = this.get(\"if\")) != null ? ref1.serialize() : void 0;\n                            variables = processVar((ref2 = this.get(\"variables\")) != null ? ref2.value() : void 0);\n                            paramList = difference_root_difference_default()(paramList, [\n                                \"transformation\",\n                                \"if\",\n                                \"variables\"\n                            ]);\n                            vars = [];\n                            transformationList = [];\n                            for(j = 0, len = paramList.length; j < len; j++){\n                                t = paramList[j];\n                                if (t.match(VAR_NAME_RE)) {\n                                    vars.push(t + \"_\" + expression.normalize((ref3 = this.get(t)) != null ? ref3.value() : void 0));\n                                } else {\n                                    transformationList.push((ref4 = this.get(t)) != null ? ref4.serialize() : void 0);\n                                }\n                            }\n                            switch(false){\n                                case !isString_root_isString_default()(transformations):\n                                    transformationList.push(transformations);\n                                    break;\n                                case !isArray_root_isArray_default()(transformations):\n                                    resultArray = resultArray.concat(transformations);\n                            }\n                            transformationList = function() {\n                                var k, len1, results;\n                                results = [];\n                                for(k = 0, len1 = transformationList.length; k < len1; k++){\n                                    value = transformationList[k];\n                                    if (isArray_root_isArray_default()(value) && !isEmpty(value) || !isArray_root_isArray_default()(value) && value) {\n                                        results.push(value);\n                                    }\n                                }\n                                return results;\n                            }();\n                            transformationList = vars.sort().concat(variables).concat(transformationList.sort());\n                            if (ifParam === \"if_end\") {\n                                transformationList.push(ifParam);\n                            } else if (!isEmpty(ifParam)) {\n                                transformationList.unshift(ifParam);\n                            }\n                            transformationString = compact_root_compact_default()(transformationList).join(this.param_separator);\n                            if (!isEmpty(transformationString)) {\n                                resultArray.push(transformationString);\n                            }\n                            return compact_root_compact_default()(resultArray).join(this.trans_separator);\n                        }\n                    },\n                    {\n                        key: \"toHtmlAttributes\",\n                        value: /**\n     * Returns the attributes for an HTML tag.\n     * @function Cloudinary.toHtmlAttributes\n     * @return PlainObject\n     */ function toHtmlAttributes() {\n                            var _this2 = this;\n                            var attrName, height, options, ref2, ref3, value, width;\n                            options = {};\n                            var snakeCaseKey;\n                            Object.keys(this.otherOptions).forEach(function(key) {\n                                value = _this2.otherOptions[key];\n                                snakeCaseKey = snakeCase(key);\n                                if (!includes_root_includes_default()(transformation_Transformation.PARAM_NAMES, snakeCaseKey) && !includes_root_includes_default()(URL_KEYS, snakeCaseKey)) {\n                                    attrName = /^html_/.test(key) ? key.slice(5) : key;\n                                    options[attrName] = value;\n                                }\n                            });\n                            // convert all \"html_key\" to \"key\" with the same value\n                            this.keys().forEach(function(key) {\n                                if (/^html_/.test(key)) {\n                                    options[camelCase(key.slice(5))] = _this2.getValue(key);\n                                }\n                            });\n                            if (!(this.hasLayer() || this.getValue(\"angle\") || includes_root_includes_default()([\n                                \"fit\",\n                                \"limit\",\n                                \"lfill\"\n                            ], this.getValue(\"crop\")))) {\n                                width = (ref2 = this.get(\"width\")) != null ? ref2.origValue : void 0;\n                                height = (ref3 = this.get(\"height\")) != null ? ref3.origValue : void 0;\n                                if (parseFloat(width) >= 1.0) {\n                                    if (options.width == null) {\n                                        options.width = width;\n                                    }\n                                }\n                                if (parseFloat(height) >= 1.0) {\n                                    if (options.height == null) {\n                                        options.height = height;\n                                    }\n                                }\n                            }\n                            return options;\n                        }\n                    },\n                    {\n                        key: \"toHtml\",\n                        value: /**\n     * Delegate to the parent (up the call chain) to produce HTML\n     * @function Transformation#toHtml\n     * @return {string} HTML representation of the parent if possible.\n     * @example\n     * tag = cloudinary.ImageTag.new(\"sample\", {cloud_name: \"demo\"})\n     * // ImageTag {name: \"img\", publicId: \"sample\"}\n     * tag.toHtml()\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/sample\">\n     * tag.transformation().crop(\"fit\").width(300).toHtml()\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/c_fit,w_300/sample\">\n     */ function toHtml() {\n                            var ref;\n                            return (ref = this.getParent()) != null ? typeof ref.toHtml === \"function\" ? ref.toHtml() : void 0 : void 0;\n                        }\n                    },\n                    {\n                        key: \"toString\",\n                        value: function toString() {\n                            return this.serialize();\n                        }\n                    },\n                    {\n                        key: \"clone\",\n                        value: function clone() {\n                            return new this.constructor(this.toOptions(true));\n                        }\n                    }\n                ], [\n                    {\n                        key: \"listNames\",\n                        value: function listNames() {\n                            return transformation_Transformation.methods;\n                        }\n                    },\n                    {\n                        key: \"isValidParamName\",\n                        value: function isValidParamName(name) {\n                            return transformation_Transformation.methods.indexOf(camelCase(name)) >= 0;\n                        }\n                    }\n                ]);\n            }();\n            var VAR_NAME_RE = /^\\$[a-zA-Z0-9]+$/;\n            transformation_TransformationBase.prototype.trans_separator = \"/\";\n            transformation_TransformationBase.prototype.param_separator = \",\";\n            function lastArgCallback(args) {\n                var callback;\n                callback = args != null ? args[args.length - 1] : void 0;\n                if (isFunction_root_isFunction_default()(callback)) {\n                    return callback;\n                } else {\n                    return void 0;\n                }\n            }\n            function processVar(varArray) {\n                var j, len, name, results, v;\n                if (isArray_root_isArray_default()(varArray)) {\n                    results = [];\n                    for(j = 0, len = varArray.length; j < len; j++){\n                        var _varArray$j = transformation_slicedToArray(varArray[j], 2);\n                        name = _varArray$j[0];\n                        v = _varArray$j[1];\n                        results.push(\"\".concat(name, \"_\").concat(expression.normalize(v)));\n                    }\n                    return results;\n                } else {\n                    return varArray;\n                }\n            }\n            function processCustomFunction(_ref) {\n                var function_type = _ref.function_type, source = _ref.source;\n                if (function_type === \"remote\") {\n                    return [\n                        function_type,\n                        btoa(source)\n                    ].join(\":\");\n                } else if (function_type === \"wasm\") {\n                    return [\n                        function_type,\n                        source\n                    ].join(\":\");\n                }\n            }\n            /**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n * @const Transformation.methods\n * @private\n * @ignore\n * @type {Array<string>}\n */ /**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n * @const {Array<string>} Transformation.PARAM_NAMES\n * @private\n * @ignore\n * @see toHtmlAttributes\n */ var transformation_Transformation = /*#__PURE__*/ function(_TransformationBase) {\n                /**\n   * Represents a single transformation.\n   * @class Transformation\n   * @example\n   * t = new cloudinary.Transformation();\n   * t.angle(20).crop(\"scale\").width(\"auto\");\n   *\n   * // or\n   *\n   * t = new cloudinary.Transformation( {angle: 20, crop: \"scale\", width: \"auto\"});\n   * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\"\n   *  target=\"_blank\">Available image transformations</a>\n   * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\"\n   *  target=\"_blank\">Available video transformations</a>\n   */ function Transformation(options) {\n                    transformation_classCallCheck(this, Transformation);\n                    return transformation_callSuper(this, Transformation, [\n                        options\n                    ]);\n                }\n                /**\n   * Convenience constructor\n   * @param {Object} options\n   * @return {Transformation}\n   * @example cl = cloudinary.Transformation.new( {angle: 20, crop: \"scale\", width: \"auto\"})\n   */ transformation_inherits(Transformation, _TransformationBase);\n                return transformation_createClass(Transformation, [\n                    {\n                        key: \"angle\",\n                        value: /*\n      Transformation Parameters\n    */ function angle(value) {\n                            return this.arrayParam(value, \"angle\", \"a\", \".\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"audioCodec\",\n                        value: function audioCodec(value) {\n                            return this.param(value, \"audio_codec\", \"ac\");\n                        }\n                    },\n                    {\n                        key: \"audioFrequency\",\n                        value: function audioFrequency(value) {\n                            return this.param(value, \"audio_frequency\", \"af\");\n                        }\n                    },\n                    {\n                        key: \"aspectRatio\",\n                        value: function aspectRatio(value) {\n                            return this.param(value, \"aspect_ratio\", \"ar\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"background\",\n                        value: function background(value) {\n                            return this.param(value, \"background\", \"b\", parameters_Param.norm_color);\n                        }\n                    },\n                    {\n                        key: \"bitRate\",\n                        value: function bitRate(value) {\n                            return this.param(value, \"bit_rate\", \"br\");\n                        }\n                    },\n                    {\n                        key: \"border\",\n                        value: function border(value) {\n                            return this.param(value, \"border\", \"bo\", function(border) {\n                                if (isPlainObject_root_isPlainObject_default()(border)) {\n                                    border = assign_root_assign_default()({}, {\n                                        color: \"black\",\n                                        width: 2\n                                    }, border);\n                                    return \"\".concat(border.width, \"px_solid_\").concat(parameters_Param.norm_color(border.color));\n                                } else {\n                                    return border;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"color\",\n                        value: function color(value) {\n                            return this.param(value, \"color\", \"co\", parameters_Param.norm_color);\n                        }\n                    },\n                    {\n                        key: \"colorSpace\",\n                        value: function colorSpace(value) {\n                            return this.param(value, \"color_space\", \"cs\");\n                        }\n                    },\n                    {\n                        key: \"crop\",\n                        value: function crop(value) {\n                            return this.param(value, \"crop\", \"c\");\n                        }\n                    },\n                    {\n                        key: \"customFunction\",\n                        value: function customFunction(value) {\n                            return this.param(value, \"custom_function\", \"fn\", function() {\n                                return processCustomFunction(value);\n                            });\n                        }\n                    },\n                    {\n                        key: \"customPreFunction\",\n                        value: function customPreFunction(value) {\n                            if (this.get(\"custom_function\")) {\n                                return;\n                            }\n                            return this.rawParam(value, \"custom_function\", \"\", function() {\n                                value = processCustomFunction(value);\n                                return value ? \"fn_pre:\".concat(value) : value;\n                            });\n                        }\n                    },\n                    {\n                        key: \"defaultImage\",\n                        value: function defaultImage(value) {\n                            return this.param(value, \"default_image\", \"d\");\n                        }\n                    },\n                    {\n                        key: \"delay\",\n                        value: function delay(value) {\n                            return this.param(value, \"delay\", \"dl\");\n                        }\n                    },\n                    {\n                        key: \"density\",\n                        value: function density(value) {\n                            return this.param(value, \"density\", \"dn\");\n                        }\n                    },\n                    {\n                        key: \"duration\",\n                        value: function duration(value) {\n                            return this.rangeParam(value, \"duration\", \"du\");\n                        }\n                    },\n                    {\n                        key: \"dpr\",\n                        value: function dpr(value) {\n                            return this.param(value, \"dpr\", \"dpr\", function(dpr) {\n                                dpr = dpr.toString();\n                                if (dpr != null ? dpr.match(/^\\d+$/) : void 0) {\n                                    return dpr + \".0\";\n                                } else {\n                                    return expression.normalize(dpr);\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"effect\",\n                        value: function effect(value) {\n                            return this.arrayParam(value, \"effect\", \"e\", \":\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"else\",\n                        value: function _else() {\n                            return this[\"if\"](\"else\");\n                        }\n                    },\n                    {\n                        key: \"endIf\",\n                        value: function endIf() {\n                            return this[\"if\"](\"end\");\n                        }\n                    },\n                    {\n                        key: \"endOffset\",\n                        value: function endOffset(value) {\n                            return this.rangeParam(value, \"end_offset\", \"eo\");\n                        }\n                    },\n                    {\n                        key: \"fallbackContent\",\n                        value: function fallbackContent(value) {\n                            return this.param(value, \"fallback_content\");\n                        }\n                    },\n                    {\n                        key: \"fetchFormat\",\n                        value: function fetchFormat(value) {\n                            return this.param(value, \"fetch_format\", \"f\");\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format(value) {\n                            return this.param(value, \"format\");\n                        }\n                    },\n                    {\n                        key: \"flags\",\n                        value: function flags(value) {\n                            return this.arrayParam(value, \"flags\", \"fl\", \".\");\n                        }\n                    },\n                    {\n                        key: \"gravity\",\n                        value: function gravity(value) {\n                            return this.param(value, \"gravity\", \"g\");\n                        }\n                    },\n                    {\n                        key: \"fps\",\n                        value: function fps(value) {\n                            return this.param(value, \"fps\", \"fps\", function(fps) {\n                                if (isString_root_isString_default()(fps)) {\n                                    return fps;\n                                } else if (isArray_root_isArray_default()(fps)) {\n                                    return fps.join(\"-\");\n                                } else {\n                                    return fps;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"height\",\n                        value: function height(value) {\n                            var _this3 = this;\n                            return this.param(value, \"height\", \"h\", function() {\n                                if (_this3.getValue(\"crop\") || _this3.getValue(\"overlay\") || _this3.getValue(\"underlay\")) {\n                                    return expression.normalize(value);\n                                } else {\n                                    return null;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"htmlHeight\",\n                        value: function htmlHeight(value) {\n                            return this.param(value, \"html_height\");\n                        }\n                    },\n                    {\n                        key: \"htmlWidth\",\n                        value: function htmlWidth(value) {\n                            return this.param(value, \"html_width\");\n                        }\n                    },\n                    {\n                        key: \"if\",\n                        value: function _if() {\n                            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n                            var i, ifVal, j, ref, trIf, trRest;\n                            switch(value){\n                                case \"else\":\n                                    this.chain();\n                                    return this.param(value, \"if\", \"if\");\n                                case \"end\":\n                                    this.chain();\n                                    for(i = j = ref = this.chained.length - 1; j >= 0; i = j += -1){\n                                        ifVal = this.chained[i].getValue(\"if\");\n                                        if (ifVal === \"end\") {\n                                            break;\n                                        } else if (ifVal != null) {\n                                            trIf = Transformation[\"new\"]()[\"if\"](ifVal);\n                                            this.chained[i].remove(\"if\");\n                                            trRest = this.chained[i];\n                                            this.chained[i] = Transformation[\"new\"]().transformation([\n                                                trIf,\n                                                trRest\n                                            ]);\n                                            if (ifVal !== \"else\") {\n                                                break;\n                                            }\n                                        }\n                                    }\n                                    return this.param(value, \"if\", \"if\");\n                                case \"\":\n                                    return condition[\"new\"]().setParent(this);\n                                default:\n                                    return this.param(value, \"if\", \"if\", function(value) {\n                                        return condition[\"new\"](value).toString();\n                                    });\n                            }\n                        }\n                    },\n                    {\n                        key: \"keyframeInterval\",\n                        value: function keyframeInterval(value) {\n                            return this.param(value, \"keyframe_interval\", \"ki\");\n                        }\n                    },\n                    {\n                        key: \"ocr\",\n                        value: function ocr(value) {\n                            return this.param(value, \"ocr\", \"ocr\");\n                        }\n                    },\n                    {\n                        key: \"offset\",\n                        value: function offset(value) {\n                            var end_o, start_o;\n                            var _ref2 = isFunction_root_isFunction_default()(value != null ? value.split : void 0) ? value.split(\"..\") : isArray_root_isArray_default()(value) ? value : [\n                                null,\n                                null\n                            ];\n                            var _ref3 = transformation_slicedToArray(_ref2, 2);\n                            start_o = _ref3[0];\n                            end_o = _ref3[1];\n                            if (start_o != null) {\n                                this.startOffset(start_o);\n                            }\n                            if (end_o != null) {\n                                return this.endOffset(end_o);\n                            }\n                        }\n                    },\n                    {\n                        key: \"opacity\",\n                        value: function opacity(value) {\n                            return this.param(value, \"opacity\", \"o\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"overlay\",\n                        value: function overlay(value) {\n                            return this.layerParam(value, \"overlay\", \"l\");\n                        }\n                    },\n                    {\n                        key: \"page\",\n                        value: function page(value) {\n                            return this.param(value, \"page\", \"pg\");\n                        }\n                    },\n                    {\n                        key: \"poster\",\n                        value: function poster(value) {\n                            return this.param(value, \"poster\");\n                        }\n                    },\n                    {\n                        key: \"prefix\",\n                        value: function prefix(value) {\n                            return this.param(value, \"prefix\", \"p\");\n                        }\n                    },\n                    {\n                        key: \"quality\",\n                        value: function quality(value) {\n                            return this.param(value, \"quality\", \"q\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"radius\",\n                        value: function radius(value) {\n                            return this.arrayParam(value, \"radius\", \"r\", \":\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"rawTransformation\",\n                        value: function rawTransformation(value) {\n                            return this.rawParam(value, \"raw_transformation\");\n                        }\n                    },\n                    {\n                        key: \"size\",\n                        value: function size(value) {\n                            var height, width;\n                            if (isFunction_root_isFunction_default()(value != null ? value.split : void 0)) {\n                                var _value$split = value.split(\"x\");\n                                var _value$split2 = transformation_slicedToArray(_value$split, 2);\n                                width = _value$split2[0];\n                                height = _value$split2[1];\n                                this.width(width);\n                                return this.height(height);\n                            }\n                        }\n                    },\n                    {\n                        key: \"sourceTypes\",\n                        value: function sourceTypes(value) {\n                            return this.param(value, \"source_types\");\n                        }\n                    },\n                    {\n                        key: \"sourceTransformation\",\n                        value: function sourceTransformation(value) {\n                            return this.param(value, \"source_transformation\");\n                        }\n                    },\n                    {\n                        key: \"startOffset\",\n                        value: function startOffset(value) {\n                            return this.rangeParam(value, \"start_offset\", \"so\");\n                        }\n                    },\n                    {\n                        key: \"streamingProfile\",\n                        value: function streamingProfile(value) {\n                            return this.param(value, \"streaming_profile\", \"sp\");\n                        }\n                    },\n                    {\n                        key: \"transformation\",\n                        value: function transformation(value) {\n                            return this.transformationParam(value, \"transformation\", \"t\");\n                        }\n                    },\n                    {\n                        key: \"underlay\",\n                        value: function underlay(value) {\n                            return this.layerParam(value, \"underlay\", \"u\");\n                        }\n                    },\n                    {\n                        key: \"variable\",\n                        value: function variable(name, value) {\n                            return this.param(value, name, name);\n                        }\n                    },\n                    {\n                        key: \"variables\",\n                        value: function variables(values) {\n                            return this.arrayParam(values, \"variables\");\n                        }\n                    },\n                    {\n                        key: \"videoCodec\",\n                        value: function videoCodec(value) {\n                            return this.param(value, \"video_codec\", \"vc\", parameters_Param.process_video_params);\n                        }\n                    },\n                    {\n                        key: \"videoSampling\",\n                        value: function videoSampling(value) {\n                            return this.param(value, \"video_sampling\", \"vs\");\n                        }\n                    },\n                    {\n                        key: \"width\",\n                        value: function width(value) {\n                            var _this4 = this;\n                            return this.param(value, \"width\", \"w\", function() {\n                                if (_this4.getValue(\"crop\") || _this4.getValue(\"overlay\") || _this4.getValue(\"underlay\")) {\n                                    return expression.normalize(value);\n                                } else {\n                                    return null;\n                                }\n                            });\n                        }\n                    },\n                    {\n                        key: \"x\",\n                        value: function x(value) {\n                            return this.param(value, \"x\", \"x\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"y\",\n                        value: function y(value) {\n                            return this.param(value, \"y\", \"y\", expression.normalize);\n                        }\n                    },\n                    {\n                        key: \"zoom\",\n                        value: function zoom(value) {\n                            return this.param(value, \"zoom\", \"z\", expression.normalize);\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(options) {\n                            return new Transformation(options);\n                        }\n                    }\n                ]);\n            }(transformation_TransformationBase);\n            /**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n */ transformation_Transformation.methods = [\n                \"angle\",\n                \"audioCodec\",\n                \"audioFrequency\",\n                \"aspectRatio\",\n                \"background\",\n                \"bitRate\",\n                \"border\",\n                \"color\",\n                \"colorSpace\",\n                \"crop\",\n                \"customFunction\",\n                \"customPreFunction\",\n                \"defaultImage\",\n                \"delay\",\n                \"density\",\n                \"duration\",\n                \"dpr\",\n                \"effect\",\n                \"else\",\n                \"endIf\",\n                \"endOffset\",\n                \"fallbackContent\",\n                \"fetchFormat\",\n                \"format\",\n                \"flags\",\n                \"gravity\",\n                \"fps\",\n                \"height\",\n                \"htmlHeight\",\n                \"htmlWidth\",\n                \"if\",\n                \"keyframeInterval\",\n                \"ocr\",\n                \"offset\",\n                \"opacity\",\n                \"overlay\",\n                \"page\",\n                \"poster\",\n                \"prefix\",\n                \"quality\",\n                \"radius\",\n                \"rawTransformation\",\n                \"size\",\n                \"sourceTypes\",\n                \"sourceTransformation\",\n                \"startOffset\",\n                \"streamingProfile\",\n                \"transformation\",\n                \"underlay\",\n                \"variable\",\n                \"variables\",\n                \"videoCodec\",\n                \"videoSampling\",\n                \"width\",\n                \"x\",\n                \"y\",\n                \"zoom\"\n            ];\n            /**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n */ transformation_Transformation.PARAM_NAMES = transformation_Transformation.methods.map(snakeCase).concat(src_configuration.CONFIG_PARAMS);\n            /* harmony default export */ var src_transformation = transformation_Transformation;\n            // CONCATENATED MODULE: ./src/tags/htmltag.js\n            function htmltag_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return htmltag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, htmltag_typeof(o);\n            }\n            function htmltag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function htmltag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, htmltag_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function htmltag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) htmltag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) htmltag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function htmltag_toPropertyKey(t) {\n                var i = htmltag_toPrimitive(t, \"string\");\n                return \"symbol\" == htmltag_typeof(i) ? i : i + \"\";\n            }\n            function htmltag_toPrimitive(t, r) {\n                if (\"object\" != htmltag_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != htmltag_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            /**\n * Generic HTML tag\n * Depends on 'transformation', 'util'\n */ /**\n * Represents an HTML (DOM) tag\n * @constructor HtmlTag\n * @param {string} name - the name of the tag\n * @param {string} [publicId]\n * @param {Object} options\n * @example tag = new HtmlTag( 'div', { 'width': 10})\n */ var htmltag_HtmlTag = /*#__PURE__*/ function() {\n                function HtmlTag(name, publicId, options) {\n                    htmltag_classCallCheck(this, HtmlTag);\n                    var transformation;\n                    this.name = name;\n                    this.publicId = publicId;\n                    if (options == null) {\n                        if (isPlainObject_root_isPlainObject_default()(publicId)) {\n                            options = publicId;\n                            this.publicId = void 0;\n                        } else {\n                            options = {};\n                        }\n                    }\n                    transformation = new src_transformation(options);\n                    transformation.setParent(this);\n                    this.transformation = function() {\n                        return transformation;\n                    };\n                }\n                /**\n   * Convenience constructor\n   * Creates a new instance of an HTML (DOM) tag\n   * @function HtmlTag.new\n   * @param {string} name - the name of the tag\n   * @param {string} [publicId]\n   * @param {Object} options\n   * @return {HtmlTag}\n   * @example tag = HtmlTag.new( 'div', { 'width': 10})\n   */ return htmltag_createClass(HtmlTag, [\n                    {\n                        key: \"htmlAttrs\",\n                        value: /**\n     * combine key and value from the `attr` to generate an HTML tag attributes string.\n     * `Transformation::toHtmlTagOptions` is used to filter out transformation and configuration keys.\n     * @protected\n     * @param {Object} attrs\n     * @return {string} the attributes in the format `'key1=\"value1\" key2=\"value2\"'`\n     * @ignore\n     */ function htmlAttrs(attrs) {\n                            var key, pairs, value;\n                            return pairs = (function() {\n                                var results;\n                                results = [];\n                                for(key in attrs){\n                                    value = escapeQuotes(attrs[key]);\n                                    if (value) {\n                                        results.push(htmltag_toAttribute(key, value));\n                                    }\n                                }\n                                return results;\n                            })().sort().join(\" \");\n                        }\n                    },\n                    {\n                        key: \"getOptions\",\n                        value: function getOptions() {\n                            return this.transformation().toOptions();\n                        }\n                    },\n                    {\n                        key: \"getOption\",\n                        value: function getOption(name) {\n                            return this.transformation().getValue(name);\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            // The attributes are be computed from the options every time this method is invoked.\n                            var htmlAttributes = this.transformation().toHtmlAttributes();\n                            Object.keys(htmlAttributes).forEach(function(key) {\n                                if (isPlainObject_root_isPlainObject_default()(htmlAttributes[key])) {\n                                    delete htmlAttributes[key];\n                                }\n                            });\n                            if (htmlAttributes.attributes) {\n                                // Currently HTML attributes are defined both at the top level and under 'attributes'\n                                merge_root_merge_default()(htmlAttributes, htmlAttributes.attributes);\n                                delete htmlAttributes.attributes;\n                            }\n                            return htmlAttributes;\n                        }\n                    },\n                    {\n                        key: \"setAttr\",\n                        value: function setAttr(name, value) {\n                            this.transformation().set(\"html_\".concat(name), value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"getAttr\",\n                        value: function getAttr(name) {\n                            return this.attributes()[\"html_\".concat(name)] || this.attributes()[name];\n                        }\n                    },\n                    {\n                        key: \"removeAttr\",\n                        value: function removeAttr(name) {\n                            var ref;\n                            return (ref = this.transformation().remove(\"html_\".concat(name))) != null ? ref : this.transformation().remove(name);\n                        }\n                    },\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"openTag\",\n                        value: function openTag() {\n                            var tag = \"<\" + this.name;\n                            var htmlAttrs = this.htmlAttrs(this.attributes());\n                            if (htmlAttrs && htmlAttrs.length > 0) {\n                                tag += \" \" + htmlAttrs;\n                            }\n                            return tag + \">\";\n                        }\n                    },\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"</\".concat(this.name, \">\");\n                        }\n                    },\n                    {\n                        key: \"toHtml\",\n                        value: function toHtml() {\n                            return this.openTag() + this.content() + this.closeTag();\n                        }\n                    },\n                    {\n                        key: \"toDOM\",\n                        value: function toDOM() {\n                            var element, name, ref, value;\n                            if (!isFunction_root_isFunction_default()(typeof document !== \"undefined\" && document !== null ? document.createElement : void 0)) {\n                                throw \"Can't create DOM if document is not present!\";\n                            }\n                            element = document.createElement(this.name);\n                            ref = this.attributes();\n                            for(name in ref){\n                                value = ref[name];\n                                element.setAttribute(name, value);\n                            }\n                            return element;\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(name, publicId, options) {\n                            return new this(name, publicId, options);\n                        }\n                    },\n                    {\n                        key: \"isResponsive\",\n                        value: function isResponsive(tag, responsiveClass) {\n                            var dataSrc;\n                            dataSrc = lodash_getData(tag, \"src-cache\") || lodash_getData(tag, \"src\");\n                            return lodash_hasClass(tag, responsiveClass) && /\\bw_auto\\b/.exec(dataSrc);\n                        }\n                    }\n                ]);\n            }();\n            ;\n            /**\n * Represent the given key and value as an HTML attribute.\n * @function toAttribute\n * @protected\n * @param {string} key - attribute name\n * @param {*|boolean} value - the value of the attribute. If the value is boolean `true`, return the key only.\n * @returns {string} the attribute\n *\n */ function htmltag_toAttribute(key, value) {\n                if (!value) {\n                    return void 0;\n                } else if (value === true) {\n                    return key;\n                } else {\n                    return \"\".concat(key, '=\"').concat(value, '\"');\n                }\n            }\n            /**\n * If given value is a string, replaces quotes with character entities (&#34;, &#39;)\n * @param value - value to change\n * @returns {*} changed value\n */ function escapeQuotes(value) {\n                return isString_root_isString_default()(value) ? value.replace('\"', \"&#34;\").replace(\"'\", \"&#39;\") : value;\n            }\n            /* harmony default export */ var htmltag = htmltag_HtmlTag;\n            // CONCATENATED MODULE: ./src/url.js\n            var _excluded = [\n                \"placeholder\",\n                \"accessibility\"\n            ];\n            function _objectWithoutProperties(source, excluded) {\n                if (source == null) return {};\n                var target = _objectWithoutPropertiesLoose(source, excluded);\n                var key, i;\n                if (Object.getOwnPropertySymbols) {\n                    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n                    for(i = 0; i < sourceSymbolKeys.length; i++){\n                        key = sourceSymbolKeys[i];\n                        if (excluded.indexOf(key) >= 0) continue;\n                        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n                        target[key] = source[key];\n                    }\n                }\n                return target;\n            }\n            function _objectWithoutPropertiesLoose(source, excluded) {\n                if (source == null) return {};\n                var target = {};\n                var sourceKeys = Object.keys(source);\n                var key, i;\n                for(i = 0; i < sourceKeys.length; i++){\n                    key = sourceKeys[i];\n                    if (excluded.indexOf(key) >= 0) continue;\n                    target[key] = source[key];\n                }\n                return target;\n            }\n            /**\n * Adds protocol, host, pathname prefixes to given string\n * @param str\n * @returns {string}\n */ function makeUrl(str) {\n                var prefix = document.location.protocol + \"//\" + document.location.host;\n                if (str[0] === \"?\") {\n                    prefix += document.location.pathname;\n                } else if (str[0] !== \"/\") {\n                    prefix += document.location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n                }\n                return prefix + str;\n            }\n            /**\n * Check is given string is a url\n * @param str\n * @returns {boolean}\n */ function isUrl(str) {\n                return str ? !!str.match(/^https?:\\//) : false;\n            }\n            // Produce a number between 1 and 5 to be used for cdn sub domains designation\n            function cdnSubdomainNumber(publicId) {\n                return src_crc32(publicId) % 5 + 1;\n            }\n            /**\n * Removes signature from options and returns the signature\n * Makes sure signature is empty or of this format: s--signature--\n * @param {object} options\n * @returns {string} the formatted signature\n */ function handleSignature(options) {\n                var signature = options.signature;\n                var isFormatted = !signature || signature.indexOf(\"s--\") === 0 && signature.substr(-2) === \"--\";\n                delete options.signature;\n                return isFormatted ? signature : \"s--\".concat(signature, \"--\");\n            }\n            /**\n * Create the URL prefix for Cloudinary resources.\n * @param {string} publicId the resource public ID\n * @param {object} options additional options\n * @param {string} options.cloud_name - the cloud name.\n * @param {boolean} [options.cdn_subdomain=false] - Whether to automatically build URLs with\n *  multiple CDN sub-domains.\n * @param {string} [options.private_cdn] - Boolean (default: false). Should be set to true for Advanced plan's users\n *  that have a private CDN distribution.\n * @param {string} [options.protocol=\"http://\"] - the URI protocol to use. If options.secure is true,\n *  the value is overridden to \"https://\"\n * @param {string} [options.secure_distribution] - The domain name of the CDN distribution to use for building HTTPS URLs.\n *  Relevant only for Advanced plan's users that have a private CDN distribution.\n * @param {string} [options.cname] - Custom domain name to use for building HTTP URLs.\n *  Relevant only for Advanced plan's users that have a private CDN distribution and a custom CNAME.\n * @param {boolean} [options.secure_cdn_subdomain=true] - When options.secure is true and this parameter is false,\n *  the subdomain is set to \"res\".\n * @param {boolean} [options.secure=false] - Force HTTPS URLs of images even if embedded in non-secure HTTP pages.\n *  When this value is true, options.secure_distribution will be used as host if provided, and options.protocol is set\n *  to \"https://\".\n * @returns {string} the URL prefix for the resource.\n * @private\n */ function handlePrefix(publicId, options) {\n                if (options.cloud_name && options.cloud_name[0] === \"/\") {\n                    return \"/res\" + options.cloud_name;\n                }\n                // defaults\n                var protocol = \"http://\";\n                var cdnPart = \"\";\n                var subdomain = \"res\";\n                var host = \".cloudinary.com\";\n                var path = \"/\" + options.cloud_name;\n                // modifications\n                if (options.protocol) {\n                    protocol = options.protocol + \"//\";\n                }\n                if (options.private_cdn) {\n                    cdnPart = options.cloud_name + \"-\";\n                    path = \"\";\n                }\n                if (options.cdn_subdomain) {\n                    subdomain = \"res-\" + cdnSubdomainNumber(publicId);\n                }\n                if (options.secure) {\n                    protocol = \"https://\";\n                    if (options.secure_cdn_subdomain === false) {\n                        subdomain = \"res\";\n                    }\n                    if (options.secure_distribution != null && options.secure_distribution !== OLD_AKAMAI_SHARED_CDN && options.secure_distribution !== SHARED_CDN) {\n                        cdnPart = \"\";\n                        subdomain = \"\";\n                        host = options.secure_distribution;\n                    }\n                } else if (options.cname) {\n                    protocol = \"http://\";\n                    cdnPart = \"\";\n                    subdomain = options.cdn_subdomain ? \"a\" + (src_crc32(publicId) % 5 + 1) + \".\" : \"\";\n                    host = options.cname;\n                }\n                return [\n                    protocol,\n                    cdnPart,\n                    subdomain,\n                    host,\n                    path\n                ].join(\"\");\n            }\n            /**\n * Return the resource type and action type based on the given configuration\n * @function Cloudinary#handleResourceType\n * @param {Object|string} resource_type\n * @param {string} [type='upload']\n * @param {string} [url_suffix]\n * @param {boolean} [use_root_path]\n * @param {boolean} [shorten]\n * @returns {string} resource_type/type\n * @ignore\n */ function handleResourceType(_ref) {\n                var _ref$resource_type = _ref.resource_type, resource_type = _ref$resource_type === void 0 ? \"image\" : _ref$resource_type, _ref$type = _ref.type, type = _ref$type === void 0 ? \"upload\" : _ref$type, url_suffix = _ref.url_suffix, use_root_path = _ref.use_root_path, shorten = _ref.shorten;\n                var options, resourceType = resource_type;\n                if (isPlainObject_root_isPlainObject_default()(resourceType)) {\n                    options = resourceType;\n                    resourceType = options.resource_type;\n                    type = options.type;\n                    shorten = options.shorten;\n                }\n                if (type == null) {\n                    type = \"upload\";\n                }\n                if (url_suffix != null) {\n                    resourceType = SEO_TYPES[\"\".concat(resourceType, \"/\").concat(type)];\n                    type = null;\n                    if (resourceType == null) {\n                        throw new Error(\"URL Suffix only supported for \".concat(Object.keys(SEO_TYPES).join(\", \")));\n                    }\n                }\n                if (use_root_path) {\n                    if (resourceType === \"image\" && type === \"upload\" || resourceType === \"images\") {\n                        resourceType = null;\n                        type = null;\n                    } else {\n                        throw new Error(\"Root path only supported for image/upload\");\n                    }\n                }\n                if (shorten && resourceType === \"image\" && type === \"upload\") {\n                    resourceType = \"iu\";\n                    type = null;\n                }\n                return [\n                    resourceType,\n                    type\n                ].join(\"/\");\n            }\n            /**\n * Encode publicId\n * @param publicId\n * @returns {string} encoded publicId\n */ function encodePublicId(publicId) {\n                return encodeURIComponent(publicId).replace(/%3A/g, \":\").replace(/%2F/g, \"/\");\n            }\n            /**\n * Encode and format publicId\n * @param publicId\n * @param options\n * @returns {string} publicId\n */ function formatPublicId(publicId, options) {\n                if (isUrl(publicId)) {\n                    publicId = encodePublicId(publicId);\n                } else {\n                    try {\n                        // Make sure publicId is URI encoded.\n                        publicId = decodeURIComponent(publicId);\n                    } catch (error) {}\n                    publicId = encodePublicId(publicId);\n                    if (options.url_suffix) {\n                        publicId = publicId + \"/\" + options.url_suffix;\n                    }\n                    if (options.format) {\n                        if (!options.trust_public_id) {\n                            publicId = publicId.replace(/\\.(jpg|png|gif|webp)$/, \"\");\n                        }\n                        publicId = publicId + \".\" + options.format;\n                    }\n                }\n                return publicId;\n            }\n            /**\n * Get any error with url options\n * @param options\n * @returns {string} if error, otherwise return undefined\n */ function validate(options) {\n                var cloud_name = options.cloud_name, url_suffix = options.url_suffix;\n                if (!cloud_name) {\n                    return \"Unknown cloud_name\";\n                }\n                if (url_suffix && url_suffix.match(/[\\.\\/]/)) {\n                    return \"url_suffix should not include . or /\";\n                }\n            }\n            /**\n * Get version part of the url\n * @param publicId\n * @param options\n * @returns {string}\n */ function handleVersion(publicId, options) {\n                // force_version param means to make sure there is a version in the url (Default is true)\n                var isForceVersion = options.force_version || typeof options.force_version === \"undefined\";\n                // Is version included in publicId or in options, or publicId is a url (doesn't need version)\n                var isVersionExist = publicId.indexOf(\"/\") < 0 || publicId.match(/^v[0-9]+/) || isUrl(publicId) || options.version;\n                if (isForceVersion && !isVersionExist) {\n                    options.version = 1;\n                }\n                return options.version ? \"v\".concat(options.version) : \"\";\n            }\n            /**\n * Get final transformation component for url string\n * @param options\n * @returns {string}\n */ function handleTransformation(options) {\n                var _ref2 = options || {}, placeholder = _ref2.placeholder, accessibility = _ref2.accessibility, otherOptions = _objectWithoutProperties(_ref2, _excluded);\n                var result = new src_transformation(otherOptions);\n                // Append accessibility transformations\n                if (accessibility && ACCESSIBILITY_MODES[accessibility]) {\n                    result.chain().effect(ACCESSIBILITY_MODES[accessibility]);\n                }\n                // Append placeholder transformations\n                if (placeholder) {\n                    if (placeholder === \"predominant-color\" && result.getValue(\"width\") && result.getValue(\"height\")) {\n                        placeholder += \"-pixel\";\n                    }\n                    var placeholderTransformations = PLACEHOLDER_IMAGE_MODES[placeholder] || PLACEHOLDER_IMAGE_MODES.blur;\n                    placeholderTransformations.forEach(function(t) {\n                        return result.chain().transformation(t);\n                    });\n                }\n                return result.serialize();\n            }\n            /**\n * If type is 'fetch', update publicId to be a url\n * @param publicId\n * @param type\n * @returns {string}\n */ function preparePublicId(publicId, _ref3) {\n                var type = _ref3.type;\n                return !isUrl(publicId) && type === \"fetch\" ? makeUrl(publicId) : publicId;\n            }\n            /**\n * Generate url string\n * @param publicId\n * @param options\n * @returns {string} final url\n */ function urlString(publicId, options) {\n                if (isUrl(publicId) && (options.type === \"upload\" || options.type === \"asset\")) {\n                    return publicId;\n                }\n                var version = handleVersion(publicId, options);\n                var transformationString = handleTransformation(options);\n                var prefix = handlePrefix(publicId, options);\n                var signature = handleSignature(options);\n                var resourceType = handleResourceType(options);\n                publicId = formatPublicId(publicId, options);\n                return compact_root_compact_default()([\n                    prefix,\n                    resourceType,\n                    signature,\n                    transformationString,\n                    version,\n                    publicId\n                ]).join(\"/\").replace(/([^:])\\/+/g, \"$1/\") // replace '///' with '//'\n                .replace(\" \", \"%20\");\n            }\n            /**\n * Merge options and config with defaults\n * update options fetch_format according to 'type' param\n * @param options\n * @param config\n * @returns {*} updated options\n */ function prepareOptions(options, config) {\n                if (options instanceof src_transformation) {\n                    options = options.toOptions();\n                }\n                options = defaults({}, options, config, DEFAULT_IMAGE_PARAMS);\n                if (options.type === \"fetch\") {\n                    options.fetch_format = options.fetch_format || options.format;\n                }\n                return options;\n            }\n            /**\n * Generates a URL for any asset in your Media library.\n * @function url\n * @ignore\n * @param {string} publicId - The public ID of the media asset.\n * @param {Object} [options={}] - The {@link Transformation} parameters to include in the URL.\n * @param {object} [config={}] - URL configuration parameters\n * @param {type} [options.type='upload'] - The asset's storage type.\n *  For details on all fetch types, see\n * <a href=\"https://cloudinary.com/documentation/image_transformations#fetching_images_from_remote_locations\"\n *  target=\"_blank\">Fetch types</a>.\n * @param {Object} [options.resource_type='image'] - The type of asset. <p>Possible values:<br/>\n *  - `image`<br/>\n *  - `video`<br/>\n *  - `raw`\n * @param {signature} [options.signature='s--12345678--'] - The signature component of a\n *  signed delivery URL of the format: /s--SIGNATURE--/.\n *  For details on signatures, see\n * <a href=\"https://cloudinary.com/documentation/signatures\" target=\"_blank\">Signatures</a>.\n * @return {string} The media asset URL.\n * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\" target=\"_blank\">\n *  Available image transformations</a>\n * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\" target=\"_blank\">\n *  Available video transformations</a>\n */ function url_url(publicId) {\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                if (!publicId) {\n                    return publicId;\n                }\n                options = prepareOptions(options, config);\n                publicId = preparePublicId(publicId, options);\n                var error = validate(options);\n                if (error) {\n                    throw error;\n                }\n                var resultUrl = urlString(publicId, options);\n                if (options.urlAnalytics) {\n                    var analyticsOptions = getAnalyticsOptions(options);\n                    var sdkAnalyticsSignature = getSDKAnalyticsSignature(analyticsOptions);\n                    // url might already have a '?' query param\n                    var appender = \"?\";\n                    if (resultUrl.indexOf(\"?\") >= 0) {\n                        appender = \"&\";\n                    }\n                    resultUrl = \"\".concat(resultUrl).concat(appender, \"_a=\").concat(sdkAnalyticsSignature);\n                }\n                if (options.auth_token) {\n                    var _appender = resultUrl.indexOf(\"?\") >= 0 ? \"&\" : \"?\";\n                    resultUrl = \"\".concat(resultUrl).concat(_appender, \"__cld_token__=\").concat(options.auth_token);\n                }\n                return resultUrl;\n            }\n            ;\n            // CONCATENATED MODULE: ./src/util/generateBreakpoints.js\n            function generateBreakpoints_slicedToArray(arr, i) {\n                return generateBreakpoints_arrayWithHoles(arr) || generateBreakpoints_iterableToArrayLimit(arr, i) || generateBreakpoints_unsupportedIterableToArray(arr, i) || generateBreakpoints_nonIterableRest();\n            }\n            function generateBreakpoints_nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function generateBreakpoints_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return generateBreakpoints_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return generateBreakpoints_arrayLikeToArray(o, minLen);\n            }\n            function generateBreakpoints_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n                return arr2;\n            }\n            function generateBreakpoints_iterableToArrayLimit(r, l) {\n                var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n                if (null != t) {\n                    var e, n, i, u, a = [], f = !0, o = !1;\n                    try {\n                        if (i = (t = t.call(r)).next, 0 === l) {\n                            if (Object(t) !== t) return;\n                            f = !1;\n                        } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n                    } catch (r) {\n                        o = !0, n = r;\n                    } finally{\n                        try {\n                            if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n                        } finally{\n                            if (o) throw n;\n                        }\n                    }\n                    return a;\n                }\n            }\n            function generateBreakpoints_arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            /**\n * Helper function. Gets or populates srcset breakpoints using provided parameters\n * Either the breakpoints or min_width, max_width, max_images must be provided.\n *\n * @private\n * @param {srcset} srcset Options with either `breakpoints` or `min_width`, `max_width`, and `max_images`\n *\n * @return {number[]} Array of breakpoints\n *\n */ function generateBreakpoints(srcset) {\n                var breakpoints = srcset.breakpoints || [];\n                if (breakpoints.length) {\n                    return breakpoints;\n                }\n                var _map = [\n                    srcset.min_width,\n                    srcset.max_width,\n                    srcset.max_images\n                ].map(Number), _map2 = generateBreakpoints_slicedToArray(_map, 3), min_width = _map2[0], max_width = _map2[1], max_images = _map2[2];\n                if ([\n                    min_width,\n                    max_width,\n                    max_images\n                ].some(isNaN)) {\n                    throw \"Either (min_width, max_width, max_images) \" + \"or breakpoints must be provided to the image srcset attribute\";\n                }\n                if (min_width > max_width) {\n                    throw \"min_width must be less than max_width\";\n                }\n                if (max_images <= 0) {\n                    throw \"max_images must be a positive integer\";\n                } else if (max_images === 1) {\n                    min_width = max_width;\n                }\n                var stepSize = Math.ceil((max_width - min_width) / Math.max(max_images - 1, 1));\n                for(var current = min_width; current < max_width; current += stepSize){\n                    breakpoints.push(current);\n                }\n                breakpoints.push(max_width);\n                return breakpoints;\n            }\n            // CONCATENATED MODULE: ./src/util/srcsetUtils.js\n            var srcsetUtils_isEmpty = isEmpty;\n            /**\n * Options used to generate the srcset attribute.\n * @typedef {object} srcset\n * @property {(number[]|string[])}   [breakpoints] An array of breakpoints.\n * @property {number}                [min_width]   Minimal width of the srcset images.\n * @property {number}                [max_width]   Maximal width of the srcset images.\n * @property {number}                [max_images]  Number of srcset images to generate.\n * @property {object|string}         [transformation] The transformation to use in the srcset urls.\n * @property {boolean}               [sizes] Whether to calculate and add the sizes attribute.\n */ /**\n * Helper function. Generates a single srcset item url\n *\n * @private\n * @param {string} public_id  Public ID of the resource.\n * @param {number} width      Width in pixels of the srcset item.\n * @param {object|string} transformation\n * @param {object} options    Additional options.\n *\n * @return {string} Resulting URL of the item\n */ function scaledUrl(public_id, width, transformation) {\n                var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n                var configParams = extractUrlParams(options);\n                transformation = transformation || options;\n                configParams.raw_transformation = new src_transformation([\n                    merge_root_merge_default.a({}, transformation),\n                    {\n                        crop: \"scale\",\n                        width: width\n                    }\n                ]).toString();\n                return url_url(public_id, configParams);\n            }\n            /**\n * If cache is enabled, get the breakpoints from the cache. If the values were not found in the cache,\n * or cache is not enabled, generate the values.\n * @param {srcset} srcset The srcset configuration parameters\n * @param {string} public_id\n * @param {object} options\n * @return {*|Array}\n */ function getOrGenerateBreakpoints(public_id) {\n                var srcset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                return generateBreakpoints(srcset);\n            }\n            /**\n * Helper function. Generates srcset attribute value of the HTML img tag\n * @private\n *\n * @param {string} public_id  Public ID of the resource\n * @param {number[]} breakpoints An array of breakpoints (in pixels)\n * @param {object} transformation The transformation\n * @param {object} options Includes html tag options, transformation options\n * @return {string} Resulting srcset attribute value\n */ function generateSrcsetAttribute(public_id, breakpoints, transformation, options) {\n                options = cloneDeep_root_cloneDeep_default.a(options);\n                patchFetchFormat(options);\n                return breakpoints.map(function(width) {\n                    return \"\".concat(scaledUrl(public_id, width, transformation, options), \" \").concat(width, \"w\");\n                }).join(\", \");\n            }\n            /**\n * Helper function. Generates sizes attribute value of the HTML img tag\n * @private\n * @param {number[]} breakpoints An array of breakpoints.\n * @return {string} Resulting sizes attribute value\n */ function generateSizesAttribute(breakpoints) {\n                if (breakpoints == null) {\n                    return \"\";\n                }\n                return breakpoints.map(function(width) {\n                    return \"(max-width: \".concat(width, \"px) \").concat(width, \"px\");\n                }).join(\", \");\n            }\n            /**\n * Helper function. Generates srcset and sizes attributes of the image tag\n *\n * Generated attributes are added to attributes argument\n *\n * @private\n * @param {string}    publicId  The public ID of the resource\n * @param {object}    attributes Existing HTML attributes.\n * @param {srcset}    srcsetData\n * @param {object}    options    Additional options.\n *\n * @return array The responsive attributes\n */ function generateImageResponsiveAttributes(publicId) {\n                var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                var srcsetData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n                // Create both srcset and sizes here to avoid fetching breakpoints twice\n                var responsiveAttributes = {};\n                if (srcsetUtils_isEmpty(srcsetData)) {\n                    return responsiveAttributes;\n                }\n                var generateSizes = !attributes.sizes && srcsetData.sizes === true;\n                var generateSrcset = !attributes.srcset;\n                if (generateSrcset || generateSizes) {\n                    var breakpoints = getOrGenerateBreakpoints(publicId, srcsetData, options);\n                    if (generateSrcset) {\n                        var transformation = srcsetData.transformation;\n                        var srcsetAttr = generateSrcsetAttribute(publicId, breakpoints, transformation, options);\n                        if (!srcsetUtils_isEmpty(srcsetAttr)) {\n                            responsiveAttributes.srcset = srcsetAttr;\n                        }\n                    }\n                    if (generateSizes) {\n                        var sizesAttr = generateSizesAttribute(breakpoints);\n                        if (!srcsetUtils_isEmpty(sizesAttr)) {\n                            responsiveAttributes.sizes = sizesAttr;\n                        }\n                    }\n                }\n                return responsiveAttributes;\n            }\n            /**\n * Generate a media query\n *\n * @private\n * @param {object} options configuration options\n * @param {number|string} options.min_width\n * @param {number|string} options.max_width\n * @return {string} a media query string\n */ function generateMediaAttr(options) {\n                var mediaQuery = [];\n                if (options != null) {\n                    if (options.min_width != null) {\n                        mediaQuery.push(\"(min-width: \".concat(options.min_width, \"px)\"));\n                    }\n                    if (options.max_width != null) {\n                        mediaQuery.push(\"(max-width: \".concat(options.max_width, \"px)\"));\n                    }\n                }\n                return mediaQuery.join(\" and \");\n            }\n            var srcsetUrl = scaledUrl;\n            // CONCATENATED MODULE: ./src/tags/imagetag.js\n            function imagetag_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return imagetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, imagetag_typeof(o);\n            }\n            function imagetag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function imagetag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, imagetag_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function imagetag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) imagetag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) imagetag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function imagetag_toPropertyKey(t) {\n                var i = imagetag_toPrimitive(t, \"string\");\n                return \"symbol\" == imagetag_typeof(i) ? i : i + \"\";\n            }\n            function imagetag_toPrimitive(t, r) {\n                if (\"object\" != imagetag_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != imagetag_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function imagetag_callSuper(t, o, e) {\n                return o = imagetag_getPrototypeOf(o), imagetag_possibleConstructorReturn(t, imagetag_isNativeReflectConstruct() ? Reflect.construct(o, e || [], imagetag_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function imagetag_possibleConstructorReturn(self, call) {\n                if (call && (imagetag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return imagetag_assertThisInitialized(self);\n            }\n            function imagetag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function imagetag_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (imagetag_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function imagetag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    imagetag_get = Reflect.get.bind();\n                } else {\n                    imagetag_get = function _get(target, property, receiver) {\n                        var base = imagetag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return imagetag_get.apply(this, arguments);\n            }\n            function imagetag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = imagetag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function imagetag_getPrototypeOf(o) {\n                imagetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return imagetag_getPrototypeOf(o);\n            }\n            function imagetag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) imagetag_setPrototypeOf(subClass, superClass);\n            }\n            function imagetag_setPrototypeOf(o, p) {\n                imagetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return imagetag_setPrototypeOf(o, p);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Image tag using Cloudinary as the source.\n * @constructor ImageTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var imagetag_ImageTag = /*#__PURE__*/ function(_HtmlTag) {\n                function ImageTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    imagetag_classCallCheck(this, ImageTag);\n                    return imagetag_callSuper(this, ImageTag, [\n                        \"img\",\n                        publicId,\n                        options\n                    ]);\n                }\n                /** @override */ imagetag_inherits(ImageTag, _HtmlTag);\n                return imagetag_createClass(ImageTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var attr, options, srcAttribute;\n                            attr = imagetag_get(imagetag_getPrototypeOf(ImageTag.prototype), \"attributes\", this).call(this) || {};\n                            options = this.getOptions();\n                            var attributes = this.getOption(\"attributes\") || {};\n                            var srcsetParam = this.getOption(\"srcset\") || attributes.srcset;\n                            var responsiveAttributes = {};\n                            if (isString_root_isString_default()(srcsetParam)) {\n                                responsiveAttributes.srcset = srcsetParam;\n                            } else {\n                                responsiveAttributes = generateImageResponsiveAttributes(this.publicId, attributes, srcsetParam, options);\n                            }\n                            if (!isEmpty(responsiveAttributes)) {\n                                delete attr.width;\n                                delete attr.height;\n                            }\n                            merge_root_merge_default()(attr, responsiveAttributes);\n                            srcAttribute = options.responsive && !options.client_hints ? \"data-src\" : \"src\";\n                            if (attr[srcAttribute] == null) {\n                                attr[srcAttribute] = url_url(this.publicId, this.getOptions());\n                            }\n                            return attr;\n                        }\n                    }\n                ]);\n            }(htmltag);\n            ;\n            /* harmony default export */ var imagetag = imagetag_ImageTag;\n            // CONCATENATED MODULE: ./src/tags/sourcetag.js\n            function sourcetag_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return sourcetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, sourcetag_typeof(o);\n            }\n            function sourcetag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function sourcetag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, sourcetag_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function sourcetag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) sourcetag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) sourcetag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function sourcetag_toPropertyKey(t) {\n                var i = sourcetag_toPrimitive(t, \"string\");\n                return \"symbol\" == sourcetag_typeof(i) ? i : i + \"\";\n            }\n            function sourcetag_toPrimitive(t, r) {\n                if (\"object\" != sourcetag_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != sourcetag_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function sourcetag_callSuper(t, o, e) {\n                return o = sourcetag_getPrototypeOf(o), sourcetag_possibleConstructorReturn(t, sourcetag_isNativeReflectConstruct() ? Reflect.construct(o, e || [], sourcetag_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function sourcetag_possibleConstructorReturn(self, call) {\n                if (call && (sourcetag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return sourcetag_assertThisInitialized(self);\n            }\n            function sourcetag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function sourcetag_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (sourcetag_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function sourcetag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    sourcetag_get = Reflect.get.bind();\n                } else {\n                    sourcetag_get = function _get(target, property, receiver) {\n                        var base = sourcetag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return sourcetag_get.apply(this, arguments);\n            }\n            function sourcetag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = sourcetag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function sourcetag_getPrototypeOf(o) {\n                sourcetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return sourcetag_getPrototypeOf(o);\n            }\n            function sourcetag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) sourcetag_setPrototypeOf(subClass, superClass);\n            }\n            function sourcetag_setPrototypeOf(o, p) {\n                sourcetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return sourcetag_setPrototypeOf(o, p);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Image tag using Cloudinary as the source.\n * @constructor SourceTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var sourcetag_SourceTag = /*#__PURE__*/ function(_HtmlTag) {\n                function SourceTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    sourcetag_classCallCheck(this, SourceTag);\n                    return sourcetag_callSuper(this, SourceTag, [\n                        \"source\",\n                        publicId,\n                        options\n                    ]);\n                }\n                /** @override */ sourcetag_inherits(SourceTag, _HtmlTag);\n                return sourcetag_createClass(SourceTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var srcsetParam = this.getOption(\"srcset\");\n                            var attr = sourcetag_get(sourcetag_getPrototypeOf(SourceTag.prototype), \"attributes\", this).call(this) || {};\n                            var options = this.getOptions();\n                            merge_root_merge_default()(attr, generateImageResponsiveAttributes(this.publicId, attr, srcsetParam, options));\n                            if (!attr.srcset) {\n                                attr.srcset = url_url(this.publicId, options);\n                            }\n                            if (!attr.media && options.media) {\n                                attr.media = generateMediaAttr(options.media);\n                            }\n                            return attr;\n                        }\n                    }\n                ]);\n            }(htmltag);\n            ;\n            /* harmony default export */ var sourcetag = sourcetag_SourceTag;\n            // CONCATENATED MODULE: ./src/tags/picturetag.js\n            function picturetag_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return picturetag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, picturetag_typeof(o);\n            }\n            function picturetag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function picturetag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, picturetag_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function picturetag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) picturetag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) picturetag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function picturetag_toPropertyKey(t) {\n                var i = picturetag_toPrimitive(t, \"string\");\n                return \"symbol\" == picturetag_typeof(i) ? i : i + \"\";\n            }\n            function picturetag_toPrimitive(t, r) {\n                if (\"object\" != picturetag_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != picturetag_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function picturetag_callSuper(t, o, e) {\n                return o = picturetag_getPrototypeOf(o), picturetag_possibleConstructorReturn(t, picturetag_isNativeReflectConstruct() ? Reflect.construct(o, e || [], picturetag_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function picturetag_possibleConstructorReturn(self, call) {\n                if (call && (picturetag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return picturetag_assertThisInitialized(self);\n            }\n            function picturetag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function picturetag_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (picturetag_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function picturetag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    picturetag_get = Reflect.get.bind();\n                } else {\n                    picturetag_get = function _get(target, property, receiver) {\n                        var base = picturetag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return picturetag_get.apply(this, arguments);\n            }\n            function picturetag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = picturetag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function picturetag_getPrototypeOf(o) {\n                picturetag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return picturetag_getPrototypeOf(o);\n            }\n            function picturetag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) picturetag_setPrototypeOf(subClass, superClass);\n            }\n            function picturetag_setPrototypeOf(o, p) {\n                picturetag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return picturetag_setPrototypeOf(o, p);\n            }\n            var picturetag_PictureTag = /*#__PURE__*/ function(_HtmlTag) {\n                function PictureTag(publicId) {\n                    var _this;\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    var sources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n                    picturetag_classCallCheck(this, PictureTag);\n                    _this = picturetag_callSuper(this, PictureTag, [\n                        \"picture\",\n                        publicId,\n                        options\n                    ]);\n                    _this.widthList = sources;\n                    return _this;\n                }\n                /** @override */ picturetag_inherits(PictureTag, _HtmlTag);\n                return picturetag_createClass(PictureTag, [\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            var _this2 = this;\n                            return this.widthList.map(function(_ref) {\n                                var min_width = _ref.min_width, max_width = _ref.max_width, transformation = _ref.transformation;\n                                var options = _this2.getOptions();\n                                var sourceTransformation = new src_transformation(options);\n                                sourceTransformation.chain().fromOptions(typeof transformation === \"string\" ? {\n                                    raw_transformation: transformation\n                                } : transformation);\n                                options = extractUrlParams(options);\n                                options.media = {\n                                    min_width: min_width,\n                                    max_width: max_width\n                                };\n                                options.transformation = sourceTransformation;\n                                return new sourcetag(_this2.publicId, options).toHtml();\n                            }).join(\"\") + new imagetag(this.publicId, this.getOptions()).toHtml();\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var attr = picturetag_get(picturetag_getPrototypeOf(PictureTag.prototype), \"attributes\", this).call(this);\n                            delete attr.width;\n                            delete attr.height;\n                            return attr;\n                        }\n                    },\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"</\" + this.name + \">\";\n                        }\n                    }\n                ]);\n            }(htmltag);\n            ;\n            /* harmony default export */ var picturetag = picturetag_PictureTag;\n            // CONCATENATED MODULE: ./src/tags/videotag.js\n            function videotag_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return videotag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, videotag_typeof(o);\n            }\n            function videotag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function videotag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, videotag_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function videotag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) videotag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) videotag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function videotag_toPropertyKey(t) {\n                var i = videotag_toPrimitive(t, \"string\");\n                return \"symbol\" == videotag_typeof(i) ? i : i + \"\";\n            }\n            function videotag_toPrimitive(t, r) {\n                if (\"object\" != videotag_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != videotag_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function videotag_callSuper(t, o, e) {\n                return o = videotag_getPrototypeOf(o), videotag_possibleConstructorReturn(t, videotag_isNativeReflectConstruct() ? Reflect.construct(o, e || [], videotag_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function videotag_possibleConstructorReturn(self, call) {\n                if (call && (videotag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return videotag_assertThisInitialized(self);\n            }\n            function videotag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function videotag_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (videotag_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function videotag_get() {\n                if (typeof Reflect !== \"undefined\" && Reflect.get) {\n                    videotag_get = Reflect.get.bind();\n                } else {\n                    videotag_get = function _get(target, property, receiver) {\n                        var base = videotag_superPropBase(target, property);\n                        if (!base) return;\n                        var desc = Object.getOwnPropertyDescriptor(base, property);\n                        if (desc.get) {\n                            return desc.get.call(arguments.length < 3 ? target : receiver);\n                        }\n                        return desc.value;\n                    };\n                }\n                return videotag_get.apply(this, arguments);\n            }\n            function videotag_superPropBase(object, property) {\n                while(!Object.prototype.hasOwnProperty.call(object, property)){\n                    object = videotag_getPrototypeOf(object);\n                    if (object === null) break;\n                }\n                return object;\n            }\n            function videotag_getPrototypeOf(o) {\n                videotag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return videotag_getPrototypeOf(o);\n            }\n            function videotag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) videotag_setPrototypeOf(subClass, superClass);\n            }\n            function videotag_setPrototypeOf(o, p) {\n                videotag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return videotag_setPrototypeOf(o, p);\n            }\n            /**\n * Video Tag\n * Depends on 'tags/htmltag', 'util', 'cloudinary'\n */ var VIDEO_TAG_PARAMS = [\n                \"source_types\",\n                \"source_transformation\",\n                \"fallback_content\",\n                \"poster\",\n                \"sources\"\n            ];\n            var videotag_DEFAULT_VIDEO_SOURCE_TYPES = [\n                \"webm\",\n                \"mp4\",\n                \"ogv\"\n            ];\n            var videotag_DEFAULT_POSTER_OPTIONS = {\n                format: \"jpg\",\n                resource_type: \"video\"\n            };\n            /**\n * Creates an HTML (DOM) Video tag using Cloudinary as the source.\n * @constructor VideoTag\n * @extends HtmlTag\n * @param {string} [publicId]\n * @param {Object} [options]\n */ var videotag_VideoTag = /*#__PURE__*/ function(_HtmlTag) {\n                function VideoTag(publicId) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    videotag_classCallCheck(this, VideoTag);\n                    options = defaults({}, options, DEFAULT_VIDEO_PARAMS);\n                    return videotag_callSuper(this, VideoTag, [\n                        \"video\",\n                        publicId.replace(/\\.(mp4|ogv|webm)$/, \"\"),\n                        options\n                    ]);\n                }\n                /**\n   * Set the transformation to apply on each source\n   * @function VideoTag#setSourceTransformation\n   * @param {Object} an object with pairs of source type and source transformation\n   * @returns {VideoTag} Returns this instance for chaining purposes.\n   */ videotag_inherits(VideoTag, _HtmlTag);\n                return videotag_createClass(VideoTag, [\n                    {\n                        key: \"setSourceTransformation\",\n                        value: function setSourceTransformation(value) {\n                            this.transformation().sourceTransformation(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setSourceTypes\",\n                        value: function setSourceTypes(value) {\n                            this.transformation().sourceTypes(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setPoster\",\n                        value: function setPoster(value) {\n                            this.transformation().poster(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setFallbackContent\",\n                        value: function setFallbackContent(value) {\n                            this.transformation().fallbackContent(value);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"content\",\n                        value: function content() {\n                            var _this = this;\n                            var sourceTypes = this.transformation().getValue(\"source_types\");\n                            var sourceTransformation = this.transformation().getValue(\"source_transformation\");\n                            var fallback = this.transformation().getValue(\"fallback_content\");\n                            var sources = this.getOption(\"sources\");\n                            var innerTags = [];\n                            if (isArray_root_isArray_default()(sources) && !isEmpty(sources)) {\n                                innerTags = sources.map(function(source) {\n                                    var src = url_url(_this.publicId, defaults({}, source.transformations || {}, {\n                                        resource_type: \"video\",\n                                        format: source.type\n                                    }), _this.getOptions());\n                                    return _this.createSourceTag(src, source.type, source.codecs);\n                                });\n                            } else {\n                                if (isEmpty(sourceTypes)) {\n                                    sourceTypes = videotag_DEFAULT_VIDEO_SOURCE_TYPES;\n                                }\n                                if (isArray_root_isArray_default()(sourceTypes)) {\n                                    innerTags = sourceTypes.map(function(srcType) {\n                                        var src = url_url(_this.publicId, defaults({}, sourceTransformation[srcType] || {}, {\n                                            resource_type: \"video\",\n                                            format: srcType\n                                        }), _this.getOptions());\n                                        return _this.createSourceTag(src, srcType);\n                                    });\n                                }\n                            }\n                            return innerTags.join(\"\") + fallback;\n                        }\n                    },\n                    {\n                        key: \"attributes\",\n                        value: function attributes() {\n                            var sourceTypes = this.getOption(\"source_types\");\n                            var poster = this.getOption(\"poster\");\n                            if (poster === undefined) {\n                                poster = {};\n                            }\n                            if (isPlainObject_root_isPlainObject_default()(poster)) {\n                                var defaultOptions = poster.public_id != null ? DEFAULT_IMAGE_PARAMS : videotag_DEFAULT_POSTER_OPTIONS;\n                                poster = url_url(poster.public_id || this.publicId, defaults({}, poster, defaultOptions, this.getOptions()));\n                            }\n                            var attr = videotag_get(videotag_getPrototypeOf(VideoTag.prototype), \"attributes\", this).call(this) || {};\n                            attr = omit(attr, VIDEO_TAG_PARAMS);\n                            var sources = this.getOption(\"sources\");\n                            // In case of empty sourceTypes - fallback to default source types is used.\n                            var hasSourceTags = !isEmpty(sources) || isEmpty(sourceTypes) || isArray_root_isArray_default()(sourceTypes);\n                            if (!hasSourceTags) {\n                                attr[\"src\"] = url_url(this.publicId, this.getOptions(), {\n                                    resource_type: \"video\",\n                                    format: sourceTypes\n                                });\n                            }\n                            if (poster != null) {\n                                attr[\"poster\"] = poster;\n                            }\n                            return attr;\n                        }\n                    },\n                    {\n                        key: \"createSourceTag\",\n                        value: function createSourceTag(src, sourceType) {\n                            var codecs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n                            var mimeType = null;\n                            if (!isEmpty(sourceType)) {\n                                var videoType = sourceType === \"ogv\" ? \"ogg\" : sourceType;\n                                mimeType = \"video/\" + videoType;\n                                if (!isEmpty(codecs)) {\n                                    var codecsStr = isArray_root_isArray_default()(codecs) ? codecs.join(\", \") : codecs;\n                                    mimeType += \"; codecs=\" + codecsStr;\n                                }\n                            }\n                            return \"<source \" + this.htmlAttrs({\n                                src: src,\n                                type: mimeType\n                            }) + \">\";\n                        }\n                    }\n                ]);\n            }(htmltag);\n            /* harmony default export */ var videotag = videotag_VideoTag;\n            // CONCATENATED MODULE: ./src/tags/clienthintsmetatag.js\n            function clienthintsmetatag_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return clienthintsmetatag_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, clienthintsmetatag_typeof(o);\n            }\n            function clienthintsmetatag_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function clienthintsmetatag_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, clienthintsmetatag_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function clienthintsmetatag_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) clienthintsmetatag_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) clienthintsmetatag_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function clienthintsmetatag_toPropertyKey(t) {\n                var i = clienthintsmetatag_toPrimitive(t, \"string\");\n                return \"symbol\" == clienthintsmetatag_typeof(i) ? i : i + \"\";\n            }\n            function clienthintsmetatag_toPrimitive(t, r) {\n                if (\"object\" != clienthintsmetatag_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != clienthintsmetatag_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            function clienthintsmetatag_callSuper(t, o, e) {\n                return o = clienthintsmetatag_getPrototypeOf(o), clienthintsmetatag_possibleConstructorReturn(t, clienthintsmetatag_isNativeReflectConstruct() ? Reflect.construct(o, e || [], clienthintsmetatag_getPrototypeOf(t).constructor) : o.apply(t, e));\n            }\n            function clienthintsmetatag_possibleConstructorReturn(self, call) {\n                if (call && (clienthintsmetatag_typeof(call) === \"object\" || typeof call === \"function\")) {\n                    return call;\n                } else if (call !== void 0) {\n                    throw new TypeError(\"Derived constructors may only return object or undefined\");\n                }\n                return clienthintsmetatag_assertThisInitialized(self);\n            }\n            function clienthintsmetatag_assertThisInitialized(self) {\n                if (self === void 0) {\n                    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                }\n                return self;\n            }\n            function clienthintsmetatag_isNativeReflectConstruct() {\n                try {\n                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n                } catch (t) {}\n                return (clienthintsmetatag_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n                    return !!t;\n                })();\n            }\n            function clienthintsmetatag_getPrototypeOf(o) {\n                clienthintsmetatag_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n                    return o.__proto__ || Object.getPrototypeOf(o);\n                };\n                return clienthintsmetatag_getPrototypeOf(o);\n            }\n            function clienthintsmetatag_inherits(subClass, superClass) {\n                if (typeof superClass !== \"function\" && superClass !== null) {\n                    throw new TypeError(\"Super expression must either be null or a function\");\n                }\n                subClass.prototype = Object.create(superClass && superClass.prototype, {\n                    constructor: {\n                        value: subClass,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n                Object.defineProperty(subClass, \"prototype\", {\n                    writable: false\n                });\n                if (superClass) clienthintsmetatag_setPrototypeOf(subClass, superClass);\n            }\n            function clienthintsmetatag_setPrototypeOf(o, p) {\n                clienthintsmetatag_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n                    o.__proto__ = p;\n                    return o;\n                };\n                return clienthintsmetatag_setPrototypeOf(o, p);\n            }\n            /**\n * Image Tag\n * Depends on 'tags/htmltag', 'cloudinary'\n */ /**\n * Creates an HTML (DOM) Meta tag that enables Client-Hints for the HTML page. <br/>\n *  See\n *  <a href=\"https://cloudinary.com/documentation/responsive_images#automating_responsive_images_with_client_hints\"\n *  target=\"_new\">Automating responsive images with Client Hints</a> for more details.\n * @constructor ClientHintsMetaTag\n * @extends HtmlTag\n * @param {object} options\n * @example\n * tag = new ClientHintsMetaTag()\n * //returns: <meta http-equiv=\"Accept-CH\" content=\"DPR, Viewport-Width, Width\">\n */ var clienthintsmetatag_ClientHintsMetaTag = /*#__PURE__*/ function(_HtmlTag) {\n                function ClientHintsMetaTag(options) {\n                    clienthintsmetatag_classCallCheck(this, ClientHintsMetaTag);\n                    return clienthintsmetatag_callSuper(this, ClientHintsMetaTag, [\n                        \"meta\",\n                        void 0,\n                        assign_root_assign_default()({\n                            \"http-equiv\": \"Accept-CH\",\n                            content: \"DPR, Viewport-Width, Width\"\n                        }, options)\n                    ]);\n                }\n                /** @override */ clienthintsmetatag_inherits(ClientHintsMetaTag, _HtmlTag);\n                return clienthintsmetatag_createClass(ClientHintsMetaTag, [\n                    {\n                        key: \"closeTag\",\n                        value: function closeTag() {\n                            return \"\";\n                        }\n                    }\n                ]);\n            }(htmltag);\n            ;\n            /* harmony default export */ var clienthintsmetatag = clienthintsmetatag_ClientHintsMetaTag;\n            // CONCATENATED MODULE: ./src/util/parse/normalizeToArray.js\n            function normalizeToArray_toConsumableArray(arr) {\n                return normalizeToArray_arrayWithoutHoles(arr) || normalizeToArray_iterableToArray(arr) || normalizeToArray_unsupportedIterableToArray(arr) || normalizeToArray_nonIterableSpread();\n            }\n            function normalizeToArray_nonIterableSpread() {\n                throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function normalizeToArray_unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return normalizeToArray_arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return normalizeToArray_arrayLikeToArray(o, minLen);\n            }\n            function normalizeToArray_iterableToArray(iter) {\n                if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n            }\n            function normalizeToArray_arrayWithoutHoles(arr) {\n                if (Array.isArray(arr)) return normalizeToArray_arrayLikeToArray(arr);\n            }\n            function normalizeToArray_arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n                return arr2;\n            }\n            /**\n * @desc normalize elements, support a single element, array or nodelist, always outputs array\n * @param elements<HTMLElement[]>\n * @returns {[]}\n */ function normalizeToArray(elements) {\n                if (isArray_root_isArray_default()(elements)) {\n                    return elements;\n                } else if (elements.constructor.name === \"NodeList\") {\n                    return normalizeToArray_toConsumableArray(elements); // ensure an array is always returned, even if nodelist\n                } else if (isString_root_isString_default()(elements)) {\n                    return Array.prototype.slice.call(document.querySelectorAll(elements), 0);\n                } else {\n                    return [\n                        elements\n                    ];\n                }\n            }\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/mountCloudinaryVideoTag.js\n            /**\n * @param {HTMLElement} htmlElContainer\n * @param {object} clInstance cloudinary instance\n * @param {string} publicId\n * @param {object} options - TransformationOptions\n * @returns Promise<HTMLElement>\n */ function mountCloudinaryVideoTag(htmlElContainer, clInstance, publicId, options) {\n                return new Promise(function(resolve, reject) {\n                    htmlElContainer.innerHTML = clInstance.videoTag(publicId, options).toHtml();\n                    // All videos under the html container must have a width of 100%, or they might overflow from the container\n                    var cloudinaryVideoElement = htmlElContainer.querySelector(\".cld-transparent-video\");\n                    cloudinaryVideoElement.style.width = \"100%\";\n                    resolve(htmlElContainer);\n                });\n            }\n            /* harmony default export */ var transparentVideo_mountCloudinaryVideoTag = mountCloudinaryVideoTag;\n            // CONCATENATED MODULE: ./src/util/transformations/addFlag.js\n            /**\n * @description - Function will push a flag to incoming options\n * @param {{transformation} | {...transformation}} options - These options are the same options provided to all our SDK methods\n *                           We expect options to either be the transformation itself, or an object containing\n *                           an array of transformations\n *\n * @param {string} flag\n * @returns the mutated options object\n */ function addFlagToOptions(options, flag) {\n                // Do we have transformation\n                if (options.transformation) {\n                    options.transformation.push({\n                        flags: [\n                            flag\n                        ]\n                    });\n                } else {\n                    // no transformation\n                    // ensure the flags are extended\n                    if (!options.flags) {\n                        options.flags = [];\n                    }\n                    if (typeof options.flags === \"string\") {\n                        options.flags = [\n                            options.flags\n                        ];\n                    }\n                    options.flags.push(flag);\n                }\n            }\n            /* harmony default export */ var addFlag = addFlagToOptions;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/enforceOptionsForTransparentVideo.js\n            /**\n * @description - Enforce option structure, sets defaults and ensures alpha flag exists\n * @param options {TransformationOptions}\n */ function enforceOptionsForTransparentVideo(options) {\n                options.autoplay = true;\n                options.muted = true;\n                options.controls = false;\n                options.max_timeout_ms = options.max_timeout_ms || DEFAULT_TIMEOUT_MS;\n                options[\"class\"] = options[\"class\"] || \"\";\n                options[\"class\"] += \" cld-transparent-video\";\n                options.externalLibraries = options.externalLibraries || {};\n                if (!options.externalLibraries.seeThru) {\n                    options.externalLibraries.seeThru = DEFAULT_EXTERNAL_LIBRARIES.seeThru;\n                }\n                // ensure there's an alpha transformation present\n                // this is a non documented internal flag\n                addFlag(options, \"alpha\");\n            }\n            /* harmony default export */ var transparentVideo_enforceOptionsForTransparentVideo = enforceOptionsForTransparentVideo;\n            // CONCATENATED MODULE: ./src/util/xhr/loadScript.js\n            /**\n * @description - Given a string URL, this function will load the script and resolve the promise.\n *                The function doesn't resolve any value,\n *                this is not a UMD loader where you can get your library name back.\n * @param scriptURL {string}\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @param isAlreadyLoaded {boolean} if true, the loadScript resolves immediately\n *                                  this is used for multiple invocations - prevents the script from being loaded multiple times\n * @return {Promise<any | {status:string, message:string}>}\n */ function loadScript(scriptURL, max_timeout_ms, isAlreadyLoaded) {\n                return new Promise(function(resolve, reject) {\n                    if (isAlreadyLoaded) {\n                        resolve();\n                    } else {\n                        var scriptTag = document.createElement(\"script\");\n                        scriptTag.src = scriptURL;\n                        var timerID = setTimeout(function() {\n                            reject({\n                                status: \"error\",\n                                message: \"Timeout loading script \".concat(scriptURL)\n                            });\n                        }, max_timeout_ms); // 10 seconds for timeout\n                        scriptTag.onerror = function() {\n                            clearTimeout(timerID); // clear timeout reject error\n                            reject({\n                                status: \"error\",\n                                message: \"Error loading \".concat(scriptURL)\n                            });\n                        };\n                        scriptTag.onload = function() {\n                            clearTimeout(timerID); // clear timeout reject error\n                            resolve();\n                        };\n                        document.head.appendChild(scriptTag);\n                    }\n                });\n            }\n            /* harmony default export */ var xhr_loadScript = loadScript;\n            // CONCATENATED MODULE: ./src/util/xhr/getBlobFromURL.js\n            /**\n * Reject on timeout\n * @param maxTimeoutMS\n * @param reject\n * @returns {number} timerID\n */ function rejectOnTimeout(maxTimeoutMS, reject) {\n                return setTimeout(function() {\n                    reject({\n                        status: \"error\",\n                        message: \"Timeout loading Blob URL\"\n                    });\n                }, maxTimeoutMS);\n            }\n            /**\n * @description Converts a URL to a BLOB URL\n * @param {string} urlToLoad\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @return {Promise<{\n *   status: 'success' | 'error'\n *   message?: string,\n *    payload: {\n *      url: string\n *    }\n * }>}\n */ function getBlobFromURL(urlToLoad, maxTimeoutMS) {\n                return new Promise(function(resolve, reject) {\n                    var timerID = rejectOnTimeout(maxTimeoutMS, reject);\n                    // If fetch exists, use it to fetch blob, otherwise use XHR.\n                    // XHR causes issues on safari 14.1 so we prefer fetch\n                    var fetchBlob = typeof fetch !== \"undefined\" && fetch ? loadUrlUsingFetch : loadUrlUsingXhr;\n                    fetchBlob(urlToLoad).then(function(blob) {\n                        resolve({\n                            status: \"success\",\n                            payload: {\n                                blobURL: URL.createObjectURL(blob)\n                            }\n                        });\n                    })[\"catch\"](function() {\n                        reject({\n                            status: \"error\",\n                            message: \"Error loading Blob URL\"\n                        });\n                    })[\"finally\"](function() {\n                        // Clear the timeout timer on fail or success.\n                        clearTimeout(timerID);\n                    });\n                });\n            }\n            /**\n * Use fetch function to fetch file\n * @param urlToLoad\n * @returns {Promise<unknown>}\n */ function loadUrlUsingFetch(urlToLoad) {\n                return new Promise(function(resolve, reject) {\n                    fetch(urlToLoad).then(function(response) {\n                        response.blob().then(function(blob) {\n                            resolve(blob);\n                        });\n                    })[\"catch\"](function() {\n                        reject(\"error\");\n                    });\n                });\n            }\n            /**\n * Use XHR to fetch file\n * @param urlToLoad\n * @returns {Promise<unknown>}\n */ function loadUrlUsingXhr(urlToLoad) {\n                return new Promise(function(resolve, reject) {\n                    var xhr = new XMLHttpRequest();\n                    xhr.responseType = \"blob\";\n                    xhr.onload = function(response) {\n                        resolve(xhr.response);\n                    };\n                    xhr.onerror = function() {\n                        reject(\"error\");\n                    };\n                    xhr.open(\"GET\", urlToLoad, true);\n                    xhr.send();\n                });\n            }\n            /* harmony default export */ var xhr_getBlobFromURL = getBlobFromURL;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/createHiddenVideoTag.js\n            /**\n * @description Creates a hidden HTMLVideoElement with the specified videoOptions\n * @param {{autoplay, playsinline, loop, muted, poster, blobURL, videoURL }} videoOptions\n * @param {boolean} videoOptions.autoplay - autoplays the video if true\n * @param {string} videoOptions.blobURL - the blobURL to set as video.src\n * @param {string} videoOptions.videoURL - the original videoURL the user created (with transformations)\n * @return {HTMLVideoElement}\n */ function createHiddenVideoTag(videoOptions) {\n                var autoplay = videoOptions.autoplay, playsinline = videoOptions.playsinline, loop = videoOptions.loop, muted = videoOptions.muted, poster = videoOptions.poster, blobURL = videoOptions.blobURL, videoURL = videoOptions.videoURL;\n                var el = document.createElement(\"video\");\n                el.style.visibility = \"hidden\";\n                el.position = \"absolute\";\n                el.x = 0;\n                el.y = 0;\n                el.src = blobURL;\n                el.setAttribute(\"data-video-url\", videoURL); // for debugging/testing\n                autoplay && el.setAttribute(\"autoplay\", autoplay);\n                playsinline && el.setAttribute(\"playsinline\", playsinline);\n                loop && el.setAttribute(\"loop\", loop);\n                muted && el.setAttribute(\"muted\", muted);\n                muted && (el.muted = muted); // this is also needed for autoplay, on top of setAttribute\n                poster && el.setAttribute(\"poster\", poster);\n                // Free memory at the end of the file loading.\n                el.onload = function() {\n                    URL.revokeObjectURL(blobURL);\n                };\n                return el;\n            }\n            /* harmony default export */ var transparentVideo_createHiddenVideoTag = createHiddenVideoTag;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/instantiateSeeThru.js\n            /**\n * @description This function creates a new instanc eof seeThru (seeThru.create()) and returns a promise of the seeThru instance\n * @param {HTMLVideoElement} videoElement\n * @param {number} max_timeout_ms - Time to elapse before promise is rejected\n * @param {string} customClass - A classname to be added to the canvas element created by seeThru\n * @param {boolean} autoPlay\n * @return {Promise<any>} SeeThru instance or rejection error\n */ function instantiateSeeThru(videoElement, max_timeout_ms, customClass, autoPlay) {\n                var _window = window, seeThru = _window.seeThru, setTimeout1 = _window.setTimeout, clearTimeout1 = _window.clearTimeout;\n                return new Promise(function(resolve, reject) {\n                    var timerID = setTimeout1(function() {\n                        reject({\n                            status: \"error\",\n                            message: \"Timeout instantiating seeThru instance\"\n                        });\n                    }, max_timeout_ms);\n                    if (seeThru) {\n                        var seeThruInstance = seeThru.create(videoElement).ready(function() {\n                            // clear timeout reject error\n                            clearTimeout1(timerID);\n                            // force container width, else the canvas can overflow out\n                            var canvasElement = seeThruInstance.getCanvas();\n                            canvasElement.style.width = \"100%\";\n                            canvasElement.className += \" \" + customClass;\n                            // start the video if autoplay is set\n                            if (autoPlay) {\n                                seeThruInstance.play();\n                            }\n                            resolve(seeThruInstance);\n                        });\n                    } else {\n                        reject({\n                            status: \"error\",\n                            message: \"Error instantiating seeThru instance\"\n                        });\n                    }\n                });\n            }\n            /* harmony default export */ var transparentVideo_instantiateSeeThru = instantiateSeeThru;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/mountSeeThruCanvasTag.js\n            /**\n *\n * @param {HTMLElement} htmlElContainer\n * @param {string} videoURL\n * @param {TransformationOptions} options\n * @return {Promise<any>}\n */ function mountSeeThruCanvasTag(htmlElContainer, videoURL, options) {\n                var poster = options.poster, autoplay = options.autoplay, playsinline = options.playsinline, loop = options.loop, muted = options.muted;\n                videoURL = videoURL + \".mp4\"; // seeThru always uses mp4\n                return new Promise(function(resolve, reject) {\n                    xhr_loadScript(options.externalLibraries.seeThru, options.max_timeout_ms, window.seeThru).then(function() {\n                        xhr_getBlobFromURL(videoURL, options.max_timeout_ms).then(function(_ref) {\n                            var payload = _ref.payload;\n                            var videoElement = transparentVideo_createHiddenVideoTag({\n                                blobURL: payload.blobURL,\n                                videoURL: videoURL,\n                                // for debugging/testing\n                                poster: poster,\n                                autoplay: autoplay,\n                                playsinline: playsinline,\n                                loop: loop,\n                                muted: muted\n                            });\n                            htmlElContainer.appendChild(videoElement);\n                            transparentVideo_instantiateSeeThru(videoElement, options.max_timeout_ms, options[\"class\"], options.autoplay).then(function() {\n                                resolve(htmlElContainer);\n                            })[\"catch\"](function(err) {\n                                reject(err);\n                            });\n                        // catch for getBlobFromURL()\n                        })[\"catch\"](function(_ref2) {\n                            var status = _ref2.status, message = _ref2.message;\n                            reject({\n                                status: status,\n                                message: message\n                            });\n                        });\n                    // catch for loadScript()\n                    })[\"catch\"](function(_ref3) {\n                        var status = _ref3.status, message = _ref3.message;\n                        reject({\n                            status: status,\n                            message: message\n                        });\n                    });\n                });\n            }\n            /* harmony default export */ var transparentVideo_mountSeeThruCanvasTag = mountSeeThruCanvasTag;\n            // CONCATENATED MODULE: ./src/util/features/transparentVideo/checkSupportForTransparency.js\n            /**\n * @return {Promise<boolean>} - Whether the browser supports transparent videos or not\n */ function checkSupportForTransparency() {\n                return new Promise(function(resolve, reject) {\n                    // Resolve early for safari.\n                    // Currently (29 December 2021) Safari can play webm/vp9,\n                    // but it does not support transparent video in the format we're outputting\n                    if (isSafari()) {\n                        resolve(false);\n                    }\n                    var video = document.createElement(\"video\");\n                    var canPlay = video.canPlayType && video.canPlayType('video/webm; codecs=\"vp9\"');\n                    resolve(canPlay === \"maybe\" || canPlay === \"probably\");\n                });\n            }\n            /* harmony default export */ var transparentVideo_checkSupportForTransparency = checkSupportForTransparency;\n            // CONCATENATED MODULE: ./src/cloudinary.js\n            function cloudinary_typeof(o) {\n                \"@babel/helpers - typeof\";\n                return cloudinary_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n                    return typeof o;\n                } : function(o) {\n                    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n                }, cloudinary_typeof(o);\n            }\n            function cloudinary_classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function cloudinary_defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, cloudinary_toPropertyKey(descriptor.key), descriptor);\n                }\n            }\n            function cloudinary_createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) cloudinary_defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) cloudinary_defineProperties(Constructor, staticProps);\n                Object.defineProperty(Constructor, \"prototype\", {\n                    writable: false\n                });\n                return Constructor;\n            }\n            function cloudinary_toPropertyKey(t) {\n                var i = cloudinary_toPrimitive(t, \"string\");\n                return \"symbol\" == cloudinary_typeof(i) ? i : i + \"\";\n            }\n            function cloudinary_toPrimitive(t, r) {\n                if (\"object\" != cloudinary_typeof(t) || !t) return t;\n                var e = t[Symbol.toPrimitive];\n                if (void 0 !== e) {\n                    var i = e.call(t, r || \"default\");\n                    if (\"object\" != cloudinary_typeof(i)) return i;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === r ? String : Number)(t);\n            }\n            var applyBreakpoints, closestAbove, defaultBreakpoints, cloudinary_findContainerWidth, cloudinary_maxWidth, updateDpr;\n            //\n            defaultBreakpoints = function defaultBreakpoints(width) {\n                var steps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n                return steps * Math.ceil(width / steps);\n            };\n            closestAbove = function closestAbove(list, value) {\n                var i;\n                i = list.length - 2;\n                while(i >= 0 && list[i] >= value){\n                    i--;\n                }\n                return list[i + 1];\n            };\n            applyBreakpoints = function applyBreakpoints(tag, width, steps, options) {\n                var ref, ref1, ref2, responsive_use_breakpoints;\n                responsive_use_breakpoints = (ref = (ref1 = (ref2 = options[\"responsive_use_breakpoints\"]) != null ? ref2 : options[\"responsive_use_stoppoints\"]) != null ? ref1 : this.config(\"responsive_use_breakpoints\")) != null ? ref : this.config(\"responsive_use_stoppoints\");\n                if (!responsive_use_breakpoints || responsive_use_breakpoints === \"resize\" && !options.resizing) {\n                    return width;\n                } else {\n                    return this.calc_breakpoint(tag, width, steps);\n                }\n            };\n            cloudinary_findContainerWidth = function findContainerWidth(element) {\n                var containerWidth, style;\n                containerWidth = 0;\n                while((element = element != null ? element.parentNode : void 0) instanceof Element && !containerWidth){\n                    style = window.getComputedStyle(element);\n                    if (!/^inline/.test(style.display)) {\n                        containerWidth = lodash_width(element);\n                    }\n                }\n                return containerWidth;\n            };\n            updateDpr = function updateDpr(dataSrc, roundDpr) {\n                return dataSrc.replace(/\\bdpr_(1\\.0|auto)\\b/g, \"dpr_\" + this.device_pixel_ratio(roundDpr));\n            };\n            cloudinary_maxWidth = function maxWidth(requiredWidth, tag) {\n                var imageWidth;\n                imageWidth = lodash_getData(tag, \"width\") || 0;\n                if (requiredWidth > imageWidth) {\n                    imageWidth = requiredWidth;\n                    lodash_setData(tag, \"width\", requiredWidth);\n                }\n                return imageWidth;\n            };\n            var cloudinary_Cloudinary = /*#__PURE__*/ function() {\n                /**\n   * Creates a new Cloudinary instance.\n   * @class Cloudinary\n   * @classdesc Main class for accessing Cloudinary functionality.\n   * @param {Object} options - A {@link Configuration} object for globally configuring Cloudinary account settings.\n   * @example<br/>\n   *  var cl = new cloudinary.Cloudinary( { cloud_name: \"mycloud\"});<br/>\n   *  var imgTag = cl.image(\"myPicID\");\n   * @see <a href=\"https://cloudinary.com/documentation/solution_overview#configuration_parameters\" target=\"_blank\">\n   *  Available configuration options</a>\n   */ function Cloudinary(options) {\n                    cloudinary_classCallCheck(this, Cloudinary);\n                    var configuration;\n                    this.devicePixelRatioCache = {};\n                    this.responsiveConfig = {};\n                    this.responsiveResizeInitialized = false;\n                    configuration = new src_configuration(options);\n                    // Provided for backward compatibility\n                    this.config = function(newConfig, newValue) {\n                        return configuration.config(newConfig, newValue);\n                    };\n                    /**\n     * Use \\<meta\\> tags in the document to configure this `cloudinary` instance.\n     * @return This {Cloudinary} instance for chaining.\n     */ this.fromDocument = function() {\n                        configuration.fromDocument();\n                        return this;\n                    };\n                    /**\n     * Use environment variables to configure this `cloudinary` instance.\n     * @return This {Cloudinary} instance for chaining.\n     */ this.fromEnvironment = function() {\n                        configuration.fromEnvironment();\n                        return this;\n                    };\n                    /**\n     * Initializes the configuration of this `cloudinary` instance.\n     *  This is a convenience method that invokes both {@link Configuration#fromEnvironment|fromEnvironment()}\n     *  (Node.js environment only) and {@link Configuration#fromDocument|fromDocument()}.\n     *  It first tries to retrieve the configuration from the environment variable.\n     *  If not available, it tries from the document meta tags.\n     * @function Cloudinary#init\n     * @see Configuration#init\n     * @return This {Cloudinary} instance for chaining.\n     */ this.init = function() {\n                        configuration.init();\n                        return this;\n                    };\n                }\n                /**\n   * Convenience constructor\n   * @param {Object} options\n   * @return {Cloudinary}\n   * @example cl = cloudinary.Cloudinary.new( { cloud_name: \"mycloud\"})\n   */ return cloudinary_createClass(Cloudinary, [\n                    {\n                        key: \"url\",\n                        value: /**\n     * Generates a URL for any asset in your Media library.\n     * @function Cloudinary#url\n     * @param {string} publicId - The public ID of the media asset.\n     * @param {Object} [options] - The {@link Transformation} parameters to include in the URL.\n     * @param {type} [options.type='upload'] - The asset's storage type.\n     *  For details on all fetch types, see\n     * <a href=\"https://cloudinary.com/documentation/image_transformations#fetching_images_from_remote_locations\"\n     *  target=\"_blank\">Fetch types</a>.\n     * @param {resourceType} [options.resource_type='image'] - The type of asset. Possible values:<br/>\n     *  - `image`<br/>\n     *  - `video`<br/>\n     *  - `raw`\n     * @return {string} The media asset URL.\n     * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\" target=\"_blank\">\n     *  Available image transformations</a>\n     * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\" target=\"_blank\">\n     *  Available video transformations</a>\n     */ function url(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            return url_url(publicId, options, this.config());\n                        }\n                    },\n                    {\n                        key: \"video_url\",\n                        value: function video_url(publicId, options) {\n                            options = assign_root_assign_default()({\n                                resource_type: \"video\"\n                            }, options);\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"video_thumbnail_url\",\n                        value: function video_thumbnail_url(publicId, options) {\n                            options = assign_root_assign_default()({}, DEFAULT_POSTER_OPTIONS, options);\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"transformation_string\",\n                        value: function transformation_string(options) {\n                            return new src_transformation(options).serialize();\n                        }\n                    },\n                    {\n                        key: \"image\",\n                        value: function image(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            var client_hints, img, ref;\n                            img = this.imageTag(publicId, options);\n                            client_hints = (ref = options.client_hints != null ? options.client_hints : this.config(\"client_hints\")) != null ? ref : false;\n                            if (options.src == null && !client_hints) {\n                                // src must be removed before creating the DOM element to avoid loading the image\n                                img.setAttr(\"src\", \"\");\n                            }\n                            img = img.toDOM();\n                            if (!client_hints) {\n                                // cache the image src\n                                lodash_setData(img, \"src-cache\", this.url(publicId, options));\n                                // set image src taking responsiveness in account\n                                this.cloudinary_update(img, options);\n                            }\n                            return img;\n                        }\n                    },\n                    {\n                        key: \"imageTag\",\n                        value: function imageTag(publicId, options) {\n                            var tag;\n                            tag = new imagetag(publicId, this.config());\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"pictureTag\",\n                        value: function pictureTag(publicId, options, sources) {\n                            var tag;\n                            tag = new picturetag(publicId, this.config(), sources);\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"sourceTag\",\n                        value: function sourceTag(publicId, options) {\n                            var tag;\n                            tag = new sourcetag(publicId, this.config());\n                            tag.transformation().fromOptions(options);\n                            return tag;\n                        }\n                    },\n                    {\n                        key: \"video_thumbnail\",\n                        value: function video_thumbnail(publicId, options) {\n                            return this.image(publicId, merge_root_merge_default()({}, DEFAULT_POSTER_OPTIONS, options));\n                        }\n                    },\n                    {\n                        key: \"facebook_profile_image\",\n                        value: function facebook_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"facebook\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"twitter_profile_image\",\n                        value: function twitter_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"twitter\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"twitter_name_profile_image\",\n                        value: function twitter_name_profile_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"twitter_name\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"gravatar_image\",\n                        value: function gravatar_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"gravatar\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"fetch_image\",\n                        value: function fetch_image(publicId, options) {\n                            return this.image(publicId, assign_root_assign_default()({\n                                type: \"fetch\"\n                            }, options));\n                        }\n                    },\n                    {\n                        key: \"video\",\n                        value: function video(publicId) {\n                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                            return this.videoTag(publicId, options).toHtml();\n                        }\n                    },\n                    {\n                        key: \"videoTag\",\n                        value: function videoTag(publicId, options) {\n                            options = defaults({}, options, this.config());\n                            return new videotag(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"sprite_css\",\n                        value: function sprite_css(publicId, options) {\n                            options = assign_root_assign_default()({\n                                type: \"sprite\"\n                            }, options);\n                            if (!publicId.match(/.css$/)) {\n                                options.format = \"css\";\n                            }\n                            return this.url(publicId, options);\n                        }\n                    },\n                    {\n                        key: \"responsive\",\n                        value: function responsive(options) {\n                            var _this = this;\n                            var bootstrap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n                            var ref, ref1, ref2, responsiveClass, responsiveResize, timeout;\n                            this.responsiveConfig = merge_root_merge_default()(this.responsiveConfig || {}, options);\n                            responsiveClass = (ref = this.responsiveConfig.responsive_class) != null ? ref : this.config(\"responsive_class\");\n                            if (bootstrap) {\n                                this.cloudinary_update(\"img.\".concat(responsiveClass, \", img.cld-hidpi\"), this.responsiveConfig);\n                            }\n                            responsiveResize = (ref1 = (ref2 = this.responsiveConfig.responsive_resize) != null ? ref2 : this.config(\"responsive_resize\")) != null ? ref1 : true;\n                            if (responsiveResize && !this.responsiveResizeInitialized) {\n                                this.responsiveConfig.resizing = this.responsiveResizeInitialized = true;\n                                timeout = null;\n                                var makeResponsive = function makeResponsive() {\n                                    var debounce, ref3, ref4, reset, run, wait, waitFunc;\n                                    debounce = (ref3 = (ref4 = _this.responsiveConfig.responsive_debounce) != null ? ref4 : _this.config(\"responsive_debounce\")) != null ? ref3 : 100;\n                                    reset = function reset() {\n                                        if (timeout) {\n                                            clearTimeout(timeout);\n                                            timeout = null;\n                                        }\n                                    };\n                                    run = function run() {\n                                        return _this.cloudinary_update(\"img.\".concat(responsiveClass), _this.responsiveConfig);\n                                    };\n                                    waitFunc = function waitFunc() {\n                                        reset();\n                                        return run();\n                                    };\n                                    wait = function wait() {\n                                        reset();\n                                        timeout = setTimeout(waitFunc, debounce);\n                                    };\n                                    if (debounce) {\n                                        return wait();\n                                    } else {\n                                        return run();\n                                    }\n                                };\n                                window.addEventListener(\"resize\", makeResponsive);\n                                return function() {\n                                    return window.removeEventListener(\"resize\", makeResponsive);\n                                };\n                            }\n                        }\n                    },\n                    {\n                        key: \"calc_breakpoint\",\n                        value: function calc_breakpoint(element, width, steps) {\n                            var breakpoints = lodash_getData(element, \"breakpoints\") || lodash_getData(element, \"stoppoints\") || this.config(\"breakpoints\") || this.config(\"stoppoints\") || defaultBreakpoints;\n                            if (isFunction_root_isFunction_default()(breakpoints)) {\n                                return breakpoints(width, steps);\n                            } else {\n                                if (isString_root_isString_default()(breakpoints)) {\n                                    breakpoints = breakpoints.split(\",\").map(function(point) {\n                                        return parseInt(point);\n                                    }).sort(function(a, b) {\n                                        return a - b;\n                                    });\n                                }\n                                return closestAbove(breakpoints, width);\n                            }\n                        }\n                    },\n                    {\n                        key: \"calc_stoppoint\",\n                        value: function calc_stoppoint(element, width, steps) {\n                            return this.calc_breakpoint(element, width, steps);\n                        }\n                    },\n                    {\n                        key: \"device_pixel_ratio\",\n                        value: function device_pixel_ratio(roundDpr) {\n                            roundDpr = roundDpr == null ? true : roundDpr;\n                            var dpr = ( false ? 0 : void 0) || 1;\n                            if (roundDpr) {\n                                dpr = Math.ceil(dpr);\n                            }\n                            if (dpr <= 0 || dpr === 0 / 0) {\n                                dpr = 1;\n                            }\n                            var dprString = dpr.toString();\n                            if (dprString.match(/^\\d+$/)) {\n                                dprString += \".0\";\n                            }\n                            return dprString;\n                        }\n                    },\n                    {\n                        key: \"processImageTags\",\n                        value: function processImageTags(nodes, options) {\n                            if (isEmpty(nodes)) {\n                                // similar to `$.fn.cloudinary`\n                                return this;\n                            }\n                            options = defaults({}, options || {}, this.config());\n                            var images = nodes.filter(function(node) {\n                                return /^img$/i.test(node.tagName);\n                            }).map(function(node) {\n                                var imgOptions = assign_root_assign_default()({\n                                    width: node.getAttribute(\"width\"),\n                                    height: node.getAttribute(\"height\"),\n                                    src: node.getAttribute(\"src\")\n                                }, options);\n                                var publicId = imgOptions[\"source\"] || imgOptions[\"src\"];\n                                delete imgOptions[\"source\"];\n                                delete imgOptions[\"src\"];\n                                var attr = new src_transformation(imgOptions).toHtmlAttributes();\n                                lodash_setData(node, \"src-cache\", url_url(publicId, imgOptions));\n                                node.setAttribute(\"width\", attr.width);\n                                node.setAttribute(\"height\", attr.height);\n                                return node;\n                            });\n                            this.cloudinary_update(images, options);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"cloudinary_update\",\n                        value: function cloudinary_update(elements, options) {\n                            var _this2 = this;\n                            var containerWidth, dataSrc, match, ref4, requiredWidth;\n                            if (elements === null) {\n                                return this;\n                            }\n                            if (options == null) {\n                                options = {};\n                            }\n                            var responsive = options.responsive != null ? options.responsive : this.config(\"responsive\");\n                            elements = normalizeToArray(elements);\n                            var responsiveClass;\n                            if (this.responsiveConfig && this.responsiveConfig.responsive_class != null) {\n                                responsiveClass = this.responsiveConfig.responsive_class;\n                            } else if (options.responsive_class != null) {\n                                responsiveClass = options.responsive_class;\n                            } else {\n                                responsiveClass = this.config(\"responsive_class\");\n                            }\n                            var roundDpr = options.round_dpr != null ? options.round_dpr : this.config(\"round_dpr\");\n                            elements.forEach(function(tag) {\n                                if (/img/i.test(tag.tagName)) {\n                                    var setUrl = true;\n                                    if (responsive) {\n                                        lodash_addClass(tag, responsiveClass);\n                                    }\n                                    dataSrc = lodash_getData(tag, \"src-cache\") || lodash_getData(tag, \"src\");\n                                    if (!isEmpty(dataSrc)) {\n                                        // Update dpr according to the device's devicePixelRatio\n                                        dataSrc = updateDpr.call(_this2, dataSrc, roundDpr);\n                                        if (htmltag.isResponsive(tag, responsiveClass)) {\n                                            containerWidth = cloudinary_findContainerWidth(tag);\n                                            if (containerWidth !== 0) {\n                                                if (/w_auto:breakpoints/.test(dataSrc)) {\n                                                    requiredWidth = cloudinary_maxWidth(containerWidth, tag);\n                                                    if (requiredWidth) {\n                                                        dataSrc = dataSrc.replace(/w_auto:breakpoints([_0-9]*)(:[0-9]+)?/, \"w_auto:breakpoints$1:\".concat(requiredWidth));\n                                                    } else {\n                                                        setUrl = false;\n                                                    }\n                                                } else {\n                                                    match = /w_auto(:(\\d+))?/.exec(dataSrc);\n                                                    if (match) {\n                                                        requiredWidth = applyBreakpoints.call(_this2, tag, containerWidth, match[2], options);\n                                                        requiredWidth = cloudinary_maxWidth(requiredWidth, tag);\n                                                        if (requiredWidth) {\n                                                            dataSrc = dataSrc.replace(/w_auto[^,\\/]*/g, \"w_\".concat(requiredWidth));\n                                                        } else {\n                                                            setUrl = false;\n                                                        }\n                                                    }\n                                                }\n                                                lodash_removeAttribute(tag, \"width\");\n                                                if (!options.responsive_preserve_height) {\n                                                    lodash_removeAttribute(tag, \"height\");\n                                                }\n                                            } else {\n                                                // Container doesn't know the size yet - usually because the image is hidden or outside the DOM.\n                                                setUrl = false;\n                                            }\n                                        }\n                                        var isLazyLoading = options.loading === \"lazy\" && !_this2.isNativeLazyLoadSupported() && _this2.isLazyLoadSupported() && !elements[0].getAttribute(\"src\");\n                                        if (setUrl || isLazyLoading) {\n                                            // If data-width exists, set width to be data-width\n                                            _this2.setAttributeIfExists(elements[0], \"width\", \"data-width\");\n                                        }\n                                        if (setUrl && !isLazyLoading) {\n                                            lodash_setAttribute(tag, \"src\", dataSrc);\n                                        }\n                                    }\n                                }\n                            });\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"setAttributeIfExists\",\n                        value: function setAttributeIfExists(element, toAttribute, fromAttribute) {\n                            var attributeValue = element.getAttribute(fromAttribute);\n                            if (attributeValue != null) {\n                                lodash_setAttribute(element, toAttribute, attributeValue);\n                            }\n                        }\n                    },\n                    {\n                        key: \"isLazyLoadSupported\",\n                        value: function isLazyLoadSupported() {\n                            return window && \"IntersectionObserver\" in window;\n                        }\n                    },\n                    {\n                        key: \"isNativeLazyLoadSupported\",\n                        value: function isNativeLazyLoadSupported() {\n                            return \"loading\" in HTMLImageElement.prototype;\n                        }\n                    },\n                    {\n                        key: \"transformation\",\n                        value: function transformation(options) {\n                            return src_transformation[\"new\"](this.config()).fromOptions(options).setParent(this);\n                        }\n                    },\n                    {\n                        key: \"injectTransparentVideoElement\",\n                        value: function injectTransparentVideoElement(htmlElContainer, publicId) {\n                            var _this3 = this;\n                            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                            return new Promise(function(resolve, reject) {\n                                if (!htmlElContainer) {\n                                    reject({\n                                        status: \"error\",\n                                        message: \"Expecting htmlElContainer to be HTMLElement\"\n                                    });\n                                }\n                                transparentVideo_enforceOptionsForTransparentVideo(options);\n                                var videoURL = _this3.video_url(publicId, options);\n                                transparentVideo_checkSupportForTransparency().then(function(isNativelyTransparent) {\n                                    var mountPromise;\n                                    if (isNativelyTransparent) {\n                                        mountPromise = transparentVideo_mountCloudinaryVideoTag(htmlElContainer, _this3, publicId, options);\n                                        resolve(htmlElContainer);\n                                    } else {\n                                        mountPromise = transparentVideo_mountSeeThruCanvasTag(htmlElContainer, videoURL, options);\n                                    }\n                                    mountPromise.then(function() {\n                                        resolve(htmlElContainer);\n                                    })[\"catch\"](function(_ref) {\n                                        var status = _ref.status, message = _ref.message;\n                                        reject({\n                                            status: status,\n                                            message: message\n                                        });\n                                    });\n                                // catch for checkSupportForTransparency()\n                                })[\"catch\"](function(_ref2) {\n                                    var status = _ref2.status, message = _ref2.message;\n                                    reject({\n                                        status: status,\n                                        message: message\n                                    });\n                                });\n                            });\n                        }\n                    }\n                ], [\n                    {\n                        key: \"new\",\n                        value: function _new(options) {\n                            return new this(options);\n                        }\n                    }\n                ]);\n            }();\n            assign_root_assign_default()(cloudinary_Cloudinary, constants_namespaceObject);\n            /* harmony default export */ var cloudinary = cloudinary_Cloudinary;\n            // CONCATENATED MODULE: ./src/namespace/cloudinary-core.js\n            /**\n * Creates the namespace for Cloudinary\n */ /* harmony default export */ var cloudinary_core = __nested_webpack_exports__[\"default\"] = {\n                ClientHintsMetaTag: clienthintsmetatag,\n                Cloudinary: cloudinary,\n                Condition: condition,\n                Configuration: src_configuration,\n                crc32: src_crc32,\n                Expression: expression,\n                FetchLayer: fetchlayer,\n                HtmlTag: htmltag,\n                ImageTag: imagetag,\n                Layer: layer_layer,\n                PictureTag: picturetag,\n                SubtitlesLayer: subtitleslayer,\n                TextLayer: textlayer,\n                Transformation: src_transformation,\n                utf8_encode: src_utf8_encode,\n                Util: lodash_namespaceObject,\n                VideoTag: videotag\n            };\n        /***/ },\n        /***/ \"lodash/assign\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_assign__;\n        /***/ },\n        /***/ \"lodash/cloneDeep\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_cloneDeep__;\n        /***/ },\n        /***/ \"lodash/compact\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_compact__;\n        /***/ },\n        /***/ \"lodash/difference\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_difference__;\n        /***/ },\n        /***/ \"lodash/functions\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_functions__;\n        /***/ },\n        /***/ \"lodash/identity\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_identity__;\n        /***/ },\n        /***/ \"lodash/includes\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_includes__;\n        /***/ },\n        /***/ \"lodash/isArray\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isArray__;\n        /***/ },\n        /***/ \"lodash/isElement\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isElement__;\n        /***/ },\n        /***/ \"lodash/isFunction\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isFunction__;\n        /***/ },\n        /***/ \"lodash/isPlainObject\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isPlainObject__;\n        /***/ },\n        /***/ \"lodash/isString\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_isString__;\n        /***/ },\n        /***/ \"lodash/merge\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_merge__;\n        /***/ },\n        /***/ \"lodash/trim\": /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_lodash_trim__;\n        /***/ }\n    });\n}); //# sourceMappingURL=cloudinary-core.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2xvdWRpbmFyeS1jb3JlL2Nsb3VkaW5hcnktY29yZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7OztHQU1HLEdBQ0YsVUFBU0EsaUNBQWlDQyxJQUFJLEVBQUVDLE9BQU87SUFDdkQsSUFBRyxJQUFpRCxFQUNuREUsT0FBT0QsT0FBTyxHQUFHRCxRQUFRRyxtQkFBT0EsQ0FBQyxvQ0FBZSxHQUFHQSxtQkFBT0EsQ0FBQywwQ0FBa0IsR0FBR0EsbUJBQU9BLENBQUMsc0NBQWdCLEdBQUdBLG1CQUFPQSxDQUFDLDRDQUFtQixHQUFHQSxtQkFBT0EsQ0FBQywwQ0FBa0IsR0FBR0EsbUJBQU9BLENBQUMsd0NBQWlCLEdBQUdBLG1CQUFPQSxDQUFDLHdDQUFpQixHQUFHQSxtQkFBT0EsQ0FBQyxzQ0FBZ0IsR0FBR0EsbUJBQU9BLENBQUMsMENBQWtCLEdBQUdBLG1CQUFPQSxDQUFDLDRDQUFtQixHQUFHQSxtQkFBT0EsQ0FBQyxrREFBc0IsR0FBR0EsbUJBQU9BLENBQUMsd0NBQWlCLEdBQUdBLG1CQUFPQSxDQUFDLGtDQUFjLEdBQUdBLG1CQUFPQSxDQUFDLGdDQUFhO1NBQzNaLEVBSzRWO0FBQ2xXLEdBQUcsUUFBTSxTQUFTRyx5Q0FBeUMsRUFBRUMsNENBQTRDLEVBQUVDLDBDQUEwQyxFQUFFQyw2Q0FBNkMsRUFBRUMsNENBQTRDLEVBQUVDLDJDQUEyQyxFQUFFQywyQ0FBMkMsRUFBRUMsMENBQTBDLEVBQUVDLDRDQUE0QyxFQUFFQyw2Q0FBNkMsRUFBRUMsZ0RBQWdELEVBQUVDLDJDQUEyQyxFQUFFQyx3Q0FBd0MsRUFBRUMsdUNBQXVDO0lBQ3ZvQixPQUFnQixNQUFILEdBQUksU0FBU0MsT0FBTztRQUNqQyxNQUFNLEdBQUksbUJBQW1CO1FBQzdCLE1BQU0sR0FBSSxJQUFJQyxtQkFBbUIsQ0FBQztRQUNsQyxNQUFNLEdBQ04sTUFBTSxHQUFJLHVCQUF1QjtRQUNqQyxNQUFNLEdBQUksU0FBU0MsK0JBQW1CQSxDQUFDQyxR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RyxHQUFHO1FBRU4sR0FBRyxHQUFHLGtCQUNOLEdBQUcsR0FBSSxTQUFTVixPQUFNLEVBQUVELFFBQU87WUFFL0JDLFFBQU9ELE9BQU8sR0FBR1k7UUFFakIsR0FBRyxHQUFHO1FBRU4sR0FBRyxHQUFHLG9CQUNOLEdBQUcsR0FBSSxTQUFTWCxPQUFNLEVBQUVELFFBQU87WUFFL0JDLFFBQU9ELE9BQU8sR0FBR2E7UUFFakIsR0FBRyxHQUFHO1FBRU4sR0FBRyxHQUFHLHFCQUNOLEdBQUcsR0FBSSxTQUFTWixPQUFNLEVBQUVELFFBQU87WUFFL0JDLFFBQU9ELE9BQU8sR0FBR2M7UUFFakIsR0FBRyxHQUFHO1FBRU4sR0FBRyxHQUFHLHdCQUNOLEdBQUcsR0FBSSxTQUFTYixPQUFNLEVBQUVELFFBQU87WUFFL0JDLFFBQU9ELE9BQU8sR0FBR2U7UUFFakIsR0FBRyxHQUFHO1FBRU4sR0FBRyxHQUFHLG1CQUNOLEdBQUcsR0FBSSxTQUFTZCxPQUFNLEVBQUVELFFBQU87WUFFL0JDLFFBQU9ELE9BQU8sR0FBR2dCO1FBRWpCLEdBQUcsR0FBRztRQUVOLEdBQUcsR0FBRyxnQkFDTixHQUFHLEdBQUksU0FBU2YsT0FBTSxFQUFFRCxRQUFPO1lBRS9CQyxRQUFPRCxPQUFPLEdBQUdpQjtRQUVqQixHQUFHLEdBQUc7UUFFTixHQUFHLEdBQUcsZUFDTixHQUFHLEdBQUksU0FBU2hCLE9BQU0sRUFBRUQsUUFBTztZQUUvQkMsUUFBT0QsT0FBTyxHQUFHa0I7UUFFakIsR0FBRyxHQUFHO0lBRUc7QUFDVCxJQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NhaWdvbnhhbmgvLi9ub2RlX21vZHVsZXMvY2xvdWRpbmFyeS1jb3JlL2Nsb3VkaW5hcnktY29yZS5qcz9mNzNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICAgKiBjbG91ZGluYXJ5LWNvcmUuanNcbiAgICogQ2xvdWRpbmFyeSdzIEphdmFTY3JpcHQgbGlicmFyeSAtIFZlcnNpb24gMi4xMy4xXG4gICAqIENvcHlyaWdodCBDbG91ZGluYXJ5XG4gICAqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2xvdWRpbmFyeS9jbG91ZGluYXJ5X2pzXG4gICAqXG4gICAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwibG9kYXNoL2Fzc2lnblwiKSwgcmVxdWlyZShcImxvZGFzaC9jbG9uZURlZXBcIiksIHJlcXVpcmUoXCJsb2Rhc2gvY29tcGFjdFwiKSwgcmVxdWlyZShcImxvZGFzaC9kaWZmZXJlbmNlXCIpLCByZXF1aXJlKFwibG9kYXNoL2Z1bmN0aW9uc1wiKSwgcmVxdWlyZShcImxvZGFzaC9pZGVudGl0eVwiKSwgcmVxdWlyZShcImxvZGFzaC9pbmNsdWRlc1wiKSwgcmVxdWlyZShcImxvZGFzaC9pc0FycmF5XCIpLCByZXF1aXJlKFwibG9kYXNoL2lzRWxlbWVudFwiKSwgcmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpLCByZXF1aXJlKFwibG9kYXNoL2lzUGxhaW5PYmplY3RcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNTdHJpbmdcIiksIHJlcXVpcmUoXCJsb2Rhc2gvbWVyZ2VcIiksIHJlcXVpcmUoXCJsb2Rhc2gvdHJpbVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJsb2Rhc2gvYXNzaWduXCIsIFwibG9kYXNoL2Nsb25lRGVlcFwiLCBcImxvZGFzaC9jb21wYWN0XCIsIFwibG9kYXNoL2RpZmZlcmVuY2VcIiwgXCJsb2Rhc2gvZnVuY3Rpb25zXCIsIFwibG9kYXNoL2lkZW50aXR5XCIsIFwibG9kYXNoL2luY2x1ZGVzXCIsIFwibG9kYXNoL2lzQXJyYXlcIiwgXCJsb2Rhc2gvaXNFbGVtZW50XCIsIFwibG9kYXNoL2lzRnVuY3Rpb25cIiwgXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiLCBcImxvZGFzaC9pc1N0cmluZ1wiLCBcImxvZGFzaC9tZXJnZVwiLCBcImxvZGFzaC90cmltXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImNsb3VkaW5hcnlcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJsb2Rhc2gvYXNzaWduXCIpLCByZXF1aXJlKFwibG9kYXNoL2Nsb25lRGVlcFwiKSwgcmVxdWlyZShcImxvZGFzaC9jb21wYWN0XCIpLCByZXF1aXJlKFwibG9kYXNoL2RpZmZlcmVuY2VcIiksIHJlcXVpcmUoXCJsb2Rhc2gvZnVuY3Rpb25zXCIpLCByZXF1aXJlKFwibG9kYXNoL2lkZW50aXR5XCIpLCByZXF1aXJlKFwibG9kYXNoL2luY2x1ZGVzXCIpLCByZXF1aXJlKFwibG9kYXNoL2lzQXJyYXlcIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNFbGVtZW50XCIpLCByZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIiksIHJlcXVpcmUoXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiKSwgcmVxdWlyZShcImxvZGFzaC9pc1N0cmluZ1wiKSwgcmVxdWlyZShcImxvZGFzaC9tZXJnZVwiKSwgcmVxdWlyZShcImxvZGFzaC90cmltXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJjbG91ZGluYXJ5XCJdID0gZmFjdG9yeShyb290W1wiX1wiXVtcImFzc2lnblwiXSwgcm9vdFtcIl9cIl1bXCJjbG9uZURlZXBcIl0sIHJvb3RbXCJfXCJdW1wiY29tcGFjdFwiXSwgcm9vdFtcIl9cIl1bXCJkaWZmZXJlbmNlXCJdLCByb290W1wiX1wiXVtcImZ1bmN0aW9uc1wiXSwgcm9vdFtcIl9cIl1bXCJpZGVudGl0eVwiXSwgcm9vdFtcIl9cIl1bXCJpbmNsdWRlc1wiXSwgcm9vdFtcIl9cIl1bXCJpc0FycmF5XCJdLCByb290W1wiX1wiXVtcImlzRWxlbWVudFwiXSwgcm9vdFtcIl9cIl1bXCJpc0Z1bmN0aW9uXCJdLCByb290W1wiX1wiXVtcImlzUGxhaW5PYmplY3RcIl0sIHJvb3RbXCJfXCJdW1wiaXNTdHJpbmdcIl0sIHJvb3RbXCJfXCJdW1wibWVyZ2VcIl0sIHJvb3RbXCJfXCJdW1widHJpbVwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9hc3NpZ25fXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfY2xvbmVEZWVwX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2NvbXBhY3RfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfZGlmZmVyZW5jZV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9mdW5jdGlvbnNfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaWRlbnRpdHlfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaW5jbHVkZXNfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNBcnJheV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc0VsZW1lbnRfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNGdW5jdGlvbl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc1BsYWluT2JqZWN0X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzU3RyaW5nX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX21lcmdlX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX3RyaW1fXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9uYW1lc3BhY2UvY2xvdWRpbmFyeS1jb3JlLmpzXCIpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoe1xuXG4vKioqLyBcIi4vc3JjL25hbWVzcGFjZS9jbG91ZGluYXJ5LWNvcmUuanNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQ2xpZW50SGludHNNZXRhVGFnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gY2xpZW50aGludHNtZXRhdGFnOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNsb3VkaW5hcnlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBjbG91ZGluYXJ5OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNvbmRpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGNvbmRpdGlvbjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJDb25maWd1cmF0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gc3JjX2NvbmZpZ3VyYXRpb247IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY3JjMzJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBzcmNfY3JjMzI7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiRXhwcmVzc2lvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGV4cHJlc3Npb247IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiRmV0Y2hMYXllclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGZldGNobGF5ZXI7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiSHRtbFRhZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGh0bWx0YWc7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiSW1hZ2VUYWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBpbWFnZXRhZzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJMYXllclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIGxheWVyX2xheWVyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlBpY3R1cmVUYWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBwaWN0dXJldGFnOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlN1YnRpdGxlc0xheWVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gc3VidGl0bGVzbGF5ZXI7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVGV4dExheWVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gdGV4dGxheWVyOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlRyYW5zZm9ybWF0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gc3JjX3RyYW5zZm9ybWF0aW9uOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInV0ZjhfZW5jb2RlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gc3JjX3V0ZjhfZW5jb2RlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlV0aWxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZpZGVvVGFnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgKi8gdmlkZW90YWc7IH0pO1xuXG4vLyBOQU1FU1BBQ0UgT0JKRUNUOiAuL3NyYy9jb25zdGFudHMuanNcbnZhciBjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0ID0ge307XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJWRVJTSU9OXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVkVSU0lPTjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJDRl9TSEFSRURfQ0ROXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ0ZfU0hBUkVEX0NETjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJPTERfQUtBTUFJX1NIQVJFRF9DRE5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBPTERfQUtBTUFJX1NIQVJFRF9DRE47IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiQUtBTUFJX1NIQVJFRF9DRE5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBBS0FNQUlfU0hBUkVEX0NETjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJTSEFSRURfQ0ROXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gU0hBUkVEX0NETjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJERUZBVUxUX1RJTUVPVVRfTVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBERUZBVUxUX1RJTUVPVVRfTVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiREVGQVVMVF9QT1NURVJfT1BUSU9OU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERFRkFVTFRfUE9TVEVSX09QVElPTlM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiREVGQVVMVF9WSURFT19TT1VSQ0VfVFlQRVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBERUZBVUxUX1ZJREVPX1NPVVJDRV9UWVBFUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJTRU9fVFlQRVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTRU9fVFlQRVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiREVGQVVMVF9JTUFHRV9QQVJBTVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBERUZBVUxUX0lNQUdFX1BBUkFNUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJERUZBVUxUX1ZJREVPX1BBUkFNU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERFRkFVTFRfVklERU9fUEFSQU1TOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIkRFRkFVTFRfVklERU9fU09VUkNFU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERFRkFVTFRfVklERU9fU09VUkNFUzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoY29uc3RhbnRzX25hbWVzcGFjZU9iamVjdCwgXCJERUZBVUxUX0VYVEVSTkFMX0xJQlJBUklFU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERFRkFVTFRfRVhURVJOQUxfTElCUkFSSUVTOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChjb25zdGFudHNfbmFtZXNwYWNlT2JqZWN0LCBcIlBMQUNFSE9MREVSX0lNQUdFX01PREVTXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gUExBQ0VIT0xERVJfSU1BR0VfTU9ERVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiQUNDRVNTSUJJTElUWV9NT0RFU1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEFDQ0VTU0lCSUxJVFlfTU9ERVM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QsIFwiVVJMX0tFWVNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBVUkxfS0VZUzsgfSk7XG5cbi8vIE5BTUVTUEFDRSBPQkpFQ1Q6IC4vc3JjL3V0aWwvbG9kYXNoLmpzXG52YXIgbG9kYXNoX25hbWVzcGFjZU9iamVjdCA9IHt9O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZ2V0U0RLQW5hbHl0aWNzU2lnbmF0dXJlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0U0RLQW5hbHl0aWNzU2lnbmF0dXJlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImdldEFuYWx5dGljc09wdGlvbnNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRBbmFseXRpY3NPcHRpb25zOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImFzc2lnblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiY2xvbmVEZWVwXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJjb21wYWN0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImRpZmZlcmVuY2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkaWZmZXJlbmNlX3Jvb3RfZGlmZmVyZW5jZV9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZnVuY3Rpb25zXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZnVuY3Rpb25zX3Jvb3RfZnVuY3Rpb25zX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpZGVudGl0eVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImluY2x1ZGVzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNBcnJheVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc1BsYWluT2JqZWN0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzU3RyaW5nXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwibWVyZ2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtZXJnZV9yb290X21lcmdlX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJjb250YWluc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzSW50ZXJzZWN0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0ludGVyc2VjdGlvbk9ic2VydmVyU3VwcG9ydGVkOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc05hdGl2ZUxhenlMb2FkU3VwcG9ydGVkOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImRldGVjdEludGVyc2VjdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRldGVjdEludGVyc2VjdGlvbjsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJvbWl0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb21pdDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJhbGxTdHJpbmdzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYmFzZXV0aWxfYWxsU3RyaW5nczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJ3aXRob3V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gd2l0aG91dDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc051bWJlckxpa2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc051bWJlckxpa2U7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwic21hcnRFc2NhcGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzbWFydEVzY2FwZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJkZWZhdWx0c1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRlZmF1bHRzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIm9iamVjdFByb3RvXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb2JqZWN0UHJvdG87IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwib2JqVG9TdHJpbmdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBvYmpUb1N0cmluZzsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc09iamVjdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzT2JqZWN0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImZ1bmNUYWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmdW5jVGFnOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcInJlV29yZHNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByZVdvcmRzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImNhbWVsQ2FzZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNhbWVsQ2FzZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJzbmFrZUNhc2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzbmFrZUNhc2U7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiY29udmVydEtleXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb252ZXJ0S2V5czsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJ3aXRoQ2FtZWxDYXNlS2V5c1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHdpdGhDYW1lbENhc2VLZXlzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIndpdGhTbmFrZUNhc2VLZXlzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gd2l0aFNuYWtlQ2FzZUtleXM7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiYmFzZTY0RW5jb2RlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYmFzZTY0RW5jb2RlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImJhc2U2NEVuY29kZVVSTFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGJhc2U2NEVuY29kZVVSTDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJleHRyYWN0VXJsUGFyYW1zXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZXh0cmFjdFVybFBhcmFtczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJwYXRjaEZldGNoRm9ybWF0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcGF0Y2hGZXRjaEZvcm1hdDsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJvcHRpb25Db25zdW1lXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb3B0aW9uQ29uc3VtZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc0VtcHR5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNFbXB0eTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc0FuZHJvaWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0FuZHJvaWQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNFZGdlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNFZGdlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzQ2hyb21lXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNDaHJvbWU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiaXNTYWZhcmlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc1NhZmFyaTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJpc0VsZW1lbnRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0VsZW1lbnRfcm9vdF9pc0VsZW1lbnRfZGVmYXVsdC5hOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImlzRnVuY3Rpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0LmE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwidHJpbVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRyaW1fcm9vdF90cmltX2RlZmF1bHQuYTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJnZXREYXRhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX2dldERhdGE7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwic2V0RGF0YVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZGFzaF9zZXREYXRhOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImdldEF0dHJpYnV0ZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxvZGFzaF9nZXRBdHRyaWJ1dGU7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwic2V0QXR0cmlidXRlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX3NldEF0dHJpYnV0ZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJyZW1vdmVBdHRyaWJ1dGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2Rhc2hfcmVtb3ZlQXR0cmlidXRlOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcInNldEF0dHJpYnV0ZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzZXRBdHRyaWJ1dGVzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImhhc0NsYXNzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX2hhc0NsYXNzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImFkZENsYXNzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX2FkZENsYXNzOyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImdldFN0eWxlc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFN0eWxlczsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJjc3NFeHBhbmRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjc3NFeHBhbmQ7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiZG9tU3R5bGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkb21TdHlsZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJjdXJDU1NcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjdXJDU1M7IH0pO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsIFwiY3NzVmFsdWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjc3NWYWx1ZTsgfSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQobG9kYXNoX25hbWVzcGFjZU9iamVjdCwgXCJhdWdtZW50V2lkdGhPckhlaWdodFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGF1Z21lbnRXaWR0aE9ySGVpZ2h0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcImdldFdpZHRoT3JIZWlnaHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0OyB9KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChsb2Rhc2hfbmFtZXNwYWNlT2JqZWN0LCBcIndpZHRoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9kYXNoX3dpZHRoOyB9KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRmOF9lbmNvZGUuanNcbi8qKlxuICogVVRGOCBlbmNvZGVyXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdXRmOF9lbmNvZGU7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfdXRmOF9lbmNvZGUgPSAodXRmOF9lbmNvZGUgPSBmdW5jdGlvbiB1dGY4X2VuY29kZShhcmdTdHJpbmcpIHtcbiAgdmFyIGMxLCBlbmMsIGVuZCwgbiwgc3RhcnQsIHN0cmluZywgc3RyaW5nbCwgdXRmdGV4dDtcbiAgLy8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcbiAgLy8gKyAgIG9yaWdpbmFsIGJ5OiBXZWJ0b29sa2l0LmluZm8gKGh0dHA6Ly93d3cud2VidG9vbGtpdC5pbmZvLylcbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBzb3diZXJyeVxuICAvLyArICAgIHR3ZWFrZWQgYnk6IEphY2tcbiAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBPbm5vIE1hcnNtYW5cbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBZdmVzIFN1Y2FldFxuICAvLyArICAgYnVnZml4ZWQgYnk6IE9ubm8gTWFyc21hblxuICAvLyArICAgYnVnZml4ZWQgYnk6IFVscmljaFxuICAvLyArICAgYnVnZml4ZWQgYnk6IFJhZmFsIEt1a2F3c2tpXG4gIC8vICsgICBpbXByb3ZlZCBieToga2lyaWxsb2lkXG4gIC8vICogICAgIGV4YW1wbGUgMTogdXRmOF9lbmNvZGUoJ0tldmluIHZhbiBab25uZXZlbGQnKTtcbiAgLy8gKiAgICAgcmV0dXJucyAxOiAnS2V2aW4gdmFuIFpvbm5ldmVsZCdcbiAgaWYgKGFyZ1N0cmluZyA9PT0gbnVsbCB8fCB0eXBlb2YgYXJnU3RyaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBzdHJpbmcgPSBhcmdTdHJpbmcgKyAnJztcbiAgLy8gLnJlcGxhY2UoL1xcclxcbi9nLCBcIlxcblwiKS5yZXBsYWNlKC9cXHIvZywgXCJcXG5cIik7XG4gIHV0ZnRleHQgPSAnJztcbiAgc3RhcnQgPSB2b2lkIDA7XG4gIGVuZCA9IHZvaWQgMDtcbiAgc3RyaW5nbCA9IDA7XG4gIHN0YXJ0ID0gZW5kID0gMDtcbiAgc3RyaW5nbCA9IHN0cmluZy5sZW5ndGg7XG4gIG4gPSAwO1xuICB3aGlsZSAobiA8IHN0cmluZ2wpIHtcbiAgICBjMSA9IHN0cmluZy5jaGFyQ29kZUF0KG4pO1xuICAgIGVuYyA9IG51bGw7XG4gICAgaWYgKGMxIDwgMTI4KSB7XG4gICAgICBlbmQrKztcbiAgICB9IGVsc2UgaWYgKGMxID4gMTI3ICYmIGMxIDwgMjA0OCkge1xuICAgICAgZW5jID0gU3RyaW5nLmZyb21DaGFyQ29kZShjMSA+PiA2IHwgMTkyLCBjMSAmIDYzIHwgMTI4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jID0gU3RyaW5nLmZyb21DaGFyQ29kZShjMSA+PiAxMiB8IDIyNCwgYzEgPj4gNiAmIDYzIHwgMTI4LCBjMSAmIDYzIHwgMTI4KTtcbiAgICB9XG4gICAgaWYgKGVuYyAhPT0gbnVsbCkge1xuICAgICAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgICAgIHV0ZnRleHQgKz0gc3RyaW5nLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgdXRmdGV4dCArPSBlbmM7XG4gICAgICBzdGFydCA9IGVuZCA9IG4gKyAxO1xuICAgIH1cbiAgICBuKys7XG4gIH1cbiAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgdXRmdGV4dCArPSBzdHJpbmcuc2xpY2Uoc3RhcnQsIHN0cmluZ2wpO1xuICB9XG4gIHJldHVybiB1dGZ0ZXh0O1xufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jcmMzMi5qc1xuXG5cbi8qKlxuICogQ1JDMzIgY2FsY3VsYXRvclxuICogRGVwZW5kcyBvbiAndXRmOF9lbmNvZGUnXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gY2FsY3VsYXRlIHRoZSBDUkMzMiBmb3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNyYzMyKHN0cikge1xuICB2YXIgY3JjLCBpLCBpVG9wLCB0YWJsZSwgeCwgeTtcbiAgLy8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcbiAgLy8gKyAgIG9yaWdpbmFsIGJ5OiBXZWJ0b29sa2l0LmluZm8gKGh0dHA6Ly93d3cud2VidG9vbGtpdC5pbmZvLylcbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBUMGJzblxuICAvLyArICAgaW1wcm92ZWQgYnk6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjY0NzkzNS9qYXZhc2NyaXB0LWNyYzMyLWZ1bmN0aW9uLWFuZC1waHAtY3JjMzItbm90LW1hdGNoaW5nXG4gIC8vIC0gICAgZGVwZW5kcyBvbjogdXRmOF9lbmNvZGVcbiAgLy8gKiAgICAgZXhhbXBsZSAxOiBjcmMzMignS2V2aW4gdmFuIFpvbm5ldmVsZCcpO1xuICAvLyAqICAgICByZXR1cm5zIDE6IDEyNDk5OTEyNDlcbiAgc3RyID0gc3JjX3V0ZjhfZW5jb2RlKHN0cik7XG4gIHRhYmxlID0gJzAwMDAwMDAwIDc3MDczMDk2IEVFMEU2MTJDIDk5MDk1MUJBIDA3NkRDNDE5IDcwNkFGNDhGIEU5NjNBNTM1IDlFNjQ5NUEzIDBFREI4ODMyIDc5RENCOEE0IEUwRDVFOTFFIDk3RDJEOTg4IDA5QjY0QzJCIDdFQjE3Q0JEIEU3QjgyRDA3IDkwQkYxRDkxIDFEQjcxMDY0IDZBQjAyMEYyIEYzQjk3MTQ4IDg0QkU0MURFIDFBREFENDdEIDZERERFNEVCIEY0RDRCNTUxIDgzRDM4NUM3IDEzNkM5ODU2IDY0NkJBOEMwIEZENjJGOTdBIDhBNjVDOUVDIDE0MDE1QzRGIDYzMDY2Q0Q5IEZBMEYzRDYzIDhEMDgwREY1IDNCNkUyMEM4IDRDNjkxMDVFIEQ1NjA0MUU0IEEyNjc3MTcyIDNDMDNFNEQxIDRCMDRENDQ3IEQyMEQ4NUZEIEE1MEFCNTZCIDM1QjVBOEZBIDQyQjI5ODZDIERCQkJDOUQ2IEFDQkNGOTQwIDMyRDg2Q0UzIDQ1REY1Qzc1IERDRDYwRENGIEFCRDEzRDU5IDI2RDkzMEFDIDUxREUwMDNBIEM4RDc1MTgwIEJGRDA2MTE2IDIxQjRGNEI1IDU2QjNDNDIzIENGQkE5NTk5IEI4QkRBNTBGIDI4MDJCODlFIDVGMDU4ODA4IEM2MENEOUIyIEIxMEJFOTI0IDJGNkY3Qzg3IDU4Njg0QzExIEMxNjExREFCIEI2NjYyRDNEIDc2REM0MTkwIDAxREI3MTA2IDk4RDIyMEJDIEVGRDUxMDJBIDcxQjE4NTg5IDA2QjZCNTFGIDlGQkZFNEE1IEU4QjhENDMzIDc4MDdDOUEyIDBGMDBGOTM0IDk2MDlBODhFIEUxMEU5ODE4IDdGNkEwREJCIDA4NkQzRDJEIDkxNjQ2Qzk3IEU2NjM1QzAxIDZCNkI1MUY0IDFDNkM2MTYyIDg1NjUzMEQ4IEYyNjIwMDRFIDZDMDY5NUVEIDFCMDFBNTdCIDgyMDhGNEMxIEY1MEZDNDU3IDY1QjBEOUM2IDEyQjdFOTUwIDhCQkVCOEVBIEZDQjk4ODdDIDYyREQxRERGIDE1REEyRDQ5IDhDRDM3Q0YzIEZCRDQ0QzY1IDREQjI2MTU4IDNBQjU1MUNFIEEzQkMwMDc0IEQ0QkIzMEUyIDRBREZBNTQxIDNERDg5NUQ3IEE0RDFDNDZEIEQzRDZGNEZCIDQzNjlFOTZBIDM0NkVEOUZDIEFENjc4ODQ2IERBNjBCOEQwIDQ0MDQyRDczIDMzMDMxREU1IEFBMEE0QzVGIEREMEQ3Q0M5IDUwMDU3MTNDIDI3MDI0MUFBIEJFMEIxMDEwIEM5MEMyMDg2IDU3NjhCNTI1IDIwNkY4NUIzIEI5NjZENDA5IENFNjFFNDlGIDVFREVGOTBFIDI5RDlDOTk4IEIwRDA5ODIyIEM3RDdBOEI0IDU5QjMzRDE3IDJFQjQwRDgxIEI3QkQ1QzNCIEMwQkE2Q0FEIEVEQjg4MzIwIDlBQkZCM0I2IDAzQjZFMjBDIDc0QjFEMjlBIEVBRDU0NzM5IDlERDI3N0FGIDA0REIyNjE1IDczREMxNjgzIEUzNjMwQjEyIDk0NjQzQjg0IDBENkQ2QTNFIDdBNkE1QUE4IEU0MEVDRjBCIDkzMDlGRjlEIDBBMDBBRTI3IDdEMDc5RUIxIEYwMEY5MzQ0IDg3MDhBM0QyIDFFMDFGMjY4IDY5MDZDMkZFIEY3NjI1NzVEIDgwNjU2N0NCIDE5NkMzNjcxIDZFNkIwNkU3IEZFRDQxQjc2IDg5RDMyQkUwIDEwREE3QTVBIDY3REQ0QUNDIEY5QjlERjZGIDhFQkVFRkY5IDE3QjdCRTQzIDYwQjA4RUQ1IEQ2RDZBM0U4IEExRDE5MzdFIDM4RDhDMkM0IDRGREZGMjUyIEQxQkI2N0YxIEE2QkM1NzY3IDNGQjUwNkREIDQ4QjIzNjRCIEQ4MEQyQkRBIEFGMEExQjRDIDM2MDM0QUY2IDQxMDQ3QTYwIERGNjBFRkMzIEE4NjdERjU1IDMxNkU4RUVGIDQ2NjlCRTc5IENCNjFCMzhDIEJDNjY4MzFBIDI1NkZEMkEwIDUyNjhFMjM2IENDMEM3Nzk1IEJCMEI0NzAzIDIyMDIxNkI5IDU1MDUyNjJGIEM1QkEzQkJFIEIyQkQwQjI4IDJCQjQ1QTkyIDVDQjM2QTA0IEMyRDdGRkE3IEI1RDBDRjMxIDJDRDk5RThCIDVCREVBRTFEIDlCNjRDMkIwIEVDNjNGMjI2IDc1NkFBMzlDIDAyNkQ5MzBBIDlDMDkwNkE5IEVCMEUzNjNGIDcyMDc2Nzg1IDA1MDA1NzEzIDk1QkY0QTgyIEUyQjg3QTE0IDdCQjEyQkFFIDBDQjYxQjM4IDkyRDI4RTlCIEU1RDVCRTBEIDdDRENFRkI3IDBCREJERjIxIDg2RDNEMkQ0IEYxRDRFMjQyIDY4RERCM0Y4IDFGREE4MzZFIDgxQkUxNkNEIEY2QjkyNjVCIDZGQjA3N0UxIDE4Qjc0Nzc3IDg4MDg1QUU2IEZGMEY2QTcwIDY2MDYzQkNBIDExMDEwQjVDIDhGNjU5RUZGIEY4NjJBRTY5IDYxNkJGRkQzIDE2NkNDRjQ1IEEwMEFFMjc4IEQ3MEREMkVFIDRFMDQ4MzU0IDM5MDNCM0MyIEE3NjcyNjYxIEQwNjAxNkY3IDQ5Njk0NzREIDNFNkU3N0RCIEFFRDE2QTRBIEQ5RDY1QURDIDQwREYwQjY2IDM3RDgzQkYwIEE5QkNBRTUzIERFQkI5RUM1IDQ3QjJDRjdGIDMwQjVGRkU5IEJEQkRGMjFDIENBQkFDMjhBIDUzQjM5MzMwIDI0QjRBM0E2IEJBRDAzNjA1IENERDcwNjkzIDU0REU1NzI5IDIzRDk2N0JGIEIzNjY3QTJFIEM0NjE0QUI4IDVENjgxQjAyIDJBNkYyQjk0IEI0MEJCRTM3IEMzMEM4RUExIDVBMDVERjFCIDJEMDJFRjhEJztcbiAgY3JjID0gMDtcbiAgeCA9IDA7XG4gIHkgPSAwO1xuICBjcmMgPSBjcmMgXiAtMTtcbiAgaSA9IDA7XG4gIGlUb3AgPSBzdHIubGVuZ3RoO1xuICB3aGlsZSAoaSA8IGlUb3ApIHtcbiAgICB5ID0gKGNyYyBeIHN0ci5jaGFyQ29kZUF0KGkpKSAmIDB4RkY7XG4gICAgeCA9ICcweCcgKyB0YWJsZS5zdWJzdHIoeSAqIDksIDgpO1xuICAgIGNyYyA9IGNyYyA+Pj4gOCBeIHg7XG4gICAgaSsrO1xuICB9XG4gIGNyYyA9IGNyYyBeIC0xO1xuICAvL2NvbnZlcnQgdG8gdW5zaWduZWQgMzItYml0IGludCBpZiBuZWVkZWRcbiAgaWYgKGNyYyA8IDApIHtcbiAgICBjcmMgKz0gNDI5NDk2NzI5NjtcbiAgfVxuICByZXR1cm4gY3JjO1xufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX2NyYzMyID0gKGNyYzMyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3Nka0FuYWx5dGljcy9zdHJpbmdQYWQuanNcbmZ1bmN0aW9uIHN0cmluZ1BhZCh2YWx1ZSwgdGFyZ2V0TGVuZ3RoLCBwYWRTdHJpbmcpIHtcbiAgdGFyZ2V0TGVuZ3RoID0gdGFyZ2V0TGVuZ3RoID4+IDA7IC8vdHJ1bmNhdGUgaWYgbnVtYmVyIG9yIGNvbnZlcnQgbm9uLW51bWJlciB0byAwO1xuICBwYWRTdHJpbmcgPSBTdHJpbmcodHlwZW9mIHBhZFN0cmluZyAhPT0gJ3VuZGVmaW5lZCcgPyBwYWRTdHJpbmcgOiAnICcpO1xuICBpZiAodmFsdWUubGVuZ3RoID4gdGFyZ2V0TGVuZ3RoKSB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0TGVuZ3RoID0gdGFyZ2V0TGVuZ3RoIC0gdmFsdWUubGVuZ3RoO1xuICAgIGlmICh0YXJnZXRMZW5ndGggPiBwYWRTdHJpbmcubGVuZ3RoKSB7XG4gICAgICBwYWRTdHJpbmcgKz0gcmVwZWF0U3RyaW5nTnVtVGltZXMocGFkU3RyaW5nLCB0YXJnZXRMZW5ndGggLyBwYWRTdHJpbmcubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhZFN0cmluZy5zbGljZSgwLCB0YXJnZXRMZW5ndGgpICsgU3RyaW5nKHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVwZWF0U3RyaW5nTnVtVGltZXMoc3RyaW5nLCB0aW1lcykge1xuICB2YXIgcmVwZWF0ZWRTdHJpbmcgPSBcIlwiO1xuICB3aGlsZSAodGltZXMgPiAwKSB7XG4gICAgcmVwZWF0ZWRTdHJpbmcgKz0gc3RyaW5nO1xuICAgIHRpbWVzLS07XG4gIH1cbiAgcmV0dXJuIHJlcGVhdGVkU3RyaW5nO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc2RrQW5hbHl0aWNzL2Jhc2U2NE1hcC5qc1xuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cblxudmFyIGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xudmFyIGJhc2U2NE1hcF9udW0gPSAwO1xudmFyIG1hcCA9IHt9O1xuX3RvQ29uc3VtYWJsZUFycmF5KGNoYXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChfY2hhcikge1xuICB2YXIga2V5ID0gYmFzZTY0TWFwX251bS50b1N0cmluZygyKTtcbiAga2V5ID0gc3RyaW5nUGFkKGtleSwgNiwgJzAnKTtcbiAgbWFwW2tleV0gPSBfY2hhcjtcbiAgYmFzZTY0TWFwX251bSsrO1xufSk7XG5cbi8qKlxuICogTWFwIG9mIHNpeC1iaXQgYmluYXJ5IGNvZGVzIHRvIEJhc2U2NCBjaGFyYWN0ZXJzXG4gKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGJhc2U2NE1hcCA9IChtYXApO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvc2RrQW5hbHl0aWNzL3JldmVyc2VWZXJzaW9uLmpzXG5cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQSBzZW1WZXIgbGlrZSBzdHJpbmcsIHgueS56IG9yIHgueSBpcyBhbGxvd2VkXG4gKiAgICAgICAgICAgICAgUmV2ZXJzZXMgdGhlIHZlcnNpb24gcG9zaXRpb25zLCB4LnkueiB0dXJucyB0byB6LnkueFxuICogICAgICAgICAgICAgIFBhZHMgZWFjaCBzZWdtZW50IHdpdGggJzAnIHNvIHRoZXkgaGF2ZSBsZW5ndGggb2YgMlxuICogICAgICAgICAgICAgIEV4YW1wbGU6IDEuMi4zIC0+IDAzLjAyLjAxXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VtVmVyIElucHV0IGNhbiBiZSBlaXRoZXIgeC55Lnogb3IgeC55XG4gKiBAcmV0dXJuIHtzdHJpbmd9IGluIHRoZSBmb3JtIG9mIHp6Lnl5Lnh4IChcbiAqL1xuZnVuY3Rpb24gcmV2ZXJzZVZlcnNpb24oc2VtVmVyKSB7XG4gIGlmIChzZW1WZXIuc3BsaXQoJy4nKS5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNlbVZlciwgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byBzZWdtZW50cycpO1xuICB9XG5cbiAgLy8gU3BsaXQgYnkgJy4nLCByZXZlcnNlLCBjcmVhdGUgbmV3IGFycmF5IHdpdGggcGFkZGVkIHZhbHVlcyBhbmQgY29uY2F0IGl0IHRvZ2V0aGVyXG4gIHJldHVybiBzZW1WZXIuc3BsaXQoJy4nKS5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgcmV0dXJuIHN0cmluZ1BhZChzZWdtZW50LCAyLCAnMCcpO1xuICB9KS5qb2luKCcuJyk7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZGtBbmFseXRpY3MvZW5jb2RlVmVyc2lvbi5qc1xuXG5cblxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBFbmNvZGVzIGEgc2VtVmVyLWxpa2UgdmVyc2lvbiBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZW1WZXIgSW5wdXQgY2FuIGJlIGVpdGhlciB4LnkueiBvciB4LnlcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgYnVpbHQgZnJvbSAzIGNoYXJhY3RlcnMgb2YgdGhlIGJhc2U2NCB0YWJsZSB0aGF0IGVuY29kZSB0aGUgc2VtVmVyXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVZlcnNpb24oc2VtVmVyKSB7XG4gIHZhciBzdHJSZXN1bHQgPSAnJztcblxuICAvLyBzdXBwb3J0IHgueSBvciB4LnkueiBieSB1c2luZyAncGFydHMnIGFzIGEgdmFyaWFibGVcbiAgdmFyIHBhcnRzID0gc2VtVmVyLnNwbGl0KCcuJykubGVuZ3RoO1xuICB2YXIgcGFkZGVkU3RyaW5nTGVuZ3RoID0gcGFydHMgKiA2OyAvLyB3ZSBwYWQgdG8gZWl0aGVyIDEyIG9yIDE4IGNoYXJhY3RlcnNcblxuICAvLyByZXZlcnNlIChidXQgZG9uJ3QgbWlycm9yKSB0aGUgdmVyc2lvbi4gMS41LjE1IC0+IDE1LjUuMVxuICAvLyBQYWQgdG8gdHdvIHNwYWNlcywgMTUuNS4xIC0+IDE1LjA1LjAxXG4gIHZhciBwYWRkZWRSZXZlcnNlZFNlbXZlciA9IHJldmVyc2VWZXJzaW9uKHNlbVZlcik7XG5cbiAgLy8gdHVybiAxNS4wNS4wMSB0byBhIHN0cmluZyAnMTUwNTAxJyB0aGVuIHRvIGEgbnVtYmVyIDE1MDUwMVxuICB2YXIgbnVtID0gcGFyc2VJbnQocGFkZGVkUmV2ZXJzZWRTZW12ZXIuc3BsaXQoJy4nKS5qb2luKCcnKSk7XG5cbiAgLy8gUmVwcmVzZW50IGFzIGJpbmFyeSwgYWRkIGxlZnQgcGFkZGluZyB0byAxMiBvciAxOCBjaGFyYWN0ZXJzLlxuICAvLyAxNTAsNTAxIC0+IDEwMDEwMDEwMTExMTEwMDEwMVxuXG4gIHZhciBwYWRkZWRCaW5hcnkgPSBudW0udG9TdHJpbmcoMik7XG4gIHBhZGRlZEJpbmFyeSA9IHN0cmluZ1BhZChwYWRkZWRCaW5hcnksIHBhZGRlZFN0cmluZ0xlbmd0aCwgJzAnKTtcblxuICAvLyBTdG9wIGluIGNhc2UgYW4gaW52YWxpZCB2ZXJzaW9uIG51bWJlciB3YXMgcHJvdmlkZWRcbiAgLy8gcGFkZGVkQmluYXJ5IG11c3QgYmUgYnVpbHQgZnJvbSBzZWN0aW9ucyBvZiA2IGJpdHNcbiAgaWYgKHBhZGRlZEJpbmFyeS5sZW5ndGggJSA2ICE9PSAwKSB7XG4gICAgdGhyb3cgJ1ZlcnNpb24gbXVzdCBiZSBzbWFsbGVyIHRoYW4gNDMuMjEuMjYpJztcbiAgfVxuXG4gIC8vIHR1cm4gZXZlcnkgNiBiaXRzIGludG8gYSBjaGFyYWN0ZXIgdXNpbmcgdGhlIGJhc2U2NE1hcFxuICBwYWRkZWRCaW5hcnkubWF0Y2goLy57MSw2fS9nKS5mb3JFYWNoKGZ1bmN0aW9uIChiaXRTdHJpbmcpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhiaXRTdHJpbmcpO1xuICAgIHN0clJlc3VsdCArPSBiYXNlNjRNYXBbYml0U3RyaW5nXTtcbiAgfSk7XG4gIHJldHVybiBzdHJSZXN1bHQ7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZGtBbmFseXRpY3MvZ2V0U0RLQW5hbHl0aWNzU2lnbmF0dXJlLmpzXG5cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gR2V0cyB0aGUgU0RLIHNpZ25hdHVyZSBieSBlbmNvZGluZyB0aGUgU0RLIHZlcnNpb24gYW5kIHRlY2ggdmVyc2lvblxuICogQHBhcmFtIHt7XG4gKiAgICBbdGVjaFZlcnNpb25dOnN0cmluZyxcbiAqICAgIFtzZGtTZW12ZXJdOiBzdHJpbmcsXG4gKiAgICBbc2RrQ29kZV06IHN0cmluZyxcbiAqICAgIFtmZWF0dXJlXTogc3RyaW5nXG4gKiB9fSBhbmFseXRpY3NPcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHNka0FuYWx5dGljc1NpZ25hdHVyZVxuICovXG5mdW5jdGlvbiBnZXRTREtBbmFseXRpY3NTaWduYXR1cmUoKSB7XG4gIHZhciBhbmFseXRpY3NPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdHJ5IHtcbiAgICB2YXIgdHdvUGFydFZlcnNpb24gPSByZW1vdmVQYXRjaEZyb21TZW12ZXIoYW5hbHl0aWNzT3B0aW9ucy50ZWNoVmVyc2lvbik7XG4gICAgdmFyIGVuY29kZWRTREtWZXJzaW9uID0gZW5jb2RlVmVyc2lvbihhbmFseXRpY3NPcHRpb25zLnNka1NlbXZlcik7XG4gICAgdmFyIGVuY29kZWRUZWNoVmVyc2lvbiA9IGVuY29kZVZlcnNpb24odHdvUGFydFZlcnNpb24pO1xuICAgIHZhciBmZWF0dXJlQ29kZSA9IGFuYWx5dGljc09wdGlvbnMuZmVhdHVyZTtcbiAgICB2YXIgU0RLQ29kZSA9IGFuYWx5dGljc09wdGlvbnMuc2RrQ29kZTtcbiAgICB2YXIgYWxnb1ZlcnNpb24gPSAnQSc7IC8vIFRoZSBhbGdvIHZlcnNpb24gaXMgZGV0ZXJtaW5lZCBoZXJlLCBpdCBzaG91bGQgbm90IGJlIGFuIGFyZ3VtZW50XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoYWxnb1ZlcnNpb24pLmNvbmNhdChTREtDb2RlKS5jb25jYXQoZW5jb2RlZFNES1ZlcnNpb24pLmNvbmNhdChlbmNvZGVkVGVjaFZlcnNpb24pLmNvbmNhdChmZWF0dXJlQ29kZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBFaXRoZXIgU0RLIG9yIE5vZGUgdmVyc2lvbnMgd2VyZSB1bnBhcnNhYmxlXG4gICAgcmV0dXJuICdFJztcbiAgfVxufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIHBhdGNoIHZlcnNpb24gZnJvbSB0aGUgc2VtdmVyIGlmIGl0IGV4aXN0c1xuICogICAgICAgICAgICAgIFR1cm5zIHgueS56IE9SIHgueSBpbnRvIHgueVxuICogQHBhcmFtIHsneC55LnonIHx8ICd4LnknIHx8IHN0cmluZ30gc2VtVmVyU3RyXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVBhdGNoRnJvbVNlbXZlcihzZW1WZXJTdHIpIHtcbiAgdmFyIHBhcnRzID0gc2VtVmVyU3RyLnNwbGl0KCcuJyk7XG4gIHJldHVybiBcIlwiLmNvbmNhdChwYXJ0c1swXSwgXCIuXCIpLmNvbmNhdChwYXJ0c1sxXSk7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zZGtBbmFseXRpY3MvZ2V0QW5hbHl0aWNzT3B0aW9ucy5qc1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gR2V0cyB0aGUgYW5hbHl0aWNzT3B0aW9ucyBmcm9tIG9wdGlvbnMtIHNob3VsZCBpbmNsdWRlIHNka1NlbXZlciwgdGVjaFZlcnNpb24sIHNka0NvZGUsIGFuZCBmZWF0dXJlXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMge3tzZGtTZW12ZXI6IChzdHJpbmcpLCBzZGtDb2RlLCBmZWF0dXJlOiBzdHJpbmcsIHRlY2hWZXJzaW9uOiAoc3RyaW5nKX0gfHwge319XG4gKi9cbmZ1bmN0aW9uIGdldEFuYWx5dGljc09wdGlvbnMob3B0aW9ucykge1xuICB2YXIgYW5hbHl0aWNzT3B0aW9ucyA9IHtcbiAgICBzZGtTZW12ZXI6IG9wdGlvbnMuc2RrU2VtdmVyLFxuICAgIHRlY2hWZXJzaW9uOiBvcHRpb25zLnRlY2hWZXJzaW9uLFxuICAgIHNka0NvZGU6IG9wdGlvbnMuc2RrQ29kZSxcbiAgICBmZWF0dXJlOiAnMCdcbiAgfTtcbiAgaWYgKG9wdGlvbnMudXJsQW5hbHl0aWNzKSB7XG4gICAgaWYgKG9wdGlvbnMuYWNjZXNzaWJpbGl0eSkge1xuICAgICAgYW5hbHl0aWNzT3B0aW9ucy5mZWF0dXJlID0gJ0QnO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sb2FkaW5nID09PSAnbGF6eScpIHtcbiAgICAgIGFuYWx5dGljc09wdGlvbnMuZmVhdHVyZSA9ICdDJztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgYW5hbHl0aWNzT3B0aW9ucy5mZWF0dXJlID0gJ0EnO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wbGFjZWhvbGRlcikge1xuICAgICAgYW5hbHl0aWNzT3B0aW9ucy5mZWF0dXJlID0gJ0InO1xuICAgIH1cbiAgICByZXR1cm4gYW5hbHl0aWNzT3B0aW9ucztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9hc3NpZ25cIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2Fzc2lnblwiLFwiYW1kXCI6XCJsb2Rhc2gvYXNzaWduXCIsXCJyb290XCI6W1wiX1wiLFwiYXNzaWduXCJdfVxudmFyIGFzc2lnbl9yb290X2Fzc2lnbl8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2Fzc2lnblwiKTtcbnZhciBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oYXNzaWduX3Jvb3RfYXNzaWduXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9jbG9uZURlZXBcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2Nsb25lRGVlcFwiLFwiYW1kXCI6XCJsb2Rhc2gvY2xvbmVEZWVwXCIsXCJyb290XCI6W1wiX1wiLFwiY2xvbmVEZWVwXCJdfVxudmFyIGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2Nsb25lRGVlcFwiKTtcbnZhciBjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9jb21wYWN0XCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9jb21wYWN0XCIsXCJhbWRcIjpcImxvZGFzaC9jb21wYWN0XCIsXCJyb290XCI6W1wiX1wiLFwiY29tcGFjdFwiXX1cbnZhciBjb21wYWN0X3Jvb3RfY29tcGFjdF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2NvbXBhY3RcIik7XG52YXIgY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29tcGFjdF9yb290X2NvbXBhY3RfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2RpZmZlcmVuY2VcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2RpZmZlcmVuY2VcIixcImFtZFwiOlwibG9kYXNoL2RpZmZlcmVuY2VcIixcInJvb3RcIjpbXCJfXCIsXCJkaWZmZXJlbmNlXCJdfVxudmFyIGRpZmZlcmVuY2Vfcm9vdF9kaWZmZXJlbmNlXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvZGlmZmVyZW5jZVwiKTtcbnZhciBkaWZmZXJlbmNlX3Jvb3RfZGlmZmVyZW5jZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihkaWZmZXJlbmNlX3Jvb3RfZGlmZmVyZW5jZV8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvZnVuY3Rpb25zXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9mdW5jdGlvbnNcIixcImFtZFwiOlwibG9kYXNoL2Z1bmN0aW9uc1wiLFwicm9vdFwiOltcIl9cIixcImZ1bmN0aW9uc1wiXX1cbnZhciBmdW5jdGlvbnNfcm9vdF9mdW5jdGlvbnNfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9mdW5jdGlvbnNcIik7XG52YXIgZnVuY3Rpb25zX3Jvb3RfZnVuY3Rpb25zX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGZ1bmN0aW9uc19yb290X2Z1bmN0aW9uc18pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvaWRlbnRpdHlcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2lkZW50aXR5XCIsXCJhbWRcIjpcImxvZGFzaC9pZGVudGl0eVwiLFwicm9vdFwiOltcIl9cIixcImlkZW50aXR5XCJdfVxudmFyIGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9pZGVudGl0eVwiKTtcbnZhciBpZGVudGl0eV9yb290X2lkZW50aXR5X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2luY2x1ZGVzXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9pbmNsdWRlc1wiLFwiYW1kXCI6XCJsb2Rhc2gvaW5jbHVkZXNcIixcInJvb3RcIjpbXCJfXCIsXCJpbmNsdWRlc1wiXX1cbnZhciBpbmNsdWRlc19yb290X2luY2x1ZGVzXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvaW5jbHVkZXNcIik7XG52YXIgaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpbmNsdWRlc19yb290X2luY2x1ZGVzXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9pc0FycmF5XCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9pc0FycmF5XCIsXCJhbWRcIjpcImxvZGFzaC9pc0FycmF5XCIsXCJyb290XCI6W1wiX1wiLFwiaXNBcnJheVwiXX1cbnZhciBpc0FycmF5X3Jvb3RfaXNBcnJheV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2lzQXJyYXlcIik7XG52YXIgaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNBcnJheV9yb290X2lzQXJyYXlfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL2lzUGxhaW5PYmplY3RcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2lzUGxhaW5PYmplY3RcIixcImFtZFwiOlwibG9kYXNoL2lzUGxhaW5PYmplY3RcIixcInJvb3RcIjpbXCJfXCIsXCJpc1BsYWluT2JqZWN0XCJdfVxudmFyIGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0XyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiKTtcbnZhciBpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJsb2Rhc2gvaXNTdHJpbmdcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2lzU3RyaW5nXCIsXCJhbWRcIjpcImxvZGFzaC9pc1N0cmluZ1wiLFwicm9vdFwiOltcIl9cIixcImlzU3RyaW5nXCJdfVxudmFyIGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImxvZGFzaC9pc1N0cmluZ1wiKTtcbnZhciBpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL21lcmdlXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9tZXJnZVwiLFwiYW1kXCI6XCJsb2Rhc2gvbWVyZ2VcIixcInJvb3RcIjpbXCJfXCIsXCJtZXJnZVwiXX1cbnZhciBtZXJnZV9yb290X21lcmdlXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvbWVyZ2VcIik7XG52YXIgbWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihtZXJnZV9yb290X21lcmdlXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9pc0VsZW1lbnRcIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL2lzRWxlbWVudFwiLFwiYW1kXCI6XCJsb2Rhc2gvaXNFbGVtZW50XCIsXCJyb290XCI6W1wiX1wiLFwiaXNFbGVtZW50XCJdfVxudmFyIGlzRWxlbWVudF9yb290X2lzRWxlbWVudF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2lzRWxlbWVudFwiKTtcbnZhciBpc0VsZW1lbnRfcm9vdF9pc0VsZW1lbnRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50Xyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImxvZGFzaC9pc0Z1bmN0aW9uXCIsXCJjb21tb25qczJcIjpcImxvZGFzaC9pc0Z1bmN0aW9uXCIsXCJhbWRcIjpcImxvZGFzaC9pc0Z1bmN0aW9uXCIsXCJyb290XCI6W1wiX1wiLFwiaXNGdW5jdGlvblwiXX1cbnZhciBpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwibG9kYXNoL2lzRnVuY3Rpb25cIik7XG52YXIgaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwibG9kYXNoL3RyaW1cIixcImNvbW1vbmpzMlwiOlwibG9kYXNoL3RyaW1cIixcImFtZFwiOlwibG9kYXNoL3RyaW1cIixcInJvb3RcIjpbXCJfXCIsXCJ0cmltXCJdfVxudmFyIHRyaW1fcm9vdF90cmltXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJsb2Rhc2gvdHJpbVwiKTtcbnZhciB0cmltX3Jvb3RfdHJpbV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih0cmltX3Jvb3RfdHJpbV8pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2xhenlMb2FkLmpzXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG4vKlxuICogSW5jbHVkZXMgdXRpbGl0eSBtZXRob2RzIGZvciBsYXp5IGxvYWRpbmcgbWVkaWFcbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIEludGVyc2VjdGlvbk9ic2VydmVyIGlzIHN1cHBvcnRlZFxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaXMgZGVmaW5lZFxuICovXG5mdW5jdGlvbiBpc0ludGVyc2VjdGlvbk9ic2VydmVyU3VwcG9ydGVkKCkge1xuICAvLyBDaGVjayB0aGF0ICdJbnRlcnNlY3Rpb25PYnNlcnZlcicgcHJvcGVydHkgaXMgZGVmaW5lZCBvbiB3aW5kb3dcbiAgcmV0dXJuICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yod2luZG93KSkgPT09IFwib2JqZWN0XCIgJiYgd2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIG5hdGl2ZSBsYXp5IGxvYWRpbmcgaXMgc3VwcG9ydGVkXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmICdsb2FkaW5nJyBwcm9wZXJ0eSBpcyBkZWZpbmVkIGZvciBIVE1MSW1hZ2VFbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWQoKSB7XG4gIHJldHVybiAodHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihIVE1MSW1hZ2VFbGVtZW50KSkgPT09IFwib2JqZWN0XCIgJiYgSFRNTEltYWdlRWxlbWVudC5wcm90b3R5cGUubG9hZGluZztcbn1cblxuLyoqXG4gKiBDYWxscyBvbkludGVyc2VjdCgpIHdoZW4gaW50ZXJzZWN0aW9uIGlzIGRldGVjdGVkLCBvciB3aGVuXG4gKiBubyBuYXRpdmUgbGF6eSBsb2FkaW5nIG9yIHdoZW4gSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaXNuJ3Qgc3VwcG9ydGVkLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIHRoZSBlbGVtZW50IHRvIG9ic2VydmVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uSW50ZXJzZWN0IC0gY2FsbGVkIHdoZW4gdGhlIGdpdmVuIGVsZW1lbnQgaXMgaW4gdmlld1xuICovXG5mdW5jdGlvbiBkZXRlY3RJbnRlcnNlY3Rpb24oZWwsIG9uSW50ZXJzZWN0KSB7XG4gIHRyeSB7XG4gICAgaWYgKGlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWQoKSB8fCAhaXNJbnRlcnNlY3Rpb25PYnNlcnZlclN1cHBvcnRlZCgpKSB7XG4gICAgICAvLyBSZXR1cm4gaWYgdGhlcmUncyBubyBuZWVkIG9yIHBvc3NpYmlsaXR5IHRvIGRldGVjdCBpbnRlcnNlY3Rpb25cbiAgICAgIG9uSW50ZXJzZWN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGV0ZWN0IGludGVyc2VjdGlvbiB3aXRoIGdpdmVuIGVsZW1lbnQgdXNpbmcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgb25JbnRlcnNlY3QoKTtcbiAgICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAgdGhyZXNob2xkOiBbMCwgMC4wMV1cbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGVsKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIG9uSW50ZXJzZWN0KCk7XG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbnN0YW50cy5qc1xudmFyIFZFUlNJT04gPSBcIjIuNS4wXCI7XG52YXIgQ0ZfU0hBUkVEX0NETiA9IFwiZDNqcGw5MXB4ZXZia2guY2xvdWRmcm9udC5uZXRcIjtcbnZhciBPTERfQUtBTUFJX1NIQVJFRF9DRE4gPSBcImNsb3VkaW5hcnktYS5ha2FtYWloZC5uZXRcIjtcbnZhciBBS0FNQUlfU0hBUkVEX0NETiA9IFwicmVzLmNsb3VkaW5hcnkuY29tXCI7XG52YXIgU0hBUkVEX0NETiA9IEFLQU1BSV9TSEFSRURfQ0ROO1xudmFyIERFRkFVTFRfVElNRU9VVF9NUyA9IDEwMDAwO1xudmFyIERFRkFVTFRfUE9TVEVSX09QVElPTlMgPSB7XG4gIGZvcm1hdDogJ2pwZycsXG4gIHJlc291cmNlX3R5cGU6ICd2aWRlbydcbn07XG52YXIgREVGQVVMVF9WSURFT19TT1VSQ0VfVFlQRVMgPSBbJ3dlYm0nLCAnbXA0JywgJ29ndiddO1xudmFyIFNFT19UWVBFUyA9IHtcbiAgXCJpbWFnZS91cGxvYWRcIjogXCJpbWFnZXNcIixcbiAgXCJpbWFnZS9wcml2YXRlXCI6IFwicHJpdmF0ZV9pbWFnZXNcIixcbiAgXCJpbWFnZS9hdXRoZW50aWNhdGVkXCI6IFwiYXV0aGVudGljYXRlZF9pbWFnZXNcIixcbiAgXCJyYXcvdXBsb2FkXCI6IFwiZmlsZXNcIixcbiAgXCJ2aWRlby91cGxvYWRcIjogXCJ2aWRlb3NcIlxufTtcblxuLyoqXG4qIEBjb25zdCB7T2JqZWN0fSBDbG91ZGluYXJ5LkRFRkFVTFRfSU1BR0VfUEFSQU1TXG4qIERlZmF1bHRzIHZhbHVlcyBmb3IgaW1hZ2UgcGFyYW1ldGVycy5cbipcbiogKFByZXZpb3VzbHkgZGVmaW5lZCB1c2luZyBvcHRpb25fY29uc3VtZSgpIClcbiAqL1xudmFyIERFRkFVTFRfSU1BR0VfUEFSQU1TID0ge1xuICByZXNvdXJjZV90eXBlOiBcImltYWdlXCIsXG4gIHRyYW5zZm9ybWF0aW9uOiBbXSxcbiAgdHlwZTogJ3VwbG9hZCdcbn07XG5cbi8qKlxuKiBEZWZhdWx0cyB2YWx1ZXMgZm9yIHZpZGVvIHBhcmFtZXRlcnMuXG4qIEBjb25zdCB7T2JqZWN0fSBDbG91ZGluYXJ5LkRFRkFVTFRfVklERU9fUEFSQU1TXG4qIChQcmV2aW91c2x5IGRlZmluZWQgdXNpbmcgb3B0aW9uX2NvbnN1bWUoKSApXG4gKi9cbnZhciBERUZBVUxUX1ZJREVPX1BBUkFNUyA9IHtcbiAgZmFsbGJhY2tfY29udGVudDogJycsXG4gIHJlc291cmNlX3R5cGU6IFwidmlkZW9cIixcbiAgc291cmNlX3RyYW5zZm9ybWF0aW9uOiB7fSxcbiAgc291cmNlX3R5cGVzOiBERUZBVUxUX1ZJREVPX1NPVVJDRV9UWVBFUyxcbiAgdHJhbnNmb3JtYXRpb246IFtdLFxuICB0eXBlOiAndXBsb2FkJ1xufTtcblxuLyoqXG4gKiBSZWNvbW1lbmRlZCBzb3VyY2VzIGZvciB2aWRlbyB0YWdcbiAqIEBjb25zdCB7T2JqZWN0fSBDbG91ZGluYXJ5LkRFRkFVTFRfVklERU9fU09VUkNFU1xuICovXG52YXIgREVGQVVMVF9WSURFT19TT1VSQ0VTID0gW3tcbiAgdHlwZTogXCJtcDRcIixcbiAgY29kZWNzOiBcImhldjFcIixcbiAgdHJhbnNmb3JtYXRpb25zOiB7XG4gICAgdmlkZW9fY29kZWM6IFwiaDI2NVwiXG4gIH1cbn0sIHtcbiAgdHlwZTogXCJ3ZWJtXCIsXG4gIGNvZGVjczogXCJ2cDlcIixcbiAgdHJhbnNmb3JtYXRpb25zOiB7XG4gICAgdmlkZW9fY29kZWM6IFwidnA5XCJcbiAgfVxufSwge1xuICB0eXBlOiBcIm1wNFwiLFxuICB0cmFuc2Zvcm1hdGlvbnM6IHtcbiAgICB2aWRlb19jb2RlYzogXCJhdXRvXCJcbiAgfVxufSwge1xuICB0eXBlOiBcIndlYm1cIixcbiAgdHJhbnNmb3JtYXRpb25zOiB7XG4gICAgdmlkZW9fY29kZWM6IFwiYXV0b1wiXG4gIH1cbn1dO1xudmFyIERFRkFVTFRfRVhURVJOQUxfTElCUkFSSUVTID0ge1xuICBzZWVUaHJ1OiAnaHR0cHM6Ly91bnBrZy5jb20vc2VldGhydUA0L2Rpc3Qvc2VlVGhydS5taW4uanMnXG59O1xuXG4vKipcbiAqIFByZWRlZmluZWQgcGxhY2Vob2xkZXIgdHJhbnNmb3JtYXRpb25zXG4gKiBAY29uc3Qge09iamVjdH0gQ2xvdWRpbmFyeS5QTEFDRUhPTERFUl9JTUFHRV9NT0RFU1xuICovXG52YXIgUExBQ0VIT0xERVJfSU1BR0VfTU9ERVMgPSB7XG4gICdibHVyJzogW3tcbiAgICBlZmZlY3Q6ICdibHVyOjIwMDAnLFxuICAgIHF1YWxpdHk6IDEsXG4gICAgZmV0Y2hfZm9ybWF0OiAnYXV0bydcbiAgfV0sXG4gIC8vIERlZmF1bHRcbiAgJ3BpeGVsYXRlJzogW3tcbiAgICBlZmZlY3Q6ICdwaXhlbGF0ZScsXG4gICAgcXVhbGl0eTogMSxcbiAgICBmZXRjaF9mb3JtYXQ6ICdhdXRvJ1xuICB9XSxcbiAgLy8gR2VuZXJhdGVzIGEgcGl4ZWwgc2l6ZSBpbWFnZSB3aGljaCBjb2xvciBpcyB0aGUgcHJlZG9taW5hbnQgY29sb3Igb2YgdGhlIG9yaWdpbmFsIGltYWdlLlxuICAncHJlZG9taW5hbnQtY29sb3ItcGl4ZWwnOiBbe1xuICAgIHdpZHRoOiAnaXdfZGl2XzInLFxuICAgIGFzcGVjdF9yYXRpbzogMSxcbiAgICBjcm9wOiAncGFkJyxcbiAgICBiYWNrZ3JvdW5kOiAnYXV0bydcbiAgfSwge1xuICAgIGNyb3A6ICdjcm9wJyxcbiAgICB3aWR0aDogMSxcbiAgICBoZWlnaHQ6IDEsXG4gICAgZ3Jhdml0eTogJ25vcnRoX2Vhc3QnXG4gIH0sIHtcbiAgICBmZXRjaF9mb3JtYXQ6ICdhdXRvJyxcbiAgICBxdWFsaXR5OiAnYXV0bydcbiAgfV0sXG4gIC8vIEdlbmVyYXRlcyBhbiBpbWFnZSB3aGljaCBjb2xvciBpcyB0aGUgcHJlZG9taW5hbnQgY29sb3Igb2YgdGhlIG9yaWdpbmFsIGltYWdlLlxuICAncHJlZG9taW5hbnQtY29sb3InOiBbe1xuICAgIHZhcmlhYmxlczogW1snJGN1cnJXaWR0aCcsICd3J10sIFsnJGN1cnJIZWlnaHQnLCAnaCddXVxuICB9LCB7XG4gICAgd2lkdGg6ICdpd19kaXZfMicsXG4gICAgYXNwZWN0X3JhdGlvOiAxLFxuICAgIGNyb3A6ICdwYWQnLFxuICAgIGJhY2tncm91bmQ6ICdhdXRvJ1xuICB9LCB7XG4gICAgY3JvcDogJ2Nyb3AnLFxuICAgIHdpZHRoOiAxMCxcbiAgICBoZWlnaHQ6IDEwLFxuICAgIGdyYXZpdHk6ICdub3J0aF9lYXN0J1xuICB9LCB7XG4gICAgd2lkdGg6ICckY3VycldpZHRoJyxcbiAgICBoZWlnaHQ6ICckY3VyckhlaWdodCcsXG4gICAgY3JvcDogJ2ZpbGwnXG4gIH0sIHtcbiAgICBmZXRjaF9mb3JtYXQ6ICdhdXRvJyxcbiAgICBxdWFsaXR5OiAnYXV0bydcbiAgfV0sXG4gICd2ZWN0b3JpemUnOiBbe1xuICAgIGVmZmVjdDogJ3ZlY3Rvcml6ZTozOjAuMScsXG4gICAgZmV0Y2hfZm9ybWF0OiAnc3ZnJ1xuICB9XVxufTtcblxuLyoqXG4gKiBQcmVkZWZpbmVkIGFjY2Vzc2liaWxpdHkgdHJhbnNmb3JtYXRpb25zXG4gKiBAY29uc3Qge09iamVjdH0gQ2xvdWRpbmFyeS5BQ0NFU1NJQklMSVRZX01PREVTXG4gKi9cbnZhciBBQ0NFU1NJQklMSVRZX01PREVTID0ge1xuICBkYXJrbW9kZTogJ3RpbnQ6NzU6YmxhY2snLFxuICBicmlnaHRtb2RlOiAndGludDo1MDp3aGl0ZScsXG4gIG1vbm9jaHJvbWU6ICdncmF5c2NhbGUnLFxuICBjb2xvcmJsaW5kOiAnYXNzaXN0X2NvbG9yYmxpbmQnXG59O1xuXG4vKipcbiAqIEEgbGlzdCBvZiBrZXlzIHVzZWQgYnkgdGhlIHVybCgpIGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xudmFyIFVSTF9LRVlTID0gWydhY2Nlc3NpYmlsaXR5JywgJ2FwaV9zZWNyZXQnLCAnYXV0aF90b2tlbicsICdjZG5fc3ViZG9tYWluJywgJ2Nsb3VkX25hbWUnLCAnY25hbWUnLCAnZm9ybWF0JywgJ3BsYWNlaG9sZGVyJywgJ3ByaXZhdGVfY2RuJywgJ3Jlc291cmNlX3R5cGUnLCAnc2VjdXJlJywgJ3NlY3VyZV9jZG5fc3ViZG9tYWluJywgJ3NlY3VyZV9kaXN0cmlidXRpb24nLCAnc2hvcnRlbicsICdzaWduX3VybCcsICdzaWduYXR1cmUnLCAnc3NsX2RldGVjdGVkJywgJ3R5cGUnLCAndXJsX3N1ZmZpeCcsICd1c2Vfcm9vdF9wYXRoJywgJ3ZlcnNpb24nXTtcblxuLyoqXG4gKiBUaGUgcmVzb3VyY2Ugc3RvcmFnZSB0eXBlXG4gKiBAdHlwZWRlZiB0eXBlXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQHByb3BlcnR5ICB7c3RyaW5nfSAndXBsb2FkJyBBIHJlc291cmNlIHVwbG9hZGVkIGRpcmVjdGx5IHRvIENsb3VkaW5hcnlcbiAqIEBwcm9wZXJ0eSAge3N0cmluZ30gJ2ZldGNoJyBBIHJlc291cmNlIGZldGNoZWQgYnkgQ2xvdWRpbmFyeSBmcm9tIGEgM3JkIHBhcnR5IHN0b3JhZ2VcbiAqIEBwcm9wZXJ0eSAge3N0cmluZ30gJ3ByaXZhdGUnXG4gKiBAcHJvcGVydHkgIHtzdHJpbmd9ICdhdXRoZW50aWNhdGVkJ1xuICogQHByb3BlcnR5ICB7c3RyaW5nfSAnc3ByaXRlJ1xuICogQHByb3BlcnR5ICB7c3RyaW5nfSAnZmFjZWJvb2snXG4gKiBAcHJvcGVydHkgIHtzdHJpbmd9ICd0d2l0dGVyJ1xuICogQHByb3BlcnR5ICB7c3RyaW5nfSAneW91dHViZSdcbiAqIEBwcm9wZXJ0eSAge3N0cmluZ30gJ3ZpbWVvJ1xuICpcbiAqL1xuXG4vKipcbiAqIFRoZSByZXNvdXJjZSB0eXBlXG4gKiBAdHlwZWRlZiByZXNvdXJjZVR5cGVcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gJ2ltYWdlJyBBbiBpbWFnZSBmaWxlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gJ3ZpZGVvJyBBIHZpZGVvIGZpbGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAncmF3JyAgIEEgcmF3IGZpbGVcbiAqL1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9iYXNldXRpbC5qc1xuZnVuY3Rpb24gYmFzZXV0aWxfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gYmFzZXV0aWxfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIGJhc2V1dGlsX3R5cGVvZihvKTsgfVxuLypcbiAqIEluY2x1ZGVzIGNvbW1vbiB1dGlsaXR5IG1ldGhvZHMgYW5kIHNoaW1zXG4gKi9cblxuXG5mdW5jdGlvbiBvbWl0KG9iaiwga2V5cykge1xuICBvYmogPSBvYmogfHwge307XG4gIHZhciBzcmNLZXlzID0gT2JqZWN0LmtleXMob2JqKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0KCkoa2V5cywga2V5KTtcbiAgfSk7XG4gIHZhciBmaWx0ZXJlZCA9IHt9O1xuICBzcmNLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBmaWx0ZXJlZFtrZXldID0gb2JqW2tleV07XG4gIH0pO1xuICByZXR1cm4gZmlsdGVyZWQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgYWxsIGl0ZW1zIGluIGxpc3QgYXJlIHN0cmluZ3NcbiAqIEBmdW5jdGlvbiBVdGlsLmFsbFN0cmluZ1xuICogQHBhcmFtIHtBcnJheX0gbGlzdCAtIGFuIGFycmF5IG9mIGl0ZW1zXG4gKi9cbnZhciBiYXNldXRpbF9hbGxTdHJpbmdzID0gZnVuY3Rpb24gYWxsU3RyaW5ncyhsaXN0KSB7XG4gIHJldHVybiBsaXN0Lmxlbmd0aCAmJiBsaXN0LmV2ZXJ5KGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdC5hKTtcbn07XG5cbi8qKlxuKiBDcmVhdGVzIGEgbmV3IGFycmF5IHdpdGhvdXQgdGhlIGdpdmVuIGl0ZW0uXG4qIEBmdW5jdGlvbiBVdGlsLndpdGhvdXRcbiogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBvcmlnaW5hbCBhcnJheVxuKiBAcGFyYW0geyp9IGl0ZW0gLSB0aGUgaXRlbSB0byBleGNsdWRlIGZyb20gdGhlIG5ldyBhcnJheVxuKiBAcmV0dXJuIHtBcnJheX0gYSBuZXcgYXJyYXkgbWFkZSBvZiB0aGUgb3JpZ2luYWwgYXJyYXkncyBpdGVtcyBleGNlcHQgZm9yIGBpdGVtYFxuICovXG52YXIgd2l0aG91dCA9IGZ1bmN0aW9uIHdpdGhvdXQoYXJyYXksIGl0ZW0pIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcihmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2ICE9PSBpdGVtO1xuICB9KTtcbn07XG5cbi8qKlxuKiBSZXR1cm4gdHJ1ZSBpcyB2YWx1ZSBpcyBhIG51bWJlciBvciBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG51bWJlci5cbiogQGZ1bmN0aW9uIFV0aWwuaXNOdW1iZXJMaWtlXG4qIEBwYXJhbSB7Kn0gdmFsdWVcbiogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdmFsdWUgaXMgYSBudW1iZXJcbiogQGV4YW1wbGVcbiogICAgVXRpbC5pc051bWJlcigwKSAvLyB0cnVlXG4qICAgIFV0aWwuaXNOdW1iZXIoXCIxLjNcIikgLy8gdHJ1ZVxuKiAgICBVdGlsLmlzTnVtYmVyKFwiXCIpIC8vIGZhbHNlXG4qICAgIFV0aWwuaXNOdW1iZXIodW5kZWZpbmVkKSAvLyBmYWxzZVxuICovXG52YXIgaXNOdW1iZXJMaWtlID0gZnVuY3Rpb24gaXNOdW1iZXJMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICFpc05hTihwYXJzZUZsb2F0KHZhbHVlKSk7XG59O1xuXG4vKipcbiAqIEVzY2FwZSBhbGwgY2hhcmFjdGVycyBtYXRjaGluZyB1bnNhZmUgaW4gdGhlIGdpdmVuIHN0cmluZ1xuICogQGZ1bmN0aW9uIFV0aWwuc21hcnRFc2NhcGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBzb3VyY2Ugc3RyaW5nIHRvIGVzY2FwZVxuICogQHBhcmFtIHtSZWdFeHB9IHVuc2FmZSAtIGNoYXJhY3RlcnMgdGhhdCBtdXN0IGJlIGVzY2FwZWRcbiAqIEByZXR1cm4ge3N0cmluZ30gZXNjYXBlZCBzdHJpbmdcbiAqL1xudmFyIHNtYXJ0RXNjYXBlID0gZnVuY3Rpb24gc21hcnRFc2NhcGUoc3RyaW5nKSB7XG4gIHZhciB1bnNhZmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IC8oW15hLXpBLVowLTlfLlxcLVxcLzpdKykvZztcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHVuc2FmZSwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIG1hdGNoLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIFwiJVwiICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBc3NpZ24gdmFsdWVzIGZyb20gc291cmNlcyBpZiB0aGV5IGFyZSBub3QgZGVmaW5lZCBpbiB0aGUgZGVzdGluYXRpb24uXG4gKiBPbmNlIGEgdmFsdWUgaXMgc2V0IGl0IGRvZXMgbm90IGNoYW5nZVxuICogQGZ1bmN0aW9uIFV0aWwuZGVmYXVsdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvbiAtIHRoZSBvYmplY3QgdG8gYXNzaWduIGRlZmF1bHRzIHRvXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlIC0gdGhlIHNvdXJjZSBvYmplY3QocykgdG8gYXNzaWduIGRlZmF1bHRzIGZyb21cbiAqIEByZXR1cm4ge09iamVjdH0gZGVzdGluYXRpb24gYWZ0ZXIgaXQgd2FzIG1vZGlmaWVkXG4gKi9cbnZhciBkZWZhdWx0cyA9IGZ1bmN0aW9uIGRlZmF1bHRzKGRlc3RpbmF0aW9uKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzb3VyY2VzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gc291cmNlcy5yZWR1Y2UoZnVuY3Rpb24gKGRlc3QsIHNvdXJjZSkge1xuICAgIHZhciBrZXksIHZhbHVlO1xuICAgIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgICAgdmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgIGlmIChkZXN0W2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICBkZXN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH0sIGRlc3RpbmF0aW9uKTtcbn07XG5cbi8qKioqKioqKioqKiBsb2Rhc2ggZnVuY3Rpb25zICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXG4gKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4jaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiNpc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiNpc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlO1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdHlwZSA9IGJhc2V1dGlsX3R5cGVvZih2YWx1ZSk7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn07XG52YXIgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbi8qKlxuKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4qIEBmdW5jdGlvbiBVdGlsLmlzRnVuY3Rpb25cbiogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4qIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4qIEBleGFtcGxlXG4qXG4qIGZ1bmN0aW9uIEZvbygpe307XG4qIGlzRnVuY3Rpb24oRm9vKTtcbiogLy8gPT4gdHJ1ZVxuKlxuKiBpc0Z1bmN0aW9uKC9hYmMvKTtcbiogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaSB3aGljaCByZXR1cm4gJ2Z1bmN0aW9uJyBmb3IgcmVnZXhlc1xuICAvLyBhbmQgU2FmYXJpIDggd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLlxuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBmdW5jVGFnO1xufTtcblxuLyoqKioqKioqKioqIGxvZGFzaCBmdW5jdGlvbnMgKi9cbi8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIHRvIGNyZWF0ZSBjb21wb3VuZCB3b3Jkcy4gKi9cbnZhciByZVdvcmRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbG93ZXIsIHVwcGVyO1xuICB1cHBlciA9ICdbQS1aXSc7XG4gIGxvd2VyID0gJ1thLXpdKyc7XG4gIHJldHVybiBSZWdFeHAodXBwZXIgKyAnKyg/PScgKyB1cHBlciArIGxvd2VyICsgJyl8JyArIHVwcGVyICsgJz8nICsgbG93ZXIgKyAnfCcgKyB1cHBlciArICcrfFswLTldKycsICdnJyk7XG59KCk7XG5cbi8qKlxuKiBDb252ZXJ0IHN0cmluZyB0byBjYW1lbENhc2VcbiogQGZ1bmN0aW9uIFV0aWwuY2FtZWxDYXNlXG4qIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgLSB0aGUgc3RyaW5nIHRvIGNvbnZlcnRcbiogQHJldHVybiB7c3RyaW5nfSBpbiBjYW1lbENhc2UgZm9ybWF0XG4gKi9cbnZhciBjYW1lbENhc2UgPSBmdW5jdGlvbiBjYW1lbENhc2Uoc291cmNlKSB7XG4gIHZhciB3b3JkcyA9IHNvdXJjZS5tYXRjaChyZVdvcmRzKTtcbiAgd29yZHMgPSB3b3Jkcy5tYXAoZnVuY3Rpb24gKHdvcmQpIHtcbiAgICByZXR1cm4gd29yZC5jaGFyQXQoMCkudG9Mb2NhbGVVcHBlckNhc2UoKSArIHdvcmQuc2xpY2UoMSkudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgfSk7XG4gIHdvcmRzWzBdID0gd29yZHNbMF0udG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgcmV0dXJuIHdvcmRzLmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHN0cmluZyB0byBzbmFrZV9jYXNlXG4gKiBAZnVuY3Rpb24gVXRpbC5zbmFrZUNhc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgLSB0aGUgc3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge3N0cmluZ30gaW4gc25ha2VfY2FzZSBmb3JtYXRcbiAqL1xudmFyIHNuYWtlQ2FzZSA9IGZ1bmN0aW9uIHNuYWtlQ2FzZShzb3VyY2UpIHtcbiAgdmFyIHdvcmRzID0gc291cmNlLm1hdGNoKHJlV29yZHMpO1xuICB3b3JkcyA9IHdvcmRzLm1hcChmdW5jdGlvbiAod29yZCkge1xuICAgIHJldHVybiB3b3JkLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gIH0pO1xuICByZXR1cm4gd29yZHMuam9pbignXycpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCBmcm9tIHNvdXJjZSwgd2l0aCB0aGUga2V5cyB0cmFuc2Zvcm1lZCB1c2luZyB0aGUgY29udmVydGVyLlxuICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZVxuICogQHBhcmFtIHtmdW5jdGlvbnxudWxsfSBjb252ZXJ0ZXJcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbnZhciBjb252ZXJ0S2V5cyA9IGZ1bmN0aW9uIGNvbnZlcnRLZXlzKHNvdXJjZSwgY29udmVydGVyKSB7XG4gIHZhciByZXN1bHQsIHZhbHVlO1xuICByZXN1bHQgPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIHZhbHVlID0gc291cmNlW2tleV07XG4gICAgaWYgKGNvbnZlcnRlcikge1xuICAgICAga2V5ID0gY29udmVydGVyKGtleSk7XG4gICAgfVxuICAgIGlmICghaXNFbXB0eShrZXkpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBjb3B5IG9mIHRoZSBzb3VyY2Ugb2JqZWN0IHdpdGggYWxsIGtleXMgaW4gY2FtZWxDYXNlXG4gKiBAZnVuY3Rpb24gVXRpbC53aXRoQ2FtZWxDYXNlS2V5c1xuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIC0gdGhlIG9iamVjdCB0byBjb3B5XG4gKiBAcmV0dXJuIHtPYmplY3R9IGEgbmV3IG9iamVjdFxuICovXG52YXIgd2l0aENhbWVsQ2FzZUtleXMgPSBmdW5jdGlvbiB3aXRoQ2FtZWxDYXNlS2V5cyhzb3VyY2UpIHtcbiAgcmV0dXJuIGNvbnZlcnRLZXlzKHNvdXJjZSwgY2FtZWxDYXNlKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgY29weSBvZiB0aGUgc291cmNlIG9iamVjdCB3aXRoIGFsbCBrZXlzIGluIHNuYWtlX2Nhc2VcbiAqIEBmdW5jdGlvbiBVdGlsLndpdGhTbmFrZUNhc2VLZXlzXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSB0aGUgb2JqZWN0IHRvIGNvcHlcbiAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0XG4gKi9cbnZhciB3aXRoU25ha2VDYXNlS2V5cyA9IGZ1bmN0aW9uIHdpdGhTbmFrZUNhc2VLZXlzKHNvdXJjZSkge1xuICByZXR1cm4gY29udmVydEtleXMoc291cmNlLCBzbmFrZUNhc2UpO1xufTtcblxuLy8gQnJvd3NlclxuLy8gTm9kZS5qc1xudmFyIGJhc2U2NEVuY29kZSA9IHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJyAmJiBpc0Z1bmN0aW9uKGJ0b2EpID8gYnRvYSA6IHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGlzRnVuY3Rpb24oQnVmZmVyKSA/IGZ1bmN0aW9uIChpbnB1dCkge1xuICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICBpbnB1dCA9IG5ldyBCdWZmZXIuZnJvbShTdHJpbmcoaW5wdXQpLCAnYmluYXJ5Jyk7XG4gIH1cbiAgcmV0dXJuIGlucHV0LnRvU3RyaW5nKCdiYXNlNjQnKTtcbn0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYmFzZTY0IGVuY29kaW5nIGZ1bmN0aW9uIGZvdW5kXCIpO1xufTtcblxuLyoqXG4qIFJldHVybnMgdGhlIEJhc2U2NC1kZWNvZGVkIHZlcnNpb24gb2YgdXJsLjxicj5cbiogVGhpcyBtZXRob2QgZGVsZWdhdGVzIHRvIGBidG9hYCBpZiBwcmVzZW50LiBPdGhlcndpc2UgaXQgdHJpZXMgYEJ1ZmZlcmAuXG4qIEBmdW5jdGlvbiBVdGlsLmJhc2U2NEVuY29kZVVSTFxuKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gdGhlIHVybCB0byBlbmNvZGUuIHRoZSB2YWx1ZSBpcyBVUklkZWNvZGVkIGFuZCB0aGVuIHJlLWVuY29kZWQgYmVmb3JlIGNvbnZlcnRpbmcgdG8gYmFzZTY0IHJlcHJlc2VudGF0aW9uXG4qIEByZXR1cm4ge3N0cmluZ30gdGhlIGJhc2U2NCByZXByZXNlbnRhdGlvbiBvZiB0aGUgVVJMXG4gKi9cbnZhciBiYXNlNjRFbmNvZGVVUkwgPSBmdW5jdGlvbiBiYXNlNjRFbmNvZGVVUkwodXJsKSB7XG4gIHRyeSB7XG4gICAgdXJsID0gZGVjb2RlVVJJKHVybCk7XG4gIH0gZmluYWxseSB7XG4gICAgdXJsID0gZW5jb2RlVVJJKHVybCk7XG4gIH1cbiAgcmV0dXJuIGJhc2U2NEVuY29kZSh1cmwpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggb25seSBVUkwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgVGhlIHNvdXJjZSBvYmplY3RcbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgb25seSBVUkwgcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiBleHRyYWN0VXJsUGFyYW1zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIFVSTF9LRVlTLnJlZHVjZShmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICBpZiAob3B0aW9uc1trZXldICE9IG51bGwpIHtcbiAgICAgIG9ialtrZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9LCB7fSk7XG59XG5cbi8qKlxuICogSGFuZGxlIHRoZSBmb3JtYXQgcGFyYW1ldGVyIGZvciBmZXRjaCB1cmxzXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIG9wdGlvbnMgdXJsIGFuZCB0cmFuc2Zvcm1hdGlvbiBvcHRpb25zLiBUaGlzIGFyZ3VtZW50IG1heSBiZSBjaGFuZ2VkIGJ5IHRoZSBmdW5jdGlvbiFcbiAqL1xuZnVuY3Rpb24gcGF0Y2hGZXRjaEZvcm1hdChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKG9wdGlvbnMudHlwZSA9PT0gXCJmZXRjaFwiKSB7XG4gICAgaWYgKG9wdGlvbnMuZmV0Y2hfZm9ybWF0ID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMuZmV0Y2hfZm9ybWF0ID0gb3B0aW9uQ29uc3VtZShvcHRpb25zLCBcImZvcm1hdFwiKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEZWxldGVzIGBvcHRpb25fbmFtZWAgZnJvbSBgb3B0aW9uc2AgYW5kIHJldHVybiB0aGUgdmFsdWUgaWYgcHJlc2VudC5cbiAqIElmIGBvcHRpb25zYCBkb2Vzbid0IGNvbnRhaW4gYG9wdGlvbl9uYW1lYCB0aGUgZGVmYXVsdCB2YWx1ZSBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGEgY29sbGVjdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbl9uYW1lIHRoZSBuYW1lIChrZXkpIG9mIHRoZSBkZXNpcmVkIHZhbHVlXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0X3ZhbHVlXSB0aGUgdmFsdWUgdG8gcmV0dXJuIGlzIG9wdGlvbl9uYW1lIGlzIG1pc3NpbmdcbiAqL1xuZnVuY3Rpb24gb3B0aW9uQ29uc3VtZShvcHRpb25zLCBvcHRpb25fbmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb3B0aW9uc1tvcHRpb25fbmFtZV07XG4gIGRlbGV0ZSBvcHRpb25zW29wdGlvbl9uYW1lXTtcbiAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGVmYXVsdF92YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBlbXB0eTpcbiAqIDx1bD5cbiAqICAgPGxpPnZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkPC9saT5cbiAqICAgPGxpPnZhbHVlIGlzIGFuIGFycmF5IG9yIHN0cmluZyBvZiBsZW5ndGggMDwvbGk+XG4gKiAgIDxsaT52YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBubyBrZXlzPC9saT5cbiAqIDwvdWw+XG4gKiBAZnVuY3Rpb24gVXRpbC5pc0VtcHR5XG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHZhbHVlIGlzIGVtcHR5XG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlLmxlbmd0aCA9PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlLnNpemUgPT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiB2YWx1ZS5zaXplID09PSAwO1xuICB9XG4gIGlmIChiYXNldXRpbF90eXBlb2YodmFsdWUpID09IFwib2JqZWN0XCIpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2Jyb3dzZXIuanNcbi8qKlxuICogQmFzZWQgb24gdmlkZW8uanMgaW1wbGVtZW50YXRpb246XG4gKiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9ibG9iLzQyMzhmNWMxZDg4ODkwNTQ3MTUzZTdlMWRlN2JkMGQxZDhlMGIyMzYvc3JjL2pzL3V0aWxzL2Jyb3dzZXIuanNcbiAqL1xuXG4vKipcbiogUmV0cmlldmUgZnJvbSB0aGUgbmF2aWdhdG9yIHRoZSB1c2VyIGFnZW50IHByb3BlcnR5LlxuKiBAcmV0dXJucyB1c2VyIGFnZW50IHByb3BlcnR5LlxuKi9cbmZ1bmN0aW9uIGdldFVzZXJBZ2VudCgpIHtcbiAgcmV0dXJuIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xufVxuXG4vKipcbiAqIERldGVjdCBpZiBjdXJyZW50IGJyb3dzZXIgaXMgYW55IEFuZHJvaWRcbiAqIEByZXR1cm5zIHRydWUgaWYgY3VycmVudCBicm93c2VyIGlzIEFuZHJvaWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNBbmRyb2lkKCkge1xuICB2YXIgdXNlckFnZW50ID0gZ2V0VXNlckFnZW50KCk7XG4gIHJldHVybiAvQW5kcm9pZC9pLnRlc3QodXNlckFnZW50KTtcbn1cblxuLyoqXG4gKiBEZXRlY3QgaWYgY3VycmVudCBicm93c2VyIGlzIGFueSBFZGdlXG4gKiBAcmV0dXJucyB0cnVlIGlmIGN1cnJlbnQgYnJvd3NlciBpcyBFZGdlLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzRWRnZSgpIHtcbiAgdmFyIHVzZXJBZ2VudCA9IGdldFVzZXJBZ2VudCgpO1xuICByZXR1cm4gL0VkZy9pLnRlc3QodXNlckFnZW50KTtcbn1cblxuLyoqXG4gKiBEZXRlY3QgaWYgY3VycmVudCBicm93c2VyIGlzIGNocm9tZS5cbiAqIEByZXR1cm5zIHRydWUgaWYgY3VycmVudCBicm93c2VyIGlzIENocm9tZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0Nocm9tZSgpIHtcbiAgdmFyIHVzZXJBZ2VudCA9IGdldFVzZXJBZ2VudCgpO1xuICByZXR1cm4gIWlzRWRnZSgpICYmICgvQ2hyb21lL2kudGVzdCh1c2VyQWdlbnQpIHx8IC9DcmlPUy9pLnRlc3QodXNlckFnZW50KSk7XG59XG5cbi8qKlxuICogRGV0ZWN0IGlmIGN1cnJlbnQgYnJvd3NlciBpcyBTYWZhcmkuXG4gKiBAcmV0dXJucyB0cnVlIGlmIGN1cnJlbnQgYnJvd3NlciBpcyBTYWZhcmksIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gIC8vIFVzZXIgYWdlbnRzIGZvciBvdGhlciBicm93c2VycyBtaWdodCBpbmNsdWRlIFwiU2FmYXJpXCIgc28gd2UgbXVzdCBleGNsdWRlIHRoZW0uXG4gIC8vIEZvciBleGFtcGxlIC0gdGhpcyBpcyB0aGUgY2hyb21lIHVzZXIgYWdlbnQgb24gd2luZG93cyAxMDpcbiAgLy8gTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzk2LjAuNDY2NC4xMTAgU2FmYXJpLzUzNy4zNlxuICB2YXIgdXNlckFnZW50ID0gZ2V0VXNlckFnZW50KCk7XG4gIHJldHVybiAvU2FmYXJpL2kudGVzdCh1c2VyQWdlbnQpICYmICFpc0Nocm9tZSgpICYmICFpc0FuZHJvaWQoKSAmJiAhaXNFZGdlKCk7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2xvZGFzaC5qc1xudmFyIG5vZGVDb250YWlucztcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKlxuICogSW5jbHVkZXMgdXRpbGl0eSBtZXRob2RzIGFuZCBsb2Rhc2ggLyBqUXVlcnkgc2hpbXNcbiAqL1xuLyoqXG4gKiBHZXQgZGF0YSBmcm9tIHRoZSBET00gZWxlbWVudC5cbiAqXG4gKiBUaGlzIG1ldGhvZCB3aWxsIHVzZSBqUXVlcnkncyBgZGF0YSgpYCBtZXRob2QgaWYgaXQgaXMgYXZhaWxhYmxlLCBvdGhlcndpc2UgaXQgd2lsbCBnZXQgdGhlIGBkYXRhLWAgYXR0cmlidXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBnZXQgdGhlIGRhdGEgZnJvbVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgZGF0YSBpdGVtXG4gKiBAcmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBgbmFtZWBcbiAqIEBmdW5jdGlvbiBVdGlsLmdldERhdGFcbiAqL1xudmFyIGxvZGFzaF9nZXREYXRhID0gZnVuY3Rpb24gZ2V0RGF0YShlbGVtZW50LCBuYW1lKSB7XG4gIHN3aXRjaCAoZmFsc2UpIHtcbiAgICBjYXNlICEoZWxlbWVudCA9PSBudWxsKTpcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuZ2V0QXR0cmlidXRlKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtXCIuY29uY2F0KG5hbWUpKTtcbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5nZXRBdHRyKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHIoXCJkYXRhLVwiLmNvbmNhdChuYW1lKSk7XG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuZGF0YSk6XG4gICAgICByZXR1cm4gZWxlbWVudC5kYXRhKG5hbWUpO1xuICAgIGNhc2UgIShpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkodHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZm4gJiYgalF1ZXJ5LmZuLmRhdGEpICYmIGlzRWxlbWVudF9yb290X2lzRWxlbWVudF9kZWZhdWx0KCkoZWxlbWVudCkpOlxuICAgICAgcmV0dXJuIGpRdWVyeShlbGVtZW50KS5kYXRhKG5hbWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBkYXRhIGluIHRoZSBET00gZWxlbWVudC5cbiAqXG4gKiBUaGlzIG1ldGhvZCB3aWxsIHVzZSBqUXVlcnkncyBgZGF0YSgpYCBtZXRob2QgaWYgaXQgaXMgYXZhaWxhYmxlLCBvdGhlcndpc2UgaXQgd2lsbCBzZXQgdGhlIGBkYXRhLWAgYXR0cmlidXRlXG4gKiBAZnVuY3Rpb24gVXRpbC5zZXREYXRhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGRhdGEgaW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGRhdGEgaXRlbVxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBiZSBzZXRcbiAqXG4gKi9cbnZhciBsb2Rhc2hfc2V0RGF0YSA9IGZ1bmN0aW9uIHNldERhdGEoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgc3dpdGNoIChmYWxzZSkge1xuICAgIGNhc2UgIShlbGVtZW50ID09IG51bGwpOlxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5zZXRBdHRyaWJ1dGUpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1cIi5jb25jYXQobmFtZSksIHZhbHVlKTtcbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5zZXRBdHRyKTpcbiAgICAgIHJldHVybiBlbGVtZW50LnNldEF0dHIoXCJkYXRhLVwiLmNvbmNhdChuYW1lKSwgdmFsdWUpO1xuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LmRhdGEpOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuZGF0YShuYW1lLCB2YWx1ZSk7XG4gICAgY2FzZSAhKGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKSh0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5mbiAmJiBqUXVlcnkuZm4uZGF0YSkgJiYgaXNFbGVtZW50X3Jvb3RfaXNFbGVtZW50X2RlZmF1bHQoKShlbGVtZW50KSk6XG4gICAgICByZXR1cm4galF1ZXJ5KGVsZW1lbnQpLmRhdGEobmFtZSwgdmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBhdHRyaWJ1dGUgZnJvbSB0aGUgRE9NIGVsZW1lbnQuXG4gKlxuICogQGZ1bmN0aW9uIFV0aWwuZ2V0QXR0cmlidXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGF0dHJpYnV0ZSBmb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICogQHJldHVybnMgeyp9IHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlXG4gKlxuICovXG52YXIgbG9kYXNoX2dldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZShlbGVtZW50LCBuYW1lKSB7XG4gIHN3aXRjaCAoZmFsc2UpIHtcbiAgICBjYXNlICEoZWxlbWVudCA9PSBudWxsKTpcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuZ2V0QXR0cmlidXRlKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5hdHRyKTpcbiAgICAgIHJldHVybiBlbGVtZW50LmF0dHIobmFtZSk7XG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuZ2V0QXR0cik6XG4gICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyKG5hbWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBhdHRyaWJ1dGUgaW4gdGhlIERPTSBlbGVtZW50LlxuICpcbiAqIEBmdW5jdGlvbiBVdGlsLnNldEF0dHJpYnV0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBhdHRyaWJ1dGUgZm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gYmUgc2V0XG4gKi9cbnZhciBsb2Rhc2hfc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gc2V0QXR0cmlidXRlKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gIHN3aXRjaCAoZmFsc2UpIHtcbiAgICBjYXNlICEoZWxlbWVudCA9PSBudWxsKTpcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuc2V0QXR0cmlidXRlKTpcbiAgICAgIHJldHVybiBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgY2FzZSAhaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCgpKGVsZW1lbnQuYXR0cik6XG4gICAgICByZXR1cm4gZWxlbWVudC5hdHRyKG5hbWUsIHZhbHVlKTtcbiAgICBjYXNlICFpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZWxlbWVudC5zZXRBdHRyKTpcbiAgICAgIHJldHVybiBlbGVtZW50LnNldEF0dHIobmFtZSwgdmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBhdHRyaWJ1dGUgaW4gdGhlIERPTSBlbGVtZW50LlxuICpcbiAqIEBmdW5jdGlvbiBVdGlsLnJlbW92ZUF0dHJpYnV0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBhdHRyaWJ1dGUgZm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcbiAqL1xudmFyIGxvZGFzaF9yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSkge1xuICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgY2FzZSAhKGVsZW1lbnQgPT0gbnVsbCk6XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIGNhc2UgIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKShlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSk6XG4gICAgICByZXR1cm4gZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBsb2Rhc2hfc2V0QXR0cmlidXRlKGVsZW1lbnQsIHZvaWQgMCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IGEgZ3JvdXAgb2YgYXR0cmlidXRlcyB0byB0aGUgZWxlbWVudFxuICogQGZ1bmN0aW9uIFV0aWwuc2V0QXR0cmlidXRlc1xuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBhdHRyaWJ1dGVzIGZvclxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBhIGhhc2ggb2YgYXR0cmlidXRlIG5hbWVzIGFuZCB2YWx1ZXNcbiAqL1xudmFyIHNldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIG5hbWUsIHJlc3VsdHMsIHZhbHVlO1xuICByZXN1bHRzID0gW107XG4gIGZvciAobmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXN1bHRzLnB1c2gobG9kYXNoX3NldEF0dHJpYnV0ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRzLnB1c2gobG9kYXNoX3JlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCBuYW1lKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgZWxlbWVudCBoYXMgYSBjc3MgY2xhc3NcbiAqIEBmdW5jdGlvbiBVdGlsLmhhc0NsYXNzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudCB0byBjaGVja1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgY2xhc3MgbmFtZVxuIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBlbGVtZW50IGhhcyB0aGUgY2xhc3NcbiAqL1xudmFyIGxvZGFzaF9oYXNDbGFzcyA9IGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIG5hbWUpIHtcbiAgaWYgKGlzRWxlbWVudF9yb290X2lzRWxlbWVudF9kZWZhdWx0KCkoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc05hbWUubWF0Y2gobmV3IFJlZ0V4cChcIlxcXFxiXCIuY29uY2F0KG5hbWUsIFwiXFxcXGJcIikpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBZGQgY2xhc3MgdG8gdGhlIGVsZW1lbnRcbiAqIEBmdW5jdGlvbiBVdGlsLmFkZENsYXNzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgY2xhc3MgbmFtZSB0byBhZGRcbiAqL1xudmFyIGxvZGFzaF9hZGRDbGFzcyA9IGZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIG5hbWUpIHtcbiAgaWYgKCFlbGVtZW50LmNsYXNzTmFtZS5tYXRjaChuZXcgUmVnRXhwKFwiXFxcXGJcIi5jb25jYXQobmFtZSwgXCJcXFxcYlwiKSkpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NOYW1lID0gdHJpbV9yb290X3RyaW1fZGVmYXVsdCgpKFwiXCIuY29uY2F0KGVsZW1lbnQuY2xhc3NOYW1lLCBcIiBcIikuY29uY2F0KG5hbWUpKTtcbiAgfVxufTtcblxuLy8gVGhlIGZvbGxvd2luZyBjb2RlIGlzIHRha2VuIGZyb20galF1ZXJ5XG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24gZ2V0U3R5bGVzKGVsZW0pIHtcbiAgLy8gU3VwcG9ydDogSUU8PTExKywgRmlyZWZveDw9MzArICgjMTUwOTgsICMxNDE1MClcbiAgLy8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG4gIC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuICBpZiAoZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3Lm9wZW5lcikge1xuICAgIHJldHVybiBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKTtcbiAgfVxuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSwgbnVsbCk7XG59O1xudmFyIGNzc0V4cGFuZCA9IFtcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiXTtcbm5vZGVDb250YWlucyA9IGZ1bmN0aW9uIG5vZGVDb250YWlucyhhLCBiKSB7XG4gIHZhciBhZG93biwgYnVwO1xuICBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGE7XG4gIGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuICByZXR1cm4gYSA9PT0gYnVwIHx8ICEhKGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgYWRvd24uY29udGFpbnMoYnVwKSk7XG59O1xuXG4vLyBUcnVuY2F0ZWQgdmVyc2lvbiBvZiBqUXVlcnkuc3R5bGUoZWxlbSwgbmFtZSlcbnZhciBkb21TdHlsZSA9IGZ1bmN0aW9uIGRvbVN0eWxlKGVsZW0sIG5hbWUpIHtcbiAgaWYgKCEoIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlKSkge1xuICAgIHJldHVybiBlbGVtLnN0eWxlW25hbWVdO1xuICB9XG59O1xudmFyIGN1ckNTUyA9IGZ1bmN0aW9uIGN1ckNTUyhlbGVtLCBuYW1lLCBjb21wdXRlZCkge1xuICB2YXIgbWF4V2lkdGgsIG1pbldpZHRoLCByZXQsIHJtYXJnaW4sIHN0eWxlLCB3aWR0aDtcbiAgcm1hcmdpbiA9IC9ebWFyZ2luLztcbiAgd2lkdGggPSB2b2lkIDA7XG4gIG1pbldpZHRoID0gdm9pZCAwO1xuICBtYXhXaWR0aCA9IHZvaWQgMDtcbiAgcmV0ID0gdm9pZCAwO1xuICBzdHlsZSA9IGVsZW0uc3R5bGU7XG4gIGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKGVsZW0pO1xuICBpZiAoY29tcHV0ZWQpIHtcbiAgICAvLyBTdXBwb3J0OiBJRTlcbiAgICAvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSAoIzEyNTM3KVxuICAgIHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUobmFtZSkgfHwgY29tcHV0ZWRbbmFtZV07XG4gIH1cbiAgaWYgKGNvbXB1dGVkKSB7XG4gICAgaWYgKHJldCA9PT0gXCJcIiAmJiAhbm9kZUNvbnRhaW5zKGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSkpIHtcbiAgICAgIHJldCA9IGRvbVN0eWxlKGVsZW0sIG5hbWUpO1xuICAgIH1cbiAgICAvLyBTdXBwb3J0OiBpT1MgPCA2XG4gICAgLy8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuICAgIC8vIGlPUyA8IDYgKGF0IGxlYXN0KSByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIGEgbGFyZ2VyIHNldCBvZiB2YWx1ZXMsIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHNcbiAgICAvLyB0aGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6IGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcbiAgICBpZiAocm51bW5vbnB4LnRlc3QocmV0KSAmJiBybWFyZ2luLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgIHdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICBtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuICAgICAgbWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcbiAgICAgIC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcbiAgICAgIHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcbiAgICAgIHJldCA9IGNvbXB1dGVkLndpZHRoO1xuICAgICAgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuICAgICAgc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgIHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG4gICAgICBzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIH1cbiAgfVxuICAvLyBTdXBwb3J0OiBJRVxuICAvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmV0ICsgXCJcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmV0O1xuICB9XG59O1xudmFyIGNzc1ZhbHVlID0gZnVuY3Rpb24gY3NzVmFsdWUoZWxlbSwgbmFtZSwgY29udmVydCwgc3R5bGVzKSB7XG4gIHZhciB2YWw7XG4gIHZhbCA9IGN1ckNTUyhlbGVtLCBuYW1lLCBzdHlsZXMpO1xuICBpZiAoY29udmVydCkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxufTtcbnZhciBhdWdtZW50V2lkdGhPckhlaWdodCA9IGZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzKSB7XG4gIHZhciBpLCBsZW4sIHNpZGUsIHNpZGVzLCB2YWw7XG4gIC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuICAvLyBPdGhlcndpc2UgaW5pdGlhbGl6ZSBmb3IgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0aWVzXG4gIGlmIChleHRyYSA9PT0gKGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHNpZGVzID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gW1wiUmlnaHRcIiwgXCJMZWZ0XCJdIDogW1wiVG9wXCIsIFwiQm90dG9tXCJdO1xuICAgIHZhbCA9IDA7XG4gICAgZm9yIChpID0gMCwgbGVuID0gc2lkZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNpZGUgPSBzaWRlc1tpXTtcbiAgICAgIGlmIChleHRyYSA9PT0gXCJtYXJnaW5cIikge1xuICAgICAgICAvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0XG4gICAgICAgIHZhbCArPSBjc3NWYWx1ZShlbGVtLCBleHRyYSArIHNpZGUsIHRydWUsIHN0eWxlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNCb3JkZXJCb3gpIHtcbiAgICAgICAgaWYgKGV4dHJhID09PSBcImNvbnRlbnRcIikge1xuICAgICAgICAgIC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuICAgICAgICAgIHZhbCAtPSBjc3NWYWx1ZShlbGVtLCBcInBhZGRpbmdcIi5jb25jYXQoc2lkZSksIHRydWUsIHN0eWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhICE9PSBcIm1hcmdpblwiKSB7XG4gICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcbiAgICAgICAgICB2YWwgLT0gY3NzVmFsdWUoZWxlbSwgXCJib3JkZXJcIi5jb25jYXQoc2lkZSwgXCJXaWR0aFwiKSwgdHJ1ZSwgc3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcbiAgICAgICAgdmFsICs9IGNzc1ZhbHVlKGVsZW0sIFwicGFkZGluZ1wiLmNvbmNhdChzaWRlKSwgdHJ1ZSwgc3R5bGVzKTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSBcInBhZGRpbmdcIikge1xuICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcbiAgICAgICAgICB2YWwgKz0gY3NzVmFsdWUoZWxlbSwgXCJib3JkZXJcIi5jb25jYXQoc2lkZSwgXCJXaWR0aFwiKSwgdHJ1ZSwgc3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG59O1xudmFyIHBudW0gPSAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLy5zb3VyY2U7XG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cChcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIpO1xudmFyIGdldFdpZHRoT3JIZWlnaHQgPSBmdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KGVsZW0sIG5hbWUsIGV4dHJhKSB7XG4gIHZhciBpc0JvcmRlckJveCwgc3R5bGVzLCB2YWwsIHZhbHVlSXNCb3JkZXJCb3g7XG4gIC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXG4gIHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlO1xuICB2YWwgPSBuYW1lID09PSBcIndpZHRoXCIgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQ7XG4gIHN0eWxlcyA9IGdldFN0eWxlcyhlbGVtKTtcbiAgaXNCb3JkZXJCb3ggPSBjc3NWYWx1ZShlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzKSA9PT0gXCJib3JkZXItYm94XCI7XG4gIC8vIFNvbWUgbm9uLWh0bWwgZWxlbWVudHMgcmV0dXJuIHVuZGVmaW5lZCBmb3Igb2Zmc2V0V2lkdGgsIHNvIGNoZWNrIGZvciBudWxsL3VuZGVmaW5lZFxuICAvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcbiAgLy8gTWF0aE1MIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDkxNjY4XG4gIGlmICh2YWwgPD0gMCB8fCB2YWwgPT0gbnVsbCkge1xuICAgIC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuICAgIHZhbCA9IGN1ckNTUyhlbGVtLCBuYW1lLCBzdHlsZXMpO1xuICAgIGlmICh2YWwgPCAwIHx8IHZhbCA9PSBudWxsKSB7XG4gICAgICB2YWwgPSBlbGVtLnN0eWxlW25hbWVdO1xuICAgIH1cbiAgICBpZiAocm51bW5vbnB4LnRlc3QodmFsKSkge1xuICAgICAgLy8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG4gICAgLy8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuICAgIC8vICAgIHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCBhbmQgKHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSBvciB2YWwgaXMgZWxlbS5zdHlsZVtuYW1lXSlcbiAgICB2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3ggJiYgdmFsID09PSBlbGVtLnN0eWxlW25hbWVdO1xuICAgIC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcbiAgICB2YWwgPSBwYXJzZUZsb2F0KHZhbCkgfHwgMDtcbiAgfVxuICAvLyBVc2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuICByZXR1cm4gdmFsICsgYXVnbWVudFdpZHRoT3JIZWlnaHQoZWxlbSwgbmFtZSwgZXh0cmEgfHwgKGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiKSwgdmFsdWVJc0JvcmRlckJveCwgc3R5bGVzKTtcbn07XG52YXIgbG9kYXNoX3dpZHRoID0gZnVuY3Rpb24gd2lkdGgoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2lkdGhPckhlaWdodChlbGVtZW50LCBcIndpZHRoXCIsIFwiY29udGVudFwiKTtcbn07XG5cbi8qKlxuICogQGNsYXNzIFV0aWxcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgaXRlbSBpcyBhIHN0cmluZ1xuICogQGZ1bmN0aW9uIFV0aWwuaXNTdHJpbmdcbiAqIEBwYXJhbSBpdGVtXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBpdGVtIGlzIGEgc3RyaW5nXG4gKi9cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGl0ZW0gaXMgZW1wdHk6XG4gKiA8dWw+XG4gKiAgIDxsaT5pdGVtIGlzIG51bGwgb3IgdW5kZWZpbmVkPC9saT5cbiAqICAgPGxpPml0ZW0gaXMgYW4gYXJyYXkgb3Igc3RyaW5nIG9mIGxlbmd0aCAwPC9saT5cbiAqICAgPGxpPml0ZW0gaXMgYW4gb2JqZWN0IHdpdGggbm8ga2V5czwvbGk+XG4gKiA8L3VsPlxuICogQGZ1bmN0aW9uIFV0aWwuaXNFbXB0eVxuICogQHBhcmFtIGl0ZW1cbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGl0ZW0gaXMgZW1wdHlcbiAqL1xuLyoqXG4gKiBBc3NpZ24gc291cmNlIHByb3BlcnRpZXMgdG8gZGVzdGluYXRpb24uXG4gKiBJZiB0aGUgcHJvcGVydHkgaXMgYW4gb2JqZWN0IGl0IGlzIGFzc2lnbmVkIGFzIGEgd2hvbGUsIG92ZXJyaWRpbmcgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBmdW5jdGlvbiBVdGlsLmFzc2lnblxuICogQHBhcmFtIHtPYmplY3R9IGRlc3RpbmF0aW9uIC0gdGhlIG9iamVjdCB0byBhc3NpZ24gdG9cbiAqL1xuLyoqXG4gKiBSZWN1cnNpdmVseSBhc3NpZ24gc291cmNlIHByb3BlcnRpZXMgdG8gZGVzdGluYXRpb25cbiAqIEBmdW5jdGlvbiBVdGlsLm1lcmdlXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdGluYXRpb24gLSB0aGUgb2JqZWN0IHRvIGFzc2lnbiB0b1xuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKi9cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGNvcHkgb2YgdGhlIGdpdmVuIG9iamVjdCwgaW5jbHVkaW5nIGFsbCBpbnRlcm5hbCBvYmplY3RzLlxuICogQGZ1bmN0aW9uIFV0aWwuY2xvbmVEZWVwXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSB0aGUgb2JqZWN0IHRvIGNsb25lXG4gKiBAcmV0dXJuIHtPYmplY3R9IGEgbmV3IGRlZXAgY29weSBvZiB0aGUgb2JqZWN0XG4gKi9cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBhcnJheSBmcm9tIHRoZSBwYXJhbWV0ZXIgd2l0aCBcImZhbHNleVwiIHZhbHVlcyByZW1vdmVkXG4gKiBAZnVuY3Rpb24gVXRpbC5jb21wYWN0XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIHRoZSBhcnJheSB0byByZW1vdmUgdmFsdWVzIGZyb21cbiAqIEByZXR1cm4ge0FycmF5fSBhIG5ldyBhcnJheSB3aXRob3V0IGZhbHNleSB2YWx1ZXNcbiAqL1xuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIGl0ZW0gaXMgaW5jbHVkZWQgaW4gdGhlIGdpdmVuIGFycmF5XG4gKiBAZnVuY3Rpb24gVXRpbC5jb250YWluc1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSB0aGUgYXJyYXkgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0geyp9IGl0ZW0gLSB0aGUgaXRlbSB0byBzZWFyY2ggZm9yXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBpdGVtIGlzIGluY2x1ZGVkIGluIHRoZSBhcnJheVxuICovXG4vKipcbiAqIFJldHVybnMgdmFsdWVzIGluIHRoZSBnaXZlbiBhcnJheSB0aGF0IGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIG90aGVyIGFycmF5XG4gKiBAZnVuY3Rpb24gVXRpbC5kaWZmZXJlbmNlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgLSB0aGUgYXJyYXkgdG8gc2VsZWN0IGZyb21cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAtIHZhbHVlcyB0byBmaWx0ZXIgZnJvbSBhcnJcbiAqIEByZXR1cm4ge0FycmF5fSB0aGUgZmlsdGVyZWQgdmFsdWVzXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHRoZSBmdW5jdGlvbiBuYW1lcyBpbiBvYmpcbiAqIEBmdW5jdGlvbiBVdGlsLmZ1bmN0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIHRoZSBvYmplY3QgdG8gaW5zcGVjdFxuICogQHJldHVybiB7QXJyYXl9IGEgbGlzdCBvZiBmdW5jdGlvbnMgb2Ygb2JqZWN0XG4gKi9cbi8qKlxuICogUmV0dXJucyB0aGUgcHJvdmlkZWQgdmFsdWUuIFRoaXMgZnVuY3Rpb25zIGlzIHVzZWQgYXMgYSBkZWZhdWx0IHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAqIEBmdW5jdGlvbiBVdGlsLmlkZW50aXR5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHsqfSB0aGUgcHJvdmlkZWQgdmFsdWVcbiAqL1xuLyoqXG4gKiBSZW1vdmUgbGVhZGluZyBvciB0cmFpbGluZyBzcGFjZXMgZnJvbSB0ZXh0XG4gKiBAZnVuY3Rpb24gVXRpbC50cmltXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgYHRleHRgIHdpdGhvdXQgbGVhZGluZyBvciB0cmFpbGluZyBzcGFjZXNcbiAqL1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZXhwcmVzc2lvbi5qc1xuZnVuY3Rpb24gZXhwcmVzc2lvbl90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBleHByZXNzaW9uX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBleHByZXNzaW9uX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gZXhwcmVzc2lvbl90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IGV4cHJlc3Npb25fdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IGV4cHJlc3Npb25fdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbi8qKlxuICogUmVwcmVzZW50cyBhIHRyYW5zZm9ybWF0aW9uIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvblN0ciAtIEFuIGV4cHJlc3Npb24gaW4gc3RyaW5nIGZvcm1hdC5cbiAqIEBjbGFzcyBFeHByZXNzaW9uXG4gKiBOb3JtYWxseSB0aGlzIGNsYXNzIGlzIG5vdCBpbnN0YW50aWF0ZWQgZGlyZWN0bHlcbiAqL1xudmFyIEV4cHJlc3Npb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFeHByZXNzaW9uKGV4cHJlc3Npb25TdHIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXhwcmVzc2lvbik7XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBpbm5lciBFeHByZXNzaW9uLWV4cHJlc3Npb25zXG4gICAgICovXG4gICAgdGhpcy5leHByZXNzaW9ucyA9IFtdO1xuICAgIGlmIChleHByZXNzaW9uU3RyICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbnMucHVzaChFeHByZXNzaW9uLm5vcm1hbGl6ZShleHByZXNzaW9uU3RyKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGNvbnN0cnVjdG9yIG1ldGhvZFxuICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5uZXdcbiAgICovXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRXhwcmVzc2lvbiwgW3tcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBleHByZXNzaW9uXG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXhwcmVzc2lvbiBhcyBhIHN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHJldHVybiBFeHByZXNzaW9uLm5vcm1hbGl6ZSh0aGlzLmV4cHJlc3Npb25zLmpvaW4oXCJfXCIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBhcmVudCB0cmFuc2Zvcm1hdGlvbiBvZiB0aGlzIGV4cHJlc3Npb25cbiAgICAgKiBAcmV0dXJuIFRyYW5zZm9ybWF0aW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGFyZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhcmVudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBhcmVudCB0cmFuc2Zvcm1hdGlvbiBvZiB0aGlzIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge1RyYW5zZm9ybWF0aW9ufSB0aGUgcGFyZW50IHRyYW5zZm9ybWF0aW9uXG4gICAgICogQHJldHVybiB7RXhwcmVzc2lvbn0gdGhpcyBleHByZXNzaW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UGFyZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgZXhwcmVzc2lvblxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uI3ByZWRpY2F0ZVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInByZWRpY2F0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVkaWNhdGUobmFtZSwgb3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICBpZiAoRXhwcmVzc2lvbi5PUEVSQVRPUlNbb3BlcmF0b3JdICE9IG51bGwpIHtcbiAgICAgICAgb3BlcmF0b3IgPSBFeHByZXNzaW9uLk9QRVJBVE9SU1tvcGVyYXRvcl07XG4gICAgICB9XG4gICAgICB0aGlzLmV4cHJlc3Npb25zLnB1c2goXCJcIi5jb25jYXQobmFtZSwgXCJfXCIpLmNvbmNhdChvcGVyYXRvciwgXCJfXCIpLmNvbmNhdCh2YWx1ZSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jYW5kXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuZCgpIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbnMucHVzaChcImFuZFwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uI29yXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwib3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3IoKSB7XG4gICAgICB0aGlzLmV4cHJlc3Npb25zLnB1c2goXCJvclwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbmNsdWRlIGV4cHJlc3Npb25cbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbiN0aGVuXG4gICAgICogQHJldHVybiB7VHJhbnNmb3JtYXRpb259IHRoZSB0cmFuc2Zvcm1hdGlvbiB0aGlzIGV4cHJlc3Npb24gaXMgZGVmaW5lZCBmb3JcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0aGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRoZW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRQYXJlbnQoKVtcImlmXCJdKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jaGVpZ2h0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7RXhwcmVzc2lvbn0gdGhpcyBleHByZXNzaW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhlaWdodChvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcImhcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbiN3aWR0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0V4cHJlc3Npb259IHRoaXMgZXhwcmVzc2lvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIndpZHRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpZHRoKG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwid1wiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uI2FzcGVjdFJhdGlvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7RXhwcmVzc2lvbn0gdGhpcyBleHByZXNzaW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYXNwZWN0UmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNwZWN0UmF0aW8ob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJhclwiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBFeHByZXNzaW9uI3BhZ2VzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7RXhwcmVzc2lvbn0gdGhpcyBleHByZXNzaW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhZ2VDb3VudChvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcInBjXCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24jZmFjZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtFeHByZXNzaW9ufSB0aGlzIGV4cHJlc3Npb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJmYWNlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFjZUNvdW50KG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwiZmNcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoX3ZhbHVlKSB7XG4gICAgICB0aGlzLmV4cHJlc3Npb25zLnB1c2goX3ZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqL1xuICB9XSwgW3tcbiAgICBrZXk6IFwibmV3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9uZXcoZXhwcmVzc2lvblN0cikge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKGV4cHJlc3Npb25TdHIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBhIHN0cmluZyBleHByZXNzaW9uXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjbm9ybWFsaXplXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gYSBleHByZXNzaW9uLCBlLmcuIFwidyBndCAxMDBcIiwgXCJ3aWR0aF9ndF8xMDBcIiwgXCJ3aWR0aCA+IDEwMFwiXG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgbm9ybWFsaXplZCBmb3JtIG9mIHRoZSB2YWx1ZSBleHByZXNzaW9uLCBlLmcuIFwid19ndF8xMDBcIlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm5vcm1hbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtYWxpemUoZXhwcmVzc2lvbikge1xuICAgICAgaWYgKGV4cHJlc3Npb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICAgIH1cbiAgICAgIGV4cHJlc3Npb24gPSBTdHJpbmcoZXhwcmVzc2lvbik7XG4gICAgICB2YXIgb3BlcmF0b3JzID0gXCJcXFxcfFxcXFx8fD49fDw9fCYmfCE9fD58PXw8fC98LXxcXFxcK3xcXFxcKnxcXFxcXlwiO1xuXG4gICAgICAvLyBvcGVyYXRvcnNcbiAgICAgIHZhciBvcGVyYXRvcnNQYXR0ZXJuID0gXCIoKFwiICsgb3BlcmF0b3JzICsgXCIpKD89WyBfXSkpXCI7XG4gICAgICB2YXIgb3BlcmF0b3JzUmVwbGFjZVJFID0gbmV3IFJlZ0V4cChvcGVyYXRvcnNQYXR0ZXJuLCBcImdcIik7XG4gICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5yZXBsYWNlKG9wZXJhdG9yc1JlcGxhY2VSRSwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBFeHByZXNzaW9uLk9QRVJBVE9SU1ttYXRjaF07XG4gICAgICB9KTtcblxuICAgICAgLy8gcHJlZGVmaW5lZCB2YXJpYWJsZXNcbiAgICAgIC8vIFRoZSA6JHt2fSBwYXJ0IGlzIHRvIHByZXZlbnQgbm9ybWFsaXphdGlvbiBvZiB2YXJzIHdpdGggYSBwcmVjZWRpbmcgY29sb24gKHN1Y2ggYXMgOmR1cmF0aW9uKSxcbiAgICAgIC8vIEl0IHdvbid0IGJlIGZvdW5kIGluIFBSRURFRklORURfVkFSUyBhbmQgc28gd29uJ3QgYmUgbm9ybWFsaXplZC5cbiAgICAgIC8vIEl0IGlzIGRvbmUgbGlrZSB0aGlzIGJlY2F1c2UgaWUxMSBkb2VzIG5vdCBzdXBwb3J0IHJlZ2V4IGxvb2tiZWhpbmRcbiAgICAgIHZhciBwcmVkZWZpbmVkVmFyc1BhdHRlcm4gPSBcIihcIiArIE9iamVjdC5rZXlzKEV4cHJlc3Npb24uUFJFREVGSU5FRF9WQVJTKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIFwiOlwiLmNvbmNhdCh2LCBcInxcIikuY29uY2F0KHYpO1xuICAgICAgfSkuam9pbihcInxcIikgKyBcIilcIjtcbiAgICAgIHZhciB1c2VyVmFyaWFibGVQYXR0ZXJuID0gJyhcXFxcJF8qW15fIF0rKSc7XG4gICAgICB2YXIgdmFyaWFibGVzUmVwbGFjZVJFID0gbmV3IFJlZ0V4cChcIlwiLmNvbmNhdCh1c2VyVmFyaWFibGVQYXR0ZXJuLCBcInxcIikuY29uY2F0KHByZWRlZmluZWRWYXJzUGF0dGVybiksIFwiZ1wiKTtcbiAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnJlcGxhY2UodmFyaWFibGVzUmVwbGFjZVJFLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIEV4cHJlc3Npb24uUFJFREVGSU5FRF9WQVJTW21hdGNoXSB8fCBtYXRjaDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGV4cHJlc3Npb24ucmVwbGFjZSgvWyBfXSsvZywgJ18nKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFyaWFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFyaWFibGUobmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhuYW1lKS52YWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJ3aWR0aFwiXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24ud2lkdGhcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ3aWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aWR0aCgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcIndpZHRoXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwiaGVpZ2h0XCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5oZWlnaHRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJoZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGVpZ2h0KCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwiaGVpZ2h0XCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwiaW5pdGlhbFdpZHRoXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5pbml0aWFsV2lkdGhcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpbml0aWFsV2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbFdpZHRoKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwiaW5pdGlhbFdpZHRoXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwiaW5pdGlhbEhlaWdodFwiXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24uaW5pdGlhbEhlaWdodFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxIZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbEhlaWdodCgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcImluaXRpYWxIZWlnaHRcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJhc3BlY3RSYXRpb1wiXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24uYXNwZWN0UmF0aW9cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhc3BlY3RSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3BlY3RSYXRpbygpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcImFzcGVjdFJhdGlvXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwiaW5pdGlhbEFzcGVjdFJhdGlvXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5pbml0aWFsQXNwZWN0UmF0aW9cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpbml0aWFsQXNwZWN0UmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbEFzcGVjdFJhdGlvKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwiaW5pdGlhbEFzcGVjdFJhdGlvXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gYSBuZXcgZXhwcmVzc2lvbiB3aXRoIHRoZSBwcmVkZWZpbmVkIHZhcmlhYmxlIFwicGFnZUNvdW50XCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5wYWdlQ291bnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwYWdlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFnZUNvdW50KCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwicGFnZUNvdW50XCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEV4cHJlc3Npb24gbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcImZhY2VDb3VudFwiXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24uZmFjZUNvdW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZmFjZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZhY2VDb3VudCgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcImZhY2VDb3VudFwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcImN1cnJlbnRQYWdlXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5jdXJyZW50UGFnZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImN1cnJlbnRQYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1cnJlbnRQYWdlKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwiY3VycmVudFBhZ2VcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJ0YWdzXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi50YWdzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidGFnc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0YWdzKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwidGFnc1wiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBFeHByZXNzaW9uIGEgbmV3IGV4cHJlc3Npb24gd2l0aCB0aGUgcHJlZGVmaW5lZCB2YXJpYWJsZSBcInBhZ2VYXCJcbiAgICAgKiBAZnVuY3Rpb24gRXhwcmVzc2lvbi5wYWdlWFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInBhZ2VYXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhZ2VYKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKFwicGFnZVhcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRXhwcmVzc2lvbiBhIG5ldyBleHByZXNzaW9uIHdpdGggdGhlIHByZWRlZmluZWQgdmFyaWFibGUgXCJwYWdlWVwiXG4gICAgICogQGZ1bmN0aW9uIEV4cHJlc3Npb24ucGFnZVlcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwYWdlWVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWdlWSgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhcInBhZ2VZXCIpO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuRXhwcmVzc2lvbi5PUEVSQVRPUlMgPSB7XG4gIFwiPVwiOiAnZXEnLFxuICBcIiE9XCI6ICduZScsXG4gIFwiPFwiOiAnbHQnLFxuICBcIj5cIjogJ2d0JyxcbiAgXCI8PVwiOiAnbHRlJyxcbiAgXCI+PVwiOiAnZ3RlJyxcbiAgXCImJlwiOiAnYW5kJyxcbiAgXCJ8fFwiOiAnb3InLFxuICBcIipcIjogXCJtdWxcIixcbiAgXCIvXCI6IFwiZGl2XCIsXG4gIFwiK1wiOiBcImFkZFwiLFxuICBcIi1cIjogXCJzdWJcIixcbiAgXCJeXCI6IFwicG93XCJcbn07XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbkV4cHJlc3Npb24uUFJFREVGSU5FRF9WQVJTID0ge1xuICBcImFzcGVjdF9yYXRpb1wiOiBcImFyXCIsXG4gIFwiYXNwZWN0UmF0aW9cIjogXCJhclwiLFxuICBcImN1cnJlbnRfcGFnZVwiOiBcImNwXCIsXG4gIFwiY3VycmVudFBhZ2VcIjogXCJjcFwiLFxuICBcImR1cmF0aW9uXCI6IFwiZHVcIixcbiAgXCJmYWNlX2NvdW50XCI6IFwiZmNcIixcbiAgXCJmYWNlQ291bnRcIjogXCJmY1wiLFxuICBcImhlaWdodFwiOiBcImhcIixcbiAgXCJpbml0aWFsX2FzcGVjdF9yYXRpb1wiOiBcImlhclwiLFxuICBcImluaXRpYWxfZHVyYXRpb25cIjogXCJpZHVcIixcbiAgXCJpbml0aWFsX2hlaWdodFwiOiBcImloXCIsXG4gIFwiaW5pdGlhbF93aWR0aFwiOiBcIml3XCIsXG4gIFwiaW5pdGlhbEFzcGVjdFJhdGlvXCI6IFwiaWFyXCIsXG4gIFwiaW5pdGlhbER1cmF0aW9uXCI6IFwiaWR1XCIsXG4gIFwiaW5pdGlhbEhlaWdodFwiOiBcImloXCIsXG4gIFwiaW5pdGlhbFdpZHRoXCI6IFwiaXdcIixcbiAgXCJwYWdlX2NvdW50XCI6IFwicGNcIixcbiAgXCJwYWdlX3hcIjogXCJweFwiLFxuICBcInBhZ2VfeVwiOiBcInB5XCIsXG4gIFwicGFnZUNvdW50XCI6IFwicGNcIixcbiAgXCJwYWdlWFwiOiBcInB4XCIsXG4gIFwicGFnZVlcIjogXCJweVwiLFxuICBcInRhZ3NcIjogXCJ0YWdzXCIsXG4gIFwid2lkdGhcIjogXCJ3XCJcbn07XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbkV4cHJlc3Npb24uQk9VTkRSWSA9IFwiWyBfXStcIjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGV4cHJlc3Npb24gPSAoRXhwcmVzc2lvbik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb25kaXRpb24uanNcbmZ1bmN0aW9uIGNvbmRpdGlvbl90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBjb25kaXRpb25fdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIGNvbmRpdGlvbl90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIGNvbmRpdGlvbl9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBjb25kaXRpb25fZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbmRpdGlvbl90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gY29uZGl0aW9uX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgY29uZGl0aW9uX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBjb25kaXRpb25fZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIGNvbmRpdGlvbl90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBjb25kaXRpb25fdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IGNvbmRpdGlvbl90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIGNvbmRpdGlvbl90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IGNvbmRpdGlvbl90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gY29uZGl0aW9uX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoY29uZGl0aW9uX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRyYW5zZm9ybWF0aW9uIGNvbmRpdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25kaXRpb25TdHIgLSBhIGNvbmRpdGlvbiBpbiBzdHJpbmcgZm9ybWF0XG4gKiBAY2xhc3MgQ29uZGl0aW9uXG4gKiBAZXhhbXBsZVxuICogLy8gbm9ybWFsbHkgdGhpcyBjbGFzcyBpcyBub3QgaW5zdGFudGlhdGVkIGRpcmVjdGx5XG4gKiB2YXIgdHIgPSBjbG91ZGluYXJ5LlRyYW5zZm9ybWF0aW9uLm5ldygpXG4gKiAgICAuaWYoKS53aWR0aCggXCI+XCIsIDEwMDApLmFuZCgpLmFzcGVjdFJhdGlvKFwiPFwiLCBcIjM6NFwiKS50aGVuKClcbiAqICAgICAgLndpZHRoKDEwMDApXG4gKiAgICAgIC5jcm9wKFwic2NhbGVcIilcbiAqICAgIC5lbHNlKClcbiAqICAgICAgLndpZHRoKDUwMClcbiAqICAgICAgLmNyb3AoXCJzY2FsZVwiKVxuICpcbiAqIHZhciB0ciA9IGNsb3VkaW5hcnkuVHJhbnNmb3JtYXRpb24ubmV3KClcbiAqICAgIC5pZihcIncgPiAxMDAwIGFuZCBhc3BlY3RSYXRpbyA8IDM6NFwiKVxuICogICAgICAud2lkdGgoMTAwMClcbiAqICAgICAgLmNyb3AoXCJzY2FsZVwiKVxuICogICAgLmVsc2UoKVxuICogICAgICAud2lkdGgoNTAwKVxuICogICAgICAuY3JvcChcInNjYWxlXCIpXG4gKlxuICovXG52YXIgQ29uZGl0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXhwcmVzc2lvbikge1xuICBmdW5jdGlvbiBDb25kaXRpb24oY29uZGl0aW9uU3RyKSB7XG4gICAgY29uZGl0aW9uX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmRpdGlvbik7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgQ29uZGl0aW9uLCBbY29uZGl0aW9uU3RyXSk7XG4gIH1cblxuICAvKipcbiAgICogQGZ1bmN0aW9uIENvbmRpdGlvbiNoZWlnaHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtDb25kaXRpb259IHRoaXMgY29uZGl0aW9uXG4gICAqL1xuICBfaW5oZXJpdHMoQ29uZGl0aW9uLCBfRXhwcmVzc2lvbik7XG4gIHJldHVybiBjb25kaXRpb25fY3JlYXRlQ2xhc3MoQ29uZGl0aW9uLCBbe1xuICAgIGtleTogXCJoZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGVpZ2h0KG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwiaFwiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBDb25kaXRpb24jd2lkdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtDb25kaXRpb259IHRoaXMgY29uZGl0aW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwid2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2lkdGgob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJ3XCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENvbmRpdGlvbiNhc3BlY3RSYXRpb1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0NvbmRpdGlvbn0gdGhpcyBjb25kaXRpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhc3BlY3RSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3BlY3RSYXRpbyhvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZShcImFyXCIsIG9wZXJhdG9yLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENvbmRpdGlvbiNwYWdlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciB0aGUgY29tcGFyaXNvbiBvcGVyYXRvciAoZS5nLiBcIjxcIiwgXCJsdFwiKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgdGhlIHJpZ2h0IGhhbmQgc2lkZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0NvbmRpdGlvbn0gdGhpcyBjb25kaXRpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwYWdlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFnZUNvdW50KG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlKFwicGNcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQ29uZGl0aW9uI2ZhY2VzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7Q29uZGl0aW9ufSB0aGlzIGNvbmRpdGlvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZhY2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmYWNlQ291bnQob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJmY1wiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBDb25kaXRpb24jZHVyYXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgdGhlIGNvbXBhcmlzb24gb3BlcmF0b3IgKGUuZy4gXCI8XCIsIFwibHRcIilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIHRoZSByaWdodCBoYW5kIHNpZGUgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtDb25kaXRpb259IHRoaXMgY29uZGl0aW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZHVyYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHVyYXRpb24ob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJkdVwiLCBvcGVyYXRvciwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBDb25kaXRpb24jaW5pdGlhbER1cmF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIHRoZSBjb21wYXJpc29uIG9wZXJhdG9yIChlLmcuIFwiPFwiLCBcImx0XCIpXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSB0aGUgcmlnaHQgaGFuZCBzaWRlIHZhbHVlXG4gICAgICogQHJldHVybiB7Q29uZGl0aW9ufSB0aGlzIGNvbmRpdGlvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxEdXJhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsRHVyYXRpb24ob3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVkaWNhdGUoXCJpZHVcIiwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgICB9XG4gIH1dKTtcbn0oZXhwcmVzc2lvbik7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb25kaXRpb24gPSAoQ29uZGl0aW9uKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbmZpZ3VyYXRpb24uanNcbmZ1bmN0aW9uIGNvbmZpZ3VyYXRpb25fdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gY29uZmlndXJhdGlvbl90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgY29uZmlndXJhdGlvbl90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgY29uZmlndXJhdGlvbl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gY29uZmlndXJhdGlvbl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGNvbmZpZ3VyYXRpb25fYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGNvbmZpZ3VyYXRpb25fYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBjb25maWd1cmF0aW9uX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5mdW5jdGlvbiBjb25maWd1cmF0aW9uX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIGNvbmZpZ3VyYXRpb25fZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbmZpZ3VyYXRpb25fdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIGNvbmZpZ3VyYXRpb25fY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBjb25maWd1cmF0aW9uX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBjb25maWd1cmF0aW9uX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBjb25maWd1cmF0aW9uX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IGNvbmZpZ3VyYXRpb25fdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IGNvbmZpZ3VyYXRpb25fdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBjb25maWd1cmF0aW9uX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gY29uZmlndXJhdGlvbl90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gY29uZmlndXJhdGlvbl90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuLyoqXG4gKiBDbGFzcyBmb3IgZGVmaW5pbmcgYWNjb3VudCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKiBEZXBlbmRzIG9uICd1dGlscydcbiAqL1xuXG5cblxuLyoqXG4gKiBDbGFzcyBmb3IgZGVmaW5pbmcgYWNjb3VudCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKiBAY29uc3RydWN0b3IgQ29uZmlndXJhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgYWNjb3VudCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgdG8gc2V0LlxuICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiXG4gKiAgdGFyZ2V0PVwiX25ld1wiPkF2YWlsYWJsZSBjb25maWd1cmF0aW9uIG9wdGlvbnM8L2E+XG4gKi9cbnZhciBjb25maWd1cmF0aW9uX0NvbmZpZ3VyYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb25maWd1cmF0aW9uKG9wdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9uX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmZpZ3VyYXRpb24pO1xuICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IG9wdGlvbnMgPT0gbnVsbCA/IHt9IDogY2xvbmVEZWVwX3Jvb3RfY2xvbmVEZWVwX2RlZmF1bHQoKShvcHRpb25zKTtcbiAgICBkZWZhdWx0cyh0aGlzLmNvbmZpZ3VyYXRpb24sIERFRkFVTFRfQ09ORklHVVJBVElPTl9QQVJBTVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjb25maWd1cmF0aW9uLiBUaGlzIG1ldGhvZCBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGludm9rZXMgYm90aFxuICAgKiAge0BsaW5rIENvbmZpZ3VyYXRpb24jZnJvbUVudmlyb25tZW50fGZyb21FbnZpcm9ubWVudCgpfSAoTm9kZS5qcyBlbnZpcm9ubWVudCBvbmx5KVxuICAgKiAgYW5kIHtAbGluayBDb25maWd1cmF0aW9uI2Zyb21Eb2N1bWVudHxmcm9tRG9jdW1lbnQoKX0uXG4gICAqICBJdCBmaXJzdCB0cmllcyB0byByZXRyaWV2ZSB0aGUgY29uZmlndXJhdGlvbiBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAgICogIElmIG5vdCBhdmFpbGFibGUsIGl0IHRyaWVzIGZyb20gdGhlIGRvY3VtZW50IG1ldGEgdGFncy5cbiAgICogQGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24jaW5pdFxuICAgKiBAcmV0dXJuIHtDb25maWd1cmF0aW9ufSByZXR1cm5zIGB0aGlzYCBmb3IgY2hhaW5pbmdcbiAgICogQHNlZSBmcm9tRG9jdW1lbnRcbiAgICogQHNlZSBmcm9tRW52aXJvbm1lbnRcbiAgICovXG4gIHJldHVybiBjb25maWd1cmF0aW9uX2NyZWF0ZUNsYXNzKENvbmZpZ3VyYXRpb24sIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuZnJvbUVudmlyb25tZW50KCk7XG4gICAgICB0aGlzLmZyb21Eb2N1bWVudCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgbmV3IGNvbmZpZ3VyYXRpb24gaXRlbVxuICAgICAqIEBmdW5jdGlvbiBDb25maWd1cmF0aW9uI3NldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGl0ZW0gdG8gc2V0XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBiZSBzZXRcbiAgICAgKiBAcmV0dXJuIHtDb25maWd1cmF0aW9ufVxuICAgICAqXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5jb25maWd1cmF0aW9uW25hbWVdID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIGEgY29uZmlndXJhdGlvbiBpdGVtXG4gICAgICogQGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24jZ2V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgaXRlbSB0byBzZXRcbiAgICAgKiBAcmV0dXJuIHsqfSB0aGUgY29uZmlndXJhdGlvbiBpdGVtXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uW25hbWVdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtZXJnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZShjb25maWcpIHtcbiAgICAgIGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkodGhpcy5jb25maWd1cmF0aW9uLCBjbG9uZURlZXBfcm9vdF9jbG9uZURlZXBfZGVmYXVsdCgpKGNvbmZpZykpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBDbG91ZGluYXJ5IGZyb20gSFRNTCBtZXRhIHRhZ3MuXG4gICAgICogQGZ1bmN0aW9uIENvbmZpZ3VyYXRpb24jZnJvbURvY3VtZW50XG4gICAgICogQHJldHVybiB7Q29uZmlndXJhdGlvbn1cbiAgICAgKiBAZXhhbXBsZSA8bWV0YSBuYW1lPVwiY2xvdWRpbmFyeV9jbG91ZF9uYW1lXCIgY29udGVudD1cIm15Y2xvdWRcIj5cbiAgICAgKlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZyb21Eb2N1bWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tRG9jdW1lbnQoKSB7XG4gICAgICB2YXIgZWwsIGksIGxlbiwgbWV0YV9lbGVtZW50cztcbiAgICAgIG1ldGFfZWxlbWVudHMgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQgIT09IG51bGwgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdtZXRhW25hbWVePVwiY2xvdWRpbmFyeV9cIl0nKSA6IHZvaWQgMDtcbiAgICAgIGlmIChtZXRhX2VsZW1lbnRzKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG1ldGFfZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBlbCA9IG1ldGFfZWxlbWVudHNbaV07XG4gICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uW2VsLmdldEF0dHJpYnV0ZSgnbmFtZScpLnJlcGxhY2UoJ2Nsb3VkaW5hcnlfJywgJycpXSA9IGVsLmdldEF0dHJpYnV0ZSgnY29udGVudCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIENsb3VkaW5hcnkgZnJvbSB0aGUgYENMT1VESU5BUllfVVJMYCBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBvbmx5IHJ1biB1bmRlciBOb2RlLmpzIGVudmlyb25tZW50LlxuICAgICAqIEBmdW5jdGlvbiBDb25maWd1cmF0aW9uI2Zyb21FbnZpcm9ubWVudFxuICAgICAqIEByZXF1aXJlcyBOb2RlLmpzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUVudmlyb25tZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21FbnZpcm9ubWVudCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgY2xvdWRpbmFyeV91cmwsIHF1ZXJ5LCB1cmksIHVyaVJlZ2V4O1xuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MgIT09IG51bGwgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuQ0xPVURJTkFSWV9VUkwpIHtcbiAgICAgICAgY2xvdWRpbmFyeV91cmwgPSBwcm9jZXNzLmVudi5DTE9VRElOQVJZX1VSTDtcbiAgICAgICAgdXJpUmVnZXggPSAvY2xvdWRpbmFyeTpcXC9cXC8oPzooXFx3KykoPzpcXDooW1xcdy1dKykpP0ApPyhbXFx3XFwuLV0rKSg/OlxcLyhbXj9dKikpPyg/OlxcPyguKykpPy87XG4gICAgICAgIHVyaSA9IHVyaVJlZ2V4LmV4ZWMoY2xvdWRpbmFyeV91cmwpO1xuICAgICAgICBpZiAodXJpKSB7XG4gICAgICAgICAgaWYgKHVyaVszXSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25bJ2Nsb3VkX25hbWUnXSA9IHVyaVszXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVyaVsxXSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25bJ2FwaV9rZXknXSA9IHVyaVsxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVyaVsyXSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25bJ2FwaV9zZWNyZXQnXSA9IHVyaVsyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVyaVs0XSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25bJ3ByaXZhdGVfY2RuJ10gPSB1cmlbNF0gIT0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVyaVs0XSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25bJ3NlY3VyZV9kaXN0cmlidXRpb24nXSA9IHVyaVs0XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcXVlcnkgPSB1cmlbNV07XG4gICAgICAgICAgaWYgKHF1ZXJ5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHF1ZXJ5LnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIF92YWx1ZSRzcGxpdCA9IHZhbHVlLnNwbGl0KCc9JyksXG4gICAgICAgICAgICAgICAgX3ZhbHVlJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF92YWx1ZSRzcGxpdCwgMiksXG4gICAgICAgICAgICAgICAgayA9IF92YWx1ZSRzcGxpdDJbMF0sXG4gICAgICAgICAgICAgICAgdiA9IF92YWx1ZSRzcGxpdDJbMV07XG4gICAgICAgICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfdGhpcy5jb25maWd1cmF0aW9uW2tdID0gdjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIG9yIG1vZGlmeSB0aGUgQ2xvdWRpbmFyeSBjbGllbnQgY29uZmlndXJhdGlvblxuICAgICAqXG4gICAgICogV2FybmluZzogYGNvbmZpZygpYCByZXR1cm5zIHRoZSBhY3R1YWwgaW50ZXJuYWwgY29uZmlndXJhdGlvbiBvYmplY3QuIG1vZGlmeWluZyBpdCB3aWxsIGNoYW5nZSB0aGUgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IG1ldGhvZC4gRm9yIG5ldyBjb2RlLCB1c2UgZ2V0KCksIG1lcmdlKCkgZXRjLlxuICAgICAqIEBmdW5jdGlvbiBDb25maWd1cmF0aW9uI2NvbmZpZ1xuICAgICAqIEBwYXJhbSB7aGFzaHxzdHJpbmd8Ym9vbGVhbn0gbmV3X2NvbmZpZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdfdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn0gY29uZmlndXJhdGlvbiwgb3IgdmFsdWVcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGZyb21FbnZpcm9ubWVudH0gZm9yIGluaXRpYWxpemF0aW9uIHVzaW5nIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgICAqIEBzZWUge0BsaW5rIGZyb21Eb2N1bWVudH0gZm9yIGluaXRpYWxpemF0aW9uIHVzaW5nIEhUTUwgbWV0YSB0YWdzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY29uZmlnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmZpZyhuZXdfY29uZmlnLCBuZXdfdmFsdWUpIHtcbiAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgY2FzZSBuZXdfdmFsdWUgPT09IHZvaWQgMDpcbiAgICAgICAgICB0aGlzLnNldChuZXdfY29uZmlnLCBuZXdfdmFsdWUpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb247XG4gICAgICAgIGNhc2UgIWlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKG5ld19jb25maWcpOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldChuZXdfY29uZmlnKTtcbiAgICAgICAgY2FzZSAhaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCgpKG5ld19jb25maWcpOlxuICAgICAgICAgIHRoaXMubWVyZ2UobmV3X2NvbmZpZyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5IC0gcmV0dXJuIHRoZSBpbnRlcm5hbCBvYmplY3RcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAgICAgKiBAZnVuY3Rpb24gQ29uZmlndXJhdGlvbiN0b09wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBhIGtleTp2YWx1ZSBjb2xsZWN0aW9uIG9mIHRoZSBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0b09wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9PcHRpb25zKCkge1xuICAgICAgcmV0dXJuIGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0KCkodGhpcy5jb25maWd1cmF0aW9uKTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbnZhciBERUZBVUxUX0NPTkZJR1VSQVRJT05fUEFSQU1TID0ge1xuICByZXNwb25zaXZlX2NsYXNzOiAnY2xkLXJlc3BvbnNpdmUnLFxuICByZXNwb25zaXZlX3VzZV9icmVha3BvaW50czogdHJ1ZSxcbiAgcm91bmRfZHByOiB0cnVlLFxuICBzZWN1cmU6ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPT0gbnVsbCA/IHdpbmRvdy5sb2NhdGlvbiA/IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA6IHZvaWQgMCA6IHZvaWQgMCkgPT09ICdodHRwczonXG59O1xuY29uZmlndXJhdGlvbl9Db25maWd1cmF0aW9uLkNPTkZJR19QQVJBTVMgPSBbXCJhcGlfa2V5XCIsIFwiYXBpX3NlY3JldFwiLCBcImNhbGxiYWNrXCIsIFwiY2RuX3N1YmRvbWFpblwiLCBcImNsb3VkX25hbWVcIiwgXCJjbmFtZVwiLCBcInByaXZhdGVfY2RuXCIsIFwicHJvdG9jb2xcIiwgXCJyZXNvdXJjZV90eXBlXCIsIFwicmVzcG9uc2l2ZVwiLCBcInJlc3BvbnNpdmVfY2xhc3NcIiwgXCJyZXNwb25zaXZlX3VzZV9icmVha3BvaW50c1wiLCBcInJlc3BvbnNpdmVfd2lkdGhcIiwgXCJyb3VuZF9kcHJcIiwgXCJzZWN1cmVcIiwgXCJzZWN1cmVfY2RuX3N1YmRvbWFpblwiLCBcInNlY3VyZV9kaXN0cmlidXRpb25cIiwgXCJzaG9ydGVuXCIsIFwidHlwZVwiLCBcInVwbG9hZF9wcmVzZXRcIiwgXCJ1cmxfc3VmZml4XCIsIFwidXNlX3Jvb3RfcGF0aFwiLCBcInZlcnNpb25cIiwgXCJleHRlcm5hbExpYnJhcmllc1wiLCBcIm1heF90aW1lb3V0X21zXCJdO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX2NvbmZpZ3VyYXRpb24gPSAoY29uZmlndXJhdGlvbl9Db25maWd1cmF0aW9uKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2xheWVyL2xheWVyLmpzXG5mdW5jdGlvbiBsYXllcl90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBsYXllcl90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgbGF5ZXJfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBsYXllcl9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbGF5ZXJfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIGxheWVyX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgbGF5ZXJfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGxheWVyX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBsYXllcl90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBsYXllcl90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gbGF5ZXJfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBsYXllcl90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IGxheWVyX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBsYXllcl90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuXG52YXIgbGF5ZXJfTGF5ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogTGF5ZXJcbiAgICogQGNvbnN0cnVjdG9yIExheWVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gbGF5ZXIgcGFyYW1ldGVyc1xuICAgKi9cbiAgZnVuY3Rpb24gTGF5ZXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgbGF5ZXJfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGF5ZXIpO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICAgIFtcInJlc291cmNlVHlwZVwiLCBcInR5cGVcIiwgXCJwdWJsaWNJZFwiLCBcImZvcm1hdFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgcmV0dXJuIF90aGlzLm9wdGlvbnNba2V5XSA9IChyZWYgPSBvcHRpb25zW2tleV0pICE9IG51bGwgPyByZWYgOiBvcHRpb25zW3NuYWtlQ2FzZShrZXkpXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGF5ZXJfY3JlYXRlQ2xhc3MoTGF5ZXIsIFt7XG4gICAga2V5OiBcInJlc291cmNlVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvdXJjZVR5cGUodmFsdWUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5yZXNvdXJjZVR5cGUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0eXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHR5cGUodmFsdWUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy50eXBlID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHVibGljSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVibGljSWQodmFsdWUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5wdWJsaWNJZCA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwdWJsaWMgSUQsIGZvcm1hdHRlZCBmb3IgbGF5ZXIgcGFyYW1ldGVyXG4gICAgICogQGZ1bmN0aW9uIExheWVyI2dldFB1YmxpY0lkXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBwdWJsaWMgSURcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRQdWJsaWNJZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQdWJsaWNJZCgpIHtcbiAgICAgIHZhciByZWY7XG4gICAgICByZXR1cm4gKHJlZiA9IHRoaXMub3B0aW9ucy5wdWJsaWNJZCkgIT0gbnVsbCA/IHJlZi5yZXBsYWNlKC9cXC8vZywgXCI6XCIpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHVibGljIElELCB3aXRoIGZvcm1hdCBpZiBwcmVzZW50XG4gICAgICogQGZ1bmN0aW9uIExheWVyI2dldEZ1bGxQdWJsaWNJZFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gcHVibGljIElEXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RnVsbFB1YmxpY0lkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZ1bGxQdWJsaWNJZCgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHVibGljSWQoKSArIFwiLlwiICsgdGhpcy5vcHRpb25zLmZvcm1hdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFB1YmxpY0lkKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQodmFsdWUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5mb3JtYXQgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyXG4gICAgICogQGZ1bmN0aW9uIExheWVyI3RvU3RyaW5nXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50cztcbiAgICAgIGNvbXBvbmVudHMgPSBbXTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucHVibGljSWQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBcIk11c3Qgc3VwcGx5IHB1YmxpY0lkXCI7XG4gICAgICB9XG4gICAgICBpZiAoISh0aGlzLm9wdGlvbnMucmVzb3VyY2VUeXBlID09PSBcImltYWdlXCIpKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzLm9wdGlvbnMucmVzb3VyY2VUeXBlKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHRoaXMub3B0aW9ucy50eXBlID09PSBcInVwbG9hZFwiKSkge1xuICAgICAgICBjb21wb25lbnRzLnB1c2godGhpcy5vcHRpb25zLnR5cGUpO1xuICAgICAgfVxuICAgICAgY29tcG9uZW50cy5wdXNoKHRoaXMuZ2V0RnVsbFB1YmxpY0lkKCkpO1xuICAgICAgcmV0dXJuIGNvbXBhY3Rfcm9vdF9jb21wYWN0X2RlZmF1bHQoKShjb21wb25lbnRzKS5qb2luKFwiOlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5vcHRpb25zKTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGxheWVyX2xheWVyID0gKGxheWVyX0xheWVyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2xheWVyL3RleHRsYXllci5qc1xuZnVuY3Rpb24gdGV4dGxheWVyX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIHRleHRsYXllcl90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgdGV4dGxheWVyX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gdGV4dGxheWVyX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIHRleHRsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgdGV4dGxheWVyX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiB0ZXh0bGF5ZXJfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSB0ZXh0bGF5ZXJfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIHRleHRsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gdGV4dGxheWVyX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IHRleHRsYXllcl90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gdGV4dGxheWVyX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gdGV4dGxheWVyX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gdGV4dGxheWVyX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSB0ZXh0bGF5ZXJfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIHRleHRsYXllcl9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IHRleHRsYXllcl9nZXRQcm90b3R5cGVPZihvKSwgdGV4dGxheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgdGV4dGxheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgdGV4dGxheWVyX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG5mdW5jdGlvbiB0ZXh0bGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmICh0ZXh0bGF5ZXJfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIHRleHRsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIHRleHRsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gdGV4dGxheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKHRleHRsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiB0ZXh0bGF5ZXJfZ2V0UHJvdG90eXBlT2YobykgeyB0ZXh0bGF5ZXJfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIHRleHRsYXllcl9nZXRQcm90b3R5cGVPZihvKTsgfVxuZnVuY3Rpb24gdGV4dGxheWVyX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIHRleHRsYXllcl9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cbmZ1bmN0aW9uIHRleHRsYXllcl9zZXRQcm90b3R5cGVPZihvLCBwKSB7IHRleHRsYXllcl9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gdGV4dGxheWVyX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cblxudmFyIHRleHRsYXllcl9UZXh0TGF5ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MYXllcikge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yIFRleHRMYXllclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGxheWVyIHBhcmFtZXRlcnNcbiAgICovXG4gIGZ1bmN0aW9uIFRleHRMYXllcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIHRleHRsYXllcl9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0TGF5ZXIpO1xuICAgIHZhciBrZXlzO1xuICAgIF90aGlzID0gdGV4dGxheWVyX2NhbGxTdXBlcih0aGlzLCBUZXh0TGF5ZXIsIFtvcHRpb25zXSk7XG4gICAga2V5cyA9IFtcInJlc291cmNlVHlwZVwiLCBcInJlc291cmNlVHlwZVwiLCBcImZvbnRGYW1pbHlcIiwgXCJmb250U2l6ZVwiLCBcImZvbnRXZWlnaHRcIiwgXCJmb250U3R5bGVcIiwgXCJ0ZXh0RGVjb3JhdGlvblwiLCBcInRleHRBbGlnblwiLCBcInN0cm9rZVwiLCBcImxldHRlclNwYWNpbmdcIiwgXCJsaW5lU3BhY2luZ1wiLCBcImZvbnRIaW50aW5nXCIsIFwiZm9udEFudGlhbGlhc2luZ1wiLCBcInRleHRcIiwgXCJ0ZXh0U3R5bGVcIl07XG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgcmV0dXJuIF90aGlzLm9wdGlvbnNba2V5XSA9IChyZWYgPSBvcHRpb25zW2tleV0pICE9IG51bGwgPyByZWYgOiBvcHRpb25zW3NuYWtlQ2FzZShrZXkpXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfdGhpcy5vcHRpb25zLnJlc291cmNlVHlwZSA9IFwidGV4dFwiO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB0ZXh0bGF5ZXJfaW5oZXJpdHMoVGV4dExheWVyLCBfTGF5ZXIpO1xuICByZXR1cm4gdGV4dGxheWVyX2NyZWF0ZUNsYXNzKFRleHRMYXllciwgW3tcbiAgICBrZXk6IFwicmVzb3VyY2VUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc291cmNlVHlwZShfcmVzb3VyY2VUeXBlKSB7XG4gICAgICB0aHJvdyBcIkNhbm5vdCBtb2RpZnkgcmVzb3VyY2VUeXBlIGZvciB0ZXh0IGxheWVyc1wiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0eXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHR5cGUoX3R5cGUpIHtcbiAgICAgIHRocm93IFwiQ2Fubm90IG1vZGlmeSB0eXBlIGZvciB0ZXh0IGxheWVyc1wiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KF9mb3JtYXQpIHtcbiAgICAgIHRocm93IFwiQ2Fubm90IG1vZGlmeSBmb3JtYXQgZm9yIHRleHQgbGF5ZXJzXCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvbnRGYW1pbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9udEZhbWlseShfZm9udEZhbWlseSkge1xuICAgICAgdGhpcy5vcHRpb25zLmZvbnRGYW1pbHkgPSBfZm9udEZhbWlseTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb250U2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb250U2l6ZShfZm9udFNpemUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5mb250U2l6ZSA9IF9mb250U2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb250V2VpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvbnRXZWlnaHQoX2ZvbnRXZWlnaHQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5mb250V2VpZ2h0ID0gX2ZvbnRXZWlnaHQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9udFN0eWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvbnRTdHlsZShfZm9udFN0eWxlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZm9udFN0eWxlID0gX2ZvbnRTdHlsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0RGVjb3JhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0RGVjb3JhdGlvbihfdGV4dERlY29yYXRpb24pIHtcbiAgICAgIHRoaXMub3B0aW9ucy50ZXh0RGVjb3JhdGlvbiA9IF90ZXh0RGVjb3JhdGlvbjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0QWxpZ25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dEFsaWduKF90ZXh0QWxpZ24pIHtcbiAgICAgIHRoaXMub3B0aW9ucy50ZXh0QWxpZ24gPSBfdGV4dEFsaWduO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0cm9rZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdHJva2UoX3N0cm9rZSkge1xuICAgICAgdGhpcy5vcHRpb25zLnN0cm9rZSA9IF9zdHJva2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGV0dGVyU3BhY2luZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZXR0ZXJTcGFjaW5nKF9sZXR0ZXJTcGFjaW5nKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubGV0dGVyU3BhY2luZyA9IF9sZXR0ZXJTcGFjaW5nO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxpbmVTcGFjaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpbmVTcGFjaW5nKF9saW5lU3BhY2luZykge1xuICAgICAgdGhpcy5vcHRpb25zLmxpbmVTcGFjaW5nID0gX2xpbmVTcGFjaW5nO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvbnRIaW50aW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvbnRIaW50aW5nKF9mb250SGludGluZykge1xuICAgICAgdGhpcy5vcHRpb25zLmZvbnRIaW50aW5nID0gX2ZvbnRIaW50aW5nO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvbnRBbnRpYWxpYXNpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9udEFudGlhbGlhc2luZyhfZm9udEFudGlhbGlhc2luZykge1xuICAgICAgdGhpcy5vcHRpb25zLmZvbnRBbnRpYWxpYXNpbmcgPSBfZm9udEFudGlhbGlhc2luZztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHQoX3RleHQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy50ZXh0ID0gX3RleHQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dFN0eWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHRTdHlsZShfdGV4dFN0eWxlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudGV4dFN0eWxlID0gX3RleHRTdHlsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyXG4gICAgICogQGZ1bmN0aW9uIFRleHRMYXllciN0b1N0cmluZ1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnRzLCBoYXNQdWJsaWNJZCwgaGFzU3R5bGUsIHB1YmxpY0lkLCByZSwgcmVzLCBzdGFydCwgc3R5bGUsIHRleHQsIHRleHRTb3VyY2U7XG4gICAgICBzdHlsZSA9IHRoaXMudGV4dFN0eWxlSWRlbnRpZmllcigpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wdWJsaWNJZCAhPSBudWxsKSB7XG4gICAgICAgIHB1YmxpY0lkID0gdGhpcy5nZXRGdWxsUHVibGljSWQoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGV4dCAhPSBudWxsKSB7XG4gICAgICAgIGhhc1B1YmxpY0lkID0gIWlzRW1wdHkocHVibGljSWQpO1xuICAgICAgICBoYXNTdHlsZSA9ICFpc0VtcHR5KHN0eWxlKTtcbiAgICAgICAgaWYgKGhhc1B1YmxpY0lkICYmIGhhc1N0eWxlIHx8ICFoYXNQdWJsaWNJZCAmJiAhaGFzU3R5bGUpIHtcbiAgICAgICAgICB0aHJvdyBcIk11c3Qgc3VwcGx5IGVpdGhlciBzdHlsZSBwYXJhbWV0ZXJzIG9yIGEgcHVibGljX2lkIHdoZW4gcHJvdmlkaW5nIHRleHQgcGFyYW1ldGVyIGluIGEgdGV4dCBvdmVybGF5L3VuZGVybGF5LCBidXQgbm90IGJvdGghXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmUgPSAvXFwkXFwoW2EtekEtWl1cXHcqXFwpL2c7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgLy8gICAgICAgIHRleHRTb3VyY2UgPSB0ZXh0LnJlcGxhY2UobmV3IFJlZ0V4cChcIlssL11cIiwgJ2cnKSwgKGMpLT4gXCIlI3tjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCl9XCIpXG4gICAgICAgIHRleHRTb3VyY2UgPSBzbWFydEVzY2FwZSh0aGlzLm9wdGlvbnMudGV4dCwgL1ssXFwvXS9nKTtcbiAgICAgICAgdGV4dCA9IFwiXCI7XG4gICAgICAgIHdoaWxlIChyZXMgPSByZS5leGVjKHRleHRTb3VyY2UpKSB7XG4gICAgICAgICAgdGV4dCArPSBzbWFydEVzY2FwZSh0ZXh0U291cmNlLnNsaWNlKHN0YXJ0LCByZXMuaW5kZXgpKTtcbiAgICAgICAgICB0ZXh0ICs9IHJlc1swXTtcbiAgICAgICAgICBzdGFydCA9IHJlcy5pbmRleCArIHJlc1swXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCArPSBzbWFydEVzY2FwZSh0ZXh0U291cmNlLnNsaWNlKHN0YXJ0KSk7XG4gICAgICB9XG4gICAgICBjb21wb25lbnRzID0gW3RoaXMub3B0aW9ucy5yZXNvdXJjZVR5cGUsIHN0eWxlLCBwdWJsaWNJZCwgdGV4dF07XG4gICAgICByZXR1cm4gY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCgpKGNvbXBvbmVudHMpLmpvaW4oXCI6XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0U3R5bGVJZGVudGlmaWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHRTdHlsZUlkZW50aWZpZXIoKSB7XG4gICAgICAvLyBOb3RlOiBpZiBhIHRleHQtc3R5bGUgYXJndW1lbnQgaXMgcHJvdmlkZWQgYXMgYSB3aG9sZSwgaXQgb3ZlcnJpZGVzIGV2ZXJ5dGhpbmcgZWxzZSwgbm8gbWl4IGFuZCBtYXRjaC5cbiAgICAgIGlmICghaXNFbXB0eSh0aGlzLm9wdGlvbnMudGV4dFN0eWxlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRleHRTdHlsZTtcbiAgICAgIH1cbiAgICAgIHZhciBjb21wb25lbnRzO1xuICAgICAgY29tcG9uZW50cyA9IFtdO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb250V2VpZ2h0ICE9PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzLm9wdGlvbnMuZm9udFdlaWdodCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZvbnRTdHlsZSAhPT0gXCJub3JtYWxcIikge1xuICAgICAgICBjb21wb25lbnRzLnB1c2godGhpcy5vcHRpb25zLmZvbnRTdHlsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRleHREZWNvcmF0aW9uICE9PSBcIm5vbmVcIikge1xuICAgICAgICBjb21wb25lbnRzLnB1c2godGhpcy5vcHRpb25zLnRleHREZWNvcmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzLm9wdGlvbnMudGV4dEFsaWduKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3Ryb2tlICE9PSBcIm5vbmVcIikge1xuICAgICAgICBjb21wb25lbnRzLnB1c2godGhpcy5vcHRpb25zLnN0cm9rZSk7XG4gICAgICB9XG4gICAgICBpZiAoIShpc0VtcHR5KHRoaXMub3B0aW9ucy5sZXR0ZXJTcGFjaW5nKSAmJiAhaXNOdW1iZXJMaWtlKHRoaXMub3B0aW9ucy5sZXR0ZXJTcGFjaW5nKSkpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKFwibGV0dGVyX3NwYWNpbmdfXCIgKyB0aGlzLm9wdGlvbnMubGV0dGVyU3BhY2luZyk7XG4gICAgICB9XG4gICAgICBpZiAoIShpc0VtcHR5KHRoaXMub3B0aW9ucy5saW5lU3BhY2luZykgJiYgIWlzTnVtYmVyTGlrZSh0aGlzLm9wdGlvbnMubGluZVNwYWNpbmcpKSkge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goXCJsaW5lX3NwYWNpbmdfXCIgKyB0aGlzLm9wdGlvbnMubGluZVNwYWNpbmcpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0VtcHR5KHRoaXMub3B0aW9ucy5mb250QW50aWFsaWFzaW5nKSkge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goXCJhbnRpYWxpYXNfXCIgKyB0aGlzLm9wdGlvbnMuZm9udEFudGlhbGlhc2luZyk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzRW1wdHkodGhpcy5vcHRpb25zLmZvbnRIaW50aW5nKSkge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goXCJoaW50aW5nX1wiICsgdGhpcy5vcHRpb25zLmZvbnRIaW50aW5nKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNFbXB0eShjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0KCkoY29tcG9uZW50cykpKSB7XG4gICAgICAgIGlmIChpc0VtcHR5KHRoaXMub3B0aW9ucy5mb250RmFtaWx5KSkge1xuICAgICAgICAgIHRocm93IFwiTXVzdCBzdXBwbHkgZm9udEZhbWlseS4gXCIuY29uY2F0KGNvbXBvbmVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0VtcHR5KHRoaXMub3B0aW9ucy5mb250U2l6ZSkgJiYgIWlzTnVtYmVyTGlrZSh0aGlzLm9wdGlvbnMuZm9udFNpemUpKSB7XG4gICAgICAgICAgdGhyb3cgXCJNdXN0IHN1cHBseSBmb250U2l6ZS5cIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29tcG9uZW50cy51bnNoaWZ0KHRoaXMub3B0aW9ucy5mb250RmFtaWx5LCB0aGlzLm9wdGlvbnMuZm9udFNpemUpO1xuICAgICAgY29tcG9uZW50cyA9IGNvbXBhY3Rfcm9vdF9jb21wYWN0X2RlZmF1bHQoKShjb21wb25lbnRzKS5qb2luKFwiX1wiKTtcbiAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbiAgfV0pO1xufShsYXllcl9sYXllcik7XG47XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0ZXh0bGF5ZXIgPSAodGV4dGxheWVyX1RleHRMYXllcik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9sYXllci9zdWJ0aXRsZXNsYXllci5qc1xuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gc3VidGl0bGVzbGF5ZXJfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIHN1YnRpdGxlc2xheWVyX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHN1YnRpdGxlc2xheWVyX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIHN1YnRpdGxlc2xheWVyX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBzdWJ0aXRsZXNsYXllcl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gc3VidGl0bGVzbGF5ZXJfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHN1YnRpdGxlc2xheWVyX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBzdWJ0aXRsZXNsYXllcl90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gc3VidGl0bGVzbGF5ZXJfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gc3VidGl0bGVzbGF5ZXJfZ2V0UHJvdG90eXBlT2YobyksIHN1YnRpdGxlc2xheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgc3VidGl0bGVzbGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBzdWJ0aXRsZXNsYXllcl9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChzdWJ0aXRsZXNsYXllcl90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gc3VidGl0bGVzbGF5ZXJfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBzdWJ0aXRsZXNsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoc3VidGl0bGVzbGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfZ2V0UHJvdG90eXBlT2YobykgeyBzdWJ0aXRsZXNsYXllcl9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gc3VidGl0bGVzbGF5ZXJfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIHN1YnRpdGxlc2xheWVyX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIHN1YnRpdGxlc2xheWVyX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gc3VidGl0bGVzbGF5ZXJfc2V0UHJvdG90eXBlT2YobywgcCkgeyBzdWJ0aXRsZXNsYXllcl9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gc3VidGl0bGVzbGF5ZXJfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIFN1YnRpdGxlc0xheWVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVGV4dExheWVyKSB7XG4gIC8qKlxuICAgKiBSZXByZXNlbnQgYSBzdWJ0aXRsZXMgbGF5ZXJcbiAgICogQGNvbnN0cnVjdG9yIFN1YnRpdGxlc0xheWVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gbGF5ZXIgcGFyYW1ldGVyc1xuICAgKi9cbiAgZnVuY3Rpb24gU3VidGl0bGVzTGF5ZXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcbiAgICBzdWJ0aXRsZXNsYXllcl9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdWJ0aXRsZXNMYXllcik7XG4gICAgX3RoaXMgPSBzdWJ0aXRsZXNsYXllcl9jYWxsU3VwZXIodGhpcywgU3VidGl0bGVzTGF5ZXIsIFtvcHRpb25zXSk7XG4gICAgX3RoaXMub3B0aW9ucy5yZXNvdXJjZVR5cGUgPSBcInN1YnRpdGxlc1wiO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBzdWJ0aXRsZXNsYXllcl9pbmhlcml0cyhTdWJ0aXRsZXNMYXllciwgX1RleHRMYXllcik7XG4gIHJldHVybiBzdWJ0aXRsZXNsYXllcl9jcmVhdGVDbGFzcyhTdWJ0aXRsZXNMYXllcik7XG59KHRleHRsYXllcik7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzdWJ0aXRsZXNsYXllciA9IChTdWJ0aXRsZXNMYXllcik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9sYXllci9mZXRjaGxheWVyLmpzXG5mdW5jdGlvbiBmZXRjaGxheWVyX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIGZldGNobGF5ZXJfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIGZldGNobGF5ZXJfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBmZXRjaGxheWVyX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIGZldGNobGF5ZXJfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGZldGNobGF5ZXJfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIGZldGNobGF5ZXJfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBmZXRjaGxheWVyX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBmZXRjaGxheWVyX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBmZXRjaGxheWVyX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IGZldGNobGF5ZXJfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IGZldGNobGF5ZXJfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBmZXRjaGxheWVyX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gZmV0Y2hsYXllcl90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gZmV0Y2hsYXllcl90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gZmV0Y2hsYXllcl9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IGZldGNobGF5ZXJfZ2V0UHJvdG90eXBlT2YobyksIGZldGNobGF5ZXJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBmZXRjaGxheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgZmV0Y2hsYXllcl9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gZmV0Y2hsYXllcl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKGZldGNobGF5ZXJfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIGZldGNobGF5ZXJfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBmZXRjaGxheWVyX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBmZXRjaGxheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKGZldGNobGF5ZXJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gZmV0Y2hsYXllcl9nZXRQcm90b3R5cGVPZihvKSB7IGZldGNobGF5ZXJfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIGZldGNobGF5ZXJfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIGZldGNobGF5ZXJfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgZmV0Y2hsYXllcl9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cbmZ1bmN0aW9uIGZldGNobGF5ZXJfc2V0UHJvdG90eXBlT2YobywgcCkgeyBmZXRjaGxheWVyX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBmZXRjaGxheWVyX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cblxudmFyIGZldGNobGF5ZXJfRmV0Y2hMYXllciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xheWVyKSB7XG4gIC8qKlxuICAgKiBAY2xhc3MgRmV0Y2hMYXllclxuICAgKiBAY2xhc3NkZXNjIENyZWF0ZXMgYW4gaW1hZ2UgbGF5ZXIgdXNpbmcgYSByZW1vdGUgVVJMLlxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IG9wdGlvbnMgLSBsYXllciBwYXJhbWV0ZXJzIG9yIGEgdXJsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVybCB0aGUgdXJsIG9mIHRoZSBpbWFnZSB0byBmZXRjaFxuICAgKi9cbiAgZnVuY3Rpb24gRmV0Y2hMYXllcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIGZldGNobGF5ZXJfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmV0Y2hMYXllcik7XG4gICAgX3RoaXMgPSBmZXRjaGxheWVyX2NhbGxTdXBlcih0aGlzLCBGZXRjaExheWVyLCBbb3B0aW9uc10pO1xuICAgIGlmIChpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKShvcHRpb25zKSkge1xuICAgICAgX3RoaXMub3B0aW9ucy51cmwgPSBvcHRpb25zO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy51cmwgOiB2b2lkIDApIHtcbiAgICAgIF90aGlzLm9wdGlvbnMudXJsID0gb3B0aW9ucy51cmw7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBmZXRjaGxheWVyX2luaGVyaXRzKEZldGNoTGF5ZXIsIF9MYXllcik7XG4gIHJldHVybiBmZXRjaGxheWVyX2NyZWF0ZUNsYXNzKEZldGNoTGF5ZXIsIFt7XG4gICAga2V5OiBcInVybFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cmwoX3VybCkge1xuICAgICAgdGhpcy5vcHRpb25zLnVybCA9IF91cmw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsYXllclxuICAgICAqIEBmdW5jdGlvbiBGZXRjaExheWVyI3RvU3RyaW5nXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiZmV0Y2g6XCIuY29uY2F0KGJhc2U2NEVuY29kZVVSTCh0aGlzLm9wdGlvbnMudXJsKSk7XG4gICAgfVxuICB9XSk7XG59KGxheWVyX2xheWVyKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGZldGNobGF5ZXIgPSAoZmV0Y2hsYXllcl9GZXRjaExheWVyKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3BhcmFtZXRlcnMuanNcbmZ1bmN0aW9uIHBhcmFtZXRlcnNfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKG8pLCBwYXJhbWV0ZXJzX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgcGFyYW1ldGVyc19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChwYXJhbWV0ZXJzX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBwYXJhbWV0ZXJzX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gcGFyYW1ldGVyc19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gcGFyYW1ldGVyc19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChwYXJhbWV0ZXJzX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIF9nZXQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQuYmluZCgpOyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gcGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5mdW5jdGlvbiBwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKG8pIHsgcGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gcGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZihvKTsgfVxuZnVuY3Rpb24gcGFyYW1ldGVyc19pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBwYXJhbWV0ZXJzX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gcGFyYW1ldGVyc19zZXRQcm90b3R5cGVPZihvLCBwKSB7IHBhcmFtZXRlcnNfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIHBhcmFtZXRlcnNfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gcGFyYW1ldGVyc190eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgcGFyYW1ldGVyc190eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gcGFyYW1ldGVyc19kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcGFyYW1ldGVyc190b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gcGFyYW1ldGVyc19jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIHBhcmFtZXRlcnNfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIHBhcmFtZXRlcnNfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gcGFyYW1ldGVyc190b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gcGFyYW1ldGVyc190eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIHBhcmFtZXRlcnNfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBwYXJhbWV0ZXJzX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBwYXJhbWV0ZXJzX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5cblxuXG5cblxuXG5cblxuLyoqXG4gKiBUcmFuc2Zvcm1hdGlvbiBwYXJhbWV0ZXJzXG4gKiBEZXBlbmRzIG9uICd1dGlsJywgJ3RyYW5zZm9ybWF0aW9uJ1xuICovXG52YXIgcGFyYW1ldGVyc19QYXJhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgc2luZ2xlIHBhcmFtZXRlci5cbiAgICogQGNsYXNzIFBhcmFtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciBpbiBzbmFrZV9jYXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaG9ydE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc2VyaWFsaXplZCBmb3JtIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIElmIGEgdmFsdWUgaXMgbm90IHByb3ZpZGVkLCB0aGUgcGFyYW1ldGVyIHdpbGwgbm90IGJlIHNlcmlhbGl6ZWQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcm9jZXNzPVV0aWwuaWRlbnRpdHkgXSAtIE1hbmlwdWxhdGUgb3JpZ1ZhbHVlIHdoZW4gdmFsdWUgaXMgY2FsbGVkXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIFBhcmFtKG5hbWUsIHNob3J0TmFtZSkge1xuICAgIHZhciBwcm9jZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBpZGVudGl0eV9yb290X2lkZW50aXR5X2RlZmF1bHQuYTtcbiAgICBwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcmFtKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIGluIHNuYWtlX2Nhc2VcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IFBhcmFtI25hbWVcbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIHBhcmFtZXRlclxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gUGFyYW0jc2hvcnROYW1lXG4gICAgICovXG4gICAgdGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWU7XG4gICAgLyoqXG4gICAgICogTWFuaXB1bGF0ZSBvcmlnVmFsdWUgd2hlbiB2YWx1ZSBpcyBjYWxsZWRcbiAgICAgKiBAbWVtYmVyIHtmdW5jdGlvbn0gUGFyYW0jcHJvY2Vzc1xuICAgICAqL1xuICAgIHRoaXMucHJvY2VzcyA9IHByb2Nlc3M7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgKHVucHJvY2Vzc2VkKSB2YWx1ZSBmb3IgdGhpcyBwYXJhbWV0ZXJcbiAgICogQGZ1bmN0aW9uIFBhcmFtI3NldFxuICAgKiBAcGFyYW0geyp9IG9yaWdWYWx1ZSAtIHRoZSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyXG4gICAqIEByZXR1cm4ge1BhcmFtfSBzZWxmIGZvciBjaGFpbmluZ1xuICAgKi9cbiAgcmV0dXJuIHBhcmFtZXRlcnNfY3JlYXRlQ2xhc3MoUGFyYW0sIFt7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQob3JpZ1ZhbHVlKSB7XG4gICAgICB0aGlzLm9yaWdWYWx1ZSA9IG9yaWdWYWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIHBhcmFtZXRlclxuICAgICAqIEBmdW5jdGlvbiBQYXJhbSNzZXJpYWxpemVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIHBhcmFtZXRlclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICB2YXIgdmFsLCB2YWxpZDtcbiAgICAgIHZhbCA9IHRoaXMudmFsdWUoKTtcbiAgICAgIHZhbGlkID0gaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHZhbCkgfHwgaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCgpKHZhbCkgfHwgaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkodmFsKSA/ICFpc0VtcHR5KHZhbCkgOiB2YWwgIT0gbnVsbDtcbiAgICAgIGlmICh0aGlzLnNob3J0TmFtZSAhPSBudWxsICYmIHZhbGlkKSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLnNob3J0TmFtZSwgXCJfXCIpLmNvbmNhdCh2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcHJvY2Vzc2VkIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICAgKiBAZnVuY3Rpb24gUGFyYW0jdmFsdWVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3ModGhpcy5vcmlnVmFsdWUpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcIm5vcm1fY29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybV9jb2xvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyB2YWx1ZS5yZXBsYWNlKC9eIy8sICdyZ2I6JykgOiB2b2lkIDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJ1aWxkX2FycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkX2FycmF5KGFyZykge1xuICAgICAgaWYgKGFyZyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKGFyZykpIHtcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbYXJnXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAqIENvdmVydCB2YWx1ZSB0byB2aWRlbyBjb2RlYyBzdHJpbmcuXG4gICAgKlxuICAgICogSWYgdGhlIHBhcmFtZXRlciBpcyBhbiBvYmplY3QsXG4gICAgKiBAcGFyYW0geyhzdHJpbmd8T2JqZWN0KX0gcGFyYW0gLSB0aGUgdmlkZW8gY29kZWMgYXMgZWl0aGVyIGEgU3RyaW5nIG9yIGEgSGFzaFxuICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgdmlkZW8gY29kZWMgc3RyaW5nIGluIHRoZSBmb3JtYXQgY29kZWM6cHJvZmlsZTpsZXZlbDpiX2ZyYW1lc1xuICAgICogQGV4YW1wbGVcbiAgICAqIHZjX1sgOnByb2ZpbGUgOiBbbGV2ZWwgOiBbYl9mcmFtZXNdXV1cbiAgICAqIG9yXG4gICAgICB7IGNvZGVjOiAnaDI2NCcsIHByb2ZpbGU6ICdiYXNpYycsIGxldmVsOiAnMy4xJywgYl9mcmFtZXM6IGZhbHNlIH1cbiAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzX3ZpZGVvX3BhcmFtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzX3ZpZGVvX3BhcmFtcyhwYXJhbSkge1xuICAgICAgdmFyIHZpZGVvO1xuICAgICAgc3dpdGNoIChwYXJhbS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBjYXNlIE9iamVjdDpcbiAgICAgICAgICB2aWRlbyA9IFwiXCI7XG4gICAgICAgICAgaWYgKCdjb2RlYycgaW4gcGFyYW0pIHtcbiAgICAgICAgICAgIHZpZGVvID0gcGFyYW0uY29kZWM7XG4gICAgICAgICAgICBpZiAoJ3Byb2ZpbGUnIGluIHBhcmFtKSB7XG4gICAgICAgICAgICAgIHZpZGVvICs9IFwiOlwiICsgcGFyYW0ucHJvZmlsZTtcbiAgICAgICAgICAgICAgaWYgKCdsZXZlbCcgaW4gcGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2aWRlbyArPSBcIjpcIiArIHBhcmFtLmxldmVsO1xuICAgICAgICAgICAgICAgIGlmICgnYl9mcmFtZXMnIGluIHBhcmFtICYmIHBhcmFtLmJfZnJhbWVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgdmlkZW8gKz0gXCI6YmZyYW1lc19ub1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmlkZW87XG4gICAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbn0oKTtcbnZhciBwYXJhbWV0ZXJzX0FycmF5UGFyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QYXJhbSkge1xuICAvKipcbiAgICogQSBwYXJhbWV0ZXIgdGhhdCByZXByZXNlbnRzIGFuIGFycmF5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgaW4gc25ha2VfY2FzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNob3J0TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIHBhcmFtZXRlclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBJZiBhIHZhbHVlIGlzIG5vdCBwcm92aWRlZCwgdGhlIHBhcmFtZXRlciB3aWxsIG5vdCBiZSBzZXJpYWxpemVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NlcD0nLiddIC0gVGhlIHNlcGFyYXRvciB0byB1c2Ugd2hlbiBqb2luaW5nIHRoZSBhcnJheSBlbGVtZW50cyB0b2dldGhlclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcHJvY2Vzcz1VdGlsLmlkZW50aXR5IF0gLSBNYW5pcHVsYXRlIG9yaWdWYWx1ZSB3aGVuIHZhbHVlIGlzIGNhbGxlZFxuICAgKiBAY2xhc3MgQXJyYXlQYXJhbVxuICAgKiBAZXh0ZW5kcyBQYXJhbVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBBcnJheVBhcmFtKG5hbWUsIHNob3J0TmFtZSkge1xuICAgIHZhciBfdGhpcztcbiAgICB2YXIgc2VwID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnLic7XG4gICAgdmFyIHByb2Nlc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcbiAgICBwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFycmF5UGFyYW0pO1xuICAgIF90aGlzID0gcGFyYW1ldGVyc19jYWxsU3VwZXIodGhpcywgQXJyYXlQYXJhbSwgW25hbWUsIHNob3J0TmFtZSwgcHJvY2Vzc10pO1xuICAgIF90aGlzLnNlcCA9IHNlcDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgcGFyYW1ldGVyc19pbmhlcml0cyhBcnJheVBhcmFtLCBfUGFyYW0pO1xuICByZXR1cm4gcGFyYW1ldGVyc19jcmVhdGVDbGFzcyhBcnJheVBhcmFtLCBbe1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgaWYgKHRoaXMuc2hvcnROYW1lICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGFycmF5VmFsdWUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgIGlmIChpc0VtcHR5KGFycmF5VmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKGFycmF5VmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuc2hvcnROYW1lLCBcIl9cIikuY29uY2F0KGFycmF5VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBmbGF0ID0gYXJyYXlWYWx1ZS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkodC5zZXJpYWxpemUpID8gdC5zZXJpYWxpemUoKSA6IHQ7XG4gICAgICAgICAgfSkuam9pbih0aGlzLnNlcCk7XG4gICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuc2hvcnROYW1lLCBcIl9cIikuY29uY2F0KGZsYXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHRoaXMub3JpZ1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnVmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5wcm9jZXNzKHYpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3ModGhpcy5vcmlnVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KG9yaWdWYWx1ZSkge1xuICAgICAgaWYgKG9yaWdWYWx1ZSA9PSBudWxsIHx8IGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShvcmlnVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YoQXJyYXlQYXJhbS5wcm90b3R5cGUpLCBcInNldFwiLCB0aGlzKS5jYWxsKHRoaXMsIG9yaWdWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX2dldChwYXJhbWV0ZXJzX2dldFByb3RvdHlwZU9mKEFycmF5UGFyYW0ucHJvdG90eXBlKSwgXCJzZXRcIiwgdGhpcykuY2FsbCh0aGlzLCBbb3JpZ1ZhbHVlXSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG59KHBhcmFtZXRlcnNfUGFyYW0pO1xudmFyIHBhcmFtZXRlcnNfVHJhbnNmb3JtYXRpb25QYXJhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BhcmFtMikge1xuICAvKipcbiAgICogQSBwYXJhbWV0ZXIgdGhhdCByZXByZXNlbnRzIGEgdHJhbnNmb3JtYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIGluIHNuYWtlX2Nhc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzaG9ydE5hbWU9J3QnXSAtIFRoZSBuYW1lIG9mIHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgdGhlIHBhcmFtZXRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NlcD0nLiddIC0gVGhlIHNlcGFyYXRvciB0byB1c2Ugd2hlbiBqb2luaW5nIHRoZSBhcnJheSBlbGVtZW50cyB0b2dldGhlclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcHJvY2Vzcz1VdGlsLmlkZW50aXR5IF0gLSBNYW5pcHVsYXRlIG9yaWdWYWx1ZSB3aGVuIHZhbHVlIGlzIGNhbGxlZFxuICAgKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25QYXJhbVxuICAgKiBAZXh0ZW5kcyBQYXJhbVxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvblBhcmFtKG5hbWUpIHtcbiAgICB2YXIgX3RoaXMzO1xuICAgIHZhciBzaG9ydE5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwidFwiO1xuICAgIHZhciBzZXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICcuJztcbiAgICB2YXIgcHJvY2VzcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNmb3JtYXRpb25QYXJhbSk7XG4gICAgX3RoaXMzID0gcGFyYW1ldGVyc19jYWxsU3VwZXIodGhpcywgVHJhbnNmb3JtYXRpb25QYXJhbSwgW25hbWUsIHNob3J0TmFtZSwgcHJvY2Vzc10pO1xuICAgIF90aGlzMy5zZXAgPSBzZXA7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBzdHJpbmcgcmVwcmVzZW50YXRpb25zIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgZWl0aGVyIHRoZSB0cmFuc2Zvcm1hdGlvbiBhcyBhIHN0cmluZywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5nIHJlcHJlc2VudGF0aW9ucy5cbiAgICovXG4gIHBhcmFtZXRlcnNfaW5oZXJpdHMoVHJhbnNmb3JtYXRpb25QYXJhbSwgX1BhcmFtMik7XG4gIHJldHVybiBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKFRyYW5zZm9ybWF0aW9uUGFyYW0sIFt7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIHZhciB2YWwgPSB0aGlzLnZhbHVlKCk7XG4gICAgICBpZiAoaXNFbXB0eSh2YWwpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHZhbCBpcyBhbiBhcnJheSBvZiBzdHJpbmdzIHNvIGpvaW4gdGhlbVxuICAgICAgaWYgKGJhc2V1dGlsX2FsbFN0cmluZ3ModmFsKSkge1xuICAgICAgICB2YXIgam9pbmVkID0gdmFsLmpvaW4odGhpcy5zZXApOyAvLyBjcmVhdGVzIHQxLnQyLnQzIGluIGNhc2UgbXVsdGlwbGUgbmFtZWQgdHJhbnNmb3JtYXRpb25zIHdlcmUgY29uZmlndXJlZFxuICAgICAgICBpZiAoIWlzRW1wdHkoam9pbmVkKSkge1xuICAgICAgICAgIC8vIGluIGNhc2Ugb3B0aW9ucy50cmFuc2Zvcm1hdGlvbiB3YXMgbm90IHNldCB3aXRoIGFuIGVtcHR5IHN0cmluZyAodmFsICE9IFsnJ10pO1xuICAgICAgICAgIHJlc3VsdCA9IFwiXCIuY29uY2F0KHRoaXMuc2hvcnROYW1lLCBcIl9cIikuY29uY2F0KGpvaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbnZlcnQgdmFsIHRvIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgICAgcmVzdWx0ID0gdmFsLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIGlmIChpc1N0cmluZ19yb290X2lzU3RyaW5nX2RlZmF1bHQoKSh0KSAmJiAhaXNFbXB0eSh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KF90aGlzNC5zaG9ydE5hbWUsIFwiX1wiKS5jb25jYXQodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkodC5zZXJpYWxpemUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdC5zZXJpYWxpemUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0X2RlZmF1bHQoKSh0KSAmJiAhaXNFbXB0eSh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBzcmNfdHJhbnNmb3JtYXRpb24odCkuc2VyaWFsaXplKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQob3JpZ1ZhbHVlMSkge1xuICAgICAgdGhpcy5vcmlnVmFsdWUgPSBvcmlnVmFsdWUxO1xuICAgICAgaWYgKGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKSh0aGlzLm9yaWdWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQocGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZihUcmFuc2Zvcm1hdGlvblBhcmFtLnByb3RvdHlwZSksIFwic2V0XCIsIHRoaXMpLmNhbGwodGhpcywgdGhpcy5vcmlnVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9nZXQocGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZihUcmFuc2Zvcm1hdGlvblBhcmFtLnByb3RvdHlwZSksIFwic2V0XCIsIHRoaXMpLmNhbGwodGhpcywgW3RoaXMub3JpZ1ZhbHVlXSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG59KHBhcmFtZXRlcnNfUGFyYW0pO1xudmFyIG51bWJlcl9wYXR0ZXJuID0gXCIoWzAtOV0qKVxcXFwuKFswLTldKyl8KFswLTldKylcIjtcbnZhciBvZmZzZXRfYW55X3BhdHRlcm4gPSBcIihcIiArIG51bWJlcl9wYXR0ZXJuICsgXCIpKFslcFBdKT9cIjtcbnZhciBwYXJhbWV0ZXJzX1JhbmdlUGFyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QYXJhbTMpIHtcbiAgLyoqXG4gICAqIEEgcGFyYW1ldGVyIHRoYXQgcmVwcmVzZW50cyBhIHJhbmdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlciBpbiBzbmFrZV9jYXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaG9ydE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc2VyaWFsaXplZCBmb3JtIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgSWYgYSB2YWx1ZSBpcyBub3QgcHJvdmlkZWQsIHRoZSBwYXJhbWV0ZXIgd2lsbCBub3QgYmUgc2VyaWFsaXplZC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3Byb2Nlc3M9bm9ybV9yYW5nZV92YWx1ZSBdIC0gTWFuaXB1bGF0ZSBvcmlnVmFsdWUgd2hlbiB2YWx1ZSBpcyBjYWxsZWRcbiAgICogQGNsYXNzIFJhbmdlUGFyYW1cbiAgICogQGV4dGVuZHMgUGFyYW1cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgZnVuY3Rpb24gUmFuZ2VQYXJhbShuYW1lLCBzaG9ydE5hbWUpIHtcbiAgICB2YXIgcHJvY2VzcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogUmFuZ2VQYXJhbS5ub3JtX3JhbmdlX3ZhbHVlO1xuICAgIHBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmFuZ2VQYXJhbSk7XG4gICAgcmV0dXJuIHBhcmFtZXRlcnNfY2FsbFN1cGVyKHRoaXMsIFJhbmdlUGFyYW0sIFtuYW1lLCBzaG9ydE5hbWUsIHByb2Nlc3NdKTtcbiAgfVxuICBwYXJhbWV0ZXJzX2luaGVyaXRzKFJhbmdlUGFyYW0sIF9QYXJhbTMpO1xuICByZXR1cm4gcGFyYW1ldGVyc19jcmVhdGVDbGFzcyhSYW5nZVBhcmFtLCBudWxsLCBbe1xuICAgIGtleTogXCJub3JtX3JhbmdlX3ZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1fcmFuZ2VfdmFsdWUodmFsdWUpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBTdHJpbmcodmFsdWUpLm1hdGNoKG5ldyBSZWdFeHAoJ14nICsgb2Zmc2V0X2FueV9wYXR0ZXJuICsgJyQnKSk7XG4gICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgIHZhciBtb2RpZmllciA9IG9mZnNldFs1XSAhPSBudWxsID8gJ3AnIDogJyc7XG4gICAgICAgIHZhbHVlID0gKG9mZnNldFsxXSB8fCBvZmZzZXRbNF0pICsgbW9kaWZpZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwcmVzc2lvbi5ub3JtYWxpemUodmFsdWUpO1xuICAgIH1cbiAgfV0pO1xufShwYXJhbWV0ZXJzX1BhcmFtKTtcbnZhciBwYXJhbWV0ZXJzX1Jhd1BhcmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGFyYW00KSB7XG4gIGZ1bmN0aW9uIFJhd1BhcmFtKG5hbWUsIHNob3J0TmFtZSkge1xuICAgIHZhciBwcm9jZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBpZGVudGl0eV9yb290X2lkZW50aXR5X2RlZmF1bHQuYTtcbiAgICBwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhd1BhcmFtKTtcbiAgICByZXR1cm4gcGFyYW1ldGVyc19jYWxsU3VwZXIodGhpcywgUmF3UGFyYW0sIFtuYW1lLCBzaG9ydE5hbWUsIHByb2Nlc3NdKTtcbiAgfVxuICBwYXJhbWV0ZXJzX2luaGVyaXRzKFJhd1BhcmFtLCBfUGFyYW00KTtcbiAgcmV0dXJuIHBhcmFtZXRlcnNfY3JlYXRlQ2xhc3MoUmF3UGFyYW0sIFt7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZSgpO1xuICAgIH1cbiAgfV0pO1xufShwYXJhbWV0ZXJzX1BhcmFtKTtcbnZhciBwYXJhbWV0ZXJzX0xheWVyUGFyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QYXJhbTUpIHtcbiAgZnVuY3Rpb24gTGF5ZXJQYXJhbSgpIHtcbiAgICBwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExheWVyUGFyYW0pO1xuICAgIHJldHVybiBwYXJhbWV0ZXJzX2NhbGxTdXBlcih0aGlzLCBMYXllclBhcmFtLCBhcmd1bWVudHMpO1xuICB9XG4gIHBhcmFtZXRlcnNfaW5oZXJpdHMoTGF5ZXJQYXJhbSwgX1BhcmFtNSk7XG4gIHJldHVybiBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKExheWVyUGFyYW0sIFt7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgdmFsdWU6XG4gICAgLy8gUGFyc2UgbGF5ZXIgb3B0aW9uc1xuICAgIC8vIEByZXR1cm4gW3N0cmluZ10gbGF5ZXIgdHJhbnNmb3JtYXRpb24gc3RyaW5nXG4gICAgLy8gQHByaXZhdGVcbiAgICBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIGlmICh0aGlzLm9yaWdWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAodGhpcy5vcmlnVmFsdWUgaW5zdGFuY2VvZiBsYXllcl9sYXllcikge1xuICAgICAgICByZXN1bHQgPSB0aGlzLm9yaWdWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCgpKHRoaXMub3JpZ1ZhbHVlKSkge1xuICAgICAgICB2YXIgbGF5ZXJPcHRpb25zID0gd2l0aENhbWVsQ2FzZUtleXModGhpcy5vcmlnVmFsdWUpO1xuICAgICAgICBpZiAobGF5ZXJPcHRpb25zLnJlc291cmNlVHlwZSA9PT0gXCJ0ZXh0XCIgfHwgbGF5ZXJPcHRpb25zLnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdCA9IG5ldyB0ZXh0bGF5ZXIobGF5ZXJPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXllck9wdGlvbnMucmVzb3VyY2VUeXBlID09PSBcInN1YnRpdGxlc1wiKSB7XG4gICAgICAgICAgcmVzdWx0ID0gbmV3IHN1YnRpdGxlc2xheWVyKGxheWVyT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAobGF5ZXJPcHRpb25zLnJlc291cmNlVHlwZSA9PT0gXCJmZXRjaFwiIHx8IGxheWVyT3B0aW9ucy51cmwgIT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdCA9IG5ldyBmZXRjaGxheWVyKGxheWVyT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gbmV3IGxheWVyX2xheWVyKGxheWVyT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkodGhpcy5vcmlnVmFsdWUpKSB7XG4gICAgICAgIGlmICgvXmZldGNoOi4rLy50ZXN0KHRoaXMub3JpZ1ZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdCA9IG5ldyBmZXRjaGxheWVyKHRoaXMub3JpZ1ZhbHVlLnN1YnN0cig2KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gdGhpcy5vcmlnVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9ICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdC50b1N0cmluZygpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInRleHRTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0U3R5bGUobGF5ZXIpIHtcbiAgICAgIHJldHVybiBuZXcgdGV4dGxheWVyKGxheWVyKS50ZXh0U3R5bGVJZGVudGlmaWVyKCk7XG4gICAgfVxuICB9XSk7XG59KHBhcmFtZXRlcnNfUGFyYW0pO1xudmFyIHBhcmFtZXRlcnNfRXhwcmVzc2lvblBhcmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGFyYW02KSB7XG4gIGZ1bmN0aW9uIEV4cHJlc3Npb25QYXJhbSgpIHtcbiAgICBwYXJhbWV0ZXJzX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV4cHJlc3Npb25QYXJhbSk7XG4gICAgcmV0dXJuIHBhcmFtZXRlcnNfY2FsbFN1cGVyKHRoaXMsIEV4cHJlc3Npb25QYXJhbSwgYXJndW1lbnRzKTtcbiAgfVxuICBwYXJhbWV0ZXJzX2luaGVyaXRzKEV4cHJlc3Npb25QYXJhbSwgX1BhcmFtNik7XG4gIHJldHVybiBwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzKEV4cHJlc3Npb25QYXJhbSwgW3tcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHJldHVybiBleHByZXNzaW9uLm5vcm1hbGl6ZShfZ2V0KHBhcmFtZXRlcnNfZ2V0UHJvdG90eXBlT2YoRXhwcmVzc2lvblBhcmFtLnByb3RvdHlwZSksIFwic2VyaWFsaXplXCIsIHRoaXMpLmNhbGwodGhpcykpO1xuICAgIH1cbiAgfV0pO1xufShwYXJhbWV0ZXJzX1BhcmFtKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdHJhbnNmb3JtYXRpb24uanNcbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gdHJhbnNmb3JtYXRpb25fZ2V0UHJvdG90eXBlT2YobyksIHRyYW5zZm9ybWF0aW9uX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgdHJhbnNmb3JtYXRpb25faXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCB0cmFuc2Zvcm1hdGlvbl9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTsgfVxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmICh0cmFuc2Zvcm1hdGlvbl90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gdHJhbnNmb3JtYXRpb25fYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25faXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAodHJhbnNmb3JtYXRpb25faXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgcmV0dXJuICEhdDsgfSkoKTsgfVxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fZ2V0UHJvdG90eXBlT2YobykgeyB0cmFuc2Zvcm1hdGlvbl9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gdHJhbnNmb3JtYXRpb25fZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIHRyYW5zZm9ybWF0aW9uX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fc2V0UHJvdG90eXBlT2YobywgcCkgeyB0cmFuc2Zvcm1hdGlvbl9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gdHJhbnNmb3JtYXRpb25fc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiB0cmFuc2Zvcm1hdGlvbl9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IHRyYW5zZm9ybWF0aW9uX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdHJhbnNmb3JtYXRpb25fdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCB0cmFuc2Zvcm1hdGlvbl9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHRyYW5zZm9ybWF0aW9uX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiB0cmFuc2Zvcm1hdGlvbl9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gdHJhbnNmb3JtYXRpb25fdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIHRyYW5zZm9ybWF0aW9uX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHRyYW5zZm9ybWF0aW9uX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiB0cmFuc2Zvcm1hdGlvbl9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIHRyYW5zZm9ybWF0aW9uX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSB0cmFuc2Zvcm1hdGlvbl9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gdHJhbnNmb3JtYXRpb25fdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHRyYW5zZm9ybWF0aW9uX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gdHJhbnNmb3JtYXRpb25fdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSB0cmFuc2Zvcm1hdGlvbl90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gdHJhbnNmb3JtYXRpb25fdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cblxuXG5cblxuXG5cblxuLyoqXG4gKiBBc3NpZ24ga2V5LCB2YWx1ZSB0byB0YXJnZXQsIHdoZW4gdmFsdWUgaXMgbm90IG51bGwuPGJyPlxuICogICBUaGlzIGZ1bmN0aW9uIG11dGF0ZXMgdGhlIHRhcmdldCFcbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgdGhlIG9iamVjdCB0byBhc3NpZ24gdGhlIHZhbHVlcyB0b1xuICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZXMgb25lIG9yIG1vcmUgb2JqZWN0cyB0byBnZXQgdmFsdWVzIGZyb21cbiAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSB0YXJnZXQgYWZ0ZXIgdGhlIGFzc2lnbm1lbnRcbiAqL1xuZnVuY3Rpb24gYXNzaWduTm90TnVsbCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHNvdXJjZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChzb3VyY2Vba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uQmFzZVxuICogRGVwZW5kcyBvbiAnY29uZmlndXJhdGlvbicsICdwYXJhbWV0ZXJzJywndXRpbCdcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgdHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb25CYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIFRoZSBiYXNlIGNsYXNzIGZvciB0cmFuc2Zvcm1hdGlvbnMuXG4gICAqIE1lbWJlcnMgb2YgdGhpcyBjbGFzcyBhcmUgZG9jdW1lbnRlZCBhcyBiZWxvbmdpbmcgdG8gdGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gY2xhc3MgZm9yIGNvbnZlbmllbmNlLlxuICAgKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25CYXNlXG4gICAqL1xuICBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbkJhc2Uob3B0aW9ucykge1xuICAgIHRyYW5zZm9ybWF0aW9uX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zZm9ybWF0aW9uQmFzZSk7XG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgdmFyIHBhcmVudCwgdHJhbnM7XG4gICAgcGFyZW50ID0gdm9pZCAwO1xuICAgIHRyYW5zID0ge307XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIG9wdGlvbnMgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGFuIGlkZW50aWNhbCBUcmFuc2Zvcm1hdGlvblxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiN0b09wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYSBwbGFpbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoaXMgdHJhbnNmb3JtYXRpb25cbiAgICAgKi9cbiAgICB0aGlzLnRvT3B0aW9ucyA9IGZ1bmN0aW9uICh3aXRoQ2hhaW4pIHtcbiAgICAgIHZhciBvcHQgPSB7fTtcbiAgICAgIGlmICh3aXRoQ2hhaW4gPT0gbnVsbCkge1xuICAgICAgICB3aXRoQ2hhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmtleXModHJhbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gb3B0W2tleV0gPSB0cmFuc1trZXldLm9yaWdWYWx1ZTtcbiAgICAgIH0pO1xuICAgICAgYXNzaWduTm90TnVsbChvcHQsIHRoaXMub3RoZXJPcHRpb25zKTtcbiAgICAgIGlmICh3aXRoQ2hhaW4gJiYgIWlzRW1wdHkodGhpcy5jaGFpbmVkKSkge1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuY2hhaW5lZC5tYXAoZnVuY3Rpb24gKHRyKSB7XG4gICAgICAgICAgcmV0dXJuIHRyLnRvT3B0aW9ucygpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGlzdC5wdXNoKG9wdCk7XG4gICAgICAgIG9wdCA9IHt9O1xuICAgICAgICBhc3NpZ25Ob3ROdWxsKG9wdCwgdGhpcy5vdGhlck9wdGlvbnMpO1xuICAgICAgICBvcHQudHJhbnNmb3JtYXRpb24gPSBsaXN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBhIHBhcmVudCBmb3IgdGhpcyBvYmplY3QgZm9yIGNoYWluaW5nIHB1cnBvc2VzLlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI3NldFBhcmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSB0aGUgcGFyZW50IHRvIGJlIGFzc2lnbmVkIHRvXG4gICAgICogQHJldHVybnMge1RyYW5zZm9ybWF0aW9ufSBSZXR1cm5zIHRoaXMgaW5zdGFuY2UgZm9yIGNoYWluaW5nIHB1cnBvc2VzLlxuICAgICAqL1xuICAgIHRoaXMuc2V0UGFyZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcGFyZW50ID0gb2JqZWN0O1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZnJvbU9wdGlvbnModHlwZW9mIG9iamVjdC50b09wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IG9iamVjdC50b09wdGlvbnMoKSA6IHZvaWQgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBhcmVudCBvZiB0aGlzIG9iamVjdCBpbiB0aGUgY2hhaW5cbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jZ2V0UGFyZW50XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgcGFyZW50IG9mIHRoaXMgb2JqZWN0IGlmIHRoZXJlIGlzIGFueVxuICAgICAqL1xuICAgIHRoaXMuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9O1xuXG4gICAgLy8gSGVscGVyIG1ldGhvZHMgdG8gY3JlYXRlIHBhcmFtZXRlciBtZXRob2RzXG4gICAgLy8gVGhlc2UgbWV0aG9kcyBhcmUgZGVmaW5lZCBoZXJlIGJlY2F1c2UgdGhleSBhY2Nlc3MgYHRyYW5zYCB3aGljaCBpc1xuICAgIC8vIGEgcHJpdmF0ZSBtZW1iZXIgb2YgYFRyYW5zZm9ybWF0aW9uQmFzZWBcblxuICAgIC8qKiBAcHJvdGVjdGVkICovXG4gICAgdGhpcy5wYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgYWJiciwgZGVmYXVsdFZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICBpZiAocHJvY2VzcyA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICAgIHByb2Nlc3MgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2VzcyA9IGlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfZGVmYXVsdC5hO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmFuc1tuYW1lXSA9IG5ldyBwYXJhbWV0ZXJzX1BhcmFtKG5hbWUsIGFiYnIsIHByb2Nlc3MpLnNldCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBAcHJvdGVjdGVkICovXG4gICAgdGhpcy5yYXdQYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgYWJiciwgZGVmYXVsdFZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICBwcm9jZXNzID0gbGFzdEFyZ0NhbGxiYWNrKGFyZ3VtZW50cyk7XG4gICAgICB0cmFuc1tuYW1lXSA9IG5ldyBwYXJhbWV0ZXJzX1Jhd1BhcmFtKG5hbWUsIGFiYnIsIHByb2Nlc3MpLnNldCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBAcHJvdGVjdGVkICovXG4gICAgdGhpcy5yYW5nZVBhcmFtID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBhYmJyLCBkZWZhdWx0VmFsdWUsIHByb2Nlc3MpIHtcbiAgICAgIHByb2Nlc3MgPSBsYXN0QXJnQ2FsbGJhY2soYXJndW1lbnRzKTtcbiAgICAgIHRyYW5zW25hbWVdID0gbmV3IHBhcmFtZXRlcnNfUmFuZ2VQYXJhbShuYW1lLCBhYmJyLCBwcm9jZXNzKS5zZXQodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogQHByb3RlY3RlZCAqL1xuICAgIHRoaXMuYXJyYXlQYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgYWJicikge1xuICAgICAgdmFyIHNlcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCI6XCI7XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBbXTtcbiAgICAgIHZhciBwcm9jZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzID0gbGFzdEFyZ0NhbGxiYWNrKGFyZ3VtZW50cyk7XG4gICAgICB0cmFuc1tuYW1lXSA9IG5ldyBwYXJhbWV0ZXJzX0FycmF5UGFyYW0obmFtZSwgYWJiciwgc2VwLCBwcm9jZXNzKS5zZXQodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogQHByb3RlY3RlZCAqL1xuICAgIHRoaXMudHJhbnNmb3JtYXRpb25QYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgYWJicikge1xuICAgICAgdmFyIHNlcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCIuXCI7XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgcHJvY2VzcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2VzcyA9IGxhc3RBcmdDYWxsYmFjayhhcmd1bWVudHMpO1xuICAgICAgdHJhbnNbbmFtZV0gPSBuZXcgcGFyYW1ldGVyc19UcmFuc2Zvcm1hdGlvblBhcmFtKG5hbWUsIGFiYnIsIHNlcCwgcHJvY2Vzcykuc2V0KHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdGhpcy5sYXllclBhcmFtID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBhYmJyKSB7XG4gICAgICB0cmFuc1tuYW1lXSA9IG5ldyBwYXJhbWV0ZXJzX0xheWVyUGFyYW0obmFtZSwgYWJicikuc2V0KHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvLyBFbmQgSGVscGVyIG1ldGhvZHNcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNnZXRWYWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlclxuICAgICAqIEByZXR1cm4geyp9IHRoZSBwcm9jZXNzZWQgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAgICogQGRlc2NyaXB0aW9uIFVzZSB7QGxpbmsgZ2V0fS5vcmlnVmFsdWUgZm9yIHRoZSB2YWx1ZSBvcmlnaW5hbGx5IHByb3ZpZGVkIGZvciB0aGUgcGFyYW1ldGVyXG4gICAgICovXG4gICAgdGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0cmFuc1tuYW1lXSAmJiB0cmFuc1tuYW1lXS52YWx1ZSgpO1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHRoaXMub3RoZXJPcHRpb25zW25hbWVdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwYXJhbWV0ZXIgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyIG5hbWVcbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jZ2V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIHRyYW5zZm9ybWF0aW9uIHBhcmFtZXRlclxuICAgICAqIEByZXR1cm5zIHtQYXJhbX0gdGhlIHBhcmFtIG9iamVjdCBmb3IgdGhlIGdpdmVuIG5hbWUsIG9yIHVuZGVmaW5lZFxuICAgICAqL1xuICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiB0cmFuc1tuYW1lXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHRyYW5zZm9ybWF0aW9uIG9wdGlvbiBmcm9tIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jcmVtb3ZlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgb3B0aW9uIHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm4geyp9IFJldHVybnMgdGhlIG9wdGlvbiB0aGF0IHdhcyByZW1vdmVkIG9yIG51bGwgaWYgbm8gb3B0aW9uIGJ5IHRoYXQgbmFtZSB3YXMgZm91bmQuIFRoZSB0eXBlIG9mIHRoZVxuICAgICAqICAgICAgICAgICAgICByZXR1cm5lZCB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdGVtcDtcbiAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgY2FzZSB0cmFuc1tuYW1lXSA9PSBudWxsOlxuICAgICAgICAgIHRlbXAgPSB0cmFuc1tuYW1lXTtcbiAgICAgICAgICBkZWxldGUgdHJhbnNbbmFtZV07XG4gICAgICAgICAgcmV0dXJuIHRlbXAub3JpZ1ZhbHVlO1xuICAgICAgICBjYXNlIHRoaXMub3RoZXJPcHRpb25zW25hbWVdID09IG51bGw6XG4gICAgICAgICAgdGVtcCA9IHRoaXMub3RoZXJPcHRpb25zW25hbWVdO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLm90aGVyT3B0aW9uc1tuYW1lXTtcbiAgICAgICAgICByZXR1cm4gdGVtcDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiBhbGwgdGhlIGtleXMgKG9wdGlvbiBuYW1lcykgaW4gdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IHRoZSBrZXlzIGluIHNuYWtlQ2FzZSBmb3JtYXRcbiAgICAgKi9cbiAgICB0aGlzLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIga2V5O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChrZXkgaW4gdHJhbnMpIHtcbiAgICAgICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChrZXkubWF0Y2goVkFSX05BTUVfUkUpID8ga2V5IDogc25ha2VDYXNlKGtleSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH0oKS5zb3J0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbi4gVmFsdWVzIGFyZSBwcm9jZXNzZWQuXG4gICAgICogQGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9uI3RvUGxhaW5PYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSB0cmFuc2Zvcm1hdGlvbiBvcHRpb25zIGFzIHBsYWluIG9iamVjdFxuICAgICAqL1xuICAgIHRoaXMudG9QbGFpbk9iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBoYXNoLCBrZXksIGxpc3Q7XG4gICAgICBoYXNoID0ge307XG4gICAgICBmb3IgKGtleSBpbiB0cmFucykge1xuICAgICAgICBoYXNoW2tleV0gPSB0cmFuc1trZXldLnZhbHVlKCk7XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkoaGFzaFtrZXldKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0KCkoaGFzaFtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc0VtcHR5KHRoaXMuY2hhaW5lZCkpIHtcbiAgICAgICAgbGlzdCA9IHRoaXMuY2hhaW5lZC5tYXAoZnVuY3Rpb24gKHRyKSB7XG4gICAgICAgICAgcmV0dXJuIHRyLnRvUGxhaW5PYmplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxpc3QucHVzaChoYXNoKTtcbiAgICAgICAgaGFzaCA9IHtcbiAgICAgICAgICB0cmFuc2Zvcm1hdGlvbjogbGlzdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZSB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBhbmQgY2hhaW4gdG8gYSBuZXcgb25lLlxuICAgICAqIEluIHRoZSBVUkwsIHRyYW5zZm9ybWF0aW9ucyBhcmUgY2hhaW5lZCB0b2dldGhlciBieSBzbGFzaGVzLlxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNjaGFpblxuICAgICAqIEByZXR1cm4ge1RyYW5zZm9ybWF0aW9ufSBSZXR1cm5zIHRoaXMgdHJhbnNmb3JtYXRpb24gZm9yIGNoYWluaW5nXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgdHIgPSBjbG91ZGluYXJ5LlRyYW5zZm9ybWF0aW9uLm5ldygpO1xuICAgICAqIHRyLndpZHRoKDEwKS5jcm9wKCdmaXQnKS5jaGFpbigpLmFuZ2xlKDE1KS5zZXJpYWxpemUoKVxuICAgICAqIC8vIHByb2R1Y2VzIFwiY19maXQsd18xMC9hXzE1XCJcbiAgICAgKi9cbiAgICB0aGlzLmNoYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWVzLCB0cjtcbiAgICAgIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModHJhbnMpO1xuICAgICAgaWYgKG5hbWVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB0ciA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMudG9PcHRpb25zKGZhbHNlKSk7XG4gICAgICAgIHRoaXMucmVzZXRUcmFuc2Zvcm1hdGlvbnMoKTtcbiAgICAgICAgdGhpcy5jaGFpbmVkLnB1c2godHIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB0aGlzLnJlc2V0VHJhbnNmb3JtYXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgdHJhbnMgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdGhpcy5vdGhlck9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmNoYWluZWQgPSBbXTtcbiAgICB0aGlzLmZyb21PcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIHRoZSBwcm92aWRlZCBvcHRpb25zIHdpdGggb3duJ3Mgb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIGtleS12YWx1ZSBsaXN0IG9mIG9wdGlvbnNcbiAgICogQHJldHVybnMge1RyYW5zZm9ybWF0aW9ufSBSZXR1cm5zIHRoaXMgaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAqL1xuICByZXR1cm4gdHJhbnNmb3JtYXRpb25fY3JlYXRlQ2xhc3MoVHJhbnNmb3JtYXRpb25CYXNlLCBbe1xuICAgIGtleTogXCJmcm9tT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tT3B0aW9ucygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgVHJhbnNmb3JtYXRpb25CYXNlKSB7XG4gICAgICAgIHRoaXMuZnJvbVRyYW5zZm9ybWF0aW9uKG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKG9wdGlvbnMpIHx8IGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShvcHRpb25zKSkge1xuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbjogb3B0aW9uc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0KCkob3B0aW9ucywgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVHJhbnNmb3JtYXRpb25CYXNlIHx8IHZhbHVlIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdmFsdWUuY2xvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBIYW5kbGluZyBvZiBcImlmXCIgc3RhdGVtZW50cyBwcmVjZWRlcyBvdGhlciBvcHRpb25zIGFzIGl0IGNyZWF0ZXMgYSBjaGFpbmVkIHRyYW5zZm9ybWF0aW9uXG4gICAgICAgIGlmIChvcHRpb25zW1wiaWZcIl0pIHtcbiAgICAgICAgICB0aGlzLnNldChcImlmXCIsIG9wdGlvbnNbXCJpZlwiXSk7XG4gICAgICAgICAgZGVsZXRlIG9wdGlvbnNbXCJpZlwiXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgIHZhciBvcHQgPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgaWYgKG9wdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoa2V5Lm1hdGNoKFZBUl9OQU1FX1JFKSkge1xuICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnJGF0dHInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoJ3ZhcmlhYmxlJywga2V5LCBvcHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnNldChrZXksIG9wdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbVRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21UcmFuc2Zvcm1hdGlvbihvdGhlcikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFRyYW5zZm9ybWF0aW9uQmFzZSkge1xuICAgICAgICBvdGhlci5rZXlzKCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnNldChrZXksIG90aGVyLmdldChrZXkpLm9yaWdWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgcGFyYW1ldGVyLlxuICAgICAqIFRoZSBwYXJhbWV0ZXIgbmFtZSBga2V5YCBpcyBjb252ZXJ0ZWQgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVzIC0gdGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICAgKiBAcmV0dXJucyB7VHJhbnNmb3JtYXRpb259IFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGtleSkge1xuICAgICAgdmFyIGNhbWVsS2V5O1xuICAgICAgY2FtZWxLZXkgPSBjYW1lbENhc2Uoa2V5KTtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgdmFsdWVzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfZGVmYXVsdCgpKHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uLm1ldGhvZHMsIGNhbWVsS2V5KSkge1xuICAgICAgICB0aGlzW2NhbWVsS2V5XS5hcHBseSh0aGlzLCB2YWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vdGhlck9wdGlvbnNba2V5XSA9IHZhbHVlc1swXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNMYXllclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNMYXllcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlKFwib3ZlcmxheVwiKSB8fCB0aGlzLmdldFZhbHVlKFwidW5kZXJsYXlcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNzZXJpYWxpemVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyYW5zZm9ybWF0aW9uIGFzIGEgc3RyaW5nXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHZhciBpZlBhcmFtLCBqLCBsZW4sIHBhcmFtTGlzdCwgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZWY0LCByZXN1bHRBcnJheSwgdCwgdHJhbnNmb3JtYXRpb25MaXN0LCB0cmFuc2Zvcm1hdGlvblN0cmluZywgdHJhbnNmb3JtYXRpb25zLCB2YWx1ZSwgdmFyaWFibGVzLCB2YXJzO1xuICAgICAgcmVzdWx0QXJyYXkgPSB0aGlzLmNoYWluZWQubWFwKGZ1bmN0aW9uICh0cikge1xuICAgICAgICByZXR1cm4gdHIuc2VyaWFsaXplKCk7XG4gICAgICB9KTtcbiAgICAgIHBhcmFtTGlzdCA9IHRoaXMua2V5cygpO1xuICAgICAgdHJhbnNmb3JtYXRpb25zID0gKHJlZiA9IHRoaXMuZ2V0KFwidHJhbnNmb3JtYXRpb25cIikpICE9IG51bGwgPyByZWYuc2VyaWFsaXplKCkgOiB2b2lkIDA7XG4gICAgICBpZlBhcmFtID0gKHJlZjEgPSB0aGlzLmdldChcImlmXCIpKSAhPSBudWxsID8gcmVmMS5zZXJpYWxpemUoKSA6IHZvaWQgMDtcbiAgICAgIHZhcmlhYmxlcyA9IHByb2Nlc3NWYXIoKHJlZjIgPSB0aGlzLmdldChcInZhcmlhYmxlc1wiKSkgIT0gbnVsbCA/IHJlZjIudmFsdWUoKSA6IHZvaWQgMCk7XG4gICAgICBwYXJhbUxpc3QgPSBkaWZmZXJlbmNlX3Jvb3RfZGlmZmVyZW5jZV9kZWZhdWx0KCkocGFyYW1MaXN0LCBbXCJ0cmFuc2Zvcm1hdGlvblwiLCBcImlmXCIsIFwidmFyaWFibGVzXCJdKTtcbiAgICAgIHZhcnMgPSBbXTtcbiAgICAgIHRyYW5zZm9ybWF0aW9uTGlzdCA9IFtdO1xuICAgICAgZm9yIChqID0gMCwgbGVuID0gcGFyYW1MaXN0Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIHQgPSBwYXJhbUxpc3Rbal07XG4gICAgICAgIGlmICh0Lm1hdGNoKFZBUl9OQU1FX1JFKSkge1xuICAgICAgICAgIHZhcnMucHVzaCh0ICsgXCJfXCIgKyBleHByZXNzaW9uLm5vcm1hbGl6ZSgocmVmMyA9IHRoaXMuZ2V0KHQpKSAhPSBudWxsID8gcmVmMy52YWx1ZSgpIDogdm9pZCAwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJhbnNmb3JtYXRpb25MaXN0LnB1c2goKHJlZjQgPSB0aGlzLmdldCh0KSkgIT0gbnVsbCA/IHJlZjQuc2VyaWFsaXplKCkgOiB2b2lkIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgIGNhc2UgIWlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKHRyYW5zZm9ybWF0aW9ucyk6XG4gICAgICAgICAgdHJhbnNmb3JtYXRpb25MaXN0LnB1c2godHJhbnNmb3JtYXRpb25zKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAhaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHRyYW5zZm9ybWF0aW9ucyk6XG4gICAgICAgICAgcmVzdWx0QXJyYXkgPSByZXN1bHRBcnJheS5jb25jYXQodHJhbnNmb3JtYXRpb25zKTtcbiAgICAgIH1cbiAgICAgIHRyYW5zZm9ybWF0aW9uTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGssIGxlbjEsIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChrID0gMCwgbGVuMSA9IHRyYW5zZm9ybWF0aW9uTGlzdC5sZW5ndGg7IGsgPCBsZW4xOyBrKyspIHtcbiAgICAgICAgICB2YWx1ZSA9IHRyYW5zZm9ybWF0aW9uTGlzdFtrXTtcbiAgICAgICAgICBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHZhbHVlKSAmJiAhaXNFbXB0eSh2YWx1ZSkgfHwgIWlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKSh2YWx1ZSkgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfSgpO1xuICAgICAgdHJhbnNmb3JtYXRpb25MaXN0ID0gdmFycy5zb3J0KCkuY29uY2F0KHZhcmlhYmxlcykuY29uY2F0KHRyYW5zZm9ybWF0aW9uTGlzdC5zb3J0KCkpO1xuICAgICAgaWYgKGlmUGFyYW0gPT09IFwiaWZfZW5kXCIpIHtcbiAgICAgICAgdHJhbnNmb3JtYXRpb25MaXN0LnB1c2goaWZQYXJhbSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VtcHR5KGlmUGFyYW0pKSB7XG4gICAgICAgIHRyYW5zZm9ybWF0aW9uTGlzdC51bnNoaWZ0KGlmUGFyYW0pO1xuICAgICAgfVxuICAgICAgdHJhbnNmb3JtYXRpb25TdHJpbmcgPSBjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0KCkodHJhbnNmb3JtYXRpb25MaXN0KS5qb2luKHRoaXMucGFyYW1fc2VwYXJhdG9yKTtcbiAgICAgIGlmICghaXNFbXB0eSh0cmFuc2Zvcm1hdGlvblN0cmluZykpIHtcbiAgICAgICAgcmVzdWx0QXJyYXkucHVzaCh0cmFuc2Zvcm1hdGlvblN0cmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCgpKHJlc3VsdEFycmF5KS5qb2luKHRoaXMudHJhbnNfc2VwYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlIGEgbGlzdCBvZiBhbGwgdGhlIHZhbGlkIHRyYW5zZm9ybWF0aW9uIG9wdGlvbiBuYW1lc1xuICAgICAqIEBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbiNsaXN0TmFtZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IGEgYXJyYXkgb2YgYWxsIHRoZSB2YWxpZCBvcHRpb24gbmFtZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0b0h0bWxBdHRyaWJ1dGVzXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXR0cmlidXRlcyBmb3IgYW4gSFRNTCB0YWcuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkudG9IdG1sQXR0cmlidXRlc1xuICAgICAqIEByZXR1cm4gUGxhaW5PYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0h0bWxBdHRyaWJ1dGVzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgYXR0ck5hbWUsIGhlaWdodCwgb3B0aW9ucywgcmVmMiwgcmVmMywgdmFsdWUsIHdpZHRoO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgdmFyIHNuYWtlQ2FzZUtleTtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMub3RoZXJPcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFsdWUgPSBfdGhpczIub3RoZXJPcHRpb25zW2tleV07XG4gICAgICAgIHNuYWtlQ2FzZUtleSA9IHNuYWtlQ2FzZShrZXkpO1xuICAgICAgICBpZiAoIWluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfZGVmYXVsdCgpKHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uLlBBUkFNX05BTUVTLCBzbmFrZUNhc2VLZXkpICYmICFpbmNsdWRlc19yb290X2luY2x1ZGVzX2RlZmF1bHQoKShVUkxfS0VZUywgc25ha2VDYXNlS2V5KSkge1xuICAgICAgICAgIGF0dHJOYW1lID0gL15odG1sXy8udGVzdChrZXkpID8ga2V5LnNsaWNlKDUpIDoga2V5O1xuICAgICAgICAgIG9wdGlvbnNbYXR0ck5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gY29udmVydCBhbGwgXCJodG1sX2tleVwiIHRvIFwia2V5XCIgd2l0aCB0aGUgc2FtZSB2YWx1ZVxuICAgICAgdGhpcy5rZXlzKCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICgvXmh0bWxfLy50ZXN0KGtleSkpIHtcbiAgICAgICAgICBvcHRpb25zW2NhbWVsQ2FzZShrZXkuc2xpY2UoNSkpXSA9IF90aGlzMi5nZXRWYWx1ZShrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghKHRoaXMuaGFzTGF5ZXIoKSB8fCB0aGlzLmdldFZhbHVlKFwiYW5nbGVcIikgfHwgaW5jbHVkZXNfcm9vdF9pbmNsdWRlc19kZWZhdWx0KCkoW1wiZml0XCIsIFwibGltaXRcIiwgXCJsZmlsbFwiXSwgdGhpcy5nZXRWYWx1ZShcImNyb3BcIikpKSkge1xuICAgICAgICB3aWR0aCA9IChyZWYyID0gdGhpcy5nZXQoXCJ3aWR0aFwiKSkgIT0gbnVsbCA/IHJlZjIub3JpZ1ZhbHVlIDogdm9pZCAwO1xuICAgICAgICBoZWlnaHQgPSAocmVmMyA9IHRoaXMuZ2V0KFwiaGVpZ2h0XCIpKSAhPSBudWxsID8gcmVmMy5vcmlnVmFsdWUgOiB2b2lkIDA7XG4gICAgICAgIGlmIChwYXJzZUZsb2F0KHdpZHRoKSA+PSAxLjApIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy53aWR0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZUZsb2F0KGhlaWdodCkgPj0gMS4wKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSHRtbFwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIERlbGVnYXRlIHRvIHRoZSBwYXJlbnQgKHVwIHRoZSBjYWxsIGNoYWluKSB0byBwcm9kdWNlIEhUTUxcbiAgICAgKiBAZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24jdG9IdG1sXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBIVE1MIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwYXJlbnQgaWYgcG9zc2libGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB0YWcgPSBjbG91ZGluYXJ5LkltYWdlVGFnLm5ldyhcInNhbXBsZVwiLCB7Y2xvdWRfbmFtZTogXCJkZW1vXCJ9KVxuICAgICAqIC8vIEltYWdlVGFnIHtuYW1lOiBcImltZ1wiLCBwdWJsaWNJZDogXCJzYW1wbGVcIn1cbiAgICAgKiB0YWcudG9IdG1sKClcbiAgICAgKiAvLyA8aW1nIHNyYz1cImh0dHA6Ly9yZXMuY2xvdWRpbmFyeS5jb20vZGVtby9pbWFnZS91cGxvYWQvc2FtcGxlXCI+XG4gICAgICogdGFnLnRyYW5zZm9ybWF0aW9uKCkuY3JvcChcImZpdFwiKS53aWR0aCgzMDApLnRvSHRtbCgpXG4gICAgICogLy8gPGltZyBzcmM9XCJodHRwOi8vcmVzLmNsb3VkaW5hcnkuY29tL2RlbW8vaW1hZ2UvdXBsb2FkL2NfZml0LHdfMzAwL3NhbXBsZVwiPlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSHRtbCgpIHtcbiAgICAgIHZhciByZWY7XG4gICAgICByZXR1cm4gKHJlZiA9IHRoaXMuZ2V0UGFyZW50KCkpICE9IG51bGwgPyB0eXBlb2YgcmVmLnRvSHRtbCA9PT0gXCJmdW5jdGlvblwiID8gcmVmLnRvSHRtbCgpIDogdm9pZCAwIDogdm9pZCAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnRvT3B0aW9ucyh0cnVlKSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwibGlzdE5hbWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3ROYW1lcygpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbi5tZXRob2RzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1ZhbGlkUGFyYW1OYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVmFsaWRQYXJhbU5hbWUobmFtZSkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uLm1ldGhvZHMuaW5kZXhPZihjYW1lbENhc2UobmFtZSkpID49IDA7XG4gICAgfVxuICB9XSk7XG59KCk7XG52YXIgVkFSX05BTUVfUkUgPSAvXlxcJFthLXpBLVowLTldKyQvO1xudHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb25CYXNlLnByb3RvdHlwZS50cmFuc19zZXBhcmF0b3IgPSAnLyc7XG50cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbkJhc2UucHJvdG90eXBlLnBhcmFtX3NlcGFyYXRvciA9ICcsJztcbmZ1bmN0aW9uIGxhc3RBcmdDYWxsYmFjayhhcmdzKSB7XG4gIHZhciBjYWxsYmFjaztcbiAgY2FsbGJhY2sgPSBhcmdzICE9IG51bGwgPyBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gOiB2b2lkIDA7XG4gIGlmIChpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoY2FsbGJhY2spKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NWYXIodmFyQXJyYXkpIHtcbiAgdmFyIGosIGxlbiwgbmFtZSwgcmVzdWx0cywgdjtcbiAgaWYgKGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKSh2YXJBcnJheSkpIHtcbiAgICByZXN1bHRzID0gW107XG4gICAgZm9yIChqID0gMCwgbGVuID0gdmFyQXJyYXkubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHZhciBfdmFyQXJyYXkkaiA9IHRyYW5zZm9ybWF0aW9uX3NsaWNlZFRvQXJyYXkodmFyQXJyYXlbal0sIDIpO1xuICAgICAgbmFtZSA9IF92YXJBcnJheSRqWzBdO1xuICAgICAgdiA9IF92YXJBcnJheSRqWzFdO1xuICAgICAgcmVzdWx0cy5wdXNoKFwiXCIuY29uY2F0KG5hbWUsIFwiX1wiKS5jb25jYXQoZXhwcmVzc2lvbi5ub3JtYWxpemUodikpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhckFycmF5O1xuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzQ3VzdG9tRnVuY3Rpb24oX3JlZikge1xuICB2YXIgZnVuY3Rpb25fdHlwZSA9IF9yZWYuZnVuY3Rpb25fdHlwZSxcbiAgICBzb3VyY2UgPSBfcmVmLnNvdXJjZTtcbiAgaWYgKGZ1bmN0aW9uX3R5cGUgPT09ICdyZW1vdGUnKSB7XG4gICAgcmV0dXJuIFtmdW5jdGlvbl90eXBlLCBidG9hKHNvdXJjZSldLmpvaW4oXCI6XCIpO1xuICB9IGVsc2UgaWYgKGZ1bmN0aW9uX3R5cGUgPT09ICd3YXNtJykge1xuICAgIHJldHVybiBbZnVuY3Rpb25fdHlwZSwgc291cmNlXS5qb2luKFwiOlwiKTtcbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uIENsYXNzIG1ldGhvZHMuXG4gKiBUaGlzIGlzIGEgbGlzdCBvZiB0aGUgcGFyYW1ldGVycyBkZWZpbmVkIGluIFRyYW5zZm9ybWF0aW9uLlxuICogVmFsdWVzIGFyZSBjYW1lbENhc2VkLlxuICogQGNvbnN0IFRyYW5zZm9ybWF0aW9uLm1ldGhvZHNcbiAqIEBwcml2YXRlXG4gKiBAaWdub3JlXG4gKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAqL1xuLyoqXG4gKiBQYXJhbWV0ZXJzIHRoYXQgYXJlIGZpbHRlcmVkIG91dCBiZWZvcmUgcGFzc2luZyB0aGUgb3B0aW9ucyB0byBhbiBIVE1MIHRhZy5cbiAqXG4gKiBUaGUgbGlzdCBvZiBwYXJhbWV0ZXJzIGlzIGEgY29tYmluYXRpb24gb2YgYFRyYW5zZm9ybWF0aW9uOjptZXRob2RzYCBhbmQgYENvbmZpZ3VyYXRpb246OkNPTkZJR19QQVJBTVNgXG4gKiBAY29uc3Qge0FycmF5PHN0cmluZz59IFRyYW5zZm9ybWF0aW9uLlBBUkFNX05BTUVTXG4gKiBAcHJpdmF0ZVxuICogQGlnbm9yZVxuICogQHNlZSB0b0h0bWxBdHRyaWJ1dGVzXG4gKi9cbnZhciB0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RyYW5zZm9ybWF0aW9uQmFzZSkge1xuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHNpbmdsZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICogQGNsYXNzIFRyYW5zZm9ybWF0aW9uXG4gICAqIEBleGFtcGxlXG4gICAqIHQgPSBuZXcgY2xvdWRpbmFyeS5UcmFuc2Zvcm1hdGlvbigpO1xuICAgKiB0LmFuZ2xlKDIwKS5jcm9wKFwic2NhbGVcIikud2lkdGgoXCJhdXRvXCIpO1xuICAgKlxuICAgKiAvLyBvclxuICAgKlxuICAgKiB0ID0gbmV3IGNsb3VkaW5hcnkuVHJhbnNmb3JtYXRpb24oIHthbmdsZTogMjAsIGNyb3A6IFwic2NhbGVcIiwgd2lkdGg6IFwiYXV0b1wifSk7XG4gICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIlxuICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiXG4gICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgKi9cbiAgZnVuY3Rpb24gVHJhbnNmb3JtYXRpb24ob3B0aW9ucykge1xuICAgIHRyYW5zZm9ybWF0aW9uX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zZm9ybWF0aW9uKTtcbiAgICByZXR1cm4gdHJhbnNmb3JtYXRpb25fY2FsbFN1cGVyKHRoaXMsIFRyYW5zZm9ybWF0aW9uLCBbb3B0aW9uc10pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1RyYW5zZm9ybWF0aW9ufVxuICAgKiBAZXhhbXBsZSBjbCA9IGNsb3VkaW5hcnkuVHJhbnNmb3JtYXRpb24ubmV3KCB7YW5nbGU6IDIwLCBjcm9wOiBcInNjYWxlXCIsIHdpZHRoOiBcImF1dG9cIn0pXG4gICAqL1xuICB0cmFuc2Zvcm1hdGlvbl9pbmhlcml0cyhUcmFuc2Zvcm1hdGlvbiwgX1RyYW5zZm9ybWF0aW9uQmFzZSk7XG4gIHJldHVybiB0cmFuc2Zvcm1hdGlvbl9jcmVhdGVDbGFzcyhUcmFuc2Zvcm1hdGlvbiwgW3tcbiAgICBrZXk6IFwiYW5nbGVcIixcbiAgICB2YWx1ZTpcbiAgICAvKlxuICAgICAgVHJhbnNmb3JtYXRpb24gUGFyYW1ldGVyc1xuICAgICovXG4gICAgZnVuY3Rpb24gYW5nbGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5UGFyYW0odmFsdWUsIFwiYW5nbGVcIiwgXCJhXCIsIFwiLlwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF1ZGlvQ29kZWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXVkaW9Db2RlYyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiYXVkaW9fY29kZWNcIiwgXCJhY1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXVkaW9GcmVxdWVuY3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXVkaW9GcmVxdWVuY3kodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImF1ZGlvX2ZyZXF1ZW5jeVwiLCBcImFmXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhc3BlY3RSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3BlY3RSYXRpbyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiYXNwZWN0X3JhdGlvXCIsIFwiYXJcIiwgZXhwcmVzc2lvbi5ub3JtYWxpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiYWNrZ3JvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJhY2tncm91bmQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImJhY2tncm91bmRcIiwgXCJiXCIsIHBhcmFtZXRlcnNfUGFyYW0ubm9ybV9jb2xvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJpdFJhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYml0UmF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiYml0X3JhdGVcIiwgXCJiclwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJvcmRlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiYm9yZGVyXCIsIFwiYm9cIiwgZnVuY3Rpb24gKGJvcmRlcikge1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdF9yb290X2lzUGxhaW5PYmplY3RfZGVmYXVsdCgpKGJvcmRlcikpIHtcbiAgICAgICAgICBib3JkZXIgPSBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHt9LCB7XG4gICAgICAgICAgICBjb2xvcjogXCJibGFja1wiLFxuICAgICAgICAgICAgd2lkdGg6IDJcbiAgICAgICAgICB9LCBib3JkZXIpO1xuICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChib3JkZXIud2lkdGgsIFwicHhfc29saWRfXCIpLmNvbmNhdChwYXJhbWV0ZXJzX1BhcmFtLm5vcm1fY29sb3IoYm9yZGVyLmNvbG9yKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJjb2xvclwiLCBcImNvXCIsIHBhcmFtZXRlcnNfUGFyYW0ubm9ybV9jb2xvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbG9yU3BhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29sb3JTcGFjZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiY29sb3Jfc3BhY2VcIiwgXCJjc1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcm9wKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJjcm9wXCIsIFwiY1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3VzdG9tRnVuY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VzdG9tRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImN1c3RvbV9mdW5jdGlvblwiLCBcImZuXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NDdXN0b21GdW5jdGlvbih2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3VzdG9tUHJlRnVuY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VzdG9tUHJlRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLmdldCgnY3VzdG9tX2Z1bmN0aW9uJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmF3UGFyYW0odmFsdWUsIFwiY3VzdG9tX2Z1bmN0aW9uXCIsIFwiXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFsdWUgPSBwcm9jZXNzQ3VzdG9tRnVuY3Rpb24odmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWUgPyBcImZuX3ByZTpcIi5jb25jYXQodmFsdWUpIDogdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVmYXVsdEltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlZmF1bHRJbWFnZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZGVmYXVsdF9pbWFnZVwiLCBcImRcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGF5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJkZWxheVwiLCBcImRsXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZW5zaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbnNpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImRlbnNpdHlcIiwgXCJkblwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHVyYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHVyYXRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhbmdlUGFyYW0odmFsdWUsIFwiZHVyYXRpb25cIiwgXCJkdVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHByXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRwcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZHByXCIsIFwiZHByXCIsIGZ1bmN0aW9uIChkcHIpIHtcbiAgICAgICAgZHByID0gZHByLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChkcHIgIT0gbnVsbCA/IGRwci5tYXRjaCgvXlxcZCskLykgOiB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gZHByICsgXCIuMFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLm5vcm1hbGl6ZShkcHIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWZmZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVmZmVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJyYXlQYXJhbSh2YWx1ZSwgXCJlZmZlY3RcIiwgXCJlXCIsIFwiOlwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVsc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Vsc2UoKSB7XG4gICAgICByZXR1cm4gdGhpc1tcImlmXCJdKCdlbHNlJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZElmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZElmKCkge1xuICAgICAgcmV0dXJuIHRoaXNbXCJpZlwiXSgnZW5kJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZE9mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRPZmZzZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhbmdlUGFyYW0odmFsdWUsIFwiZW5kX29mZnNldFwiLCBcImVvXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmYWxsYmFja0NvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFsbGJhY2tDb250ZW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJmYWxsYmFja19jb250ZW50XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmZXRjaEZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmZXRjaEZvcm1hdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZmV0Y2hfZm9ybWF0XCIsIFwiZlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ybWF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZm9ybWF0XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmbGFnc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmbGFncyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJyYXlQYXJhbSh2YWx1ZSwgXCJmbGFnc1wiLCBcImZsXCIsIFwiLlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ3Jhdml0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBncmF2aXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJncmF2aXR5XCIsIFwiZ1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnBzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZwcyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiZnBzXCIsIFwiZnBzXCIsIGZ1bmN0aW9uIChmcHMpIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKGZwcykpIHtcbiAgICAgICAgICByZXR1cm4gZnBzO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShmcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZwcy5qb2luKFwiLVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZnBzO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhlaWdodCh2YWx1ZSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJoZWlnaHRcIiwgXCJoXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzMy5nZXRWYWx1ZShcImNyb3BcIikgfHwgX3RoaXMzLmdldFZhbHVlKFwib3ZlcmxheVwiKSB8fCBfdGhpczMuZ2V0VmFsdWUoXCJ1bmRlcmxheVwiKSkge1xuICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLm5vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJodG1sSGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGh0bWxIZWlnaHQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcImh0bWxfaGVpZ2h0XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJodG1sV2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaHRtbFdpZHRoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJodG1sX3dpZHRoXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaWYoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFwiXCI7XG4gICAgICB2YXIgaSwgaWZWYWwsIGosIHJlZiwgdHJJZiwgdHJSZXN0O1xuICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlIFwiZWxzZVwiOlxuICAgICAgICAgIHRoaXMuY2hhaW4oKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJpZlwiLCBcImlmXCIpO1xuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgdGhpcy5jaGFpbigpO1xuICAgICAgICAgIGZvciAoaSA9IGogPSByZWYgPSB0aGlzLmNoYWluZWQubGVuZ3RoIC0gMTsgaiA+PSAwOyBpID0gaiArPSAtMSkge1xuICAgICAgICAgICAgaWZWYWwgPSB0aGlzLmNoYWluZWRbaV0uZ2V0VmFsdWUoXCJpZlwiKTtcbiAgICAgICAgICAgIGlmIChpZlZhbCA9PT0gXCJlbmRcIikge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWZWYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB0cklmID0gVHJhbnNmb3JtYXRpb25bXCJuZXdcIl0oKVtcImlmXCJdKGlmVmFsKTtcbiAgICAgICAgICAgICAgdGhpcy5jaGFpbmVkW2ldLnJlbW92ZShcImlmXCIpO1xuICAgICAgICAgICAgICB0clJlc3QgPSB0aGlzLmNoYWluZWRbaV07XG4gICAgICAgICAgICAgIHRoaXMuY2hhaW5lZFtpXSA9IFRyYW5zZm9ybWF0aW9uW1wibmV3XCJdKCkudHJhbnNmb3JtYXRpb24oW3RySWYsIHRyUmVzdF0pO1xuICAgICAgICAgICAgICBpZiAoaWZWYWwgIT09IFwiZWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiaWZcIiwgXCJpZlwiKTtcbiAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgIHJldHVybiBjb25kaXRpb25bXCJuZXdcIl0oKS5zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiaWZcIiwgXCJpZlwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25kaXRpb25bXCJuZXdcIl0odmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImtleWZyYW1lSW50ZXJ2YWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2V5ZnJhbWVJbnRlcnZhbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwia2V5ZnJhbWVfaW50ZXJ2YWxcIiwgXCJraVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib2NyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9jcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwib2NyXCIsIFwib2NyXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2Zmc2V0KHZhbHVlKSB7XG4gICAgICB2YXIgZW5kX28sIHN0YXJ0X287XG4gICAgICB2YXIgX3JlZjIgPSBpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkodmFsdWUgIT0gbnVsbCA/IHZhbHVlLnNwbGl0IDogdm9pZCAwKSA/IHZhbHVlLnNwbGl0KCcuLicpIDogaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHZhbHVlKSA/IHZhbHVlIDogW251bGwsIG51bGxdO1xuICAgICAgdmFyIF9yZWYzID0gdHJhbnNmb3JtYXRpb25fc2xpY2VkVG9BcnJheShfcmVmMiwgMik7XG4gICAgICBzdGFydF9vID0gX3JlZjNbMF07XG4gICAgICBlbmRfbyA9IF9yZWYzWzFdO1xuICAgICAgaWYgKHN0YXJ0X28gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnN0YXJ0T2Zmc2V0KHN0YXJ0X28pO1xuICAgICAgfVxuICAgICAgaWYgKGVuZF9vICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kT2Zmc2V0KGVuZF9vKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3BhY2l0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGFjaXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJvcGFjaXR5XCIsIFwib1wiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm92ZXJsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3ZlcmxheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMubGF5ZXJQYXJhbSh2YWx1ZSwgXCJvdmVybGF5XCIsIFwibFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWdlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJwYWdlXCIsIFwicGdcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0ZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInBvc3RlclwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlZml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZWZpeCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwicHJlZml4XCIsIFwicFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicXVhbGl0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBxdWFsaXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJxdWFsaXR5XCIsIFwicVwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJhZGl1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYWRpdXModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5UGFyYW0odmFsdWUsIFwicmFkaXVzXCIsIFwiclwiLCBcIjpcIiwgZXhwcmVzc2lvbi5ub3JtYWxpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyYXdUcmFuc2Zvcm1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYXdUcmFuc2Zvcm1hdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmF3UGFyYW0odmFsdWUsIFwicmF3X3RyYW5zZm9ybWF0aW9uXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpemUodmFsdWUpIHtcbiAgICAgIHZhciBoZWlnaHQsIHdpZHRoO1xuICAgICAgaWYgKGlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKSh2YWx1ZSAhPSBudWxsID8gdmFsdWUuc3BsaXQgOiB2b2lkIDApKSB7XG4gICAgICAgIHZhciBfdmFsdWUkc3BsaXQgPSB2YWx1ZS5zcGxpdCgneCcpO1xuICAgICAgICB2YXIgX3ZhbHVlJHNwbGl0MiA9IHRyYW5zZm9ybWF0aW9uX3NsaWNlZFRvQXJyYXkoX3ZhbHVlJHNwbGl0LCAyKTtcbiAgICAgICAgd2lkdGggPSBfdmFsdWUkc3BsaXQyWzBdO1xuICAgICAgICBoZWlnaHQgPSBfdmFsdWUkc3BsaXQyWzFdO1xuICAgICAgICB0aGlzLndpZHRoKHdpZHRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0KGhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNvdXJjZVR5cGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvdXJjZVR5cGVzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJzb3VyY2VfdHlwZXNcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNvdXJjZVRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvdXJjZVRyYW5zZm9ybWF0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJzb3VyY2VfdHJhbnNmb3JtYXRpb25cIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0T2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0T2Zmc2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYW5nZVBhcmFtKHZhbHVlLCBcInN0YXJ0X29mZnNldFwiLCBcInNvXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdHJlYW1pbmdQcm9maWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0cmVhbWluZ1Byb2ZpbGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInN0cmVhbWluZ19wcm9maWxlXCIsIFwic3BcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvblBhcmFtKHZhbHVlLCBcInRyYW5zZm9ybWF0aW9uXCIsIFwidFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5kZXJsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5kZXJsYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmxheWVyUGFyYW0odmFsdWUsIFwidW5kZXJsYXlcIiwgXCJ1XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YXJpYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YXJpYWJsZShuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIG5hbWUsIG5hbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YXJpYWJsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFyaWFibGVzKHZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuYXJyYXlQYXJhbSh2YWx1ZXMsIFwidmFyaWFibGVzXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2aWRlb0NvZGVjXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZGVvQ29kZWModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInZpZGVvX2NvZGVjXCIsIFwidmNcIiwgcGFyYW1ldGVyc19QYXJhbS5wcm9jZXNzX3ZpZGVvX3BhcmFtcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZpZGVvU2FtcGxpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlkZW9TYW1wbGluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwidmlkZW9fc2FtcGxpbmdcIiwgXCJ2c1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2lkdGgodmFsdWUpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwid2lkdGhcIiwgXCJ3XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzNC5nZXRWYWx1ZShcImNyb3BcIikgfHwgX3RoaXM0LmdldFZhbHVlKFwib3ZlcmxheVwiKSB8fCBfdGhpczQuZ2V0VmFsdWUoXCJ1bmRlcmxheVwiKSkge1xuICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLm5vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHgodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtKHZhbHVlLCBcInhcIiwgXCJ4XCIsIGV4cHJlc3Npb24ubm9ybWFsaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJhbSh2YWx1ZSwgXCJ5XCIsIFwieVwiLCBleHByZXNzaW9uLm5vcm1hbGl6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInpvb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gem9vbSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW0odmFsdWUsIFwiem9vbVwiLCBcInpcIiwgZXhwcmVzc2lvbi5ub3JtYWxpemUpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcIm5ld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbmV3KG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgVHJhbnNmb3JtYXRpb24ob3B0aW9ucyk7XG4gICAgfVxuICB9XSk7XG59KHRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uQmFzZSk7XG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uIENsYXNzIG1ldGhvZHMuXG4gKiBUaGlzIGlzIGEgbGlzdCBvZiB0aGUgcGFyYW1ldGVycyBkZWZpbmVkIGluIFRyYW5zZm9ybWF0aW9uLlxuICogVmFsdWVzIGFyZSBjYW1lbENhc2VkLlxuICovXG50cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbi5tZXRob2RzID0gW1wiYW5nbGVcIiwgXCJhdWRpb0NvZGVjXCIsIFwiYXVkaW9GcmVxdWVuY3lcIiwgXCJhc3BlY3RSYXRpb1wiLCBcImJhY2tncm91bmRcIiwgXCJiaXRSYXRlXCIsIFwiYm9yZGVyXCIsIFwiY29sb3JcIiwgXCJjb2xvclNwYWNlXCIsIFwiY3JvcFwiLCBcImN1c3RvbUZ1bmN0aW9uXCIsIFwiY3VzdG9tUHJlRnVuY3Rpb25cIiwgXCJkZWZhdWx0SW1hZ2VcIiwgXCJkZWxheVwiLCBcImRlbnNpdHlcIiwgXCJkdXJhdGlvblwiLCBcImRwclwiLCBcImVmZmVjdFwiLCBcImVsc2VcIiwgXCJlbmRJZlwiLCBcImVuZE9mZnNldFwiLCBcImZhbGxiYWNrQ29udGVudFwiLCBcImZldGNoRm9ybWF0XCIsIFwiZm9ybWF0XCIsIFwiZmxhZ3NcIiwgXCJncmF2aXR5XCIsIFwiZnBzXCIsIFwiaGVpZ2h0XCIsIFwiaHRtbEhlaWdodFwiLCBcImh0bWxXaWR0aFwiLCBcImlmXCIsIFwia2V5ZnJhbWVJbnRlcnZhbFwiLCBcIm9jclwiLCBcIm9mZnNldFwiLCBcIm9wYWNpdHlcIiwgXCJvdmVybGF5XCIsIFwicGFnZVwiLCBcInBvc3RlclwiLCBcInByZWZpeFwiLCBcInF1YWxpdHlcIiwgXCJyYWRpdXNcIiwgXCJyYXdUcmFuc2Zvcm1hdGlvblwiLCBcInNpemVcIiwgXCJzb3VyY2VUeXBlc1wiLCBcInNvdXJjZVRyYW5zZm9ybWF0aW9uXCIsIFwic3RhcnRPZmZzZXRcIiwgXCJzdHJlYW1pbmdQcm9maWxlXCIsIFwidHJhbnNmb3JtYXRpb25cIiwgXCJ1bmRlcmxheVwiLCBcInZhcmlhYmxlXCIsIFwidmFyaWFibGVzXCIsIFwidmlkZW9Db2RlY1wiLCBcInZpZGVvU2FtcGxpbmdcIiwgXCJ3aWR0aFwiLCBcInhcIiwgXCJ5XCIsIFwiem9vbVwiXTtcblxuLyoqXG4gKiBQYXJhbWV0ZXJzIHRoYXQgYXJlIGZpbHRlcmVkIG91dCBiZWZvcmUgcGFzc2luZyB0aGUgb3B0aW9ucyB0byBhbiBIVE1MIHRhZy5cbiAqXG4gKiBUaGUgbGlzdCBvZiBwYXJhbWV0ZXJzIGlzIGEgY29tYmluYXRpb24gb2YgYFRyYW5zZm9ybWF0aW9uOjptZXRob2RzYCBhbmQgYENvbmZpZ3VyYXRpb246OkNPTkZJR19QQVJBTVNgXG4gKi9cbnRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uLlBBUkFNX05BTUVTID0gdHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24ubWV0aG9kcy5tYXAoc25ha2VDYXNlKS5jb25jYXQoc3JjX2NvbmZpZ3VyYXRpb24uQ09ORklHX1BBUkFNUyk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfdHJhbnNmb3JtYXRpb24gPSAodHJhbnNmb3JtYXRpb25fVHJhbnNmb3JtYXRpb24pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdGFncy9odG1sdGFnLmpzXG5mdW5jdGlvbiBodG1sdGFnX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIGh0bWx0YWdfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIGh0bWx0YWdfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBodG1sdGFnX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIGh0bWx0YWdfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGh0bWx0YWdfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIGh0bWx0YWdfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBodG1sdGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBodG1sdGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBodG1sdGFnX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IGh0bWx0YWdfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IGh0bWx0YWdfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBodG1sdGFnX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gaHRtbHRhZ190eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gaHRtbHRhZ190eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuLyoqXG4gKiBHZW5lcmljIEhUTUwgdGFnXG4gKiBEZXBlbmRzIG9uICd0cmFuc2Zvcm1hdGlvbicsICd1dGlsJ1xuICovXG5cblxuXG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBIVE1MIChET00pIHRhZ1xuICogQGNvbnN0cnVjdG9yIEh0bWxUYWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIHRhZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtwdWJsaWNJZF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAZXhhbXBsZSB0YWcgPSBuZXcgSHRtbFRhZyggJ2RpdicsIHsgJ3dpZHRoJzogMTB9KVxuICovXG52YXIgaHRtbHRhZ19IdG1sVGFnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSHRtbFRhZyhuYW1lLCBwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgIGh0bWx0YWdfY2xhc3NDYWxsQ2hlY2sodGhpcywgSHRtbFRhZyk7XG4gICAgdmFyIHRyYW5zZm9ybWF0aW9uO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wdWJsaWNJZCA9IHB1YmxpY0lkO1xuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkocHVibGljSWQpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBwdWJsaWNJZDtcbiAgICAgICAgdGhpcy5wdWJsaWNJZCA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJhbnNmb3JtYXRpb24gPSBuZXcgc3JjX3RyYW5zZm9ybWF0aW9uKG9wdGlvbnMpO1xuICAgIHRyYW5zZm9ybWF0aW9uLnNldFBhcmVudCh0aGlzKTtcbiAgICB0aGlzLnRyYW5zZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgY29uc3RydWN0b3JcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBIVE1MIChET00pIHRhZ1xuICAgKiBAZnVuY3Rpb24gSHRtbFRhZy5uZXdcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgdGFnXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcHVibGljSWRdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge0h0bWxUYWd9XG4gICAqIEBleGFtcGxlIHRhZyA9IEh0bWxUYWcubmV3KCAnZGl2JywgeyAnd2lkdGgnOiAxMH0pXG4gICAqL1xuICByZXR1cm4gaHRtbHRhZ19jcmVhdGVDbGFzcyhIdG1sVGFnLCBbe1xuICAgIGtleTogXCJodG1sQXR0cnNcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBjb21iaW5lIGtleSBhbmQgdmFsdWUgZnJvbSB0aGUgYGF0dHJgIHRvIGdlbmVyYXRlIGFuIEhUTUwgdGFnIGF0dHJpYnV0ZXMgc3RyaW5nLlxuICAgICAqIGBUcmFuc2Zvcm1hdGlvbjo6dG9IdG1sVGFnT3B0aW9uc2AgaXMgdXNlZCB0byBmaWx0ZXIgb3V0IHRyYW5zZm9ybWF0aW9uIGFuZCBjb25maWd1cmF0aW9uIGtleXMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyc1xuICAgICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGF0dHJpYnV0ZXMgaW4gdGhlIGZvcm1hdCBgJ2tleTE9XCJ2YWx1ZTFcIiBrZXkyPVwidmFsdWUyXCInYFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBodG1sQXR0cnMoYXR0cnMpIHtcbiAgICAgIHZhciBrZXksIHBhaXJzLCB2YWx1ZTtcbiAgICAgIHJldHVybiBwYWlycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgICB2YWx1ZSA9IGVzY2FwZVF1b3RlcyhhdHRyc1trZXldKTtcbiAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChodG1sdGFnX3RvQXR0cmlidXRlKGtleSwgdmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9KCkuc29ydCgpLmpvaW4oJyAnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIG9wdGlvbnMgcmVsYXRlZCB0byB0aGlzIHRhZy5cbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNnZXRPcHRpb25zXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGhlIG9wdGlvbnNcbiAgICAgKlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3B0aW9ucygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uKCkudG9PcHRpb25zKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiBvcHRpb24gYG5hbWVgXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjZ2V0T3B0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgb3B0aW9uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBvcHRpb25cbiAgICAgKlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldE9wdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPcHRpb24obmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtYXRpb24oKS5nZXRWYWx1ZShuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIHRhZy5cbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNhdHRyaWJ1dGVzXG4gICAgICogQHJldHVybnMge09iamVjdH0gYXR0cmlidXRlc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlcygpIHtcbiAgICAgIC8vIFRoZSBhdHRyaWJ1dGVzIGFyZSBiZSBjb21wdXRlZCBmcm9tIHRoZSBvcHRpb25zIGV2ZXJ5IHRpbWUgdGhpcyBtZXRob2QgaXMgaW52b2tlZC5cbiAgICAgIHZhciBodG1sQXR0cmlidXRlcyA9IHRoaXMudHJhbnNmb3JtYXRpb24oKS50b0h0bWxBdHRyaWJ1dGVzKCk7XG4gICAgICBPYmplY3Qua2V5cyhodG1sQXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkoaHRtbEF0dHJpYnV0ZXNba2V5XSkpIHtcbiAgICAgICAgICBkZWxldGUgaHRtbEF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoaHRtbEF0dHJpYnV0ZXMuYXR0cmlidXRlcykge1xuICAgICAgICAvLyBDdXJyZW50bHkgSFRNTCBhdHRyaWJ1dGVzIGFyZSBkZWZpbmVkIGJvdGggYXQgdGhlIHRvcCBsZXZlbCBhbmQgdW5kZXIgJ2F0dHJpYnV0ZXMnXG4gICAgICAgIG1lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdCgpKGh0bWxBdHRyaWJ1dGVzLCBodG1sQXR0cmlidXRlcy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgZGVsZXRlIGh0bWxBdHRyaWJ1dGVzLmF0dHJpYnV0ZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gaHRtbEF0dHJpYnV0ZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgdGFnIGF0dHJpYnV0ZSBuYW1lZCBgbmFtZWAgdG8gYHZhbHVlYFxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI3NldEF0dHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldEF0dHJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXR0cihuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy50cmFuc2Zvcm1hdGlvbigpLnNldChcImh0bWxfXCIuY29uY2F0KG5hbWUpLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSB0YWcgYXR0cmlidXRlIGBuYW1lYFxuICAgICAqIEBmdW5jdGlvbiBIdG1sVGFnI2dldEF0dHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRBdHRyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dHIobmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcygpW1wiaHRtbF9cIi5jb25jYXQobmFtZSldIHx8IHRoaXMuYXR0cmlidXRlcygpW25hbWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgdGFnIGF0dHJpYnV0ZWQgbmFtZWQgYG5hbWVgXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjcmVtb3ZlQXR0clxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUF0dHJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQXR0cihuYW1lKSB7XG4gICAgICB2YXIgcmVmO1xuICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLnRyYW5zZm9ybWF0aW9uKCkucmVtb3ZlKFwiaHRtbF9cIi5jb25jYXQobmFtZSkpKSAhPSBudWxsID8gcmVmIDogdGhpcy50cmFuc2Zvcm1hdGlvbigpLnJlbW92ZShuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNjb250ZW50XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRlbnQoKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyNvcGVuVGFnXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJvcGVuVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5UYWcoKSB7XG4gICAgICB2YXIgdGFnID0gXCI8XCIgKyB0aGlzLm5hbWU7XG4gICAgICB2YXIgaHRtbEF0dHJzID0gdGhpcy5odG1sQXR0cnModGhpcy5hdHRyaWJ1dGVzKCkpO1xuICAgICAgaWYgKGh0bWxBdHRycyAmJiBodG1sQXR0cnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0YWcgKz0gXCIgXCIgKyBodG1sQXR0cnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFnICsgXCI+XCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIEh0bWxUYWcjY2xvc2VUYWdcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsb3NlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlVGFnKCkge1xuICAgICAgcmV0dXJuIFwiPC9cIi5jb25jYXQodGhpcy5uYW1lLCBcIj5cIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIEhUTUwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRhZy5cbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyN0b0h0bWxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIEhUTUwgaW4gc3RyaW5nIGZvcm1hdFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRvSHRtbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0h0bWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcGVuVGFnKCkgKyB0aGlzLmNvbnRlbnQoKSArIHRoaXMuY2xvc2VUYWcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgRE9NIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHRhZy5cbiAgICAgKiBAZnVuY3Rpb24gSHRtbFRhZyN0b0RPTVxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRvRE9NXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvRE9NKCkge1xuICAgICAgdmFyIGVsZW1lbnQsIG5hbWUsIHJlZiwgdmFsdWU7XG4gICAgICBpZiAoIWlzRnVuY3Rpb25fcm9vdF9pc0Z1bmN0aW9uX2RlZmF1bHQoKSh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQgIT09IG51bGwgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50IDogdm9pZCAwKSkge1xuICAgICAgICB0aHJvdyBcIkNhbid0IGNyZWF0ZSBET00gaWYgZG9jdW1lbnQgaXMgbm90IHByZXNlbnQhXCI7XG4gICAgICB9XG4gICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm5hbWUpO1xuICAgICAgcmVmID0gdGhpcy5hdHRyaWJ1dGVzKCk7XG4gICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgIHZhbHVlID0gcmVmW25hbWVdO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJuZXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25ldyhuYW1lLCBwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKG5hbWUsIHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNSZXNwb25zaXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzUmVzcG9uc2l2ZSh0YWcsIHJlc3BvbnNpdmVDbGFzcykge1xuICAgICAgdmFyIGRhdGFTcmM7XG4gICAgICBkYXRhU3JjID0gbG9kYXNoX2dldERhdGEodGFnLCAnc3JjLWNhY2hlJykgfHwgbG9kYXNoX2dldERhdGEodGFnLCAnc3JjJyk7XG4gICAgICByZXR1cm4gbG9kYXNoX2hhc0NsYXNzKHRhZywgcmVzcG9uc2l2ZUNsYXNzKSAmJiAvXFxid19hdXRvXFxiLy5leGVjKGRhdGFTcmMpO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuO1xuXG4vKipcbiAqIFJlcHJlc2VudCB0aGUgZ2l2ZW4ga2V5IGFuZCB2YWx1ZSBhcyBhbiBIVE1MIGF0dHJpYnV0ZS5cbiAqIEBmdW5jdGlvbiB0b0F0dHJpYnV0ZVxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIGF0dHJpYnV0ZSBuYW1lXG4gKiBAcGFyYW0geyp8Ym9vbGVhbn0gdmFsdWUgLSB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZS4gSWYgdGhlIHZhbHVlIGlzIGJvb2xlYW4gYHRydWVgLCByZXR1cm4gdGhlIGtleSBvbmx5LlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGF0dHJpYnV0ZVxuICpcbiAqL1xuZnVuY3Rpb24gaHRtbHRhZ190b0F0dHJpYnV0ZShrZXksIHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGtleTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoa2V5LCBcIj1cXFwiXCIpLmNvbmNhdCh2YWx1ZSwgXCJcXFwiXCIpO1xuICB9XG59XG5cbi8qKlxuICogSWYgZ2l2ZW4gdmFsdWUgaXMgYSBzdHJpbmcsIHJlcGxhY2VzIHF1b3RlcyB3aXRoIGNoYXJhY3RlciBlbnRpdGllcyAoJiMzNDssICYjMzk7KVxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gY2hhbmdlXG4gKiBAcmV0dXJucyB7Kn0gY2hhbmdlZCB2YWx1ZVxuICovXG5mdW5jdGlvbiBlc2NhcGVRdW90ZXModmFsdWUpIHtcbiAgcmV0dXJuIGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKHZhbHVlKSA/IHZhbHVlLnJlcGxhY2UoJ1wiJywgJyYjMzQ7JykucmVwbGFjZShcIidcIiwgJyYjMzk7JykgOiB2YWx1ZTtcbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGh0bWx0YWcgPSAoaHRtbHRhZ19IdG1sVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3VybC5qc1xudmFyIF9leGNsdWRlZCA9IFtcInBsYWNlaG9sZGVyXCIsIFwiYWNjZXNzaWJpbGl0eVwiXTtcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5cblxuXG5cblxuXG4vKipcbiAqIEFkZHMgcHJvdG9jb2wsIGhvc3QsIHBhdGhuYW1lIHByZWZpeGVzIHRvIGdpdmVuIHN0cmluZ1xuICogQHBhcmFtIHN0clxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbWFrZVVybChzdHIpIHtcbiAgdmFyIHByZWZpeCA9IGRvY3VtZW50LmxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGRvY3VtZW50LmxvY2F0aW9uLmhvc3Q7XG4gIGlmIChzdHJbMF0gPT09ICc/Jykge1xuICAgIHByZWZpeCArPSBkb2N1bWVudC5sb2NhdGlvbi5wYXRobmFtZTtcbiAgfSBlbHNlIGlmIChzdHJbMF0gIT09ICcvJykge1xuICAgIHByZWZpeCArPSBkb2N1bWVudC5sb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sICcvJyk7XG4gIH1cbiAgcmV0dXJuIHByZWZpeCArIHN0cjtcbn1cblxuLyoqXG4gKiBDaGVjayBpcyBnaXZlbiBzdHJpbmcgaXMgYSB1cmxcbiAqIEBwYXJhbSBzdHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1VybChzdHIpIHtcbiAgcmV0dXJuIHN0ciA/ICEhc3RyLm1hdGNoKC9eaHR0cHM/OlxcLy8pIDogZmFsc2U7XG59XG5cbi8vIFByb2R1Y2UgYSBudW1iZXIgYmV0d2VlbiAxIGFuZCA1IHRvIGJlIHVzZWQgZm9yIGNkbiBzdWIgZG9tYWlucyBkZXNpZ25hdGlvblxuZnVuY3Rpb24gY2RuU3ViZG9tYWluTnVtYmVyKHB1YmxpY0lkKSB7XG4gIHJldHVybiBzcmNfY3JjMzIocHVibGljSWQpICUgNSArIDE7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBzaWduYXR1cmUgZnJvbSBvcHRpb25zIGFuZCByZXR1cm5zIHRoZSBzaWduYXR1cmVcbiAqIE1ha2VzIHN1cmUgc2lnbmF0dXJlIGlzIGVtcHR5IG9yIG9mIHRoaXMgZm9ybWF0OiBzLS1zaWduYXR1cmUtLVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBmb3JtYXR0ZWQgc2lnbmF0dXJlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVNpZ25hdHVyZShvcHRpb25zKSB7XG4gIHZhciBzaWduYXR1cmUgPSBvcHRpb25zLnNpZ25hdHVyZTtcbiAgdmFyIGlzRm9ybWF0dGVkID0gIXNpZ25hdHVyZSB8fCBzaWduYXR1cmUuaW5kZXhPZigncy0tJykgPT09IDAgJiYgc2lnbmF0dXJlLnN1YnN0cigtMikgPT09ICctLSc7XG4gIGRlbGV0ZSBvcHRpb25zLnNpZ25hdHVyZTtcbiAgcmV0dXJuIGlzRm9ybWF0dGVkID8gc2lnbmF0dXJlIDogXCJzLS1cIi5jb25jYXQoc2lnbmF0dXJlLCBcIi0tXCIpO1xufVxuXG4vKipcbiAqIENyZWF0ZSB0aGUgVVJMIHByZWZpeCBmb3IgQ2xvdWRpbmFyeSByZXNvdXJjZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgdGhlIHJlc291cmNlIHB1YmxpYyBJRFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgYWRkaXRpb25hbCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jbG91ZF9uYW1lIC0gdGhlIGNsb3VkIG5hbWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNkbl9zdWJkb21haW49ZmFsc2VdIC0gV2hldGhlciB0byBhdXRvbWF0aWNhbGx5IGJ1aWxkIFVSTHMgd2l0aFxuICogIG11bHRpcGxlIENETiBzdWItZG9tYWlucy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wcml2YXRlX2Nkbl0gLSBCb29sZWFuIChkZWZhdWx0OiBmYWxzZSkuIFNob3VsZCBiZSBzZXQgdG8gdHJ1ZSBmb3IgQWR2YW5jZWQgcGxhbidzIHVzZXJzXG4gKiAgdGhhdCBoYXZlIGEgcHJpdmF0ZSBDRE4gZGlzdHJpYnV0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnByb3RvY29sPVwiaHR0cDovL1wiXSAtIHRoZSBVUkkgcHJvdG9jb2wgdG8gdXNlLiBJZiBvcHRpb25zLnNlY3VyZSBpcyB0cnVlLFxuICogIHRoZSB2YWx1ZSBpcyBvdmVycmlkZGVuIHRvIFwiaHR0cHM6Ly9cIlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNlY3VyZV9kaXN0cmlidXRpb25dIC0gVGhlIGRvbWFpbiBuYW1lIG9mIHRoZSBDRE4gZGlzdHJpYnV0aW9uIHRvIHVzZSBmb3IgYnVpbGRpbmcgSFRUUFMgVVJMcy5cbiAqICBSZWxldmFudCBvbmx5IGZvciBBZHZhbmNlZCBwbGFuJ3MgdXNlcnMgdGhhdCBoYXZlIGEgcHJpdmF0ZSBDRE4gZGlzdHJpYnV0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNuYW1lXSAtIEN1c3RvbSBkb21haW4gbmFtZSB0byB1c2UgZm9yIGJ1aWxkaW5nIEhUVFAgVVJMcy5cbiAqICBSZWxldmFudCBvbmx5IGZvciBBZHZhbmNlZCBwbGFuJ3MgdXNlcnMgdGhhdCBoYXZlIGEgcHJpdmF0ZSBDRE4gZGlzdHJpYnV0aW9uIGFuZCBhIGN1c3RvbSBDTkFNRS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlX2Nkbl9zdWJkb21haW49dHJ1ZV0gLSBXaGVuIG9wdGlvbnMuc2VjdXJlIGlzIHRydWUgYW5kIHRoaXMgcGFyYW1ldGVyIGlzIGZhbHNlLFxuICogIHRoZSBzdWJkb21haW4gaXMgc2V0IHRvIFwicmVzXCIuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZT1mYWxzZV0gLSBGb3JjZSBIVFRQUyBVUkxzIG9mIGltYWdlcyBldmVuIGlmIGVtYmVkZGVkIGluIG5vbi1zZWN1cmUgSFRUUCBwYWdlcy5cbiAqICBXaGVuIHRoaXMgdmFsdWUgaXMgdHJ1ZSwgb3B0aW9ucy5zZWN1cmVfZGlzdHJpYnV0aW9uIHdpbGwgYmUgdXNlZCBhcyBob3N0IGlmIHByb3ZpZGVkLCBhbmQgb3B0aW9ucy5wcm90b2NvbCBpcyBzZXRcbiAqICB0byBcImh0dHBzOi8vXCIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgVVJMIHByZWZpeCBmb3IgdGhlIHJlc291cmNlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJlZml4KHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmNsb3VkX25hbWUgJiYgb3B0aW9ucy5jbG91ZF9uYW1lWzBdID09PSAnLycpIHtcbiAgICByZXR1cm4gJy9yZXMnICsgb3B0aW9ucy5jbG91ZF9uYW1lO1xuICB9XG4gIC8vIGRlZmF1bHRzXG4gIHZhciBwcm90b2NvbCA9IFwiaHR0cDovL1wiO1xuICB2YXIgY2RuUGFydCA9IFwiXCI7XG4gIHZhciBzdWJkb21haW4gPSBcInJlc1wiO1xuICB2YXIgaG9zdCA9IFwiLmNsb3VkaW5hcnkuY29tXCI7XG4gIHZhciBwYXRoID0gXCIvXCIgKyBvcHRpb25zLmNsb3VkX25hbWU7XG4gIC8vIG1vZGlmaWNhdGlvbnNcbiAgaWYgKG9wdGlvbnMucHJvdG9jb2wpIHtcbiAgICBwcm90b2NvbCA9IG9wdGlvbnMucHJvdG9jb2wgKyAnLy8nO1xuICB9XG4gIGlmIChvcHRpb25zLnByaXZhdGVfY2RuKSB7XG4gICAgY2RuUGFydCA9IG9wdGlvbnMuY2xvdWRfbmFtZSArIFwiLVwiO1xuICAgIHBhdGggPSBcIlwiO1xuICB9XG4gIGlmIChvcHRpb25zLmNkbl9zdWJkb21haW4pIHtcbiAgICBzdWJkb21haW4gPSBcInJlcy1cIiArIGNkblN1YmRvbWFpbk51bWJlcihwdWJsaWNJZCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc2VjdXJlKSB7XG4gICAgcHJvdG9jb2wgPSBcImh0dHBzOi8vXCI7XG4gICAgaWYgKG9wdGlvbnMuc2VjdXJlX2Nkbl9zdWJkb21haW4gPT09IGZhbHNlKSB7XG4gICAgICBzdWJkb21haW4gPSBcInJlc1wiO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zZWN1cmVfZGlzdHJpYnV0aW9uICE9IG51bGwgJiYgb3B0aW9ucy5zZWN1cmVfZGlzdHJpYnV0aW9uICE9PSBPTERfQUtBTUFJX1NIQVJFRF9DRE4gJiYgb3B0aW9ucy5zZWN1cmVfZGlzdHJpYnV0aW9uICE9PSBTSEFSRURfQ0ROKSB7XG4gICAgICBjZG5QYXJ0ID0gXCJcIjtcbiAgICAgIHN1YmRvbWFpbiA9IFwiXCI7XG4gICAgICBob3N0ID0gb3B0aW9ucy5zZWN1cmVfZGlzdHJpYnV0aW9uO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvcHRpb25zLmNuYW1lKSB7XG4gICAgcHJvdG9jb2wgPSBcImh0dHA6Ly9cIjtcbiAgICBjZG5QYXJ0ID0gXCJcIjtcbiAgICBzdWJkb21haW4gPSBvcHRpb25zLmNkbl9zdWJkb21haW4gPyAnYScgKyAoc3JjX2NyYzMyKHB1YmxpY0lkKSAlIDUgKyAxKSArICcuJyA6ICcnO1xuICAgIGhvc3QgPSBvcHRpb25zLmNuYW1lO1xuICB9XG4gIHJldHVybiBbcHJvdG9jb2wsIGNkblBhcnQsIHN1YmRvbWFpbiwgaG9zdCwgcGF0aF0uam9pbihcIlwiKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHJlc291cmNlIHR5cGUgYW5kIGFjdGlvbiB0eXBlIGJhc2VkIG9uIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uXG4gKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNoYW5kbGVSZXNvdXJjZVR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gcmVzb3VyY2VfdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlPSd1cGxvYWQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFt1cmxfc3VmZml4XVxuICogQHBhcmFtIHtib29sZWFufSBbdXNlX3Jvb3RfcGF0aF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Nob3J0ZW5dXG4gKiBAcmV0dXJucyB7c3RyaW5nfSByZXNvdXJjZV90eXBlL3R5cGVcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gaGFuZGxlUmVzb3VyY2VUeXBlKF9yZWYpIHtcbiAgdmFyIF9yZWYkcmVzb3VyY2VfdHlwZSA9IF9yZWYucmVzb3VyY2VfdHlwZSxcbiAgICByZXNvdXJjZV90eXBlID0gX3JlZiRyZXNvdXJjZV90eXBlID09PSB2b2lkIDAgPyBcImltYWdlXCIgOiBfcmVmJHJlc291cmNlX3R5cGUsXG4gICAgX3JlZiR0eXBlID0gX3JlZi50eXBlLFxuICAgIHR5cGUgPSBfcmVmJHR5cGUgPT09IHZvaWQgMCA/IFwidXBsb2FkXCIgOiBfcmVmJHR5cGUsXG4gICAgdXJsX3N1ZmZpeCA9IF9yZWYudXJsX3N1ZmZpeCxcbiAgICB1c2Vfcm9vdF9wYXRoID0gX3JlZi51c2Vfcm9vdF9wYXRoLFxuICAgIHNob3J0ZW4gPSBfcmVmLnNob3J0ZW47XG4gIHZhciBvcHRpb25zLFxuICAgIHJlc291cmNlVHlwZSA9IHJlc291cmNlX3R5cGU7XG4gIGlmIChpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkocmVzb3VyY2VUeXBlKSkge1xuICAgIG9wdGlvbnMgPSByZXNvdXJjZVR5cGU7XG4gICAgcmVzb3VyY2VUeXBlID0gb3B0aW9ucy5yZXNvdXJjZV90eXBlO1xuICAgIHR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgc2hvcnRlbiA9IG9wdGlvbnMuc2hvcnRlbjtcbiAgfVxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgdHlwZSA9ICd1cGxvYWQnO1xuICB9XG4gIGlmICh1cmxfc3VmZml4ICE9IG51bGwpIHtcbiAgICByZXNvdXJjZVR5cGUgPSBTRU9fVFlQRVNbXCJcIi5jb25jYXQocmVzb3VyY2VUeXBlLCBcIi9cIikuY29uY2F0KHR5cGUpXTtcbiAgICB0eXBlID0gbnVsbDtcbiAgICBpZiAocmVzb3VyY2VUeXBlID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVSTCBTdWZmaXggb25seSBzdXBwb3J0ZWQgZm9yIFwiLmNvbmNhdChPYmplY3Qua2V5cyhTRU9fVFlQRVMpLmpvaW4oJywgJykpKTtcbiAgICB9XG4gIH1cbiAgaWYgKHVzZV9yb290X3BhdGgpIHtcbiAgICBpZiAocmVzb3VyY2VUeXBlID09PSAnaW1hZ2UnICYmIHR5cGUgPT09ICd1cGxvYWQnIHx8IHJlc291cmNlVHlwZSA9PT0gXCJpbWFnZXNcIikge1xuICAgICAgcmVzb3VyY2VUeXBlID0gbnVsbDtcbiAgICAgIHR5cGUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb290IHBhdGggb25seSBzdXBwb3J0ZWQgZm9yIGltYWdlL3VwbG9hZFwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNob3J0ZW4gJiYgcmVzb3VyY2VUeXBlID09PSAnaW1hZ2UnICYmIHR5cGUgPT09ICd1cGxvYWQnKSB7XG4gICAgcmVzb3VyY2VUeXBlID0gJ2l1JztcbiAgICB0eXBlID0gbnVsbDtcbiAgfVxuICByZXR1cm4gW3Jlc291cmNlVHlwZSwgdHlwZV0uam9pbihcIi9cIik7XG59XG5cbi8qKlxuICogRW5jb2RlIHB1YmxpY0lkXG4gKiBAcGFyYW0gcHVibGljSWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGVuY29kZWQgcHVibGljSWRcbiAqL1xuZnVuY3Rpb24gZW5jb2RlUHVibGljSWQocHVibGljSWQpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChwdWJsaWNJZCkucmVwbGFjZSgvJTNBL2csICc6JykucmVwbGFjZSgvJTJGL2csICcvJyk7XG59XG5cbi8qKlxuICogRW5jb2RlIGFuZCBmb3JtYXQgcHVibGljSWRcbiAqIEBwYXJhbSBwdWJsaWNJZFxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHB1YmxpY0lkXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFB1YmxpY0lkKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gIGlmIChpc1VybChwdWJsaWNJZCkpIHtcbiAgICBwdWJsaWNJZCA9IGVuY29kZVB1YmxpY0lkKHB1YmxpY0lkKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgLy8gTWFrZSBzdXJlIHB1YmxpY0lkIGlzIFVSSSBlbmNvZGVkLlxuICAgICAgcHVibGljSWQgPSBkZWNvZGVVUklDb21wb25lbnQocHVibGljSWQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuICAgIHB1YmxpY0lkID0gZW5jb2RlUHVibGljSWQocHVibGljSWQpO1xuICAgIGlmIChvcHRpb25zLnVybF9zdWZmaXgpIHtcbiAgICAgIHB1YmxpY0lkID0gcHVibGljSWQgKyAnLycgKyBvcHRpb25zLnVybF9zdWZmaXg7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZvcm1hdCkge1xuICAgICAgaWYgKCFvcHRpb25zLnRydXN0X3B1YmxpY19pZCkge1xuICAgICAgICBwdWJsaWNJZCA9IHB1YmxpY0lkLnJlcGxhY2UoL1xcLihqcGd8cG5nfGdpZnx3ZWJwKSQvLCAnJyk7XG4gICAgICB9XG4gICAgICBwdWJsaWNJZCA9IHB1YmxpY0lkICsgJy4nICsgb3B0aW9ucy5mb3JtYXQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBwdWJsaWNJZDtcbn1cblxuLyoqXG4gKiBHZXQgYW55IGVycm9yIHdpdGggdXJsIG9wdGlvbnNcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBpZiBlcnJvciwgb3RoZXJ3aXNlIHJldHVybiB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucykge1xuICB2YXIgY2xvdWRfbmFtZSA9IG9wdGlvbnMuY2xvdWRfbmFtZSxcbiAgICB1cmxfc3VmZml4ID0gb3B0aW9ucy51cmxfc3VmZml4O1xuICBpZiAoIWNsb3VkX25hbWUpIHtcbiAgICByZXR1cm4gJ1Vua25vd24gY2xvdWRfbmFtZSc7XG4gIH1cbiAgaWYgKHVybF9zdWZmaXggJiYgdXJsX3N1ZmZpeC5tYXRjaCgvW1xcLlxcL10vKSkge1xuICAgIHJldHVybiAndXJsX3N1ZmZpeCBzaG91bGQgbm90IGluY2x1ZGUgLiBvciAvJztcbiAgfVxufVxuXG4vKipcbiAqIEdldCB2ZXJzaW9uIHBhcnQgb2YgdGhlIHVybFxuICogQHBhcmFtIHB1YmxpY0lkXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaGFuZGxlVmVyc2lvbihwdWJsaWNJZCwgb3B0aW9ucykge1xuICAvLyBmb3JjZV92ZXJzaW9uIHBhcmFtIG1lYW5zIHRvIG1ha2Ugc3VyZSB0aGVyZSBpcyBhIHZlcnNpb24gaW4gdGhlIHVybCAoRGVmYXVsdCBpcyB0cnVlKVxuICB2YXIgaXNGb3JjZVZlcnNpb24gPSBvcHRpb25zLmZvcmNlX3ZlcnNpb24gfHwgdHlwZW9mIG9wdGlvbnMuZm9yY2VfdmVyc2lvbiA9PT0gJ3VuZGVmaW5lZCc7XG5cbiAgLy8gSXMgdmVyc2lvbiBpbmNsdWRlZCBpbiBwdWJsaWNJZCBvciBpbiBvcHRpb25zLCBvciBwdWJsaWNJZCBpcyBhIHVybCAoZG9lc24ndCBuZWVkIHZlcnNpb24pXG4gIHZhciBpc1ZlcnNpb25FeGlzdCA9IHB1YmxpY0lkLmluZGV4T2YoJy8nKSA8IDAgfHwgcHVibGljSWQubWF0Y2goL152WzAtOV0rLykgfHwgaXNVcmwocHVibGljSWQpIHx8IG9wdGlvbnMudmVyc2lvbjtcbiAgaWYgKGlzRm9yY2VWZXJzaW9uICYmICFpc1ZlcnNpb25FeGlzdCkge1xuICAgIG9wdGlvbnMudmVyc2lvbiA9IDE7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnMudmVyc2lvbiA/IFwidlwiLmNvbmNhdChvcHRpb25zLnZlcnNpb24pIDogJyc7XG59XG5cbi8qKlxuICogR2V0IGZpbmFsIHRyYW5zZm9ybWF0aW9uIGNvbXBvbmVudCBmb3IgdXJsIHN0cmluZ1xuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVRyYW5zZm9ybWF0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIF9yZWYyID0gb3B0aW9ucyB8fCB7fSxcbiAgICBwbGFjZWhvbGRlciA9IF9yZWYyLnBsYWNlaG9sZGVyLFxuICAgIGFjY2Vzc2liaWxpdHkgPSBfcmVmMi5hY2Nlc3NpYmlsaXR5LFxuICAgIG90aGVyT3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgX2V4Y2x1ZGVkKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBzcmNfdHJhbnNmb3JtYXRpb24ob3RoZXJPcHRpb25zKTtcblxuICAvLyBBcHBlbmQgYWNjZXNzaWJpbGl0eSB0cmFuc2Zvcm1hdGlvbnNcbiAgaWYgKGFjY2Vzc2liaWxpdHkgJiYgQUNDRVNTSUJJTElUWV9NT0RFU1thY2Nlc3NpYmlsaXR5XSkge1xuICAgIHJlc3VsdC5jaGFpbigpLmVmZmVjdChBQ0NFU1NJQklMSVRZX01PREVTW2FjY2Vzc2liaWxpdHldKTtcbiAgfVxuXG4gIC8vIEFwcGVuZCBwbGFjZWhvbGRlciB0cmFuc2Zvcm1hdGlvbnNcbiAgaWYgKHBsYWNlaG9sZGVyKSB7XG4gICAgaWYgKHBsYWNlaG9sZGVyID09PSBcInByZWRvbWluYW50LWNvbG9yXCIgJiYgcmVzdWx0LmdldFZhbHVlKCd3aWR0aCcpICYmIHJlc3VsdC5nZXRWYWx1ZSgnaGVpZ2h0JykpIHtcbiAgICAgIHBsYWNlaG9sZGVyICs9ICctcGl4ZWwnO1xuICAgIH1cbiAgICB2YXIgcGxhY2Vob2xkZXJUcmFuc2Zvcm1hdGlvbnMgPSBQTEFDRUhPTERFUl9JTUFHRV9NT0RFU1twbGFjZWhvbGRlcl0gfHwgUExBQ0VIT0xERVJfSU1BR0VfTU9ERVMuYmx1cjtcbiAgICBwbGFjZWhvbGRlclRyYW5zZm9ybWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0LmNoYWluKCkudHJhbnNmb3JtYXRpb24odCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5zZXJpYWxpemUoKTtcbn1cblxuLyoqXG4gKiBJZiB0eXBlIGlzICdmZXRjaCcsIHVwZGF0ZSBwdWJsaWNJZCB0byBiZSBhIHVybFxuICogQHBhcmFtIHB1YmxpY0lkXG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcHJlcGFyZVB1YmxpY0lkKHB1YmxpY0lkLCBfcmVmMykge1xuICB2YXIgdHlwZSA9IF9yZWYzLnR5cGU7XG4gIHJldHVybiAhaXNVcmwocHVibGljSWQpICYmIHR5cGUgPT09ICdmZXRjaCcgPyBtYWtlVXJsKHB1YmxpY0lkKSA6IHB1YmxpY0lkO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIHVybCBzdHJpbmdcbiAqIEBwYXJhbSBwdWJsaWNJZFxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGZpbmFsIHVybFxuICovXG5mdW5jdGlvbiB1cmxTdHJpbmcocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgaWYgKGlzVXJsKHB1YmxpY0lkKSAmJiAob3B0aW9ucy50eXBlID09PSAndXBsb2FkJyB8fCBvcHRpb25zLnR5cGUgPT09ICdhc3NldCcpKSB7XG4gICAgcmV0dXJuIHB1YmxpY0lkO1xuICB9XG4gIHZhciB2ZXJzaW9uID0gaGFuZGxlVmVyc2lvbihwdWJsaWNJZCwgb3B0aW9ucyk7XG4gIHZhciB0cmFuc2Zvcm1hdGlvblN0cmluZyA9IGhhbmRsZVRyYW5zZm9ybWF0aW9uKG9wdGlvbnMpO1xuICB2YXIgcHJlZml4ID0gaGFuZGxlUHJlZml4KHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgdmFyIHNpZ25hdHVyZSA9IGhhbmRsZVNpZ25hdHVyZShvcHRpb25zKTtcbiAgdmFyIHJlc291cmNlVHlwZSA9IGhhbmRsZVJlc291cmNlVHlwZShvcHRpb25zKTtcbiAgcHVibGljSWQgPSBmb3JtYXRQdWJsaWNJZChwdWJsaWNJZCwgb3B0aW9ucyk7XG4gIHJldHVybiBjb21wYWN0X3Jvb3RfY29tcGFjdF9kZWZhdWx0KCkoW3ByZWZpeCwgcmVzb3VyY2VUeXBlLCBzaWduYXR1cmUsIHRyYW5zZm9ybWF0aW9uU3RyaW5nLCB2ZXJzaW9uLCBwdWJsaWNJZF0pLmpvaW4oJy8nKS5yZXBsYWNlKC8oW146XSlcXC8rL2csICckMS8nKSAvLyByZXBsYWNlICcvLy8nIHdpdGggJy8vJ1xuICAucmVwbGFjZSgnICcsICclMjAnKTtcbn1cblxuLyoqXG4gKiBNZXJnZSBvcHRpb25zIGFuZCBjb25maWcgd2l0aCBkZWZhdWx0c1xuICogdXBkYXRlIG9wdGlvbnMgZmV0Y2hfZm9ybWF0IGFjY29yZGluZyB0byAndHlwZScgcGFyYW1cbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gY29uZmlnXG4gKiBAcmV0dXJucyB7Kn0gdXBkYXRlZCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHByZXBhcmVPcHRpb25zKG9wdGlvbnMsIGNvbmZpZykge1xuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIHNyY190cmFuc2Zvcm1hdGlvbikge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zLnRvT3B0aW9ucygpO1xuICB9XG4gIG9wdGlvbnMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucywgY29uZmlnLCBERUZBVUxUX0lNQUdFX1BBUkFNUyk7XG4gIGlmIChvcHRpb25zLnR5cGUgPT09ICdmZXRjaCcpIHtcbiAgICBvcHRpb25zLmZldGNoX2Zvcm1hdCA9IG9wdGlvbnMuZmV0Y2hfZm9ybWF0IHx8IG9wdGlvbnMuZm9ybWF0O1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIFVSTCBmb3IgYW55IGFzc2V0IGluIHlvdXIgTWVkaWEgbGlicmFyeS5cbiAqIEBmdW5jdGlvbiB1cmxcbiAqIEBpZ25vcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBwdWJsaWMgSUQgb2YgdGhlIG1lZGlhIGFzc2V0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMgdG8gaW5jbHVkZSBpbiB0aGUgVVJMLlxuICogQHBhcmFtIHtvYmplY3R9IFtjb25maWc9e31dIC0gVVJMIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHt0eXBlfSBbb3B0aW9ucy50eXBlPSd1cGxvYWQnXSAtIFRoZSBhc3NldCdzIHN0b3JhZ2UgdHlwZS5cbiAqICBGb3IgZGV0YWlscyBvbiBhbGwgZmV0Y2ggdHlwZXMsIHNlZVxuICogPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbnMjZmV0Y2hpbmdfaW1hZ2VzX2Zyb21fcmVtb3RlX2xvY2F0aW9uc1wiXG4gKiAgdGFyZ2V0PVwiX2JsYW5rXCI+RmV0Y2ggdHlwZXM8L2E+LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnJlc291cmNlX3R5cGU9J2ltYWdlJ10gLSBUaGUgdHlwZSBvZiBhc3NldC4gPHA+UG9zc2libGUgdmFsdWVzOjxici8+XG4gKiAgLSBgaW1hZ2VgPGJyLz5cbiAqICAtIGB2aWRlb2A8YnIvPlxuICogIC0gYHJhd2BcbiAqIEBwYXJhbSB7c2lnbmF0dXJlfSBbb3B0aW9ucy5zaWduYXR1cmU9J3MtLTEyMzQ1Njc4LS0nXSAtIFRoZSBzaWduYXR1cmUgY29tcG9uZW50IG9mIGFcbiAqICBzaWduZWQgZGVsaXZlcnkgVVJMIG9mIHRoZSBmb3JtYXQ6IC9zLS1TSUdOQVRVUkUtLS8uXG4gKiAgRm9yIGRldGFpbHMgb24gc2lnbmF0dXJlcywgc2VlXG4gKiA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NpZ25hdHVyZXNcIiB0YXJnZXQ9XCJfYmxhbmtcIj5TaWduYXR1cmVzPC9hPi5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG1lZGlhIGFzc2V0IFVSTC5cbiAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICogIEF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gKi9cbmZ1bmN0aW9uIHVybF91cmwocHVibGljSWQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgY29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgaWYgKCFwdWJsaWNJZCkge1xuICAgIHJldHVybiBwdWJsaWNJZDtcbiAgfVxuICBvcHRpb25zID0gcHJlcGFyZU9wdGlvbnMob3B0aW9ucywgY29uZmlnKTtcbiAgcHVibGljSWQgPSBwcmVwYXJlUHVibGljSWQocHVibGljSWQsIG9wdGlvbnMpO1xuICB2YXIgZXJyb3IgPSB2YWxpZGF0ZShvcHRpb25zKTtcbiAgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgdmFyIHJlc3VsdFVybCA9IHVybFN0cmluZyhwdWJsaWNJZCwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLnVybEFuYWx5dGljcykge1xuICAgIHZhciBhbmFseXRpY3NPcHRpb25zID0gZ2V0QW5hbHl0aWNzT3B0aW9ucyhvcHRpb25zKTtcbiAgICB2YXIgc2RrQW5hbHl0aWNzU2lnbmF0dXJlID0gZ2V0U0RLQW5hbHl0aWNzU2lnbmF0dXJlKGFuYWx5dGljc09wdGlvbnMpO1xuICAgIC8vIHVybCBtaWdodCBhbHJlYWR5IGhhdmUgYSAnPycgcXVlcnkgcGFyYW1cbiAgICB2YXIgYXBwZW5kZXIgPSAnPyc7XG4gICAgaWYgKHJlc3VsdFVybC5pbmRleE9mKCc/JykgPj0gMCkge1xuICAgICAgYXBwZW5kZXIgPSAnJic7XG4gICAgfVxuICAgIHJlc3VsdFVybCA9IFwiXCIuY29uY2F0KHJlc3VsdFVybCkuY29uY2F0KGFwcGVuZGVyLCBcIl9hPVwiKS5jb25jYXQoc2RrQW5hbHl0aWNzU2lnbmF0dXJlKTtcbiAgfVxuICBpZiAob3B0aW9ucy5hdXRoX3Rva2VuKSB7XG4gICAgdmFyIF9hcHBlbmRlciA9IHJlc3VsdFVybC5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/JztcbiAgICByZXN1bHRVcmwgPSBcIlwiLmNvbmNhdChyZXN1bHRVcmwpLmNvbmNhdChfYXBwZW5kZXIsIFwiX19jbGRfdG9rZW5fXz1cIikuY29uY2F0KG9wdGlvbnMuYXV0aF90b2tlbik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFVybDtcbn1cbjtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvZ2VuZXJhdGVCcmVha3BvaW50cy5qc1xuZnVuY3Rpb24gZ2VuZXJhdGVCcmVha3BvaW50c19zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gZ2VuZXJhdGVCcmVha3BvaW50c19hcnJheVdpdGhIb2xlcyhhcnIpIHx8IGdlbmVyYXRlQnJlYWtwb2ludHNfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBnZW5lcmF0ZUJyZWFrcG9pbnRzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgZ2VuZXJhdGVCcmVha3BvaW50c19ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gZ2VuZXJhdGVCcmVha3BvaW50c19ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIGdlbmVyYXRlQnJlYWtwb2ludHNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBnZW5lcmF0ZUJyZWFrcG9pbnRzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBnZW5lcmF0ZUJyZWFrcG9pbnRzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gZ2VuZXJhdGVCcmVha3BvaW50c19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5mdW5jdGlvbiBnZW5lcmF0ZUJyZWFrcG9pbnRzX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBnZW5lcmF0ZUJyZWFrcG9pbnRzX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbi4gR2V0cyBvciBwb3B1bGF0ZXMgc3Jjc2V0IGJyZWFrcG9pbnRzIHVzaW5nIHByb3ZpZGVkIHBhcmFtZXRlcnNcbiAqIEVpdGhlciB0aGUgYnJlYWtwb2ludHMgb3IgbWluX3dpZHRoLCBtYXhfd2lkdGgsIG1heF9pbWFnZXMgbXVzdCBiZSBwcm92aWRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzcmNzZXR9IHNyY3NldCBPcHRpb25zIHdpdGggZWl0aGVyIGBicmVha3BvaW50c2Agb3IgYG1pbl93aWR0aGAsIGBtYXhfd2lkdGhgLCBhbmQgYG1heF9pbWFnZXNgXG4gKlxuICogQHJldHVybiB7bnVtYmVyW119IEFycmF5IG9mIGJyZWFrcG9pbnRzXG4gKlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUJyZWFrcG9pbnRzKHNyY3NldCkge1xuICB2YXIgYnJlYWtwb2ludHMgPSBzcmNzZXQuYnJlYWtwb2ludHMgfHwgW107XG4gIGlmIChicmVha3BvaW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYnJlYWtwb2ludHM7XG4gIH1cbiAgdmFyIF9tYXAgPSBbc3Jjc2V0Lm1pbl93aWR0aCwgc3Jjc2V0Lm1heF93aWR0aCwgc3Jjc2V0Lm1heF9pbWFnZXNdLm1hcChOdW1iZXIpLFxuICAgIF9tYXAyID0gZ2VuZXJhdGVCcmVha3BvaW50c19zbGljZWRUb0FycmF5KF9tYXAsIDMpLFxuICAgIG1pbl93aWR0aCA9IF9tYXAyWzBdLFxuICAgIG1heF93aWR0aCA9IF9tYXAyWzFdLFxuICAgIG1heF9pbWFnZXMgPSBfbWFwMlsyXTtcbiAgaWYgKFttaW5fd2lkdGgsIG1heF93aWR0aCwgbWF4X2ltYWdlc10uc29tZShpc05hTikpIHtcbiAgICB0aHJvdyAnRWl0aGVyIChtaW5fd2lkdGgsIG1heF93aWR0aCwgbWF4X2ltYWdlcykgJyArICdvciBicmVha3BvaW50cyBtdXN0IGJlIHByb3ZpZGVkIHRvIHRoZSBpbWFnZSBzcmNzZXQgYXR0cmlidXRlJztcbiAgfVxuICBpZiAobWluX3dpZHRoID4gbWF4X3dpZHRoKSB7XG4gICAgdGhyb3cgJ21pbl93aWR0aCBtdXN0IGJlIGxlc3MgdGhhbiBtYXhfd2lkdGgnO1xuICB9XG4gIGlmIChtYXhfaW1hZ2VzIDw9IDApIHtcbiAgICB0aHJvdyAnbWF4X2ltYWdlcyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcic7XG4gIH0gZWxzZSBpZiAobWF4X2ltYWdlcyA9PT0gMSkge1xuICAgIG1pbl93aWR0aCA9IG1heF93aWR0aDtcbiAgfVxuICB2YXIgc3RlcFNpemUgPSBNYXRoLmNlaWwoKG1heF93aWR0aCAtIG1pbl93aWR0aCkgLyBNYXRoLm1heChtYXhfaW1hZ2VzIC0gMSwgMSkpO1xuICBmb3IgKHZhciBjdXJyZW50ID0gbWluX3dpZHRoOyBjdXJyZW50IDwgbWF4X3dpZHRoOyBjdXJyZW50ICs9IHN0ZXBTaXplKSB7XG4gICAgYnJlYWtwb2ludHMucHVzaChjdXJyZW50KTtcbiAgfVxuICBicmVha3BvaW50cy5wdXNoKG1heF93aWR0aCk7XG4gIHJldHVybiBicmVha3BvaW50cztcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvc3Jjc2V0VXRpbHMuanNcblxudmFyIHNyY3NldFV0aWxzX2lzRW1wdHkgPSBpc0VtcHR5O1xuXG5cblxuXG4vKipcbiAqIE9wdGlvbnMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgc3Jjc2V0IGF0dHJpYnV0ZS5cbiAqIEB0eXBlZGVmIHtvYmplY3R9IHNyY3NldFxuICogQHByb3BlcnR5IHsobnVtYmVyW118c3RyaW5nW10pfSAgIFticmVha3BvaW50c10gQW4gYXJyYXkgb2YgYnJlYWtwb2ludHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gICAgICAgICAgICAgICAgW21pbl93aWR0aF0gICBNaW5pbWFsIHdpZHRoIG9mIHRoZSBzcmNzZXQgaW1hZ2VzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9ICAgICAgICAgICAgICAgIFttYXhfd2lkdGhdICAgTWF4aW1hbCB3aWR0aCBvZiB0aGUgc3Jjc2V0IGltYWdlcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgICAgICAgICAgICAgICBbbWF4X2ltYWdlc10gIE51bWJlciBvZiBzcmNzZXQgaW1hZ2VzIHRvIGdlbmVyYXRlLlxuICogQHByb3BlcnR5IHtvYmplY3R8c3RyaW5nfSAgICAgICAgIFt0cmFuc2Zvcm1hdGlvbl0gVGhlIHRyYW5zZm9ybWF0aW9uIHRvIHVzZSBpbiB0aGUgc3Jjc2V0IHVybHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59ICAgICAgICAgICAgICAgW3NpemVzXSBXaGV0aGVyIHRvIGNhbGN1bGF0ZSBhbmQgYWRkIHRoZSBzaXplcyBhdHRyaWJ1dGUuXG4gKi9cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24uIEdlbmVyYXRlcyBhIHNpbmdsZSBzcmNzZXQgaXRlbSB1cmxcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY19pZCAgUHVibGljIElEIG9mIHRoZSByZXNvdXJjZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAgICAgIFdpZHRoIGluIHBpeGVscyBvZiB0aGUgc3Jjc2V0IGl0ZW0uXG4gKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IHRyYW5zZm9ybWF0aW9uXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgICBBZGRpdGlvbmFsIG9wdGlvbnMuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBSZXN1bHRpbmcgVVJMIG9mIHRoZSBpdGVtXG4gKi9cbmZ1bmN0aW9uIHNjYWxlZFVybChwdWJsaWNfaWQsIHdpZHRoLCB0cmFuc2Zvcm1hdGlvbikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIHZhciBjb25maWdQYXJhbXMgPSBleHRyYWN0VXJsUGFyYW1zKG9wdGlvbnMpO1xuICB0cmFuc2Zvcm1hdGlvbiA9IHRyYW5zZm9ybWF0aW9uIHx8IG9wdGlvbnM7XG4gIGNvbmZpZ1BhcmFtcy5yYXdfdHJhbnNmb3JtYXRpb24gPSBuZXcgc3JjX3RyYW5zZm9ybWF0aW9uKFttZXJnZV9yb290X21lcmdlX2RlZmF1bHQuYSh7fSwgdHJhbnNmb3JtYXRpb24pLCB7XG4gICAgY3JvcDogJ3NjYWxlJyxcbiAgICB3aWR0aDogd2lkdGhcbiAgfV0pLnRvU3RyaW5nKCk7XG4gIHJldHVybiB1cmxfdXJsKHB1YmxpY19pZCwgY29uZmlnUGFyYW1zKTtcbn1cblxuLyoqXG4gKiBJZiBjYWNoZSBpcyBlbmFibGVkLCBnZXQgdGhlIGJyZWFrcG9pbnRzIGZyb20gdGhlIGNhY2hlLiBJZiB0aGUgdmFsdWVzIHdlcmUgbm90IGZvdW5kIGluIHRoZSBjYWNoZSxcbiAqIG9yIGNhY2hlIGlzIG5vdCBlbmFibGVkLCBnZW5lcmF0ZSB0aGUgdmFsdWVzLlxuICogQHBhcmFtIHtzcmNzZXR9IHNyY3NldCBUaGUgc3Jjc2V0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY19pZFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyp8QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGdldE9yR2VuZXJhdGVCcmVha3BvaW50cyhwdWJsaWNfaWQpIHtcbiAgdmFyIHNyY3NldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgcmV0dXJuIGdlbmVyYXRlQnJlYWtwb2ludHMoc3Jjc2V0KTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24uIEdlbmVyYXRlcyBzcmNzZXQgYXR0cmlidXRlIHZhbHVlIG9mIHRoZSBIVE1MIGltZyB0YWdcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY19pZCAgUHVibGljIElEIG9mIHRoZSByZXNvdXJjZVxuICogQHBhcmFtIHtudW1iZXJbXX0gYnJlYWtwb2ludHMgQW4gYXJyYXkgb2YgYnJlYWtwb2ludHMgKGluIHBpeGVscylcbiAqIEBwYXJhbSB7b2JqZWN0fSB0cmFuc2Zvcm1hdGlvbiBUaGUgdHJhbnNmb3JtYXRpb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIEluY2x1ZGVzIGh0bWwgdGFnIG9wdGlvbnMsIHRyYW5zZm9ybWF0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm4ge3N0cmluZ30gUmVzdWx0aW5nIHNyY3NldCBhdHRyaWJ1dGUgdmFsdWVcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVTcmNzZXRBdHRyaWJ1dGUocHVibGljX2lkLCBicmVha3BvaW50cywgdHJhbnNmb3JtYXRpb24sIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0LmEob3B0aW9ucyk7XG4gIHBhdGNoRmV0Y2hGb3JtYXQob3B0aW9ucyk7XG4gIHJldHVybiBicmVha3BvaW50cy5tYXAoZnVuY3Rpb24gKHdpZHRoKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHNjYWxlZFVybChwdWJsaWNfaWQsIHdpZHRoLCB0cmFuc2Zvcm1hdGlvbiwgb3B0aW9ucyksIFwiIFwiKS5jb25jYXQod2lkdGgsIFwid1wiKTtcbiAgfSkuam9pbignLCAnKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24uIEdlbmVyYXRlcyBzaXplcyBhdHRyaWJ1dGUgdmFsdWUgb2YgdGhlIEhUTUwgaW1nIHRhZ1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyW119IGJyZWFrcG9pbnRzIEFuIGFycmF5IG9mIGJyZWFrcG9pbnRzLlxuICogQHJldHVybiB7c3RyaW5nfSBSZXN1bHRpbmcgc2l6ZXMgYXR0cmlidXRlIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlU2l6ZXNBdHRyaWJ1dGUoYnJlYWtwb2ludHMpIHtcbiAgaWYgKGJyZWFrcG9pbnRzID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIGJyZWFrcG9pbnRzLm1hcChmdW5jdGlvbiAod2lkdGgpIHtcbiAgICByZXR1cm4gXCIobWF4LXdpZHRoOiBcIi5jb25jYXQod2lkdGgsIFwicHgpIFwiKS5jb25jYXQod2lkdGgsIFwicHhcIik7XG4gIH0pLmpvaW4oJywgJyk7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uLiBHZW5lcmF0ZXMgc3Jjc2V0IGFuZCBzaXplcyBhdHRyaWJ1dGVzIG9mIHRoZSBpbWFnZSB0YWdcbiAqXG4gKiBHZW5lcmF0ZWQgYXR0cmlidXRlcyBhcmUgYWRkZWQgdG8gYXR0cmlidXRlcyBhcmd1bWVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgcHVibGljSWQgIFRoZSBwdWJsaWMgSUQgb2YgdGhlIHJlc291cmNlXG4gKiBAcGFyYW0ge29iamVjdH0gICAgYXR0cmlidXRlcyBFeGlzdGluZyBIVE1MIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge3NyY3NldH0gICAgc3Jjc2V0RGF0YVxuICogQHBhcmFtIHtvYmplY3R9ICAgIG9wdGlvbnMgICAgQWRkaXRpb25hbCBvcHRpb25zLlxuICpcbiAqIEByZXR1cm4gYXJyYXkgVGhlIHJlc3BvbnNpdmUgYXR0cmlidXRlc1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlUmVzcG9uc2l2ZUF0dHJpYnV0ZXMocHVibGljSWQpIHtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgc3Jjc2V0RGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgLy8gQ3JlYXRlIGJvdGggc3Jjc2V0IGFuZCBzaXplcyBoZXJlIHRvIGF2b2lkIGZldGNoaW5nIGJyZWFrcG9pbnRzIHR3aWNlXG5cbiAgdmFyIHJlc3BvbnNpdmVBdHRyaWJ1dGVzID0ge307XG4gIGlmIChzcmNzZXRVdGlsc19pc0VtcHR5KHNyY3NldERhdGEpKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNpdmVBdHRyaWJ1dGVzO1xuICB9XG4gIHZhciBnZW5lcmF0ZVNpemVzID0gIWF0dHJpYnV0ZXMuc2l6ZXMgJiYgc3Jjc2V0RGF0YS5zaXplcyA9PT0gdHJ1ZTtcbiAgdmFyIGdlbmVyYXRlU3Jjc2V0ID0gIWF0dHJpYnV0ZXMuc3Jjc2V0O1xuICBpZiAoZ2VuZXJhdGVTcmNzZXQgfHwgZ2VuZXJhdGVTaXplcykge1xuICAgIHZhciBicmVha3BvaW50cyA9IGdldE9yR2VuZXJhdGVCcmVha3BvaW50cyhwdWJsaWNJZCwgc3Jjc2V0RGF0YSwgb3B0aW9ucyk7XG4gICAgaWYgKGdlbmVyYXRlU3Jjc2V0KSB7XG4gICAgICB2YXIgdHJhbnNmb3JtYXRpb24gPSBzcmNzZXREYXRhLnRyYW5zZm9ybWF0aW9uO1xuICAgICAgdmFyIHNyY3NldEF0dHIgPSBnZW5lcmF0ZVNyY3NldEF0dHJpYnV0ZShwdWJsaWNJZCwgYnJlYWtwb2ludHMsIHRyYW5zZm9ybWF0aW9uLCBvcHRpb25zKTtcbiAgICAgIGlmICghc3Jjc2V0VXRpbHNfaXNFbXB0eShzcmNzZXRBdHRyKSkge1xuICAgICAgICByZXNwb25zaXZlQXR0cmlidXRlcy5zcmNzZXQgPSBzcmNzZXRBdHRyO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ2VuZXJhdGVTaXplcykge1xuICAgICAgdmFyIHNpemVzQXR0ciA9IGdlbmVyYXRlU2l6ZXNBdHRyaWJ1dGUoYnJlYWtwb2ludHMpO1xuICAgICAgaWYgKCFzcmNzZXRVdGlsc19pc0VtcHR5KHNpemVzQXR0cikpIHtcbiAgICAgICAgcmVzcG9uc2l2ZUF0dHJpYnV0ZXMuc2l6ZXMgPSBzaXplc0F0dHI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNwb25zaXZlQXR0cmlidXRlcztcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1lZGlhIHF1ZXJ5XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBvcHRpb25zLm1pbl93aWR0aFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBvcHRpb25zLm1heF93aWR0aFxuICogQHJldHVybiB7c3RyaW5nfSBhIG1lZGlhIHF1ZXJ5IHN0cmluZ1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZU1lZGlhQXR0cihvcHRpb25zKSB7XG4gIHZhciBtZWRpYVF1ZXJ5ID0gW107XG4gIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICBpZiAob3B0aW9ucy5taW5fd2lkdGggIT0gbnVsbCkge1xuICAgICAgbWVkaWFRdWVyeS5wdXNoKFwiKG1pbi13aWR0aDogXCIuY29uY2F0KG9wdGlvbnMubWluX3dpZHRoLCBcInB4KVwiKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm1heF93aWR0aCAhPSBudWxsKSB7XG4gICAgICBtZWRpYVF1ZXJ5LnB1c2goXCIobWF4LXdpZHRoOiBcIi5jb25jYXQob3B0aW9ucy5tYXhfd2lkdGgsIFwicHgpXCIpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lZGlhUXVlcnkuam9pbignIGFuZCAnKTtcbn1cbnZhciBzcmNzZXRVcmwgPSBzY2FsZWRVcmw7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90YWdzL2ltYWdldGFnLmpzXG5mdW5jdGlvbiBpbWFnZXRhZ190eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBpbWFnZXRhZ190eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgaW1hZ2V0YWdfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBpbWFnZXRhZ19jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBpbWFnZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgaW1hZ2V0YWdfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIGltYWdldGFnX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgaW1hZ2V0YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGltYWdldGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBpbWFnZXRhZ190b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBpbWFnZXRhZ190b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gaW1hZ2V0YWdfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBpbWFnZXRhZ190b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IGltYWdldGFnX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBpbWFnZXRhZ190eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gaW1hZ2V0YWdfY2FsbFN1cGVyKHQsIG8sIGUpIHsgcmV0dXJuIG8gPSBpbWFnZXRhZ19nZXRQcm90b3R5cGVPZihvKSwgaW1hZ2V0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBpbWFnZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIGltYWdldGFnX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG5mdW5jdGlvbiBpbWFnZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKGltYWdldGFnX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBpbWFnZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIGltYWdldGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBpbWFnZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHRyeSB7IHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgfSBjYXRjaCAodCkge30gcmV0dXJuIChpbWFnZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBpbWFnZXRhZ19nZXQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBpbWFnZXRhZ19nZXQgPSBSZWZsZWN0LmdldC5iaW5kKCk7IH0gZWxzZSB7IGltYWdldGFnX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBpbWFnZXRhZ19zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBpbWFnZXRhZ19nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gaW1hZ2V0YWdfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IGltYWdldGFnX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cbmZ1bmN0aW9uIGltYWdldGFnX2dldFByb3RvdHlwZU9mKG8pIHsgaW1hZ2V0YWdfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIGltYWdldGFnX2dldFByb3RvdHlwZU9mKG8pOyB9XG5mdW5jdGlvbiBpbWFnZXRhZ19pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBpbWFnZXRhZ19zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cbmZ1bmN0aW9uIGltYWdldGFnX3NldFByb3RvdHlwZU9mKG8sIHApIHsgaW1hZ2V0YWdfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIGltYWdldGFnX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG4vKipcbiAqIEltYWdlIFRhZ1xuICogRGVwZW5kcyBvbiAndGFncy9odG1sdGFnJywgJ2Nsb3VkaW5hcnknXG4gKi9cblxuXG5cblxuXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBIVE1MIChET00pIEltYWdlIHRhZyB1c2luZyBDbG91ZGluYXJ5IGFzIHRoZSBzb3VyY2UuXG4gKiBAY29uc3RydWN0b3IgSW1hZ2VUYWdcbiAqIEBleHRlbmRzIEh0bWxUYWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHVibGljSWRdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKi9cbnZhciBpbWFnZXRhZ19JbWFnZVRhZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0h0bWxUYWcpIHtcbiAgZnVuY3Rpb24gSW1hZ2VUYWcocHVibGljSWQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgaW1hZ2V0YWdfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW1hZ2VUYWcpO1xuICAgIHJldHVybiBpbWFnZXRhZ19jYWxsU3VwZXIodGhpcywgSW1hZ2VUYWcsIFtcImltZ1wiLCBwdWJsaWNJZCwgb3B0aW9uc10pO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBpbWFnZXRhZ19pbmhlcml0cyhJbWFnZVRhZywgX0h0bWxUYWcpO1xuICByZXR1cm4gaW1hZ2V0YWdfY3JlYXRlQ2xhc3MoSW1hZ2VUYWcsIFt7XG4gICAga2V5OiBcImNsb3NlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlVGFnKCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICB9LCB7XG4gICAga2V5OiBcImF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlcygpIHtcbiAgICAgIHZhciBhdHRyLCBvcHRpb25zLCBzcmNBdHRyaWJ1dGU7XG4gICAgICBhdHRyID0gaW1hZ2V0YWdfZ2V0KGltYWdldGFnX2dldFByb3RvdHlwZU9mKEltYWdlVGFnLnByb3RvdHlwZSksIFwiYXR0cmlidXRlc1wiLCB0aGlzKS5jYWxsKHRoaXMpIHx8IHt9O1xuICAgICAgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmdldE9wdGlvbignYXR0cmlidXRlcycpIHx8IHt9O1xuICAgICAgdmFyIHNyY3NldFBhcmFtID0gdGhpcy5nZXRPcHRpb24oJ3NyY3NldCcpIHx8IGF0dHJpYnV0ZXMuc3Jjc2V0O1xuICAgICAgdmFyIHJlc3BvbnNpdmVBdHRyaWJ1dGVzID0ge307XG4gICAgICBpZiAoaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0KCkoc3Jjc2V0UGFyYW0pKSB7XG4gICAgICAgIHJlc3BvbnNpdmVBdHRyaWJ1dGVzLnNyY3NldCA9IHNyY3NldFBhcmFtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzcG9uc2l2ZUF0dHJpYnV0ZXMgPSBnZW5lcmF0ZUltYWdlUmVzcG9uc2l2ZUF0dHJpYnV0ZXModGhpcy5wdWJsaWNJZCwgYXR0cmlidXRlcywgc3Jjc2V0UGFyYW0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0VtcHR5KHJlc3BvbnNpdmVBdHRyaWJ1dGVzKSkge1xuICAgICAgICBkZWxldGUgYXR0ci53aWR0aDtcbiAgICAgICAgZGVsZXRlIGF0dHIuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgbWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0KCkoYXR0ciwgcmVzcG9uc2l2ZUF0dHJpYnV0ZXMpO1xuICAgICAgc3JjQXR0cmlidXRlID0gb3B0aW9ucy5yZXNwb25zaXZlICYmICFvcHRpb25zLmNsaWVudF9oaW50cyA/ICdkYXRhLXNyYycgOiAnc3JjJztcbiAgICAgIGlmIChhdHRyW3NyY0F0dHJpYnV0ZV0gPT0gbnVsbCkge1xuICAgICAgICBhdHRyW3NyY0F0dHJpYnV0ZV0gPSB1cmxfdXJsKHRoaXMucHVibGljSWQsIHRoaXMuZ2V0T3B0aW9ucygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyO1xuICAgIH1cbiAgfV0pO1xufShodG1sdGFnKTtcbjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGltYWdldGFnID0gKGltYWdldGFnX0ltYWdlVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3RhZ3Mvc291cmNldGFnLmpzXG5mdW5jdGlvbiBzb3VyY2V0YWdfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gc291cmNldGFnX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBzb3VyY2V0YWdfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBzb3VyY2V0YWdfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gc291cmNldGFnX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBzb3VyY2V0YWdfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIHNvdXJjZXRhZ19jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIHNvdXJjZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgc291cmNldGFnX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBzb3VyY2V0YWdfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gc291cmNldGFnX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBzb3VyY2V0YWdfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBzb3VyY2V0YWdfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBzb3VyY2V0YWdfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IHNvdXJjZXRhZ190eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gc291cmNldGFnX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gc291cmNldGFnX2dldFByb3RvdHlwZU9mKG8pLCBzb3VyY2V0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBzb3VyY2V0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIHNvdXJjZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKHNvdXJjZXRhZ190eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gc291cmNldGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gc291cmNldGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBzb3VyY2V0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoc291cmNldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIHNvdXJjZXRhZ19nZXQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBzb3VyY2V0YWdfZ2V0ID0gUmVmbGVjdC5nZXQuYmluZCgpOyB9IGVsc2UgeyBzb3VyY2V0YWdfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IHNvdXJjZXRhZ19zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBzb3VyY2V0YWdfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIHNvdXJjZXRhZ19zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gc291cmNldGFnX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cbmZ1bmN0aW9uIHNvdXJjZXRhZ19nZXRQcm90b3R5cGVPZihvKSB7IHNvdXJjZXRhZ19nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gc291cmNldGFnX2dldFByb3RvdHlwZU9mKG8pOyB9XG5mdW5jdGlvbiBzb3VyY2V0YWdfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgc291cmNldGFnX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gc291cmNldGFnX3NldFByb3RvdHlwZU9mKG8sIHApIHsgc291cmNldGFnX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBzb3VyY2V0YWdfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbi8qKlxuICogSW1hZ2UgVGFnXG4gKiBEZXBlbmRzIG9uICd0YWdzL2h0bWx0YWcnLCAnY2xvdWRpbmFyeSdcbiAqL1xuXG5cblxuXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBIVE1MIChET00pIEltYWdlIHRhZyB1c2luZyBDbG91ZGluYXJ5IGFzIHRoZSBzb3VyY2UuXG4gKiBAY29uc3RydWN0b3IgU291cmNlVGFnXG4gKiBAZXh0ZW5kcyBIdG1sVGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gW3B1YmxpY0lkXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICovXG52YXIgc291cmNldGFnX1NvdXJjZVRhZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0h0bWxUYWcpIHtcbiAgZnVuY3Rpb24gU291cmNlVGFnKHB1YmxpY0lkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHNvdXJjZXRhZ19jbGFzc0NhbGxDaGVjayh0aGlzLCBTb3VyY2VUYWcpO1xuICAgIHJldHVybiBzb3VyY2V0YWdfY2FsbFN1cGVyKHRoaXMsIFNvdXJjZVRhZywgW1wic291cmNlXCIsIHB1YmxpY0lkLCBvcHRpb25zXSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIHNvdXJjZXRhZ19pbmhlcml0cyhTb3VyY2VUYWcsIF9IdG1sVGFnKTtcbiAgcmV0dXJuIHNvdXJjZXRhZ19jcmVhdGVDbGFzcyhTb3VyY2VUYWcsIFt7XG4gICAga2V5OiBcImNsb3NlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlVGFnKCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICB9LCB7XG4gICAga2V5OiBcImF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlcygpIHtcbiAgICAgIHZhciBzcmNzZXRQYXJhbSA9IHRoaXMuZ2V0T3B0aW9uKCdzcmNzZXQnKTtcbiAgICAgIHZhciBhdHRyID0gc291cmNldGFnX2dldChzb3VyY2V0YWdfZ2V0UHJvdG90eXBlT2YoU291cmNlVGFnLnByb3RvdHlwZSksIFwiYXR0cmlidXRlc1wiLCB0aGlzKS5jYWxsKHRoaXMpIHx8IHt9O1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgIG1lcmdlX3Jvb3RfbWVyZ2VfZGVmYXVsdCgpKGF0dHIsIGdlbmVyYXRlSW1hZ2VSZXNwb25zaXZlQXR0cmlidXRlcyh0aGlzLnB1YmxpY0lkLCBhdHRyLCBzcmNzZXRQYXJhbSwgb3B0aW9ucykpO1xuICAgICAgaWYgKCFhdHRyLnNyY3NldCkge1xuICAgICAgICBhdHRyLnNyY3NldCA9IHVybF91cmwodGhpcy5wdWJsaWNJZCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAoIWF0dHIubWVkaWEgJiYgb3B0aW9ucy5tZWRpYSkge1xuICAgICAgICBhdHRyLm1lZGlhID0gZ2VuZXJhdGVNZWRpYUF0dHIob3B0aW9ucy5tZWRpYSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cjtcbiAgICB9XG4gIH1dKTtcbn0oaHRtbHRhZyk7XG47XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzb3VyY2V0YWcgPSAoc291cmNldGFnX1NvdXJjZVRhZyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90YWdzL3BpY3R1cmV0YWcuanNcbmZ1bmN0aW9uIHBpY3R1cmV0YWdfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gcGljdHVyZXRhZ190eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgcGljdHVyZXRhZ190eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuZnVuY3Rpb24gcGljdHVyZXRhZ19kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcGljdHVyZXRhZ190b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gcGljdHVyZXRhZ19jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIHBpY3R1cmV0YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIHBpY3R1cmV0YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gcGljdHVyZXRhZ190b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gcGljdHVyZXRhZ190eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBwaWN0dXJldGFnX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBwaWN0dXJldGFnX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBwaWN0dXJldGFnX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gcGljdHVyZXRhZ19nZXRQcm90b3R5cGVPZihvKSwgcGljdHVyZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIHBpY3R1cmV0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBwaWN0dXJldGFnX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG5mdW5jdGlvbiBwaWN0dXJldGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAocGljdHVyZXRhZ190eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gcGljdHVyZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAocGljdHVyZXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBwaWN0dXJldGFnX2dldCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IHBpY3R1cmV0YWdfZ2V0ID0gUmVmbGVjdC5nZXQuYmluZCgpOyB9IGVsc2UgeyBwaWN0dXJldGFnX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBwaWN0dXJldGFnX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIHBpY3R1cmV0YWdfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IHBpY3R1cmV0YWdfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuZnVuY3Rpb24gcGljdHVyZXRhZ19nZXRQcm90b3R5cGVPZihvKSB7IHBpY3R1cmV0YWdfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIHBpY3R1cmV0YWdfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgcGljdHVyZXRhZ19zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cbmZ1bmN0aW9uIHBpY3R1cmV0YWdfc2V0UHJvdG90eXBlT2YobywgcCkgeyBwaWN0dXJldGFnX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBwaWN0dXJldGFnX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cblxuXG5cblxudmFyIHBpY3R1cmV0YWdfUGljdHVyZVRhZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0h0bWxUYWcpIHtcbiAgZnVuY3Rpb24gUGljdHVyZVRhZyhwdWJsaWNJZCkge1xuICAgIHZhciBfdGhpcztcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHNvdXJjZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuICAgIHBpY3R1cmV0YWdfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGljdHVyZVRhZyk7XG4gICAgX3RoaXMgPSBwaWN0dXJldGFnX2NhbGxTdXBlcih0aGlzLCBQaWN0dXJlVGFnLCBbJ3BpY3R1cmUnLCBwdWJsaWNJZCwgb3B0aW9uc10pO1xuICAgIF90aGlzLndpZHRoTGlzdCA9IHNvdXJjZXM7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBwaWN0dXJldGFnX2luaGVyaXRzKFBpY3R1cmVUYWcsIF9IdG1sVGFnKTtcbiAgcmV0dXJuIHBpY3R1cmV0YWdfY3JlYXRlQ2xhc3MoUGljdHVyZVRhZywgW3tcbiAgICBrZXk6IFwiY29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb250ZW50KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aExpc3QubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBtaW5fd2lkdGggPSBfcmVmLm1pbl93aWR0aCxcbiAgICAgICAgICBtYXhfd2lkdGggPSBfcmVmLm1heF93aWR0aCxcbiAgICAgICAgICB0cmFuc2Zvcm1hdGlvbiA9IF9yZWYudHJhbnNmb3JtYXRpb247XG4gICAgICAgIHZhciBvcHRpb25zID0gX3RoaXMyLmdldE9wdGlvbnMoKTtcbiAgICAgICAgdmFyIHNvdXJjZVRyYW5zZm9ybWF0aW9uID0gbmV3IHNyY190cmFuc2Zvcm1hdGlvbihvcHRpb25zKTtcbiAgICAgICAgc291cmNlVHJhbnNmb3JtYXRpb24uY2hhaW4oKS5mcm9tT3B0aW9ucyh0eXBlb2YgdHJhbnNmb3JtYXRpb24gPT09ICdzdHJpbmcnID8ge1xuICAgICAgICAgIHJhd190cmFuc2Zvcm1hdGlvbjogdHJhbnNmb3JtYXRpb25cbiAgICAgICAgfSA6IHRyYW5zZm9ybWF0aW9uKTtcbiAgICAgICAgb3B0aW9ucyA9IGV4dHJhY3RVcmxQYXJhbXMob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMubWVkaWEgPSB7XG4gICAgICAgICAgbWluX3dpZHRoOiBtaW5fd2lkdGgsXG4gICAgICAgICAgbWF4X3dpZHRoOiBtYXhfd2lkdGhcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy50cmFuc2Zvcm1hdGlvbiA9IHNvdXJjZVRyYW5zZm9ybWF0aW9uO1xuICAgICAgICByZXR1cm4gbmV3IHNvdXJjZXRhZyhfdGhpczIucHVibGljSWQsIG9wdGlvbnMpLnRvSHRtbCgpO1xuICAgICAgfSkuam9pbignJykgKyBuZXcgaW1hZ2V0YWcodGhpcy5wdWJsaWNJZCwgdGhpcy5nZXRPcHRpb25zKCkpLnRvSHRtbCgpO1xuICAgIH1cblxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgfSwge1xuICAgIGtleTogXCJhdHRyaWJ1dGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZXMoKSB7XG4gICAgICB2YXIgYXR0ciA9IHBpY3R1cmV0YWdfZ2V0KHBpY3R1cmV0YWdfZ2V0UHJvdG90eXBlT2YoUGljdHVyZVRhZy5wcm90b3R5cGUpLCBcImF0dHJpYnV0ZXNcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIGRlbGV0ZSBhdHRyLndpZHRoO1xuICAgICAgZGVsZXRlIGF0dHIuaGVpZ2h0O1xuICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfVxuXG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsb3NlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlVGFnKCkge1xuICAgICAgcmV0dXJuIFwiPC9cIiArIHRoaXMubmFtZSArIFwiPlwiO1xuICAgIH1cbiAgfV0pO1xufShodG1sdGFnKTtcbjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHBpY3R1cmV0YWcgPSAocGljdHVyZXRhZ19QaWN0dXJlVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3RhZ3MvdmlkZW90YWcuanNcbmZ1bmN0aW9uIHZpZGVvdGFnX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIHZpZGVvdGFnX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCB2aWRlb3RhZ190eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIHZpZGVvdGFnX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIHZpZGVvdGFnX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCB2aWRlb3RhZ190b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gdmlkZW90YWdfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSB2aWRlb3RhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgdmlkZW90YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIHZpZGVvdGFnX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IHZpZGVvdGFnX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSB2aWRlb3RhZ190eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIHZpZGVvdGFnX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gdmlkZW90YWdfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IHZpZGVvdGFnX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiB2aWRlb3RhZ19jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IHZpZGVvdGFnX2dldFByb3RvdHlwZU9mKG8pLCB2aWRlb3RhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIHZpZGVvdGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgdmlkZW90YWdfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIHZpZGVvdGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAodmlkZW90YWdfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIHZpZGVvdGFnX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gdmlkZW90YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIHZpZGVvdGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKHZpZGVvdGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIHZpZGVvdGFnX2dldCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IHZpZGVvdGFnX2dldCA9IFJlZmxlY3QuZ2V0LmJpbmQoKTsgfSBlbHNlIHsgdmlkZW90YWdfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IHZpZGVvdGFnX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIHZpZGVvdGFnX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiB2aWRlb3RhZ19zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gdmlkZW90YWdfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuZnVuY3Rpb24gdmlkZW90YWdfZ2V0UHJvdG90eXBlT2YobykgeyB2aWRlb3RhZ19nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gdmlkZW90YWdfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIHZpZGVvdGFnX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIHZpZGVvdGFnX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gdmlkZW90YWdfc2V0UHJvdG90eXBlT2YobywgcCkgeyB2aWRlb3RhZ19zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gdmlkZW90YWdfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbi8qKlxuICogVmlkZW8gVGFnXG4gKiBEZXBlbmRzIG9uICd0YWdzL2h0bWx0YWcnLCAndXRpbCcsICdjbG91ZGluYXJ5J1xuICovXG5cblxuXG5cblxudmFyIFZJREVPX1RBR19QQVJBTVMgPSBbJ3NvdXJjZV90eXBlcycsICdzb3VyY2VfdHJhbnNmb3JtYXRpb24nLCAnZmFsbGJhY2tfY29udGVudCcsICdwb3N0ZXInLCAnc291cmNlcyddO1xudmFyIHZpZGVvdGFnX0RFRkFVTFRfVklERU9fU09VUkNFX1RZUEVTID0gWyd3ZWJtJywgJ21wNCcsICdvZ3YnXTtcbnZhciB2aWRlb3RhZ19ERUZBVUxUX1BPU1RFUl9PUFRJT05TID0ge1xuICBmb3JtYXQ6ICdqcGcnLFxuICByZXNvdXJjZV90eXBlOiAndmlkZW8nXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gSFRNTCAoRE9NKSBWaWRlbyB0YWcgdXNpbmcgQ2xvdWRpbmFyeSBhcyB0aGUgc291cmNlLlxuICogQGNvbnN0cnVjdG9yIFZpZGVvVGFnXG4gKiBAZXh0ZW5kcyBIdG1sVGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gW3B1YmxpY0lkXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICovXG52YXIgdmlkZW90YWdfVmlkZW9UYWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9IdG1sVGFnKSB7XG4gIGZ1bmN0aW9uIFZpZGVvVGFnKHB1YmxpY0lkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZpZGVvdGFnX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZGVvVGFnKTtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMoe30sIG9wdGlvbnMsIERFRkFVTFRfVklERU9fUEFSQU1TKTtcbiAgICByZXR1cm4gdmlkZW90YWdfY2FsbFN1cGVyKHRoaXMsIFZpZGVvVGFnLCBbXCJ2aWRlb1wiLCBwdWJsaWNJZC5yZXBsYWNlKC9cXC4obXA0fG9ndnx3ZWJtKSQvLCAnJyksIG9wdGlvbnNdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRyYW5zZm9ybWF0aW9uIHRvIGFwcGx5IG9uIGVhY2ggc291cmNlXG4gICAqIEBmdW5jdGlvbiBWaWRlb1RhZyNzZXRTb3VyY2VUcmFuc2Zvcm1hdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gYW4gb2JqZWN0IHdpdGggcGFpcnMgb2Ygc291cmNlIHR5cGUgYW5kIHNvdXJjZSB0cmFuc2Zvcm1hdGlvblxuICAgKiBAcmV0dXJucyB7VmlkZW9UYWd9IFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmcgcHVycG9zZXMuXG4gICAqL1xuICB2aWRlb3RhZ19pbmhlcml0cyhWaWRlb1RhZywgX0h0bWxUYWcpO1xuICByZXR1cm4gdmlkZW90YWdfY3JlYXRlQ2xhc3MoVmlkZW9UYWcsIFt7XG4gICAga2V5OiBcInNldFNvdXJjZVRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNvdXJjZVRyYW5zZm9ybWF0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybWF0aW9uKCkuc291cmNlVHJhbnNmb3JtYXRpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzb3VyY2UgdHlwZXMgdG8gaW5jbHVkZSBpbiB0aGUgdmlkZW8gdGFnXG4gICAgICogQGZ1bmN0aW9uIFZpZGVvVGFnI3NldFNvdXJjZVR5cGVzXG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhbiBhcnJheSBvZiBzb3VyY2UgdHlwZXNcbiAgICAgKiBAcmV0dXJucyB7VmlkZW9UYWd9IFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmcgcHVycG9zZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U291cmNlVHlwZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U291cmNlVHlwZXModmFsdWUpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtYXRpb24oKS5zb3VyY2VUeXBlcyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBvc3RlciB0byBiZSB1c2VkIGluIHRoZSB2aWRlbyB0YWdcbiAgICAgKiBAZnVuY3Rpb24gVmlkZW9UYWcjc2V0UG9zdGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSB2YWx1ZVxuICAgICAqIC0gc3RyaW5nOiBhIFVSTCB0byB1c2UgZm9yIHRoZSBwb3N0ZXJcbiAgICAgKiAtIE9iamVjdDogdHJhbnNmb3JtYXRpb24gcGFyYW1ldGVycyB0byBhcHBseSB0byB0aGUgcG9zdGVyLiBNYXkgb3B0aW9uYWxseSBpbmNsdWRlIGEgcHVibGljX2lkIHRvIHVzZSBpbnN0ZWFkIG9mIHRoZSB2aWRlbyBwdWJsaWNfaWQuXG4gICAgICogQHJldHVybnMge1ZpZGVvVGFnfSBSZXR1cm5zIHRoaXMgaW5zdGFuY2UgZm9yIGNoYWluaW5nIHB1cnBvc2VzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFBvc3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3N0ZXIodmFsdWUpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtYXRpb24oKS5wb3N0ZXIodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjb250ZW50IHRvIHVzZSBhcyBmYWxsYmFjayBpbiB0aGUgdmlkZW8gdGFnXG4gICAgICogQGZ1bmN0aW9uIFZpZGVvVGFnI3NldEZhbGxiYWNrQ29udGVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSBjb250ZW50IHRvIHVzZSwgaW4gSFRNTCBmb3JtYXRcbiAgICAgKiBAcmV0dXJucyB7VmlkZW9UYWd9IFJldHVybnMgdGhpcyBpbnN0YW5jZSBmb3IgY2hhaW5pbmcgcHVycG9zZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RmFsbGJhY2tDb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZhbGxiYWNrQ29udGVudCh2YWx1ZSkge1xuICAgICAgdGhpcy50cmFuc2Zvcm1hdGlvbigpLmZhbGxiYWNrQ29udGVudCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb250ZW50KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBzb3VyY2VUeXBlcyA9IHRoaXMudHJhbnNmb3JtYXRpb24oKS5nZXRWYWx1ZSgnc291cmNlX3R5cGVzJyk7XG4gICAgICB2YXIgc291cmNlVHJhbnNmb3JtYXRpb24gPSB0aGlzLnRyYW5zZm9ybWF0aW9uKCkuZ2V0VmFsdWUoJ3NvdXJjZV90cmFuc2Zvcm1hdGlvbicpO1xuICAgICAgdmFyIGZhbGxiYWNrID0gdGhpcy50cmFuc2Zvcm1hdGlvbigpLmdldFZhbHVlKCdmYWxsYmFja19jb250ZW50Jyk7XG4gICAgICB2YXIgc291cmNlcyA9IHRoaXMuZ2V0T3B0aW9uKCdzb3VyY2VzJyk7XG4gICAgICB2YXIgaW5uZXJUYWdzID0gW107XG4gICAgICBpZiAoaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHNvdXJjZXMpICYmICFpc0VtcHR5KHNvdXJjZXMpKSB7XG4gICAgICAgIGlubmVyVGFncyA9IHNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICB2YXIgc3JjID0gdXJsX3VybChfdGhpcy5wdWJsaWNJZCwgZGVmYXVsdHMoe30sIHNvdXJjZS50cmFuc2Zvcm1hdGlvbnMgfHwge30sIHtcbiAgICAgICAgICAgIHJlc291cmNlX3R5cGU6ICd2aWRlbycsXG4gICAgICAgICAgICBmb3JtYXQ6IHNvdXJjZS50eXBlXG4gICAgICAgICAgfSksIF90aGlzLmdldE9wdGlvbnMoKSk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmNyZWF0ZVNvdXJjZVRhZyhzcmMsIHNvdXJjZS50eXBlLCBzb3VyY2UuY29kZWNzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNFbXB0eShzb3VyY2VUeXBlcykpIHtcbiAgICAgICAgICBzb3VyY2VUeXBlcyA9IHZpZGVvdGFnX0RFRkFVTFRfVklERU9fU09VUkNFX1RZUEVTO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkoc291cmNlVHlwZXMpKSB7XG4gICAgICAgICAgaW5uZXJUYWdzID0gc291cmNlVHlwZXMubWFwKGZ1bmN0aW9uIChzcmNUeXBlKSB7XG4gICAgICAgICAgICB2YXIgc3JjID0gdXJsX3VybChfdGhpcy5wdWJsaWNJZCwgZGVmYXVsdHMoe30sIHNvdXJjZVRyYW5zZm9ybWF0aW9uW3NyY1R5cGVdIHx8IHt9LCB7XG4gICAgICAgICAgICAgIHJlc291cmNlX3R5cGU6ICd2aWRlbycsXG4gICAgICAgICAgICAgIGZvcm1hdDogc3JjVHlwZVxuICAgICAgICAgICAgfSksIF90aGlzLmdldE9wdGlvbnMoKSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY3JlYXRlU291cmNlVGFnKHNyYywgc3JjVHlwZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpbm5lclRhZ3Muam9pbignJykgKyBmYWxsYmFjaztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXR0cmlidXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVzKCkge1xuICAgICAgdmFyIHNvdXJjZVR5cGVzID0gdGhpcy5nZXRPcHRpb24oJ3NvdXJjZV90eXBlcycpO1xuICAgICAgdmFyIHBvc3RlciA9IHRoaXMuZ2V0T3B0aW9uKCdwb3N0ZXInKTtcbiAgICAgIGlmIChwb3N0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb3N0ZXIgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0KCkocG9zdGVyKSkge1xuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSBwb3N0ZXIucHVibGljX2lkICE9IG51bGwgPyBERUZBVUxUX0lNQUdFX1BBUkFNUyA6IHZpZGVvdGFnX0RFRkFVTFRfUE9TVEVSX09QVElPTlM7XG4gICAgICAgIHBvc3RlciA9IHVybF91cmwocG9zdGVyLnB1YmxpY19pZCB8fCB0aGlzLnB1YmxpY0lkLCBkZWZhdWx0cyh7fSwgcG9zdGVyLCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpKTtcbiAgICAgIH1cbiAgICAgIHZhciBhdHRyID0gdmlkZW90YWdfZ2V0KHZpZGVvdGFnX2dldFByb3RvdHlwZU9mKFZpZGVvVGFnLnByb3RvdHlwZSksIFwiYXR0cmlidXRlc1wiLCB0aGlzKS5jYWxsKHRoaXMpIHx8IHt9O1xuICAgICAgYXR0ciA9IG9taXQoYXR0ciwgVklERU9fVEFHX1BBUkFNUyk7XG4gICAgICB2YXIgc291cmNlcyA9IHRoaXMuZ2V0T3B0aW9uKCdzb3VyY2VzJyk7XG4gICAgICAvLyBJbiBjYXNlIG9mIGVtcHR5IHNvdXJjZVR5cGVzIC0gZmFsbGJhY2sgdG8gZGVmYXVsdCBzb3VyY2UgdHlwZXMgaXMgdXNlZC5cbiAgICAgIHZhciBoYXNTb3VyY2VUYWdzID0gIWlzRW1wdHkoc291cmNlcykgfHwgaXNFbXB0eShzb3VyY2VUeXBlcykgfHwgaXNBcnJheV9yb290X2lzQXJyYXlfZGVmYXVsdCgpKHNvdXJjZVR5cGVzKTtcbiAgICAgIGlmICghaGFzU291cmNlVGFncykge1xuICAgICAgICBhdHRyW1wic3JjXCJdID0gdXJsX3VybCh0aGlzLnB1YmxpY0lkLCB0aGlzLmdldE9wdGlvbnMoKSwge1xuICAgICAgICAgIHJlc291cmNlX3R5cGU6ICd2aWRlbycsXG4gICAgICAgICAgZm9ybWF0OiBzb3VyY2VUeXBlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChwb3N0ZXIgIT0gbnVsbCkge1xuICAgICAgICBhdHRyW1wicG9zdGVyXCJdID0gcG9zdGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVNvdXJjZVRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTb3VyY2VUYWcoc3JjLCBzb3VyY2VUeXBlKSB7XG4gICAgICB2YXIgY29kZWNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgICAgdmFyIG1pbWVUeXBlID0gbnVsbDtcbiAgICAgIGlmICghaXNFbXB0eShzb3VyY2VUeXBlKSkge1xuICAgICAgICB2YXIgdmlkZW9UeXBlID0gc291cmNlVHlwZSA9PT0gJ29ndicgPyAnb2dnJyA6IHNvdXJjZVR5cGU7XG4gICAgICAgIG1pbWVUeXBlID0gJ3ZpZGVvLycgKyB2aWRlb1R5cGU7XG4gICAgICAgIGlmICghaXNFbXB0eShjb2RlY3MpKSB7XG4gICAgICAgICAgdmFyIGNvZGVjc1N0ciA9IGlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQoKShjb2RlY3MpID8gY29kZWNzLmpvaW4oJywgJykgOiBjb2RlY3M7XG4gICAgICAgICAgbWltZVR5cGUgKz0gJzsgY29kZWNzPScgKyBjb2RlY3NTdHI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBcIjxzb3VyY2UgXCIgKyB0aGlzLmh0bWxBdHRycyh7XG4gICAgICAgIHNyYzogc3JjLFxuICAgICAgICB0eXBlOiBtaW1lVHlwZVxuICAgICAgfSkgKyBcIj5cIjtcbiAgICB9XG4gIH1dKTtcbn0oaHRtbHRhZyk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB2aWRlb3RhZyA9ICh2aWRlb3RhZ19WaWRlb1RhZyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90YWdzL2NsaWVudGhpbnRzbWV0YXRhZy5qc1xuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIGNsaWVudGhpbnRzbWV0YXRhZ190eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgY2xpZW50aGludHNtZXRhdGFnX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY2xpZW50aGludHNtZXRhdGFnX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBjbGllbnRoaW50c21ldGF0YWdfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGNsaWVudGhpbnRzbWV0YXRhZ19kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IGNsaWVudGhpbnRzbWV0YXRhZ190b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gY2xpZW50aGludHNtZXRhdGFnX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gY2xpZW50aGludHNtZXRhdGFnX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBjbGllbnRoaW50c21ldGF0YWdfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IGNsaWVudGhpbnRzbWV0YXRhZ19nZXRQcm90b3R5cGVPZihvKSwgY2xpZW50aGludHNtZXRhdGFnX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgY2xpZW50aGludHNtZXRhdGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgY2xpZW50aGludHNtZXRhdGFnX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChjbGllbnRoaW50c21ldGF0YWdfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIGNsaWVudGhpbnRzbWV0YXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgdHJ5IHsgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyB9IGNhdGNoICh0KSB7fSByZXR1cm4gKGNsaWVudGhpbnRzbWV0YXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyByZXR1cm4gISF0OyB9KSgpOyB9XG5mdW5jdGlvbiBjbGllbnRoaW50c21ldGF0YWdfZ2V0UHJvdG90eXBlT2YobykgeyBjbGllbnRoaW50c21ldGF0YWdfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIGNsaWVudGhpbnRzbWV0YXRhZ19nZXRQcm90b3R5cGVPZihvKTsgfVxuZnVuY3Rpb24gY2xpZW50aGludHNtZXRhdGFnX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIGNsaWVudGhpbnRzbWV0YXRhZ19zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cbmZ1bmN0aW9uIGNsaWVudGhpbnRzbWV0YXRhZ19zZXRQcm90b3R5cGVPZihvLCBwKSB7IGNsaWVudGhpbnRzbWV0YXRhZ19zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gY2xpZW50aGludHNtZXRhdGFnX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG4vKipcbiAqIEltYWdlIFRhZ1xuICogRGVwZW5kcyBvbiAndGFncy9odG1sdGFnJywgJ2Nsb3VkaW5hcnknXG4gKi9cblxuXG5cblxuLyoqXG4gKiBDcmVhdGVzIGFuIEhUTUwgKERPTSkgTWV0YSB0YWcgdGhhdCBlbmFibGVzIENsaWVudC1IaW50cyBmb3IgdGhlIEhUTUwgcGFnZS4gPGJyLz5cbiAqICBTZWVcbiAqICA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3Jlc3BvbnNpdmVfaW1hZ2VzI2F1dG9tYXRpbmdfcmVzcG9uc2l2ZV9pbWFnZXNfd2l0aF9jbGllbnRfaGludHNcIlxuICogIHRhcmdldD1cIl9uZXdcIj5BdXRvbWF0aW5nIHJlc3BvbnNpdmUgaW1hZ2VzIHdpdGggQ2xpZW50IEhpbnRzPC9hPiBmb3IgbW9yZSBkZXRhaWxzLlxuICogQGNvbnN0cnVjdG9yIENsaWVudEhpbnRzTWV0YVRhZ1xuICogQGV4dGVuZHMgSHRtbFRhZ1xuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBleGFtcGxlXG4gKiB0YWcgPSBuZXcgQ2xpZW50SGludHNNZXRhVGFnKClcbiAqIC8vcmV0dXJuczogPG1ldGEgaHR0cC1lcXVpdj1cIkFjY2VwdC1DSFwiIGNvbnRlbnQ9XCJEUFIsIFZpZXdwb3J0LVdpZHRoLCBXaWR0aFwiPlxuICovXG52YXIgY2xpZW50aGludHNtZXRhdGFnX0NsaWVudEhpbnRzTWV0YVRhZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0h0bWxUYWcpIHtcbiAgZnVuY3Rpb24gQ2xpZW50SGludHNNZXRhVGFnKG9wdGlvbnMpIHtcbiAgICBjbGllbnRoaW50c21ldGF0YWdfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xpZW50SGludHNNZXRhVGFnKTtcbiAgICByZXR1cm4gY2xpZW50aGludHNtZXRhdGFnX2NhbGxTdXBlcih0aGlzLCBDbGllbnRIaW50c01ldGFUYWcsIFsnbWV0YScsIHZvaWQgMCwgYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICBcImh0dHAtZXF1aXZcIjogXCJBY2NlcHQtQ0hcIixcbiAgICAgIGNvbnRlbnQ6IFwiRFBSLCBWaWV3cG9ydC1XaWR0aCwgV2lkdGhcIlxuICAgIH0sIG9wdGlvbnMpXSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGNsaWVudGhpbnRzbWV0YXRhZ19pbmhlcml0cyhDbGllbnRIaW50c01ldGFUYWcsIF9IdG1sVGFnKTtcbiAgcmV0dXJuIGNsaWVudGhpbnRzbWV0YXRhZ19jcmVhdGVDbGFzcyhDbGllbnRIaW50c01ldGFUYWcsIFt7XG4gICAga2V5OiBcImNsb3NlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlVGFnKCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICB9XSk7XG59KGh0bWx0YWcpO1xuO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2xpZW50aGludHNtZXRhdGFnID0gKGNsaWVudGhpbnRzbWV0YXRhZ19DbGllbnRIaW50c01ldGFUYWcpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9wYXJzZS9ub3JtYWxpemVUb0FycmF5LmpzXG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5X3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gbm9ybWFsaXplVG9BcnJheV9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IG5vcm1hbGl6ZVRvQXJyYXlfaXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9ybWFsaXplVG9BcnJheV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vcm1hbGl6ZVRvQXJyYXlfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheV9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvQXJyYXlfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBub3JtYWxpemVUb0FycmF5X2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBub3JtYWxpemVUb0FycmF5X2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheV9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheV9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIG5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5X2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cblxuXG4vKipcbiAqIEBkZXNjIG5vcm1hbGl6ZSBlbGVtZW50cywgc3VwcG9ydCBhIHNpbmdsZSBlbGVtZW50LCBhcnJheSBvciBub2RlbGlzdCwgYWx3YXlzIG91dHB1dHMgYXJyYXlcbiAqIEBwYXJhbSBlbGVtZW50czxIVE1MRWxlbWVudFtdPlxuICogQHJldHVybnMge1tdfVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVUb0FycmF5KGVsZW1lbnRzKSB7XG4gIGlmIChpc0FycmF5X3Jvb3RfaXNBcnJheV9kZWZhdWx0KCkoZWxlbWVudHMpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9IGVsc2UgaWYgKGVsZW1lbnRzLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiTm9kZUxpc3RcIikge1xuICAgIHJldHVybiBub3JtYWxpemVUb0FycmF5X3RvQ29uc3VtYWJsZUFycmF5KGVsZW1lbnRzKTsgLy8gZW5zdXJlIGFuIGFycmF5IGlzIGFsd2F5cyByZXR1cm5lZCwgZXZlbiBpZiBub2RlbGlzdFxuICB9IGVsc2UgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKGVsZW1lbnRzKSkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnRzKSwgMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtlbGVtZW50c107XG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvZmVhdHVyZXMvdHJhbnNwYXJlbnRWaWRlby9tb3VudENsb3VkaW5hcnlWaWRlb1RhZy5qc1xuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBodG1sRWxDb250YWluZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBjbEluc3RhbmNlIGNsb3VkaW5hcnkgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUcmFuc2Zvcm1hdGlvbk9wdGlvbnNcbiAqIEByZXR1cm5zIFByb21pc2U8SFRNTEVsZW1lbnQ+XG4gKi9cbmZ1bmN0aW9uIG1vdW50Q2xvdWRpbmFyeVZpZGVvVGFnKGh0bWxFbENvbnRhaW5lciwgY2xJbnN0YW5jZSwgcHVibGljSWQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBodG1sRWxDb250YWluZXIuaW5uZXJIVE1MID0gY2xJbnN0YW5jZS52aWRlb1RhZyhwdWJsaWNJZCwgb3B0aW9ucykudG9IdG1sKCk7XG5cbiAgICAvLyBBbGwgdmlkZW9zIHVuZGVyIHRoZSBodG1sIGNvbnRhaW5lciBtdXN0IGhhdmUgYSB3aWR0aCBvZiAxMDAlLCBvciB0aGV5IG1pZ2h0IG92ZXJmbG93IGZyb20gdGhlIGNvbnRhaW5lclxuICAgIHZhciBjbG91ZGluYXJ5VmlkZW9FbGVtZW50ID0gaHRtbEVsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5jbGQtdHJhbnNwYXJlbnQtdmlkZW8nKTtcbiAgICBjbG91ZGluYXJ5VmlkZW9FbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHJlc29sdmUoaHRtbEVsQ29udGFpbmVyKTtcbiAgfSk7XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BhcmVudFZpZGVvX21vdW50Q2xvdWRpbmFyeVZpZGVvVGFnID0gKG1vdW50Q2xvdWRpbmFyeVZpZGVvVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvdHJhbnNmb3JtYXRpb25zL2FkZEZsYWcuanNcbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gRnVuY3Rpb24gd2lsbCBwdXNoIGEgZmxhZyB0byBpbmNvbWluZyBvcHRpb25zXG4gKiBAcGFyYW0ge3t0cmFuc2Zvcm1hdGlvbn0gfCB7Li4udHJhbnNmb3JtYXRpb259fSBvcHRpb25zIC0gVGhlc2Ugb3B0aW9ucyBhcmUgdGhlIHNhbWUgb3B0aW9ucyBwcm92aWRlZCB0byBhbGwgb3VyIFNESyBtZXRob2RzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFdlIGV4cGVjdCBvcHRpb25zIHRvIGVpdGhlciBiZSB0aGUgdHJhbnNmb3JtYXRpb24gaXRzZWxmLCBvciBhbiBvYmplY3QgY29udGFpbmluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICBhbiBhcnJheSBvZiB0cmFuc2Zvcm1hdGlvbnNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmxhZ1xuICogQHJldHVybnMgdGhlIG11dGF0ZWQgb3B0aW9ucyBvYmplY3RcbiAqL1xuXG5mdW5jdGlvbiBhZGRGbGFnVG9PcHRpb25zKG9wdGlvbnMsIGZsYWcpIHtcbiAgLy8gRG8gd2UgaGF2ZSB0cmFuc2Zvcm1hdGlvblxuICBpZiAob3B0aW9ucy50cmFuc2Zvcm1hdGlvbikge1xuICAgIG9wdGlvbnMudHJhbnNmb3JtYXRpb24ucHVzaCh7XG4gICAgICBmbGFnczogW2ZsYWddXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm8gdHJhbnNmb3JtYXRpb25cbiAgICAvLyBlbnN1cmUgdGhlIGZsYWdzIGFyZSBleHRlbmRlZFxuICAgIGlmICghb3B0aW9ucy5mbGFncykge1xuICAgICAgb3B0aW9ucy5mbGFncyA9IFtdO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmxhZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRpb25zLmZsYWdzID0gW29wdGlvbnMuZmxhZ3NdO1xuICAgIH1cbiAgICBvcHRpb25zLmZsYWdzLnB1c2goZmxhZyk7XG4gIH1cbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGFkZEZsYWcgPSAoYWRkRmxhZ1RvT3B0aW9ucyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2ZlYXR1cmVzL3RyYW5zcGFyZW50VmlkZW8vZW5mb3JjZU9wdGlvbnNGb3JUcmFuc3BhcmVudFZpZGVvLmpzXG5cblxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiAtIEVuZm9yY2Ugb3B0aW9uIHN0cnVjdHVyZSwgc2V0cyBkZWZhdWx0cyBhbmQgZW5zdXJlcyBhbHBoYSBmbGFnIGV4aXN0c1xuICogQHBhcmFtIG9wdGlvbnMge1RyYW5zZm9ybWF0aW9uT3B0aW9uc31cbiAqL1xuZnVuY3Rpb24gZW5mb3JjZU9wdGlvbnNGb3JUcmFuc3BhcmVudFZpZGVvKG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5hdXRvcGxheSA9IHRydWU7XG4gIG9wdGlvbnMubXV0ZWQgPSB0cnVlO1xuICBvcHRpb25zLmNvbnRyb2xzID0gZmFsc2U7XG4gIG9wdGlvbnMubWF4X3RpbWVvdXRfbXMgPSBvcHRpb25zLm1heF90aW1lb3V0X21zIHx8IERFRkFVTFRfVElNRU9VVF9NUztcbiAgb3B0aW9uc1tcImNsYXNzXCJdID0gb3B0aW9uc1tcImNsYXNzXCJdIHx8ICcnO1xuICBvcHRpb25zW1wiY2xhc3NcIl0gKz0gJyBjbGQtdHJhbnNwYXJlbnQtdmlkZW8nO1xuICBvcHRpb25zLmV4dGVybmFsTGlicmFyaWVzID0gb3B0aW9ucy5leHRlcm5hbExpYnJhcmllcyB8fCB7fTtcbiAgaWYgKCFvcHRpb25zLmV4dGVybmFsTGlicmFyaWVzLnNlZVRocnUpIHtcbiAgICBvcHRpb25zLmV4dGVybmFsTGlicmFyaWVzLnNlZVRocnUgPSBERUZBVUxUX0VYVEVSTkFMX0xJQlJBUklFUy5zZWVUaHJ1O1xuICB9XG5cbiAgLy8gZW5zdXJlIHRoZXJlJ3MgYW4gYWxwaGEgdHJhbnNmb3JtYXRpb24gcHJlc2VudFxuICAvLyB0aGlzIGlzIGEgbm9uIGRvY3VtZW50ZWQgaW50ZXJuYWwgZmxhZ1xuICBhZGRGbGFnKG9wdGlvbnMsICdhbHBoYScpO1xufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwYXJlbnRWaWRlb19lbmZvcmNlT3B0aW9uc0ZvclRyYW5zcGFyZW50VmlkZW8gPSAoZW5mb3JjZU9wdGlvbnNGb3JUcmFuc3BhcmVudFZpZGVvKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwveGhyL2xvYWRTY3JpcHQuanNcbi8qKlxuICogQGRlc2NyaXB0aW9uIC0gR2l2ZW4gYSBzdHJpbmcgVVJMLCB0aGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCB0aGUgc2NyaXB0IGFuZCByZXNvbHZlIHRoZSBwcm9taXNlLlxuICogICAgICAgICAgICAgICAgVGhlIGZ1bmN0aW9uIGRvZXNuJ3QgcmVzb2x2ZSBhbnkgdmFsdWUsXG4gKiAgICAgICAgICAgICAgICB0aGlzIGlzIG5vdCBhIFVNRCBsb2FkZXIgd2hlcmUgeW91IGNhbiBnZXQgeW91ciBsaWJyYXJ5IG5hbWUgYmFjay5cbiAqIEBwYXJhbSBzY3JpcHRVUkwge3N0cmluZ31cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhfdGltZW91dF9tcyAtIFRpbWUgdG8gZWxhcHNlIGJlZm9yZSBwcm9taXNlIGlzIHJlamVjdGVkXG4gKiBAcGFyYW0gaXNBbHJlYWR5TG9hZGVkIHtib29sZWFufSBpZiB0cnVlLCB0aGUgbG9hZFNjcmlwdCByZXNvbHZlcyBpbW1lZGlhdGVseVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBpcyB1c2VkIGZvciBtdWx0aXBsZSBpbnZvY2F0aW9ucyAtIHByZXZlbnRzIHRoZSBzY3JpcHQgZnJvbSBiZWluZyBsb2FkZWQgbXVsdGlwbGUgdGltZXNcbiAqIEByZXR1cm4ge1Byb21pc2U8YW55IHwge3N0YXR1czpzdHJpbmcsIG1lc3NhZ2U6c3RyaW5nfT59XG4gKi9cbmZ1bmN0aW9uIGxvYWRTY3JpcHQoc2NyaXB0VVJMLCBtYXhfdGltZW91dF9tcywgaXNBbHJlYWR5TG9hZGVkKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKGlzQWxyZWFkeUxvYWRlZCkge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2NyaXB0VGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHRUYWcuc3JjID0gc2NyaXB0VVJMO1xuICAgICAgdmFyIHRpbWVySUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogXCJUaW1lb3V0IGxvYWRpbmcgc2NyaXB0IFwiLmNvbmNhdChzY3JpcHRVUkwpXG4gICAgICAgIH0pO1xuICAgICAgfSwgbWF4X3RpbWVvdXRfbXMpOyAvLyAxMCBzZWNvbmRzIGZvciB0aW1lb3V0XG5cbiAgICAgIHNjcmlwdFRhZy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJRCk7IC8vIGNsZWFyIHRpbWVvdXQgcmVqZWN0IGVycm9yXG4gICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgIG1lc3NhZ2U6IFwiRXJyb3IgbG9hZGluZyBcIi5jb25jYXQoc2NyaXB0VVJMKVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBzY3JpcHRUYWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJRCk7IC8vIGNsZWFyIHRpbWVvdXQgcmVqZWN0IGVycm9yXG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdFRhZyk7XG4gICAgfVxuICB9KTtcbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHhocl9sb2FkU2NyaXB0ID0gKGxvYWRTY3JpcHQpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC94aHIvZ2V0QmxvYkZyb21VUkwuanNcbi8qKlxuICogUmVqZWN0IG9uIHRpbWVvdXRcbiAqIEBwYXJhbSBtYXhUaW1lb3V0TVNcbiAqIEBwYXJhbSByZWplY3RcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRpbWVySURcbiAqL1xuZnVuY3Rpb24gcmVqZWN0T25UaW1lb3V0KG1heFRpbWVvdXRNUywgcmVqZWN0KSB7XG4gIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICByZWplY3Qoe1xuICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgbWVzc2FnZTogJ1RpbWVvdXQgbG9hZGluZyBCbG9iIFVSTCdcbiAgICB9KTtcbiAgfSwgbWF4VGltZW91dE1TKTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQ29udmVydHMgYSBVUkwgdG8gYSBCTE9CIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHVybFRvTG9hZFxuICogQHBhcmFtIHtudW1iZXJ9IG1heF90aW1lb3V0X21zIC0gVGltZSB0byBlbGFwc2UgYmVmb3JlIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAqIEByZXR1cm4ge1Byb21pc2U8e1xuICogICBzdGF0dXM6ICdzdWNjZXNzJyB8ICdlcnJvcidcbiAqICAgbWVzc2FnZT86IHN0cmluZyxcbiAqICAgIHBheWxvYWQ6IHtcbiAqICAgICAgdXJsOiBzdHJpbmdcbiAqICAgIH1cbiAqIH0+fVxuICovXG5mdW5jdGlvbiBnZXRCbG9iRnJvbVVSTCh1cmxUb0xvYWQsIG1heFRpbWVvdXRNUykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciB0aW1lcklEID0gcmVqZWN0T25UaW1lb3V0KG1heFRpbWVvdXRNUywgcmVqZWN0KTtcblxuICAgIC8vIElmIGZldGNoIGV4aXN0cywgdXNlIGl0IHRvIGZldGNoIGJsb2IsIG90aGVyd2lzZSB1c2UgWEhSLlxuICAgIC8vIFhIUiBjYXVzZXMgaXNzdWVzIG9uIHNhZmFyaSAxNC4xIHNvIHdlIHByZWZlciBmZXRjaFxuICAgIHZhciBmZXRjaEJsb2IgPSB0eXBlb2YgZmV0Y2ggIT09ICd1bmRlZmluZWQnICYmIGZldGNoID8gbG9hZFVybFVzaW5nRmV0Y2ggOiBsb2FkVXJsVXNpbmdYaHI7XG4gICAgZmV0Y2hCbG9iKHVybFRvTG9hZCkudGhlbihmdW5jdGlvbiAoYmxvYikge1xuICAgICAgcmVzb2x2ZSh7XG4gICAgICAgIHN0YXR1czogJ3N1Y2Nlc3MnLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgYmxvYlVSTDogVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlamVjdCh7XG4gICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgbWVzc2FnZTogJ0Vycm9yIGxvYWRpbmcgQmxvYiBVUkwnXG4gICAgICB9KTtcbiAgICB9KVtcImZpbmFsbHlcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgLy8gQ2xlYXIgdGhlIHRpbWVvdXQgdGltZXIgb24gZmFpbCBvciBzdWNjZXNzLlxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySUQpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBVc2UgZmV0Y2ggZnVuY3Rpb24gdG8gZmV0Y2ggZmlsZVxuICogQHBhcmFtIHVybFRvTG9hZFxuICogQHJldHVybnMge1Byb21pc2U8dW5rbm93bj59XG4gKi9cbmZ1bmN0aW9uIGxvYWRVcmxVc2luZ0ZldGNoKHVybFRvTG9hZCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZldGNoKHVybFRvTG9hZCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIHJlc3BvbnNlLmJsb2IoKS50aGVuKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgIHJlc29sdmUoYmxvYik7XG4gICAgICB9KTtcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlamVjdCgnZXJyb3InKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogVXNlIFhIUiB0byBmZXRjaCBmaWxlXG4gKiBAcGFyYW0gdXJsVG9Mb2FkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx1bmtub3duPn1cbiAqL1xuZnVuY3Rpb24gbG9hZFVybFVzaW5nWGhyKHVybFRvTG9hZCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIHJlc29sdmUoeGhyLnJlc3BvbnNlKTtcbiAgICB9O1xuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmVqZWN0KCdlcnJvcicpO1xuICAgIH07XG4gICAgeGhyLm9wZW4oJ0dFVCcsIHVybFRvTG9hZCwgdHJ1ZSk7XG4gICAgeGhyLnNlbmQoKTtcbiAgfSk7XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB4aHJfZ2V0QmxvYkZyb21VUkwgPSAoZ2V0QmxvYkZyb21VUkwpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbC9mZWF0dXJlcy90cmFuc3BhcmVudFZpZGVvL2NyZWF0ZUhpZGRlblZpZGVvVGFnLmpzXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgaGlkZGVuIEhUTUxWaWRlb0VsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIHZpZGVvT3B0aW9uc1xuICogQHBhcmFtIHt7YXV0b3BsYXksIHBsYXlzaW5saW5lLCBsb29wLCBtdXRlZCwgcG9zdGVyLCBibG9iVVJMLCB2aWRlb1VSTCB9fSB2aWRlb09wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmlkZW9PcHRpb25zLmF1dG9wbGF5IC0gYXV0b3BsYXlzIHRoZSB2aWRlbyBpZiB0cnVlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmlkZW9PcHRpb25zLmJsb2JVUkwgLSB0aGUgYmxvYlVSTCB0byBzZXQgYXMgdmlkZW8uc3JjXG4gKiBAcGFyYW0ge3N0cmluZ30gdmlkZW9PcHRpb25zLnZpZGVvVVJMIC0gdGhlIG9yaWdpbmFsIHZpZGVvVVJMIHRoZSB1c2VyIGNyZWF0ZWQgKHdpdGggdHJhbnNmb3JtYXRpb25zKVxuICogQHJldHVybiB7SFRNTFZpZGVvRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSGlkZGVuVmlkZW9UYWcodmlkZW9PcHRpb25zKSB7XG4gIHZhciBhdXRvcGxheSA9IHZpZGVvT3B0aW9ucy5hdXRvcGxheSxcbiAgICBwbGF5c2lubGluZSA9IHZpZGVvT3B0aW9ucy5wbGF5c2lubGluZSxcbiAgICBsb29wID0gdmlkZW9PcHRpb25zLmxvb3AsXG4gICAgbXV0ZWQgPSB2aWRlb09wdGlvbnMubXV0ZWQsXG4gICAgcG9zdGVyID0gdmlkZW9PcHRpb25zLnBvc3RlcixcbiAgICBibG9iVVJMID0gdmlkZW9PcHRpb25zLmJsb2JVUkwsXG4gICAgdmlkZW9VUkwgPSB2aWRlb09wdGlvbnMudmlkZW9VUkw7XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gIGVsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgZWwucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBlbC54ID0gMDtcbiAgZWwueSA9IDA7XG4gIGVsLnNyYyA9IGJsb2JVUkw7XG4gIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS12aWRlby11cmwnLCB2aWRlb1VSTCk7IC8vIGZvciBkZWJ1Z2dpbmcvdGVzdGluZ1xuXG4gIGF1dG9wbGF5ICYmIGVsLnNldEF0dHJpYnV0ZSgnYXV0b3BsYXknLCBhdXRvcGxheSk7XG4gIHBsYXlzaW5saW5lICYmIGVsLnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCBwbGF5c2lubGluZSk7XG4gIGxvb3AgJiYgZWwuc2V0QXR0cmlidXRlKCdsb29wJywgbG9vcCk7XG4gIG11dGVkICYmIGVsLnNldEF0dHJpYnV0ZSgnbXV0ZWQnLCBtdXRlZCk7XG4gIG11dGVkICYmIChlbC5tdXRlZCA9IG11dGVkKTsgLy8gdGhpcyBpcyBhbHNvIG5lZWRlZCBmb3IgYXV0b3BsYXksIG9uIHRvcCBvZiBzZXRBdHRyaWJ1dGVcbiAgcG9zdGVyICYmIGVsLnNldEF0dHJpYnV0ZSgncG9zdGVyJywgcG9zdGVyKTtcblxuICAvLyBGcmVlIG1lbW9yeSBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlIGxvYWRpbmcuXG4gIGVsLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGJsb2JVUkwpO1xuICB9O1xuICByZXR1cm4gZWw7XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BhcmVudFZpZGVvX2NyZWF0ZUhpZGRlblZpZGVvVGFnID0gKGNyZWF0ZUhpZGRlblZpZGVvVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvZmVhdHVyZXMvdHJhbnNwYXJlbnRWaWRlby9pbnN0YW50aWF0ZVNlZVRocnUuanNcbi8qKlxuICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhIG5ldyBpbnN0YW5jIGVvZiBzZWVUaHJ1IChzZWVUaHJ1LmNyZWF0ZSgpKSBhbmQgcmV0dXJucyBhIHByb21pc2Ugb2YgdGhlIHNlZVRocnUgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudH0gdmlkZW9FbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gbWF4X3RpbWVvdXRfbXMgLSBUaW1lIHRvIGVsYXBzZSBiZWZvcmUgcHJvbWlzZSBpcyByZWplY3RlZFxuICogQHBhcmFtIHtzdHJpbmd9IGN1c3RvbUNsYXNzIC0gQSBjbGFzc25hbWUgdG8gYmUgYWRkZWQgdG8gdGhlIGNhbnZhcyBlbGVtZW50IGNyZWF0ZWQgYnkgc2VlVGhydVxuICogQHBhcmFtIHtib29sZWFufSBhdXRvUGxheVxuICogQHJldHVybiB7UHJvbWlzZTxhbnk+fSBTZWVUaHJ1IGluc3RhbmNlIG9yIHJlamVjdGlvbiBlcnJvclxuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVNlZVRocnUodmlkZW9FbGVtZW50LCBtYXhfdGltZW91dF9tcywgY3VzdG9tQ2xhc3MsIGF1dG9QbGF5KSB7XG4gIHZhciBfd2luZG93ID0gd2luZG93LFxuICAgIHNlZVRocnUgPSBfd2luZG93LnNlZVRocnUsXG4gICAgc2V0VGltZW91dCA9IF93aW5kb3cuc2V0VGltZW91dCxcbiAgICBjbGVhclRpbWVvdXQgPSBfd2luZG93LmNsZWFyVGltZW91dDtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgdGltZXJJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmVqZWN0KHtcbiAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICBtZXNzYWdlOiAnVGltZW91dCBpbnN0YW50aWF0aW5nIHNlZVRocnUgaW5zdGFuY2UnXG4gICAgICB9KTtcbiAgICB9LCBtYXhfdGltZW91dF9tcyk7XG4gICAgaWYgKHNlZVRocnUpIHtcbiAgICAgIHZhciBzZWVUaHJ1SW5zdGFuY2UgPSBzZWVUaHJ1LmNyZWF0ZSh2aWRlb0VsZW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY2xlYXIgdGltZW91dCByZWplY3QgZXJyb3JcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySUQpO1xuXG4gICAgICAgIC8vIGZvcmNlIGNvbnRhaW5lciB3aWR0aCwgZWxzZSB0aGUgY2FudmFzIGNhbiBvdmVyZmxvdyBvdXRcbiAgICAgICAgdmFyIGNhbnZhc0VsZW1lbnQgPSBzZWVUaHJ1SW5zdGFuY2UuZ2V0Q2FudmFzKCk7XG4gICAgICAgIGNhbnZhc0VsZW1lbnQuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIGNhbnZhc0VsZW1lbnQuY2xhc3NOYW1lICs9ICcgJyArIGN1c3RvbUNsYXNzO1xuXG4gICAgICAgIC8vIHN0YXJ0IHRoZSB2aWRlbyBpZiBhdXRvcGxheSBpcyBzZXRcbiAgICAgICAgaWYgKGF1dG9QbGF5KSB7XG4gICAgICAgICAgc2VlVGhydUluc3RhbmNlLnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHNlZVRocnVJbnN0YW5jZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVqZWN0KHtcbiAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICBtZXNzYWdlOiAnRXJyb3IgaW5zdGFudGlhdGluZyBzZWVUaHJ1IGluc3RhbmNlJ1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcGFyZW50VmlkZW9faW5zdGFudGlhdGVTZWVUaHJ1ID0gKGluc3RhbnRpYXRlU2VlVGhydSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlsL2ZlYXR1cmVzL3RyYW5zcGFyZW50VmlkZW8vbW91bnRTZWVUaHJ1Q2FudmFzVGFnLmpzXG5cblxuXG5cblxuLyoqXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaHRtbEVsQ29udGFpbmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmlkZW9VUkxcbiAqIEBwYXJhbSB7VHJhbnNmb3JtYXRpb25PcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gKi9cbmZ1bmN0aW9uIG1vdW50U2VlVGhydUNhbnZhc1RhZyhodG1sRWxDb250YWluZXIsIHZpZGVvVVJMLCBvcHRpb25zKSB7XG4gIHZhciBwb3N0ZXIgPSBvcHRpb25zLnBvc3RlcixcbiAgICBhdXRvcGxheSA9IG9wdGlvbnMuYXV0b3BsYXksXG4gICAgcGxheXNpbmxpbmUgPSBvcHRpb25zLnBsYXlzaW5saW5lLFxuICAgIGxvb3AgPSBvcHRpb25zLmxvb3AsXG4gICAgbXV0ZWQgPSBvcHRpb25zLm11dGVkO1xuICB2aWRlb1VSTCA9IHZpZGVvVVJMICsgJy5tcDQnOyAvLyBzZWVUaHJ1IGFsd2F5cyB1c2VzIG1wNFxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHhocl9sb2FkU2NyaXB0KG9wdGlvbnMuZXh0ZXJuYWxMaWJyYXJpZXMuc2VlVGhydSwgb3B0aW9ucy5tYXhfdGltZW91dF9tcywgd2luZG93LnNlZVRocnUpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgeGhyX2dldEJsb2JGcm9tVVJMKHZpZGVvVVJMLCBvcHRpb25zLm1heF90aW1lb3V0X21zKS50aGVuKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBwYXlsb2FkID0gX3JlZi5wYXlsb2FkO1xuICAgICAgICB2YXIgdmlkZW9FbGVtZW50ID0gdHJhbnNwYXJlbnRWaWRlb19jcmVhdGVIaWRkZW5WaWRlb1RhZyh7XG4gICAgICAgICAgYmxvYlVSTDogcGF5bG9hZC5ibG9iVVJMLFxuICAgICAgICAgIHZpZGVvVVJMOiB2aWRlb1VSTCxcbiAgICAgICAgICAvLyBmb3IgZGVidWdnaW5nL3Rlc3RpbmdcbiAgICAgICAgICBwb3N0ZXI6IHBvc3RlcixcbiAgICAgICAgICBhdXRvcGxheTogYXV0b3BsYXksXG4gICAgICAgICAgcGxheXNpbmxpbmU6IHBsYXlzaW5saW5lLFxuICAgICAgICAgIGxvb3A6IGxvb3AsXG4gICAgICAgICAgbXV0ZWQ6IG11dGVkXG4gICAgICAgIH0pO1xuICAgICAgICBodG1sRWxDb250YWluZXIuYXBwZW5kQ2hpbGQodmlkZW9FbGVtZW50KTtcbiAgICAgICAgdHJhbnNwYXJlbnRWaWRlb19pbnN0YW50aWF0ZVNlZVRocnUodmlkZW9FbGVtZW50LCBvcHRpb25zLm1heF90aW1lb3V0X21zLCBvcHRpb25zW1wiY2xhc3NcIl0sIG9wdGlvbnMuYXV0b3BsYXkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlc29sdmUoaHRtbEVsQ29udGFpbmVyKTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNhdGNoIGZvciBnZXRCbG9iRnJvbVVSTCgpXG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIgc3RhdHVzID0gX3JlZjIuc3RhdHVzLFxuICAgICAgICAgIG1lc3NhZ2UgPSBfcmVmMi5tZXNzYWdlO1xuICAgICAgICByZWplY3Qoe1xuICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIGNhdGNoIGZvciBsb2FkU2NyaXB0KClcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgdmFyIHN0YXR1cyA9IF9yZWYzLnN0YXR1cyxcbiAgICAgICAgbWVzc2FnZSA9IF9yZWYzLm1lc3NhZ2U7XG4gICAgICByZWplY3Qoe1xuICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwYXJlbnRWaWRlb19tb3VudFNlZVRocnVDYW52YXNUYWcgPSAobW91bnRTZWVUaHJ1Q2FudmFzVGFnKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWwvZmVhdHVyZXMvdHJhbnNwYXJlbnRWaWRlby9jaGVja1N1cHBvcnRGb3JUcmFuc3BhcmVuY3kuanNcbi8qKlxuICogQHJldHVybiB7UHJvbWlzZTxib29sZWFuPn0gLSBXaGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHRyYW5zcGFyZW50IHZpZGVvcyBvciBub3RcbiAqL1xuXG5mdW5jdGlvbiBjaGVja1N1cHBvcnRGb3JUcmFuc3BhcmVuY3koKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgLy8gUmVzb2x2ZSBlYXJseSBmb3Igc2FmYXJpLlxuICAgIC8vIEN1cnJlbnRseSAoMjkgRGVjZW1iZXIgMjAyMSkgU2FmYXJpIGNhbiBwbGF5IHdlYm0vdnA5LFxuICAgIC8vIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0IHRyYW5zcGFyZW50IHZpZGVvIGluIHRoZSBmb3JtYXQgd2UncmUgb3V0cHV0dGluZ1xuICAgIGlmIChpc1NhZmFyaSgpKSB7XG4gICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgdmFyIHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICB2YXIgY2FuUGxheSA9IHZpZGVvLmNhblBsYXlUeXBlICYmIHZpZGVvLmNhblBsYXlUeXBlKCd2aWRlby93ZWJtOyBjb2RlY3M9XCJ2cDlcIicpO1xuICAgIHJlc29sdmUoY2FuUGxheSA9PT0gJ21heWJlJyB8fCBjYW5QbGF5ID09PSAncHJvYmFibHknKTtcbiAgfSk7XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BhcmVudFZpZGVvX2NoZWNrU3VwcG9ydEZvclRyYW5zcGFyZW5jeSA9IChjaGVja1N1cHBvcnRGb3JUcmFuc3BhcmVuY3kpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY2xvdWRpbmFyeS5qc1xuZnVuY3Rpb24gY2xvdWRpbmFyeV90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBjbG91ZGluYXJ5X3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBjbG91ZGluYXJ5X3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gY2xvdWRpbmFyeV9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBjbG91ZGluYXJ5X2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjbG91ZGluYXJ5X3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBjbG91ZGluYXJ5X2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgY2xvdWRpbmFyeV9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgY2xvdWRpbmFyeV9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gY2xvdWRpbmFyeV90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBjbG91ZGluYXJ5X3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBjbG91ZGluYXJ5X3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gY2xvdWRpbmFyeV90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IGNsb3VkaW5hcnlfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IGNsb3VkaW5hcnlfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cblxudmFyIGFwcGx5QnJlYWtwb2ludHMsIGNsb3Nlc3RBYm92ZSwgZGVmYXVsdEJyZWFrcG9pbnRzLCBjbG91ZGluYXJ5X2ZpbmRDb250YWluZXJXaWR0aCwgY2xvdWRpbmFyeV9tYXhXaWR0aCwgdXBkYXRlRHByO1xuXG5cblxuXG5cblxuXG5cblxuXG4vL1xuXG5cblxuXG5cbmRlZmF1bHRCcmVha3BvaW50cyA9IGZ1bmN0aW9uIGRlZmF1bHRCcmVha3BvaW50cyh3aWR0aCkge1xuICB2YXIgc3RlcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDEwMDtcbiAgcmV0dXJuIHN0ZXBzICogTWF0aC5jZWlsKHdpZHRoIC8gc3RlcHMpO1xufTtcbmNsb3Nlc3RBYm92ZSA9IGZ1bmN0aW9uIGNsb3Nlc3RBYm92ZShsaXN0LCB2YWx1ZSkge1xuICB2YXIgaTtcbiAgaSA9IGxpc3QubGVuZ3RoIC0gMjtcbiAgd2hpbGUgKGkgPj0gMCAmJiBsaXN0W2ldID49IHZhbHVlKSB7XG4gICAgaS0tO1xuICB9XG4gIHJldHVybiBsaXN0W2kgKyAxXTtcbn07XG5hcHBseUJyZWFrcG9pbnRzID0gZnVuY3Rpb24gYXBwbHlCcmVha3BvaW50cyh0YWcsIHdpZHRoLCBzdGVwcywgb3B0aW9ucykge1xuICB2YXIgcmVmLCByZWYxLCByZWYyLCByZXNwb25zaXZlX3VzZV9icmVha3BvaW50cztcbiAgcmVzcG9uc2l2ZV91c2VfYnJlYWtwb2ludHMgPSAocmVmID0gKHJlZjEgPSAocmVmMiA9IG9wdGlvbnNbJ3Jlc3BvbnNpdmVfdXNlX2JyZWFrcG9pbnRzJ10pICE9IG51bGwgPyByZWYyIDogb3B0aW9uc1sncmVzcG9uc2l2ZV91c2Vfc3RvcHBvaW50cyddKSAhPSBudWxsID8gcmVmMSA6IHRoaXMuY29uZmlnKCdyZXNwb25zaXZlX3VzZV9icmVha3BvaW50cycpKSAhPSBudWxsID8gcmVmIDogdGhpcy5jb25maWcoJ3Jlc3BvbnNpdmVfdXNlX3N0b3Bwb2ludHMnKTtcbiAgaWYgKCFyZXNwb25zaXZlX3VzZV9icmVha3BvaW50cyB8fCByZXNwb25zaXZlX3VzZV9icmVha3BvaW50cyA9PT0gJ3Jlc2l6ZScgJiYgIW9wdGlvbnMucmVzaXppbmcpIHtcbiAgICByZXR1cm4gd2lkdGg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuY2FsY19icmVha3BvaW50KHRhZywgd2lkdGgsIHN0ZXBzKTtcbiAgfVxufTtcbmNsb3VkaW5hcnlfZmluZENvbnRhaW5lcldpZHRoID0gZnVuY3Rpb24gZmluZENvbnRhaW5lcldpZHRoKGVsZW1lbnQpIHtcbiAgdmFyIGNvbnRhaW5lcldpZHRoLCBzdHlsZTtcbiAgY29udGFpbmVyV2lkdGggPSAwO1xuICB3aGlsZSAoKGVsZW1lbnQgPSBlbGVtZW50ICE9IG51bGwgPyBlbGVtZW50LnBhcmVudE5vZGUgOiB2b2lkIDApIGluc3RhbmNlb2YgRWxlbWVudCAmJiAhY29udGFpbmVyV2lkdGgpIHtcbiAgICBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIGlmICghL15pbmxpbmUvLnRlc3Qoc3R5bGUuZGlzcGxheSkpIHtcbiAgICAgIGNvbnRhaW5lcldpZHRoID0gbG9kYXNoX3dpZHRoKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29udGFpbmVyV2lkdGg7XG59O1xudXBkYXRlRHByID0gZnVuY3Rpb24gdXBkYXRlRHByKGRhdGFTcmMsIHJvdW5kRHByKSB7XG4gIHJldHVybiBkYXRhU3JjLnJlcGxhY2UoL1xcYmRwcl8oMVxcLjB8YXV0bylcXGIvZywgJ2Rwcl8nICsgdGhpcy5kZXZpY2VfcGl4ZWxfcmF0aW8ocm91bmREcHIpKTtcbn07XG5jbG91ZGluYXJ5X21heFdpZHRoID0gZnVuY3Rpb24gbWF4V2lkdGgocmVxdWlyZWRXaWR0aCwgdGFnKSB7XG4gIHZhciBpbWFnZVdpZHRoO1xuICBpbWFnZVdpZHRoID0gbG9kYXNoX2dldERhdGEodGFnLCAnd2lkdGgnKSB8fCAwO1xuICBpZiAocmVxdWlyZWRXaWR0aCA+IGltYWdlV2lkdGgpIHtcbiAgICBpbWFnZVdpZHRoID0gcmVxdWlyZWRXaWR0aDtcbiAgICBsb2Rhc2hfc2V0RGF0YSh0YWcsICd3aWR0aCcsIHJlcXVpcmVkV2lkdGgpO1xuICB9XG4gIHJldHVybiBpbWFnZVdpZHRoO1xufTtcbnZhciBjbG91ZGluYXJ5X0Nsb3VkaW5hcnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBDbG91ZGluYXJ5IGluc3RhbmNlLlxuICAgKiBAY2xhc3MgQ2xvdWRpbmFyeVxuICAgKiBAY2xhc3NkZXNjIE1haW4gY2xhc3MgZm9yIGFjY2Vzc2luZyBDbG91ZGluYXJ5IGZ1bmN0aW9uYWxpdHkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQSB7QGxpbmsgQ29uZmlndXJhdGlvbn0gb2JqZWN0IGZvciBnbG9iYWxseSBjb25maWd1cmluZyBDbG91ZGluYXJ5IGFjY291bnQgc2V0dGluZ3MuXG4gICAqIEBleGFtcGxlPGJyLz5cbiAgICogIHZhciBjbCA9IG5ldyBjbG91ZGluYXJ5LkNsb3VkaW5hcnkoIHsgY2xvdWRfbmFtZTogXCJteWNsb3VkXCJ9KTs8YnIvPlxuICAgKiAgdmFyIGltZ1RhZyA9IGNsLmltYWdlKFwibXlQaWNJRFwiKTtcbiAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3NvbHV0aW9uX292ZXJ2aWV3I2NvbmZpZ3VyYXRpb25fcGFyYW1ldGVyc1wiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgKiAgQXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAgICovXG4gIGZ1bmN0aW9uIENsb3VkaW5hcnkob3B0aW9ucykge1xuICAgIGNsb3VkaW5hcnlfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xvdWRpbmFyeSk7XG4gICAgdmFyIGNvbmZpZ3VyYXRpb247XG4gICAgdGhpcy5kZXZpY2VQaXhlbFJhdGlvQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnJlc3BvbnNpdmVDb25maWcgPSB7fTtcbiAgICB0aGlzLnJlc3BvbnNpdmVSZXNpemVJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIGNvbmZpZ3VyYXRpb24gPSBuZXcgc3JjX2NvbmZpZ3VyYXRpb24ob3B0aW9ucyk7XG4gICAgLy8gUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICB0aGlzLmNvbmZpZyA9IGZ1bmN0aW9uIChuZXdDb25maWcsIG5ld1ZhbHVlKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbi5jb25maWcobmV3Q29uZmlnLCBuZXdWYWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVc2UgXFw8bWV0YVxcPiB0YWdzIGluIHRoZSBkb2N1bWVudCB0byBjb25maWd1cmUgdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybiBUaGlzIHtDbG91ZGluYXJ5fSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgdGhpcy5mcm9tRG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25maWd1cmF0aW9uLmZyb21Eb2N1bWVudCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVc2UgZW52aXJvbm1lbnQgdmFyaWFibGVzIHRvIGNvbmZpZ3VyZSB0aGlzIGBjbG91ZGluYXJ5YCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJuIFRoaXMge0Nsb3VkaW5hcnl9IGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICB0aGlzLmZyb21FbnZpcm9ubWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbmZpZ3VyYXRpb24uZnJvbUVudmlyb25tZW50KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoaXMgYGNsb3VkaW5hcnlgIGluc3RhbmNlLlxuICAgICAqICBUaGlzIGlzIGEgY29udmVuaWVuY2UgbWV0aG9kIHRoYXQgaW52b2tlcyBib3RoIHtAbGluayBDb25maWd1cmF0aW9uI2Zyb21FbnZpcm9ubWVudHxmcm9tRW52aXJvbm1lbnQoKX1cbiAgICAgKiAgKE5vZGUuanMgZW52aXJvbm1lbnQgb25seSkgYW5kIHtAbGluayBDb25maWd1cmF0aW9uI2Zyb21Eb2N1bWVudHxmcm9tRG9jdW1lbnQoKX0uXG4gICAgICogIEl0IGZpcnN0IHRyaWVzIHRvIHJldHJpZXZlIHRoZSBjb25maWd1cmF0aW9uIGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICAgICAqICBJZiBub3QgYXZhaWxhYmxlLCBpdCB0cmllcyBmcm9tIHRoZSBkb2N1bWVudCBtZXRhIHRhZ3MuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjaW5pdFxuICAgICAqIEBzZWUgQ29uZmlndXJhdGlvbiNpbml0XG4gICAgICogQHJldHVybiBUaGlzIHtDbG91ZGluYXJ5fSBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29uZmlndXJhdGlvbi5pbml0KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge0Nsb3VkaW5hcnl9XG4gICAqIEBleGFtcGxlIGNsID0gY2xvdWRpbmFyeS5DbG91ZGluYXJ5Lm5ldyggeyBjbG91ZF9uYW1lOiBcIm15Y2xvdWRcIn0pXG4gICAqL1xuICByZXR1cm4gY2xvdWRpbmFyeV9jcmVhdGVDbGFzcyhDbG91ZGluYXJ5LCBbe1xuICAgIGtleTogXCJ1cmxcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBVUkwgZm9yIGFueSBhc3NldCBpbiB5b3VyIE1lZGlhIGxpYnJhcnkuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIHB1YmxpYyBJRCBvZiB0aGUgbWVkaWEgYXNzZXQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMgdG8gaW5jbHVkZSBpbiB0aGUgVVJMLlxuICAgICAqIEBwYXJhbSB7dHlwZX0gW29wdGlvbnMudHlwZT0ndXBsb2FkJ10gLSBUaGUgYXNzZXQncyBzdG9yYWdlIHR5cGUuXG4gICAgICogIEZvciBkZXRhaWxzIG9uIGFsbCBmZXRjaCB0eXBlcywgc2VlXG4gICAgICogPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbnMjZmV0Y2hpbmdfaW1hZ2VzX2Zyb21fcmVtb3RlX2xvY2F0aW9uc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkZldGNoIHR5cGVzPC9hPi5cbiAgICAgKiBAcGFyYW0ge3Jlc291cmNlVHlwZX0gW29wdGlvbnMucmVzb3VyY2VfdHlwZT0naW1hZ2UnXSAtIFRoZSB0eXBlIG9mIGFzc2V0LiBQb3NzaWJsZSB2YWx1ZXM6PGJyLz5cbiAgICAgKiAgLSBgaW1hZ2VgPGJyLz5cbiAgICAgKiAgLSBgdmlkZW9gPGJyLz5cbiAgICAgKiAgLSBgcmF3YFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG1lZGlhIGFzc2V0IFVSTC5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vaW1hZ2VfdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVybChwdWJsaWNJZCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgcmV0dXJuIHVybF91cmwocHVibGljSWQsIG9wdGlvbnMsIHRoaXMuY29uZmlnKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHZpZGVvIGFzc2V0IFVSTC5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN2aWRlb191cmxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgcHVibGljIElEIG9mIHRoZSB2aWRlby5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycyB0byBpbmNsdWRlIGluIHRoZSBVUkwuXG4gICAgICogQHBhcmFtIHt0eXBlfSBbb3B0aW9ucy50eXBlPSd1cGxvYWQnXSAtIFRoZSBhc3NldCdzIHN0b3JhZ2UgdHlwZS5cbiAgICAgKiAgRm9yIGRldGFpbHMgb24gYWxsIGZldGNoIHR5cGVzLCBzZWVcbiAgICAgKiAgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbnMjZmV0Y2hpbmdfaW1hZ2VzX2Zyb21fcmVtb3RlX2xvY2F0aW9uc1wiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkZldGNoIHR5cGVzPC9hPi5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB2aWRlbyBVUkwuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiXG4gICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmlkZW9fdXJsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZGVvX3VybChwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe1xuICAgICAgICByZXNvdXJjZV90eXBlOiAndmlkZW8nXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLnVybChwdWJsaWNJZCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgVVJMIGZvciBhbiBpbWFnZSBpbnRlbmRlZCB0byBiZSB1c2VkIGFzIGEgdGh1bWJuYWlsIGZvciB0aGUgc3BlY2lmaWVkIHZpZGVvLlxuICAgICAqICBJZGVudGljYWwgdG8ge0BsaW5rIENsb3VkaW5hcnkjdXJsfHVybH0sIGV4Y2VwdCB0aGF0IHRoZSBgcmVzb3VyY2VfdHlwZWAgaXMgYHZpZGVvYFxuICAgICAqICBhbmQgdGhlIGRlZmF1bHQgYGZvcm1hdGAgaXMgYGpwZ2AuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdmlkZW9fdGh1bWJuYWlsX3VybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtICBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHZpZGVvIGZyb20gd2hpY2ggeW91IHdhbnQgdG8gZ2VuZXJhdGUgYSB0aHVtYm5haWwgaW1hZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBpbWFnZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMgdG8gYXBwbHkgdG8gdGhlIHRodW1ibmFpbC5cbiAgICAgKiBJbiBhZGRpdGlvbiB0byBzdGFuZGFyZCBpbWFnZSB0cmFuc2Zvcm1hdGlvbnMsIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGBzdGFydF9vZmZzZXRgIHRyYW5zZm9ybWF0aW9uIHBhcmFtZXRlclxuICAgICAqIHRvIGluc3RydWN0IENsb3VkaW5hcnkgdG8gZ2VuZXJhdGUgdGhlIHRodW1ibmFpbCBmcm9tIGEgZnJhbWUgb3RoZXIgdGhhbiB0aGUgbWlkZGxlIGZyYW1lIG9mIHRoZSB2aWRlby5cbiAgICAgKiBGb3IgZGV0YWlscywgc2VlXG4gICAgICogPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi92aWRlb19tYW5pcHVsYXRpb25fYW5kX2RlbGl2ZXJ5I2dlbmVyYXRpbmdfdmlkZW9fdGh1bWJuYWlsc1wiXG4gICAgICogdGFyZ2V0PVwiX2JsYW5rXCI+R2VuZXJhdGluZyB2aWRlbyB0aHVtYm5haWxzPC9hPiBpbiB0aGUgQ2xvdWRpbmFyeSBkb2N1bWVudGF0aW9uLlxuICAgICAqIEBwYXJhbSB7dHlwZX0gW29wdGlvbnMudHlwZT0ndXBsb2FkJ10gLSBUaGUgYXNzZXQncyBzdG9yYWdlIHR5cGUuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVJMIG9mIHRoZSB2aWRlbyB0aHVtYm5haWwgaW1hZ2UuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInZpZGVvX3RodW1ibmFpbF91cmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlkZW9fdGh1bWJuYWlsX3VybChwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe30sIERFRkFVTFRfUE9TVEVSX09QVElPTlMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMudXJsKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNwZWNpZmllZCB0cmFuc2Zvcm1hdGlvbiBvcHRpb25zLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3RyYW5zZm9ybWF0aW9uX3N0cmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdHJhbnNmb3JtYXRpb24gc3RyaW5nLlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNmb3JtYXRpb25fc3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zZm9ybWF0aW9uX3N0cmluZyhvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IHNyY190cmFuc2Zvcm1hdGlvbihvcHRpb25zKS5zZXJpYWxpemUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gaW1hZ2UgdGFnLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2ltYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIHB1YmxpYyBJRCBvZiB0aGUgaW1hZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzLCB7QGxpbmsgQ29uZmlndXJhdGlvbn0gcGFyYW1ldGVycyxcbiAgICAgKiAgYW5kIHN0YW5kYXJkIEhUTUwgJmx0O2ltZyZndDsgdGFnIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIGltYWdlIHRhZy5cbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBBbiBpbWFnZSB0YWcgRE9NIGVsZW1lbnQuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGltYWdlKHB1YmxpY0lkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgY2xpZW50X2hpbnRzLCBpbWcsIHJlZjtcbiAgICAgIGltZyA9IHRoaXMuaW1hZ2VUYWcocHVibGljSWQsIG9wdGlvbnMpO1xuICAgICAgY2xpZW50X2hpbnRzID0gKHJlZiA9IG9wdGlvbnMuY2xpZW50X2hpbnRzICE9IG51bGwgPyBvcHRpb25zLmNsaWVudF9oaW50cyA6IHRoaXMuY29uZmlnKCdjbGllbnRfaGludHMnKSkgIT0gbnVsbCA/IHJlZiA6IGZhbHNlO1xuICAgICAgaWYgKG9wdGlvbnMuc3JjID09IG51bGwgJiYgIWNsaWVudF9oaW50cykge1xuICAgICAgICAvLyBzcmMgbXVzdCBiZSByZW1vdmVkIGJlZm9yZSBjcmVhdGluZyB0aGUgRE9NIGVsZW1lbnQgdG8gYXZvaWQgbG9hZGluZyB0aGUgaW1hZ2VcbiAgICAgICAgaW1nLnNldEF0dHIoXCJzcmNcIiwgJycpO1xuICAgICAgfVxuICAgICAgaW1nID0gaW1nLnRvRE9NKCk7XG4gICAgICBpZiAoIWNsaWVudF9oaW50cykge1xuICAgICAgICAvLyBjYWNoZSB0aGUgaW1hZ2Ugc3JjXG4gICAgICAgIGxvZGFzaF9zZXREYXRhKGltZywgJ3NyYy1jYWNoZScsIHRoaXMudXJsKHB1YmxpY0lkLCBvcHRpb25zKSk7XG4gICAgICAgIC8vIHNldCBpbWFnZSBzcmMgdGFraW5nIHJlc3BvbnNpdmVuZXNzIGluIGFjY291bnRcbiAgICAgICAgdGhpcy5jbG91ZGluYXJ5X3VwZGF0ZShpbWcsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGltZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEltYWdlVGFnIGluc3RhbmNlIHVzaW5nIHRoZSBjb25maWd1cmF0aW9uIGRlZmluZWQgZm9yIHRoaXMgYGNsb3VkaW5hcnlgIGluc3RhbmNlLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2ltYWdlVGFnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIHB1YmxpYyBJRCBvZiB0aGUgaW1hZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMsIHtAbGluayBDb25maWd1cmF0aW9ufSBwYXJhbWV0ZXJzLFxuICAgICAqICBhbmQgc3RhbmRhcmQgSFRNTCAmbHQ7aW1nJmd0OyB0YWcgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgaW1hZ2UgdGFnLlxuICAgICAqIEByZXR1cm4ge0ltYWdlVGFnfSBBbiBJbWFnZVRhZyBpbnN0YW5jZSB0aGF0IGlzIGF0dGFjaGVkIChjaGFpbmVkKSB0byB0aGlzIENsb3VkaW5hcnkgaW5zdGFuY2UuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImltYWdlVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGltYWdlVGFnKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICB2YXIgdGFnO1xuICAgICAgdGFnID0gbmV3IGltYWdldGFnKHB1YmxpY0lkLCB0aGlzLmNvbmZpZygpKTtcbiAgICAgIHRhZy50cmFuc2Zvcm1hdGlvbigpLmZyb21PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFBpY3R1cmVUYWcgaW5zdGFuY2UsIGNvbmZpZ3VyZWQgdXNpbmcgdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjUGljdHVyZVRhZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIHRoZSBwdWJsaWMgSUQgb2YgdGhlIHJlc291cmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBhZGRpdGlvbmFsIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgbmV3IEltYWdlVGFnIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBzb3VyY2VzIC0gdGhlIHNvdXJjZXMgZGVmaW5pdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQaWN0dXJlVGFnfSBBIFBpY3R1cmVUYWcgdGhhdCBpcyBhdHRhY2hlZCAoY2hhaW5lZCkgdG8gdGhpcyBDbG91ZGluYXJ5IGluc3RhbmNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicGljdHVyZVRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwaWN0dXJlVGFnKHB1YmxpY0lkLCBvcHRpb25zLCBzb3VyY2VzKSB7XG4gICAgICB2YXIgdGFnO1xuICAgICAgdGFnID0gbmV3IHBpY3R1cmV0YWcocHVibGljSWQsIHRoaXMuY29uZmlnKCksIHNvdXJjZXMpO1xuICAgICAgdGFnLnRyYW5zZm9ybWF0aW9uKCkuZnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU291cmNlVGFnIGluc3RhbmNlLCBjb25maWd1cmVkIHVzaW5nIHRoaXMgYGNsb3VkaW5hcnlgIGluc3RhbmNlLlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I1NvdXJjZVRhZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIHRoZSBwdWJsaWMgSUQgb2YgdGhlIHJlc291cmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gYWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIG5ldyBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJuIHtTb3VyY2VUYWd9IEEgU291cmNlVGFnIHRoYXQgaXMgYXR0YWNoZWQgKGNoYWluZWQpIHRvIHRoaXMgQ2xvdWRpbmFyeSBpbnN0YW5jZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNvdXJjZVRhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb3VyY2VUYWcocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB0YWc7XG4gICAgICB0YWcgPSBuZXcgc291cmNldGFnKHB1YmxpY0lkLCB0aGlzLmNvbmZpZygpKTtcbiAgICAgIHRhZy50cmFuc2Zvcm1hdGlvbigpLmZyb21PcHRpb25zKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB2aWRlbyB0aHVtYm5haWwgVVJMIGZyb20gdGhlIHNwZWNpZmllZCByZW1vdGUgdmlkZW8gYW5kIGluY2x1ZGVzIGl0IGluIGFuIGltYWdlIHRhZy5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN2aWRlb190aHVtYm5haWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHZpZGVvIGZyb20gdGhlIHJlbGV2YW50IHZpZGVvIHNpdGUuXG4gICAgICogIEFkZGl0aW9uYWxseSwgZWl0aGVyIGFwcGVuZCB0aGUgaW1hZ2UgZXh0ZW5zaW9uIHR5cGUgdG8gdGhlIGlkZW50aWZpZXIgdmFsdWUgb3Igc2V0XG4gICAgICogIHRoZSBpbWFnZSBkZWxpdmVyeSBmb3JtYXQgaW4gdGhlICdvcHRpb25zJyBwYXJhbWV0ZXIgdXNpbmcgdGhlICdmb3JtYXQnIHRyYW5zZm9ybWF0aW9uIG9wdGlvbi5cbiAgICAgKiAgRm9yIGV4YW1wbGUsIGEgWW91VHViZSB2aWRlbyBtaWdodCBoYXZlIHRoZSBpZGVudGlmaWVyOiAnby11cm5sYUpwT0EuanBnJy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycyB0byBhcHBseS5cbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBBbiBIVE1MIGltYWdlIHRhZyBlbGVtZW50XG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInZpZGVvX3RodW1ibmFpbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWRlb190aHVtYm5haWwocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlKHB1YmxpY0lkLCBtZXJnZV9yb290X21lcmdlX2RlZmF1bHQoKSh7fSwgREVGQVVMVF9QT1NURVJfT1BUSU9OUywgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBmYWNlYm9vayBwcm9maWxlIGltYWdlIGFuZCBkZWxpdmVycyBpdCBpbiBhbiBpbWFnZSB0YWcgZWxlbWVudC5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNmYWNlYm9va19wcm9maWxlX2ltYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIEZhY2Vib29rIG51bWVyaWMgSUQuIEFkZGl0aW9uYWxseSwgZWl0aGVyIGFwcGVuZCB0aGUgaW1hZ2UgZXh0ZW5zaW9uIHR5cGVcbiAgICAgKiAgdG8gdGhlIElEIG9yIHNldCB0aGUgaW1hZ2UgZGVsaXZlcnkgZm9ybWF0IGluIHRoZSAnb3B0aW9ucycgcGFyYW1ldGVyIHVzaW5nIHRoZSAnZm9ybWF0JyB0cmFuc2Zvcm1hdGlvbiBvcHRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMsIHtAbGluayBDb25maWd1cmF0aW9ufSBwYXJhbWV0ZXJzLFxuICAgICAqICBhbmQgc3RhbmRhcmQgSFRNTCAmbHQ7aW1nJmd0OyB0YWcgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgaW1hZ2UgdGFnLlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJmYWNlYm9va19wcm9maWxlX2ltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZhY2Vib29rX3Byb2ZpbGVfaW1hZ2UocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlKHB1YmxpY0lkLCBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgICAgdHlwZTogJ2ZhY2Vib29rJ1xuICAgICAgfSwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBUd2l0dGVyIHByb2ZpbGUgaW1hZ2UgYnkgSUQgYW5kIGRlbGl2ZXJzIGl0IGluIGFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I3R3aXR0ZXJfcHJvZmlsZV9pbWFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBUd2l0dGVyIG51bWVyaWMgSUQuIEFkZGl0aW9uYWxseSwgZWl0aGVyIGFwcGVuZCB0aGUgaW1hZ2UgZXh0ZW5zaW9uIHR5cGVcbiAgICAgKiAgdG8gdGhlIElEIG9yIHNldCB0aGUgaW1hZ2UgZGVsaXZlcnkgZm9ybWF0IGluIHRoZSAnb3B0aW9ucycgcGFyYW1ldGVyIHVzaW5nIHRoZSAnZm9ybWF0JyB0cmFuc2Zvcm1hdGlvbiBvcHRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMsIHtAbGluayBDb25maWd1cmF0aW9ufSBwYXJhbWV0ZXJzLFxuICAgICAqICBhbmQgc3RhbmRhcmQgSFRNTCAmbHQ7aW1nJmd0OyB0YWcgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgaW1hZ2UgdGFnLlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0d2l0dGVyX3Byb2ZpbGVfaW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHdpdHRlcl9wcm9maWxlX2ltYWdlKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWFnZShwdWJsaWNJZCwgYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICAgIHR5cGU6ICd0d2l0dGVyJ1xuICAgICAgfSwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBUd2l0dGVyIHByb2ZpbGUgaW1hZ2UgYnkgbmFtZSBhbmQgZGVsaXZlcnMgaXQgaW4gYW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdHdpdHRlcl9uYW1lX3Byb2ZpbGVfaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgVHdpdHRlciBzY3JlZW4gbmFtZS4gQWRkaXRpb25hbGx5LCBlaXRoZXIgYXBwZW5kIHRoZSBpbWFnZSBleHRlbnNpb24gdHlwZVxuICAgICAqICB0byB0aGUgc2NyZWVuIG5hbWUgb3Igc2V0IHRoZSBpbWFnZSBkZWxpdmVyeSBmb3JtYXQgaW4gdGhlICdvcHRpb25zJyBwYXJhbWV0ZXIgdXNpbmcgdGhlICdmb3JtYXQnIHRyYW5zZm9ybWF0aW9uIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gQW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInR3aXR0ZXJfbmFtZV9wcm9maWxlX2ltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHR3aXR0ZXJfbmFtZV9wcm9maWxlX2ltYWdlKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWFnZShwdWJsaWNJZCwgYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICAgIHR5cGU6ICd0d2l0dGVyX25hbWUnXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIEdyYXZhdGFyIHByb2ZpbGUgaW1hZ2UgYW5kIGRlbGl2ZXJzIGl0IGluIGFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2dyYXZhdGFyX2ltYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0lkIC0gVGhlIGNhbGN1bGF0ZWQgaGFzaCBmb3IgdGhlIEdyYXZhdGFyIGVtYWlsIGFkZHJlc3MuXG4gICAgICogIEFkZGl0aW9uYWxseSwgZWl0aGVyIGFwcGVuZCB0aGUgaW1hZ2UgZXh0ZW5zaW9uIHR5cGUgdG8gdGhlIHNjcmVlbiBuYW1lIG9yIHNldCB0aGUgaW1hZ2UgZGVsaXZlcnkgZm9ybWF0XG4gICAgICogIGluIHRoZSAnb3B0aW9ucycgcGFyYW1ldGVyIHVzaW5nIHRoZSAnZm9ybWF0JyB0cmFuc2Zvcm1hdGlvbiBvcHRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IHBhcmFtZXRlcnMsIHtAbGluayBDb25maWd1cmF0aW9ufSBwYXJhbWV0ZXJzLFxuICAgICAqICBhbmQgc3RhbmRhcmQgSFRNTCAmbHQ7aW1nJmd0OyB0YWcgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgaW1hZ2UgdGFnLlxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEFuIGltYWdlIHRhZyBlbGVtZW50LlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vc29sdXRpb25fb3ZlcnZpZXcjY29uZmlndXJhdGlvbl9wYXJhbWV0ZXJzXCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXZhaWxhYmxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uczwvYT5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJncmF2YXRhcl9pbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBncmF2YXRhcl9pbWFnZShwdWJsaWNJZCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2UocHVibGljSWQsIGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe1xuICAgICAgICB0eXBlOiAnZ3JhdmF0YXInXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhbiBpbWFnZSBmcm9tIGEgcmVtb3RlIFVSTCBhbmQgZGVsaXZlcnMgaXQgaW4gYW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjZmV0Y2hfaW1hZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgZnVsbCBVUkwgb2YgdGhlIGltYWdlIHRvIGZldGNoLCBpbmNsdWRpbmcgdGhlIGV4dGVuc2lvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gQW4gaW1hZ2UgdGFnIGVsZW1lbnQuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL2ltYWdlX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgaW1hZ2UgdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZldGNoX2ltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZldGNoX2ltYWdlKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWFnZShwdWJsaWNJZCwgYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKSh7XG4gICAgICAgIHR5cGU6ICdmZXRjaCdcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB2aWRlbyB0YWcuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjdmlkZW9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljSWQgLSBUaGUgcHVibGljIElEIG9mIHRoZSB2aWRlby5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7SFRNTFZpZGVvRWxlbWVudH0gQSB2aWRlbyB0YWcgRE9NIGVsZW1lbnQuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInZpZGVvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZGVvKHB1YmxpY0lkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICByZXR1cm4gdGhpcy52aWRlb1RhZyhwdWJsaWNJZCwgb3B0aW9ucykudG9IdG1sKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBWaWRlb1RhZyBpbnN0YW5jZSB1c2luZyB0aGUgY29uZmlndXJhdGlvbiBkZWZpbmVkIGZvciB0aGlzIGBjbG91ZGluYXJ5YCBpbnN0YW5jZS5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN2aWRlb1RhZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSBwdWJsaWMgSUQgb2YgdGhlIHZpZGVvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIHtAbGluayBUcmFuc2Zvcm1hdGlvbn0gcGFyYW1ldGVycywge0BsaW5rIENvbmZpZ3VyYXRpb259IHBhcmFtZXRlcnMsXG4gICAgICogIGFuZCBzdGFuZGFyZCBIVE1MICZsdDtpbWcmZ3Q7IHRhZyBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBpbWFnZSB0YWcuXG4gICAgICogQHJldHVybiB7VmlkZW9UYWd9IEEgVmlkZW9UYWcgdGhhdCBpcyBhdHRhY2hlZCAoY2hhaW5lZCkgdG8gdGhpcyBgY2xvdWRpbmFyeWAgaW5zdGFuY2UuXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3ZpZGVvX3RyYW5zZm9ybWF0aW9uX3JlZmVyZW5jZVwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAqICBBdmFpbGFibGUgdmlkZW8gdHJhbnNmb3JtYXRpb25zPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9zb2x1dGlvbl9vdmVydmlldyNjb25maWd1cmF0aW9uX3BhcmFtZXRlcnNcIlxuICAgICAqICB0YXJnZXQ9XCJfYmxhbmtcIj5BdmFpbGFibGUgY29uZmlndXJhdGlvbiBvcHRpb25zPC9hPlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInZpZGVvVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZGVvVGFnKHB1YmxpY0lkLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdHMoe30sIG9wdGlvbnMsIHRoaXMuY29uZmlnKCkpO1xuICAgICAgcmV0dXJuIG5ldyB2aWRlb3RhZyhwdWJsaWNJZCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgc3ByaXRlIFBORyBpbWFnZSB0aGF0IGNvbnRhaW5zIGFsbCBpbWFnZXMgd2l0aCB0aGUgc3BlY2lmaWVkIHRhZyBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgY3NzIGZpbGUuXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjc3ByaXRlX2Nzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZCAtIFRoZSB0YWcgb24gd2hpY2ggdG8gYmFzZSB0aGUgc3ByaXRlIGltYWdlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUge0BsaW5rIFRyYW5zZm9ybWF0aW9ufSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgaW4gdGhlIFVSTC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVUkwgb2YgdGhlIGdlbmVyYXRlZCBDU1MgZmlsZS4gVGhlIHNwcml0ZSBpbWFnZSBoYXMgdGhlIHNhbWUgVVJMLCBidXQgd2l0aCBhIFBORyBleHRlbnNpb24uXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3Nwcml0ZV9nZW5lcmF0aW9uXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIFNwcml0ZSBnZW5lcmF0aW9uPC9hPlxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzcHJpdGVfY3NzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwcml0ZV9jc3MocHVibGljSWQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBhc3NpZ25fcm9vdF9hc3NpZ25fZGVmYXVsdCgpKHtcbiAgICAgICAgdHlwZTogJ3Nwcml0ZSdcbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgaWYgKCFwdWJsaWNJZC5tYXRjaCgvLmNzcyQvKSkge1xuICAgICAgICBvcHRpb25zLmZvcm1hdCA9ICdjc3MnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudXJsKHB1YmxpY0lkLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyByZXNwb25zaXZlIGltYWdlIGJlaGF2aW9yIGZvciBhbGwgaW1hZ2UgdGFncyB3aXRoIHRoZSAnY2xkLXJlc3BvbnNpdmUnXG4gICAgICogIChvciBvdGhlciBkZWZpbmVkIHtAbGluayBDbG91ZGluYXJ5I3Jlc3BvbnNpdmV8cmVzcG9uc2l2ZX0gY2xhc3MpLjxici8+XG4gICAgICogIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBpbnZva2VkIGFmdGVyIHRoZSBwYWdlIGhhcyBsb2FkZWQuPGJyLz5cbiAgICAgKiAgPGI+Tm90ZTwvYj46IENhbGxzIHtAbGluayBDbG91ZGluYXJ5I2Nsb3VkaW5hcnlfdXBkYXRlfGNsb3VkaW5hcnlfdXBkYXRlfSB0byBtb2RpZnkgaW1hZ2UgdGFncy5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNyZXNwb25zaXZlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVzcG9uc2l2ZV9jbGFzcz0nY2xkLXJlc3BvbnNpdmUnXSAtIEFuIGFsdGVybmF0aXZlIGNsYXNzXG4gICAgICogIHRvIGxvY2F0ZSB0aGUgcmVsZXZhbnQgJmx0O2ltZyZndDsgdGFncy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVzcG9uc2l2ZV9kZWJvdW5jZT0xMDBdIC0gVGhlIGRlYm91bmNlIGludGVydmFsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtib290c3RyYXA9dHJ1ZV0gSWYgdHJ1ZSwgcHJvY2Vzc2VzIHRoZSAmbHQ7aW1nJmd0OyB0YWdzIGJ5IGNhbGxpbmdcbiAgICAgKiAge0BsaW5rIENsb3VkaW5hcnkjY2xvdWRpbmFyeV91cGRhdGV8Y2xvdWRpbmFyeV91cGRhdGV9LiBXaGVuIGZhbHNlLCB0aGUgdGFncyBhcmUgcHJvY2Vzc2VkXG4gICAgICogIG9ubHkgYWZ0ZXIgYSByZXNpemUgZXZlbnQuXG4gICAgICogQHNlZSB7QGxpbmsgQ2xvdWRpbmFyeSNjbG91ZGluYXJ5X3VwZGF0ZXxjbG91ZGluYXJ5X3VwZGF0ZX0gZm9yIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gICAgICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jbG91ZGluYXJ5LmNvbS9kb2N1bWVudGF0aW9uL3Jlc3BvbnNpdmVfaW1hZ2VzI2F1dG9tYXRpbmdfcmVzcG9uc2l2ZV9pbWFnZXNfd2l0aF9qYXZhc2NyaXB0XCJcbiAgICAgKiAgdGFyZ2V0PVwiX2JsYW5rXCI+QXV0b21hdGluZyByZXNwb25zaXZlIGltYWdlcyB3aXRoIEphdmFTY3JpcHQ8L2E+XG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259IHRoYXQgd2hlbiBjYWxsZWQsIHJlbW92ZXMgdGhlIHJlc2l6ZSBFdmVudExpc3RlbmVyIGFkZGVkIGJ5IHRoaXMgZnVuY3Rpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZXNwb25zaXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3BvbnNpdmUob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBib290c3RyYXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB2YXIgcmVmLCByZWYxLCByZWYyLCByZXNwb25zaXZlQ2xhc3MsIHJlc3BvbnNpdmVSZXNpemUsIHRpbWVvdXQ7XG4gICAgICB0aGlzLnJlc3BvbnNpdmVDb25maWcgPSBtZXJnZV9yb290X21lcmdlX2RlZmF1bHQoKSh0aGlzLnJlc3BvbnNpdmVDb25maWcgfHwge30sIG9wdGlvbnMpO1xuICAgICAgcmVzcG9uc2l2ZUNsYXNzID0gKHJlZiA9IHRoaXMucmVzcG9uc2l2ZUNvbmZpZy5yZXNwb25zaXZlX2NsYXNzKSAhPSBudWxsID8gcmVmIDogdGhpcy5jb25maWcoJ3Jlc3BvbnNpdmVfY2xhc3MnKTtcbiAgICAgIGlmIChib290c3RyYXApIHtcbiAgICAgICAgdGhpcy5jbG91ZGluYXJ5X3VwZGF0ZShcImltZy5cIi5jb25jYXQocmVzcG9uc2l2ZUNsYXNzLCBcIiwgaW1nLmNsZC1oaWRwaVwiKSwgdGhpcy5yZXNwb25zaXZlQ29uZmlnKTtcbiAgICAgIH1cbiAgICAgIHJlc3BvbnNpdmVSZXNpemUgPSAocmVmMSA9IChyZWYyID0gdGhpcy5yZXNwb25zaXZlQ29uZmlnLnJlc3BvbnNpdmVfcmVzaXplKSAhPSBudWxsID8gcmVmMiA6IHRoaXMuY29uZmlnKCdyZXNwb25zaXZlX3Jlc2l6ZScpKSAhPSBudWxsID8gcmVmMSA6IHRydWU7XG4gICAgICBpZiAocmVzcG9uc2l2ZVJlc2l6ZSAmJiAhdGhpcy5yZXNwb25zaXZlUmVzaXplSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5yZXNwb25zaXZlQ29uZmlnLnJlc2l6aW5nID0gdGhpcy5yZXNwb25zaXZlUmVzaXplSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdmFyIG1ha2VSZXNwb25zaXZlID0gZnVuY3Rpb24gbWFrZVJlc3BvbnNpdmUoKSB7XG4gICAgICAgICAgdmFyIGRlYm91bmNlLCByZWYzLCByZWY0LCByZXNldCwgcnVuLCB3YWl0LCB3YWl0RnVuYztcbiAgICAgICAgICBkZWJvdW5jZSA9IChyZWYzID0gKHJlZjQgPSBfdGhpcy5yZXNwb25zaXZlQ29uZmlnLnJlc3BvbnNpdmVfZGVib3VuY2UpICE9IG51bGwgPyByZWY0IDogX3RoaXMuY29uZmlnKCdyZXNwb25zaXZlX2RlYm91bmNlJykpICE9IG51bGwgPyByZWYzIDogMTAwO1xuICAgICAgICAgIHJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgcnVuID0gZnVuY3Rpb24gcnVuKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNsb3VkaW5hcnlfdXBkYXRlKFwiaW1nLlwiLmNvbmNhdChyZXNwb25zaXZlQ2xhc3MpLCBfdGhpcy5yZXNwb25zaXZlQ29uZmlnKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHdhaXRGdW5jID0gZnVuY3Rpb24gd2FpdEZ1bmMoKSB7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJ1bigpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgd2FpdCA9IGZ1bmN0aW9uIHdhaXQoKSB7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQod2FpdEZ1bmMsIGRlYm91bmNlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChkZWJvdW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdhaXQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJ1bigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG1ha2VSZXNwb25zaXZlKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG1ha2VSZXNwb25zaXZlKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNjYWxjX2JyZWFrcG9pbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjYWxjX2JyZWFrcG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY19icmVha3BvaW50KGVsZW1lbnQsIHdpZHRoLCBzdGVwcykge1xuICAgICAgdmFyIGJyZWFrcG9pbnRzID0gbG9kYXNoX2dldERhdGEoZWxlbWVudCwgJ2JyZWFrcG9pbnRzJykgfHwgbG9kYXNoX2dldERhdGEoZWxlbWVudCwgJ3N0b3Bwb2ludHMnKSB8fCB0aGlzLmNvbmZpZygnYnJlYWtwb2ludHMnKSB8fCB0aGlzLmNvbmZpZygnc3RvcHBvaW50cycpIHx8IGRlZmF1bHRCcmVha3BvaW50cztcbiAgICAgIGlmIChpc0Z1bmN0aW9uX3Jvb3RfaXNGdW5jdGlvbl9kZWZhdWx0KCkoYnJlYWtwb2ludHMpKSB7XG4gICAgICAgIHJldHVybiBicmVha3BvaW50cyh3aWR0aCwgc3RlcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfZGVmYXVsdCgpKGJyZWFrcG9pbnRzKSkge1xuICAgICAgICAgIGJyZWFrcG9pbnRzID0gYnJlYWtwb2ludHMuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQocG9pbnQpO1xuICAgICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvc2VzdEFib3ZlKGJyZWFrcG9pbnRzLCB3aWR0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIENsb3VkaW5hcnkjY2FsY19zdG9wcG9pbnRcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGNhbGNfYnJlYWtwb2ludH0gaW5zdGVhZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjYWxjX3N0b3Bwb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjX3N0b3Bwb2ludChlbGVtZW50LCB3aWR0aCwgc3RlcHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGNfYnJlYWtwb2ludChlbGVtZW50LCB3aWR0aCwgc3RlcHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2RldmljZV9waXhlbF9yYXRpb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGV2aWNlX3BpeGVsX3JhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldmljZV9waXhlbF9yYXRpbyhyb3VuZERwcikge1xuICAgICAgcm91bmREcHIgPSByb3VuZERwciA9PSBudWxsID8gdHJ1ZSA6IHJvdW5kRHByO1xuICAgICAgdmFyIGRwciA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPT0gbnVsbCA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogdm9pZCAwKSB8fCAxO1xuICAgICAgaWYgKHJvdW5kRHByKSB7XG4gICAgICAgIGRwciA9IE1hdGguY2VpbChkcHIpO1xuICAgICAgfVxuICAgICAgaWYgKGRwciA8PSAwIHx8IGRwciA9PT0gMCAvIDApIHtcbiAgICAgICAgZHByID0gMTtcbiAgICAgIH1cbiAgICAgIHZhciBkcHJTdHJpbmcgPSBkcHIudG9TdHJpbmcoKTtcbiAgICAgIGlmIChkcHJTdHJpbmcubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICAgIGRwclN0cmluZyArPSAnLjAnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRwclN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEFwcGxpZXMgcmVzcG9uc2l2ZW5lc3MgdG8gYWxsIDxjb2RlPiZsdDtpbWcmZ3Q7PC9jb2RlPiB0YWdzIHVuZGVyIGVhY2ggcmVsZXZhbnQgbm9kZVxuICAgICogIChyZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIHRhZyBjb250YWlucyB0aGUge0BsaW5rIENsb3VkaW5hcnkjcmVzcG9uc2l2ZXxyZXNwb25zaXZlfSBjbGFzcykuXG4gICAgKiBAcGFyYW0ge0VsZW1lbnRbXX0gbm9kZXMgVGhlIHBhcmVudCBub2RlcyB3aGVyZSB5b3Ugd2FudCB0byBzZWFyY2ggZm9yICZsdDtpbWcmZ3Q7IHRhZ3MuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSB7QGxpbmsgQ2xvdWRpbmFyeSNjbG91ZGluYXJ5X3VwZGF0ZXxjbG91ZGluYXJ5X3VwZGF0ZX0gb3B0aW9ucyB0byBhcHBseS5cbiAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIlxuICAgICogIHRhcmdldD1cIl9ibGFua1wiPkF2YWlsYWJsZSBpbWFnZSB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSNwcm9jZXNzSW1hZ2VUYWdzXG4gICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzSW1hZ2VUYWdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NJbWFnZVRhZ3Mobm9kZXMsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChpc0VtcHR5KG5vZGVzKSkge1xuICAgICAgICAvLyBzaW1pbGFyIHRvIGAkLmZuLmNsb3VkaW5hcnlgXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRzKHt9LCBvcHRpb25zIHx8IHt9LCB0aGlzLmNvbmZpZygpKTtcbiAgICAgIHZhciBpbWFnZXMgPSBub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIC9eaW1nJC9pLnRlc3Qobm9kZS50YWdOYW1lKTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgaW1nT3B0aW9ucyA9IGFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0KCkoe1xuICAgICAgICAgIHdpZHRoOiBub2RlLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSxcbiAgICAgICAgICBoZWlnaHQ6IG5vZGUuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSxcbiAgICAgICAgICBzcmM6IG5vZGUuZ2V0QXR0cmlidXRlKCdzcmMnKVxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIHB1YmxpY0lkID0gaW1nT3B0aW9uc1snc291cmNlJ10gfHwgaW1nT3B0aW9uc1snc3JjJ107XG4gICAgICAgIGRlbGV0ZSBpbWdPcHRpb25zWydzb3VyY2UnXTtcbiAgICAgICAgZGVsZXRlIGltZ09wdGlvbnNbJ3NyYyddO1xuICAgICAgICB2YXIgYXR0ciA9IG5ldyBzcmNfdHJhbnNmb3JtYXRpb24oaW1nT3B0aW9ucykudG9IdG1sQXR0cmlidXRlcygpO1xuICAgICAgICBsb2Rhc2hfc2V0RGF0YShub2RlLCAnc3JjLWNhY2hlJywgdXJsX3VybChwdWJsaWNJZCwgaW1nT3B0aW9ucykpO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBhdHRyLndpZHRoKTtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGF0dHIuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY2xvdWRpbmFyeV91cGRhdGUoaW1hZ2VzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogVXBkYXRlcyB0aGUgZHByIChmb3IgYGRwcl9hdXRvYCkgYW5kIHJlc3BvbnNpdmUgKGZvciBgd19hdXRvYCkgZmllbGRzIGFjY29yZGluZyB0b1xuICAgICogIHRoZSBjdXJyZW50IGNvbnRhaW5lciBzaXplIGFuZCB0aGUgZGV2aWNlIHBpeGVsIHJhdGlvLjxici8+XG4gICAgKiAgPGI+Tm90ZTwvYj46YHdfYXV0b2AgaXMgdXBkYXRlZCBvbmx5IGZvciBpbWFnZXMgbWFya2VkIHdpdGggdGhlIGBjbGQtcmVzcG9uc2l2ZWBcbiAgICAqICAob3Igb3RoZXIgZGVmaW5lZCB7QGxpbmsgQ2xvdWRpbmFyeSNyZXNwb25zaXZlfHJlc3BvbnNpdmV9KSBjbGFzcy5cbiAgICAqIEBmdW5jdGlvbiBDbG91ZGluYXJ5I2Nsb3VkaW5hcnlfdXBkYXRlXG4gICAgKiBAcGFyYW0geyhBcnJheXxzdHJpbmd8Tm9kZUxpc3QpfSBlbGVtZW50cyAtIFRoZSBIVE1MIGltYWdlIGVsZW1lbnRzIHRvIG1vZGlmeS5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW58c3RyaW5nfSBbb3B0aW9ucy5yZXNwb25zaXZlX3VzZV9icmVha3BvaW50cz10cnVlXVxuICAgICogUG9zc2libGUgdmFsdWVzOjxici8+XG4gICAgKiAgLSBgdHJ1ZWA6IEFsd2F5cyB1c2UgYnJlYWtwb2ludHMgZm9yIHdpZHRoLjxici8+XG4gICAgKiAgLSBgcmVzaXplYDogVXNlIGV4YWN0IHdpZHRoIG9uIGZpcnN0IHJlbmRlciBhbmQgYnJlYWtwb2ludHMgb24gcmVzaXplLjxici8+XG4gICAgKiAgLSBgZmFsc2VgOiBBbHdheXMgdXNlIGV4YWN0IHdpZHRoLlxuICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXNwb25zaXZlXSAtIElmIGB0cnVlYCwgZW5hYmxlIHJlc3BvbnNpdmUgb24gYWxsIHNwZWNpZmllZCBlbGVtZW50cy5cbiAgICAqICBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIGRlZmluZSBzcGVjaWZpYyBIVE1MIGVsZW1lbnRzIHRvIG1vZGlmeSBieSBhZGRpbmcgdGhlIGBjbGQtcmVzcG9uc2l2ZWBcbiAgICAqICAob3Igb3RoZXIgY3VzdG9tLWRlZmluZWQge0BsaW5rIENsb3VkaW5hcnkjcmVzcG9uc2l2ZXxyZXNwb25zaXZlX2NsYXNzfSkgY2xhc3MgdG8gdGhvc2UgZWxlbWVudHMuXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlc3BvbnNpdmVfcHJlc2VydmVfaGVpZ2h0XSAtIElmIGB0cnVlYCwgb3JpZ2luYWwgY3NzIGhlaWdodCBpcyBwcmVzZXJ2ZWQuXG4gICAgKiAgU2hvdWxkIGJlIHVzZWQgb25seSBpZiB0aGUgdHJhbnNmb3JtYXRpb24gc3VwcG9ydHMgZGlmZmVyZW50IGFzcGVjdCByYXRpb3MuXG4gICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbG91ZGluYXJ5X3VwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG91ZGluYXJ5X3VwZGF0ZShlbGVtZW50cywgb3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgY29udGFpbmVyV2lkdGgsIGRhdGFTcmMsIG1hdGNoLCByZWY0LCByZXF1aXJlZFdpZHRoO1xuICAgICAgaWYgKGVsZW1lbnRzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG4gICAgICB2YXIgcmVzcG9uc2l2ZSA9IG9wdGlvbnMucmVzcG9uc2l2ZSAhPSBudWxsID8gb3B0aW9ucy5yZXNwb25zaXZlIDogdGhpcy5jb25maWcoJ3Jlc3BvbnNpdmUnKTtcbiAgICAgIGVsZW1lbnRzID0gbm9ybWFsaXplVG9BcnJheShlbGVtZW50cyk7XG4gICAgICB2YXIgcmVzcG9uc2l2ZUNsYXNzO1xuICAgICAgaWYgKHRoaXMucmVzcG9uc2l2ZUNvbmZpZyAmJiB0aGlzLnJlc3BvbnNpdmVDb25maWcucmVzcG9uc2l2ZV9jbGFzcyAhPSBudWxsKSB7XG4gICAgICAgIHJlc3BvbnNpdmVDbGFzcyA9IHRoaXMucmVzcG9uc2l2ZUNvbmZpZy5yZXNwb25zaXZlX2NsYXNzO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnJlc3BvbnNpdmVfY2xhc3MgIT0gbnVsbCkge1xuICAgICAgICByZXNwb25zaXZlQ2xhc3MgPSBvcHRpb25zLnJlc3BvbnNpdmVfY2xhc3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwb25zaXZlQ2xhc3MgPSB0aGlzLmNvbmZpZygncmVzcG9uc2l2ZV9jbGFzcycpO1xuICAgICAgfVxuICAgICAgdmFyIHJvdW5kRHByID0gb3B0aW9ucy5yb3VuZF9kcHIgIT0gbnVsbCA/IG9wdGlvbnMucm91bmRfZHByIDogdGhpcy5jb25maWcoJ3JvdW5kX2RwcicpO1xuICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgIGlmICgvaW1nL2kudGVzdCh0YWcudGFnTmFtZSkpIHtcbiAgICAgICAgICB2YXIgc2V0VXJsID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocmVzcG9uc2l2ZSkge1xuICAgICAgICAgICAgbG9kYXNoX2FkZENsYXNzKHRhZywgcmVzcG9uc2l2ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVNyYyA9IGxvZGFzaF9nZXREYXRhKHRhZywgJ3NyYy1jYWNoZScpIHx8IGxvZGFzaF9nZXREYXRhKHRhZywgJ3NyYycpO1xuICAgICAgICAgIGlmICghaXNFbXB0eShkYXRhU3JjKSkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGRwciBhY2NvcmRpbmcgdG8gdGhlIGRldmljZSdzIGRldmljZVBpeGVsUmF0aW9cbiAgICAgICAgICAgIGRhdGFTcmMgPSB1cGRhdGVEcHIuY2FsbChfdGhpczIsIGRhdGFTcmMsIHJvdW5kRHByKTtcbiAgICAgICAgICAgIGlmIChodG1sdGFnLmlzUmVzcG9uc2l2ZSh0YWcsIHJlc3BvbnNpdmVDbGFzcykpIHtcbiAgICAgICAgICAgICAgY29udGFpbmVyV2lkdGggPSBjbG91ZGluYXJ5X2ZpbmRDb250YWluZXJXaWR0aCh0YWcpO1xuICAgICAgICAgICAgICBpZiAoY29udGFpbmVyV2lkdGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoL3dfYXV0bzpicmVha3BvaW50cy8udGVzdChkYXRhU3JjKSkge1xuICAgICAgICAgICAgICAgICAgcmVxdWlyZWRXaWR0aCA9IGNsb3VkaW5hcnlfbWF4V2lkdGgoY29udGFpbmVyV2lkdGgsIHRhZyk7XG4gICAgICAgICAgICAgICAgICBpZiAocmVxdWlyZWRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhU3JjID0gZGF0YVNyYy5yZXBsYWNlKC93X2F1dG86YnJlYWtwb2ludHMoW18wLTldKikoOlswLTldKyk/LywgXCJ3X2F1dG86YnJlYWtwb2ludHMkMTpcIi5jb25jYXQocmVxdWlyZWRXaWR0aCkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VXJsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoID0gL3dfYXV0byg6KFxcZCspKT8vLmV4ZWMoZGF0YVNyYyk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRXaWR0aCA9IGFwcGx5QnJlYWtwb2ludHMuY2FsbChfdGhpczIsIHRhZywgY29udGFpbmVyV2lkdGgsIG1hdGNoWzJdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRXaWR0aCA9IGNsb3VkaW5hcnlfbWF4V2lkdGgocmVxdWlyZWRXaWR0aCwgdGFnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVpcmVkV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhU3JjID0gZGF0YVNyYy5yZXBsYWNlKC93X2F1dG9bXixcXC9dKi9nLCBcIndfXCIuY29uY2F0KHJlcXVpcmVkV2lkdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRVcmwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2Rhc2hfcmVtb3ZlQXR0cmlidXRlKHRhZywgJ3dpZHRoJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLnJlc3BvbnNpdmVfcHJlc2VydmVfaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICBsb2Rhc2hfcmVtb3ZlQXR0cmlidXRlKHRhZywgJ2hlaWdodCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDb250YWluZXIgZG9lc24ndCBrbm93IHRoZSBzaXplIHlldCAtIHVzdWFsbHkgYmVjYXVzZSB0aGUgaW1hZ2UgaXMgaGlkZGVuIG9yIG91dHNpZGUgdGhlIERPTS5cbiAgICAgICAgICAgICAgICBzZXRVcmwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlzTGF6eUxvYWRpbmcgPSBvcHRpb25zLmxvYWRpbmcgPT09ICdsYXp5JyAmJiAhX3RoaXMyLmlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWQoKSAmJiBfdGhpczIuaXNMYXp5TG9hZFN1cHBvcnRlZCgpICYmICFlbGVtZW50c1swXS5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICAgICAgaWYgKHNldFVybCB8fCBpc0xhenlMb2FkaW5nKSB7XG4gICAgICAgICAgICAgIC8vIElmIGRhdGEtd2lkdGggZXhpc3RzLCBzZXQgd2lkdGggdG8gYmUgZGF0YS13aWR0aFxuICAgICAgICAgICAgICBfdGhpczIuc2V0QXR0cmlidXRlSWZFeGlzdHMoZWxlbWVudHNbMF0sICd3aWR0aCcsICdkYXRhLXdpZHRoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2V0VXJsICYmICFpc0xhenlMb2FkaW5nKSB7XG4gICAgICAgICAgICAgIGxvZGFzaF9zZXRBdHRyaWJ1dGUodGFnLCAnc3JjJywgZGF0YVNyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgZWxlbWVudFt0b0F0dHJpYnV0ZV0gPSBlbGVtZW50W2Zyb21BdHRyaWJ1dGVdIGlmIGVsZW1lbnRbZnJvbUF0dHJpYnV0ZV0gaXMgc2V0XG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gdG9BdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0gZnJvbUF0dHJpYnV0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldEF0dHJpYnV0ZUlmRXhpc3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZUlmRXhpc3RzKGVsZW1lbnQsIHRvQXR0cmlidXRlLCBmcm9tQXR0cmlidXRlKSB7XG4gICAgICB2YXIgYXR0cmlidXRlVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShmcm9tQXR0cmlidXRlKTtcbiAgICAgIGlmIChhdHRyaWJ1dGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGxvZGFzaF9zZXRBdHRyaWJ1dGUoZWxlbWVudCwgdG9BdHRyaWJ1dGUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgSW50ZXJzZWN0aW9uIE9ic2VydmVyIEFQSSBpcyBzdXBwb3J0ZWRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpc0xhenlMb2FkU3VwcG9ydGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzTGF6eUxvYWRTdXBwb3J0ZWQoKSB7XG4gICAgICByZXR1cm4gd2luZG93ICYmICdJbnRlcnNlY3Rpb25PYnNlcnZlcicgaW4gd2luZG93O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB1c2luZyBDaHJvbWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpc05hdGl2ZUxhenlMb2FkU3VwcG9ydGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWQoKSB7XG4gICAgICByZXR1cm4gJ2xvYWRpbmcnIGluIEhUTUxJbWFnZUVsZW1lbnQucHJvdG90eXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IG9iamVjdCwgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIG9wdGlvbnMsIGZvciBjaGFpbmluZyBwdXJwb3Nlcy5cbiAgICAgKiBAZnVuY3Rpb24gQ2xvdWRpbmFyeSN0cmFuc2Zvcm1hdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSB7QGxpbmsgVHJhbnNmb3JtYXRpb259IG9wdGlvbnMgdG8gYXBwbHkuXG4gICAgICogQHJldHVybiB7VHJhbnNmb3JtYXRpb259XG4gICAgICogQHNlZSBUcmFuc2Zvcm1hdGlvblxuICAgICAqIEBzZWUgPGEgaHJlZj1cImh0dHBzOi8vY2xvdWRpbmFyeS5jb20vZG9jdW1lbnRhdGlvbi9pbWFnZV90cmFuc2Zvcm1hdGlvbl9yZWZlcmVuY2VcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgKiAgQXZhaWxhYmxlIGltYWdlIHRyYW5zZm9ybWF0aW9uczwvYT5cbiAgICAgKiBAc2VlIDxhIGhyZWY9XCJodHRwczovL2Nsb3VkaW5hcnkuY29tL2RvY3VtZW50YXRpb24vdmlkZW9fdHJhbnNmb3JtYXRpb25fcmVmZXJlbmNlXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICogIEF2YWlsYWJsZSB2aWRlbyB0cmFuc2Zvcm1hdGlvbnM8L2E+XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtYXRpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHNyY190cmFuc2Zvcm1hdGlvbltcIm5ld1wiXSh0aGlzLmNvbmZpZygpKS5mcm9tT3B0aW9ucyhvcHRpb25zKS5zZXRQYXJlbnQodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gd2lsbCBhcHBlbmQgYSBUcmFuc3BhcmVudFZpZGVvIGVsZW1lbnQgdG8gdGhlIGh0bWxFbENvbnRhaW5lciBwYXNzZWQgdG8gaXQuXG4gICAgICogICAgICAgICAgICAgIFRyYW5zcGFyZW50VmlkZW8gY2FuIGVpdGhlciBiZSBhbiBIVE1MIFZpZGVvIHRhZywgb3IgYW4gSFRNTCBDYW52YXMgVGFnLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGh0bWxFbENvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNJZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFRoZSB7QGxpbmsgVHJhbnNwYXJlbnRWaWRlb09wdGlvbnN9IG9wdGlvbnMgdG8gYXBwbHkgLSBFeHRlbmRzIFRyYW5zZm9ybWF0aW9uT3B0aW9uc1xuICAgICAqICAgICAgICAgICAgICAgICBvcHRpb25zLnBsYXlzaW5saW5lICAgIC0gSFRNTCBWaWRlbyBUYWcncyBuYXRpdmUgcGxheXNpbmxpbmUgLSBwYXNzZWQgdG8gdmlkZW8gZWxlbWVudC5cbiAgICAgKiAgICAgICAgICAgICAgICAgb3B0aW9ucy5wb3N0ZXIgICAgICAgICAtIEhUTUwgVmlkZW8gVGFnJ3MgbmF0aXZlIHBvc3RlciAtIHBhc3NlZCB0byB2aWRlbyBlbGVtZW50LlxuICAgICAqICAgICAgICAgICAgICAgICBvcHRpb25zLmxvb3AgICAgICAgICAgIC0gSFRNTCBWaWRlbyBUYWcncyBuYXRpdmUgbG9vcCAtIHBhc3NlZCB0byB2aWRlbyBlbGVtZW50LlxuICAgICAqICAgICAgICAgICAgICAgICBvcHRpb25zPy5leHRlcm5hbExpYnJhcmllcyA9IHsgW2tleTogc3RyaW5nXTogc3RyaW5nfSAtIG1hcCBvZiBleHRlcm5hbCBsaWJyYXJpZXMgdG8gYmUgbG9hZGVkXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxIVE1MRWxlbWVudCB8IHtzdGF0dXM6c3RyaW5nLCBtZXNzYWdlOnN0cmluZ30+fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImluamVjdFRyYW5zcGFyZW50VmlkZW9FbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluamVjdFRyYW5zcGFyZW50VmlkZW9FbGVtZW50KGh0bWxFbENvbnRhaW5lciwgcHVibGljSWQpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgaWYgKCFodG1sRWxDb250YWluZXIpIHtcbiAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0V4cGVjdGluZyBodG1sRWxDb250YWluZXIgdG8gYmUgSFRNTEVsZW1lbnQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNwYXJlbnRWaWRlb19lbmZvcmNlT3B0aW9uc0ZvclRyYW5zcGFyZW50VmlkZW8ob3B0aW9ucyk7XG4gICAgICAgIHZhciB2aWRlb1VSTCA9IF90aGlzMy52aWRlb191cmwocHVibGljSWQsIG9wdGlvbnMpO1xuICAgICAgICB0cmFuc3BhcmVudFZpZGVvX2NoZWNrU3VwcG9ydEZvclRyYW5zcGFyZW5jeSgpLnRoZW4oZnVuY3Rpb24gKGlzTmF0aXZlbHlUcmFuc3BhcmVudCkge1xuICAgICAgICAgIHZhciBtb3VudFByb21pc2U7XG4gICAgICAgICAgaWYgKGlzTmF0aXZlbHlUcmFuc3BhcmVudCkge1xuICAgICAgICAgICAgbW91bnRQcm9taXNlID0gdHJhbnNwYXJlbnRWaWRlb19tb3VudENsb3VkaW5hcnlWaWRlb1RhZyhodG1sRWxDb250YWluZXIsIF90aGlzMywgcHVibGljSWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmVzb2x2ZShodG1sRWxDb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb3VudFByb21pc2UgPSB0cmFuc3BhcmVudFZpZGVvX21vdW50U2VlVGhydUNhbnZhc1RhZyhodG1sRWxDb250YWluZXIsIHZpZGVvVVJMLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW91bnRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShodG1sRWxDb250YWluZXIpO1xuICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICAgIHZhciBzdGF0dXMgPSBfcmVmLnN0YXR1cyxcbiAgICAgICAgICAgICAgbWVzc2FnZSA9IF9yZWYubWVzc2FnZTtcbiAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIGNhdGNoIGZvciBjaGVja1N1cHBvcnRGb3JUcmFuc3BhcmVuY3koKVxuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgIHZhciBzdGF0dXMgPSBfcmVmMi5zdGF0dXMsXG4gICAgICAgICAgICBtZXNzYWdlID0gX3JlZjIubWVzc2FnZTtcbiAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwibmV3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9uZXcob3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKG9wdGlvbnMpO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuYXNzaWduX3Jvb3RfYXNzaWduX2RlZmF1bHQoKShjbG91ZGluYXJ5X0Nsb3VkaW5hcnksIGNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2xvdWRpbmFyeSA9IChjbG91ZGluYXJ5X0Nsb3VkaW5hcnkpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbmFtZXNwYWNlL2Nsb3VkaW5hcnktY29yZS5qc1xuLyoqXG4gKiBDcmVhdGVzIHRoZSBuYW1lc3BhY2UgZm9yIENsb3VkaW5hcnlcbiAqL1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNsb3VkaW5hcnlfY29yZSA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgQ2xpZW50SGludHNNZXRhVGFnOiBjbGllbnRoaW50c21ldGF0YWcsXG4gIENsb3VkaW5hcnk6IGNsb3VkaW5hcnksXG4gIENvbmRpdGlvbjogY29uZGl0aW9uLFxuICBDb25maWd1cmF0aW9uOiBzcmNfY29uZmlndXJhdGlvbixcbiAgY3JjMzI6IHNyY19jcmMzMixcbiAgRXhwcmVzc2lvbjogZXhwcmVzc2lvbixcbiAgRmV0Y2hMYXllcjogZmV0Y2hsYXllcixcbiAgSHRtbFRhZzogaHRtbHRhZyxcbiAgSW1hZ2VUYWc6IGltYWdldGFnLFxuICBMYXllcjogbGF5ZXJfbGF5ZXIsXG4gIFBpY3R1cmVUYWc6IHBpY3R1cmV0YWcsXG4gIFN1YnRpdGxlc0xheWVyOiBzdWJ0aXRsZXNsYXllcixcbiAgVGV4dExheWVyOiB0ZXh0bGF5ZXIsXG4gIFRyYW5zZm9ybWF0aW9uOiBzcmNfdHJhbnNmb3JtYXRpb24sXG4gIHV0ZjhfZW5jb2RlOiBzcmNfdXRmOF9lbmNvZGUsXG4gIFV0aWw6IGxvZGFzaF9uYW1lc3BhY2VPYmplY3QsXG4gIFZpZGVvVGFnOiB2aWRlb3RhZ1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2Fzc2lnblwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2Fzc2lnbl9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvY2xvbmVEZWVwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfY2xvbmVEZWVwX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9jb21wYWN0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfY29tcGFjdF9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvZGlmZmVyZW5jZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2RpZmZlcmVuY2VfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2Z1bmN0aW9uc1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2Z1bmN0aW9uc19fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvaWRlbnRpdHlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pZGVudGl0eV9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvaW5jbHVkZXNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pbmNsdWRlc19fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvaXNBcnJheVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzQXJyYXlfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2lzRWxlbWVudFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzRWxlbWVudF9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJsb2Rhc2gvaXNGdW5jdGlvblwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzRnVuY3Rpb25fXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwibG9kYXNoL2lzUGxhaW5PYmplY3RcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pc1BsYWluT2JqZWN0X187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9pc1N0cmluZ1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzU3RyaW5nX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC9tZXJnZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX21lcmdlX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImxvZGFzaC90cmltXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfdHJpbV9fO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyB9KTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xvdWRpbmFyeS1jb3JlLmpzLm1hcCJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJkZWZpbmUiLCJhbWQiLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9hc3NpZ25fXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2Nsb25lRGVlcF9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfY29tcGFjdF9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfZGlmZmVyZW5jZV9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfZnVuY3Rpb25zX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF9pZGVudGl0eV9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaW5jbHVkZXNfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzQXJyYXlfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX2lzRWxlbWVudF9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNGdW5jdGlvbl9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNQbGFpbk9iamVjdF9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfaXNTdHJpbmdfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX21lcmdlX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2xvZGFzaF90cmltX18iLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImkiLCJsIiwiY2FsbCIsIm0iLCJjIiwiZCIsIm5hbWUiLCJnZXR0ZXIiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiciIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJ0IiwibW9kZSIsIl9fZXNNb2R1bGUiLCJucyIsImNyZWF0ZSIsImtleSIsImJpbmQiLCJuIiwiZ2V0RGVmYXVsdCIsImdldE1vZHVsZUV4cG9ydHMiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiY2xpZW50aGludHNtZXRhdGFnIiwiY2xvdWRpbmFyeSIsImNvbmRpdGlvbiIsInNyY19jb25maWd1cmF0aW9uIiwic3JjX2NyYzMyIiwiZXhwcmVzc2lvbiIsImZldGNobGF5ZXIiLCJodG1sdGFnIiwiaW1hZ2V0YWciLCJsYXllcl9sYXllciIsInBpY3R1cmV0YWciLCJzdWJ0aXRsZXNsYXllciIsInRleHRsYXllciIsInNyY190cmFuc2Zvcm1hdGlvbiIsInNyY191dGY4X2VuY29kZSIsImxvZGFzaF9uYW1lc3BhY2VPYmplY3QiLCJ2aWRlb3RhZyIsImNvbnN0YW50c19uYW1lc3BhY2VPYmplY3QiLCJWRVJTSU9OIiwiQ0ZfU0hBUkVEX0NETiIsIk9MRF9BS0FNQUlfU0hBUkVEX0NETiIsIkFLQU1BSV9TSEFSRURfQ0ROIiwiU0hBUkVEX0NETiIsIkRFRkFVTFRfVElNRU9VVF9NUyIsIkRFRkFVTFRfUE9TVEVSX09QVElPTlMiLCJERUZBVUxUX1ZJREVPX1NPVVJDRV9UWVBFUyIsIlNFT19UWVBFUyIsIkRFRkFVTFRfSU1BR0VfUEFSQU1TIiwiREVGQVVMVF9WSURFT19QQVJBTVMiLCJERUZBVUxUX1ZJREVPX1NPVVJDRVMiLCJERUZBVUxUX0VYVEVSTkFMX0xJQlJBUklFUyIsIlBMQUNFSE9MREVSX0lNQUdFX01PREVTIiwiQUNDRVNTSUJJTElUWV9NT0RFUyIsIlVSTF9LRVlTIiwiZ2V0U0RLQW5hbHl0aWNzU2lnbmF0dXJlIiwiZ2V0QW5hbHl0aWNzT3B0aW9ucyIsImFzc2lnbl9yb290X2Fzc2lnbl9kZWZhdWx0IiwiYSIsImNsb25lRGVlcF9yb290X2Nsb25lRGVlcF9kZWZhdWx0IiwiY29tcGFjdF9yb290X2NvbXBhY3RfZGVmYXVsdCIsImRpZmZlcmVuY2Vfcm9vdF9kaWZmZXJlbmNlX2RlZmF1bHQiLCJmdW5jdGlvbnNfcm9vdF9mdW5jdGlvbnNfZGVmYXVsdCIsImlkZW50aXR5X3Jvb3RfaWRlbnRpdHlfZGVmYXVsdCIsImluY2x1ZGVzX3Jvb3RfaW5jbHVkZXNfZGVmYXVsdCIsImlzQXJyYXlfcm9vdF9pc0FycmF5X2RlZmF1bHQiLCJpc1BsYWluT2JqZWN0X3Jvb3RfaXNQbGFpbk9iamVjdF9kZWZhdWx0IiwiaXNTdHJpbmdfcm9vdF9pc1N0cmluZ19kZWZhdWx0IiwibWVyZ2Vfcm9vdF9tZXJnZV9kZWZhdWx0IiwiaXNJbnRlcnNlY3Rpb25PYnNlcnZlclN1cHBvcnRlZCIsImlzTmF0aXZlTGF6eUxvYWRTdXBwb3J0ZWQiLCJkZXRlY3RJbnRlcnNlY3Rpb24iLCJvbWl0IiwiYmFzZXV0aWxfYWxsU3RyaW5ncyIsIndpdGhvdXQiLCJpc051bWJlckxpa2UiLCJzbWFydEVzY2FwZSIsImRlZmF1bHRzIiwib2JqZWN0UHJvdG8iLCJvYmpUb1N0cmluZyIsImlzT2JqZWN0IiwiZnVuY1RhZyIsInJlV29yZHMiLCJjYW1lbENhc2UiLCJzbmFrZUNhc2UiLCJjb252ZXJ0S2V5cyIsIndpdGhDYW1lbENhc2VLZXlzIiwid2l0aFNuYWtlQ2FzZUtleXMiLCJiYXNlNjRFbmNvZGUiLCJiYXNlNjRFbmNvZGVVUkwiLCJleHRyYWN0VXJsUGFyYW1zIiwicGF0Y2hGZXRjaEZvcm1hdCIsIm9wdGlvbkNvbnN1bWUiLCJpc0VtcHR5IiwiaXNBbmRyb2lkIiwiaXNFZGdlIiwiaXNDaHJvbWUiLCJpc1NhZmFyaSIsImlzRWxlbWVudF9yb290X2lzRWxlbWVudF9kZWZhdWx0IiwiaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fZGVmYXVsdCIsInRyaW1fcm9vdF90cmltX2RlZmF1bHQiLCJsb2Rhc2hfZ2V0RGF0YSIsImxvZGFzaF9zZXREYXRhIiwibG9kYXNoX2dldEF0dHJpYnV0ZSIsImxvZGFzaF9zZXRBdHRyaWJ1dGUiLCJsb2Rhc2hfcmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlcyIsImxvZGFzaF9oYXNDbGFzcyIsImxvZGFzaF9hZGRDbGFzcyIsImdldFN0eWxlcyIsImNzc0V4cGFuZCIsImRvbVN0eWxlIiwiY3VyQ1NTIiwiY3NzVmFsdWUiLCJhdWdtZW50V2lkdGhPckhlaWdodCIsImdldFdpZHRoT3JIZWlnaHQiLCJsb2Rhc2hfd2lkdGgiLCJ1dGY4X2VuY29kZSIsImFyZ1N0cmluZyIsImMxIiwiZW5jIiwiZW5kIiwic3RhcnQiLCJzdHJpbmciLCJzdHJpbmdsIiwidXRmdGV4dCIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzbGljZSIsImNyYzMyIiwic3RyIiwiY3JjIiwiaVRvcCIsInRhYmxlIiwieCIsInkiLCJzdWJzdHIiLCJzdHJpbmdQYWQiLCJ0YXJnZXRMZW5ndGgiLCJwYWRTdHJpbmciLCJyZXBlYXRTdHJpbmdOdW1UaW1lcyIsInRpbWVzIiwicmVwZWF0ZWRTdHJpbmciLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiVHlwZUVycm9yIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJ0b1N0cmluZyIsImNvbnN0cnVjdG9yIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsIml0ZXIiLCJpdGVyYXRvciIsImlzQXJyYXkiLCJsZW4iLCJhcnIyIiwiY2hhcnMiLCJiYXNlNjRNYXBfbnVtIiwibWFwIiwiZm9yRWFjaCIsIl9jaGFyIiwiYmFzZTY0TWFwIiwicmV2ZXJzZVZlcnNpb24iLCJzZW1WZXIiLCJzcGxpdCIsIkVycm9yIiwicmV2ZXJzZSIsInNlZ21lbnQiLCJqb2luIiwiZW5jb2RlVmVyc2lvbiIsInN0clJlc3VsdCIsInBhcnRzIiwicGFkZGVkU3RyaW5nTGVuZ3RoIiwicGFkZGVkUmV2ZXJzZWRTZW12ZXIiLCJudW0iLCJwYXJzZUludCIsInBhZGRlZEJpbmFyeSIsIm1hdGNoIiwiYml0U3RyaW5nIiwiYW5hbHl0aWNzT3B0aW9ucyIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsInR3b1BhcnRWZXJzaW9uIiwicmVtb3ZlUGF0Y2hGcm9tU2VtdmVyIiwidGVjaFZlcnNpb24iLCJlbmNvZGVkU0RLVmVyc2lvbiIsInNka1NlbXZlciIsImVuY29kZWRUZWNoVmVyc2lvbiIsImZlYXR1cmVDb2RlIiwiZmVhdHVyZSIsIlNES0NvZGUiLCJzZGtDb2RlIiwiYWxnb1ZlcnNpb24iLCJjb25jYXQiLCJlIiwic2VtVmVyU3RyIiwib3B0aW9ucyIsInVybEFuYWx5dGljcyIsImFjY2Vzc2liaWxpdHkiLCJsb2FkaW5nIiwicmVzcG9uc2l2ZSIsInBsYWNlaG9sZGVyIiwiYXNzaWduX3Jvb3RfYXNzaWduXyIsImNsb25lRGVlcF9yb290X2Nsb25lRGVlcF8iLCJjb21wYWN0X3Jvb3RfY29tcGFjdF8iLCJkaWZmZXJlbmNlX3Jvb3RfZGlmZmVyZW5jZV8iLCJmdW5jdGlvbnNfcm9vdF9mdW5jdGlvbnNfIiwiaWRlbnRpdHlfcm9vdF9pZGVudGl0eV8iLCJpbmNsdWRlc19yb290X2luY2x1ZGVzXyIsImlzQXJyYXlfcm9vdF9pc0FycmF5XyIsImlzUGxhaW5PYmplY3Rfcm9vdF9pc1BsYWluT2JqZWN0XyIsImlzU3RyaW5nX3Jvb3RfaXNTdHJpbmdfIiwibWVyZ2Vfcm9vdF9tZXJnZV8iLCJpc0VsZW1lbnRfcm9vdF9pc0VsZW1lbnRfIiwiaXNGdW5jdGlvbl9yb290X2lzRnVuY3Rpb25fIiwidHJpbV9yb290X3RyaW1fIiwiX3R5cGVvZiIsIndpbmRvdyIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiSFRNTEltYWdlRWxlbWVudCIsImVsIiwib25JbnRlcnNlY3QiLCJvYnNlcnZlciIsImVudHJpZXMiLCJlbnRyeSIsImlzSW50ZXJzZWN0aW5nIiwidW5vYnNlcnZlIiwidGFyZ2V0IiwidGhyZXNob2xkIiwib2JzZXJ2ZSIsImZvcm1hdCIsInJlc291cmNlX3R5cGUiLCJ0cmFuc2Zvcm1hdGlvbiIsInR5cGUiLCJmYWxsYmFja19jb250ZW50Iiwic291cmNlX3RyYW5zZm9ybWF0aW9uIiwic291cmNlX3R5cGVzIiwiY29kZWNzIiwidHJhbnNmb3JtYXRpb25zIiwidmlkZW9fY29kZWMiLCJzZWVUaHJ1IiwiZWZmZWN0IiwicXVhbGl0eSIsImZldGNoX2Zvcm1hdCIsIndpZHRoIiwiYXNwZWN0X3JhdGlvIiwiY3JvcCIsImJhY2tncm91bmQiLCJoZWlnaHQiLCJncmF2aXR5IiwidmFyaWFibGVzIiwiZGFya21vZGUiLCJicmlnaHRtb2RlIiwibW9ub2Nocm9tZSIsImNvbG9yYmxpbmQiLCJiYXNldXRpbF90eXBlb2YiLCJvYmoiLCJrZXlzIiwic3JjS2V5cyIsImZpbHRlciIsImZpbHRlcmVkIiwiYWxsU3RyaW5ncyIsImxpc3QiLCJldmVyeSIsImFycmF5IiwiaXRlbSIsInYiLCJpc05hTiIsInBhcnNlRmxvYXQiLCJ1bnNhZmUiLCJyZXBsYWNlIiwidG9VcHBlckNhc2UiLCJkZXN0aW5hdGlvbiIsIl9sZW4iLCJzb3VyY2VzIiwiX2tleSIsInJlZHVjZSIsImRlc3QiLCJzb3VyY2UiLCJpc0Z1bmN0aW9uIiwibG93ZXIiLCJ1cHBlciIsIlJlZ0V4cCIsIndvcmRzIiwid29yZCIsImNoYXJBdCIsInRvTG9jYWxlVXBwZXJDYXNlIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJjb252ZXJ0ZXIiLCJyZXN1bHQiLCJidG9hIiwiQnVmZmVyIiwiaW5wdXQiLCJ1cmwiLCJkZWNvZGVVUkkiLCJlbmNvZGVVUkkiLCJvcHRpb25fbmFtZSIsImRlZmF1bHRfdmFsdWUiLCJzaXplIiwiZ2V0VXNlckFnZW50IiwibmF2aWdhdG9yIiwidXNlckFnZW50Iiwibm9kZUNvbnRhaW5zIiwiZ2V0RGF0YSIsImVsZW1lbnQiLCJnZXRBdHRyaWJ1dGUiLCJnZXRBdHRyIiwiZGF0YSIsImpRdWVyeSIsImZuIiwic2V0RGF0YSIsInNldEF0dHJpYnV0ZSIsInNldEF0dHIiLCJhdHRyIiwicmVtb3ZlQXR0cmlidXRlIiwiYXR0cmlidXRlcyIsInJlc3VsdHMiLCJwdXNoIiwiaGFzQ2xhc3MiLCJjbGFzc05hbWUiLCJhZGRDbGFzcyIsImVsZW0iLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJvcGVuZXIiLCJnZXRDb21wdXRlZFN0eWxlIiwiYiIsImFkb3duIiwiYnVwIiwibm9kZVR5cGUiLCJkb2N1bWVudEVsZW1lbnQiLCJwYXJlbnROb2RlIiwiY29udGFpbnMiLCJzdHlsZSIsImNvbXB1dGVkIiwibWF4V2lkdGgiLCJtaW5XaWR0aCIsInJldCIsInJtYXJnaW4iLCJnZXRQcm9wZXJ0eVZhbHVlIiwicm51bW5vbnB4IiwiY29udmVydCIsInN0eWxlcyIsInZhbCIsImV4dHJhIiwiaXNCb3JkZXJCb3giLCJzaWRlIiwic2lkZXMiLCJwbnVtIiwidmFsdWVJc0JvcmRlckJveCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiZXhwcmVzc2lvbl90eXBlb2YiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1Byb3BlcnR5S2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJOdW1iZXIiLCJFeHByZXNzaW9uIiwiZXhwcmVzc2lvblN0ciIsImV4cHJlc3Npb25zIiwibm9ybWFsaXplIiwic2VyaWFsaXplIiwiZ2V0UGFyZW50IiwicGFyZW50Iiwic2V0UGFyZW50IiwicHJlZGljYXRlIiwib3BlcmF0b3IiLCJPUEVSQVRPUlMiLCJhbmQiLCJvciIsInRoZW4iLCJhc3BlY3RSYXRpbyIsInBhZ2VDb3VudCIsImZhY2VDb3VudCIsIl92YWx1ZSIsIl9uZXciLCJvcGVyYXRvcnMiLCJvcGVyYXRvcnNQYXR0ZXJuIiwib3BlcmF0b3JzUmVwbGFjZVJFIiwicHJlZGVmaW5lZFZhcnNQYXR0ZXJuIiwiUFJFREVGSU5FRF9WQVJTIiwidXNlclZhcmlhYmxlUGF0dGVybiIsInZhcmlhYmxlc1JlcGxhY2VSRSIsInZhcmlhYmxlIiwiaW5pdGlhbFdpZHRoIiwiaW5pdGlhbEhlaWdodCIsImluaXRpYWxBc3BlY3RSYXRpbyIsImN1cnJlbnRQYWdlIiwidGFncyIsInBhZ2VYIiwicGFnZVkiLCJCT1VORFJZIiwiY29uZGl0aW9uX3R5cGVvZiIsImNvbmRpdGlvbl9jbGFzc0NhbGxDaGVjayIsImNvbmRpdGlvbl9kZWZpbmVQcm9wZXJ0aWVzIiwiY29uZGl0aW9uX3RvUHJvcGVydHlLZXkiLCJjb25kaXRpb25fY3JlYXRlQ2xhc3MiLCJjb25kaXRpb25fdG9QcmltaXRpdmUiLCJfY2FsbFN1cGVyIiwiX2dldFByb3RvdHlwZU9mIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsImFwcGx5Iiwic2VsZiIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJSZWZlcmVuY2VFcnJvciIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsIl9zZXRQcm90b3R5cGVPZiIsIkNvbmRpdGlvbiIsIl9FeHByZXNzaW9uIiwiY29uZGl0aW9uU3RyIiwiZHVyYXRpb24iLCJpbml0aWFsRHVyYXRpb24iLCJjb25maWd1cmF0aW9uX3R5cGVvZiIsIl9zbGljZWRUb0FycmF5IiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiY29uZmlndXJhdGlvbl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJjb25maWd1cmF0aW9uX2FycmF5TGlrZVRvQXJyYXkiLCJ1IiwiZiIsIm5leHQiLCJkb25lIiwiY29uZmlndXJhdGlvbl9jbGFzc0NhbGxDaGVjayIsImNvbmZpZ3VyYXRpb25fZGVmaW5lUHJvcGVydGllcyIsImNvbmZpZ3VyYXRpb25fdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYXRpb25fY3JlYXRlQ2xhc3MiLCJjb25maWd1cmF0aW9uX3RvUHJpbWl0aXZlIiwiY29uZmlndXJhdGlvbl9Db25maWd1cmF0aW9uIiwiQ29uZmlndXJhdGlvbiIsImNvbmZpZ3VyYXRpb24iLCJERUZBVUxUX0NPTkZJR1VSQVRJT05fUEFSQU1TIiwiaW5pdCIsImZyb21FbnZpcm9ubWVudCIsImZyb21Eb2N1bWVudCIsInNldCIsIm1lcmdlIiwiY29uZmlnIiwibWV0YV9lbGVtZW50cyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsIl90aGlzIiwiY2xvdWRpbmFyeV91cmwiLCJxdWVyeSIsInVyaSIsInVyaVJlZ2V4IiwicHJvY2VzcyIsImVudiIsIkNMT1VESU5BUllfVVJMIiwiZXhlYyIsIl92YWx1ZSRzcGxpdCIsIl92YWx1ZSRzcGxpdDIiLCJrIiwibmV3X2NvbmZpZyIsIm5ld192YWx1ZSIsInRvT3B0aW9ucyIsInJlc3BvbnNpdmVfY2xhc3MiLCJyZXNwb25zaXZlX3VzZV9icmVha3BvaW50cyIsInJvdW5kX2RwciIsInNlY3VyZSIsImxvY2F0aW9uIiwicHJvdG9jb2wiLCJDT05GSUdfUEFSQU1TIiwibGF5ZXJfdHlwZW9mIiwibGF5ZXJfY2xhc3NDYWxsQ2hlY2siLCJsYXllcl9kZWZpbmVQcm9wZXJ0aWVzIiwibGF5ZXJfdG9Qcm9wZXJ0eUtleSIsImxheWVyX2NyZWF0ZUNsYXNzIiwibGF5ZXJfdG9QcmltaXRpdmUiLCJsYXllcl9MYXllciIsIkxheWVyIiwicmVmIiwicmVzb3VyY2VUeXBlIiwicHVibGljSWQiLCJnZXRQdWJsaWNJZCIsImdldEZ1bGxQdWJsaWNJZCIsImNvbXBvbmVudHMiLCJjbG9uZSIsInRleHRsYXllcl90eXBlb2YiLCJ0ZXh0bGF5ZXJfY2xhc3NDYWxsQ2hlY2siLCJ0ZXh0bGF5ZXJfZGVmaW5lUHJvcGVydGllcyIsInRleHRsYXllcl90b1Byb3BlcnR5S2V5IiwidGV4dGxheWVyX2NyZWF0ZUNsYXNzIiwidGV4dGxheWVyX3RvUHJpbWl0aXZlIiwidGV4dGxheWVyX2NhbGxTdXBlciIsInRleHRsYXllcl9nZXRQcm90b3R5cGVPZiIsInRleHRsYXllcl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwidGV4dGxheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsInRleHRsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJ0ZXh0bGF5ZXJfaW5oZXJpdHMiLCJ0ZXh0bGF5ZXJfc2V0UHJvdG90eXBlT2YiLCJ0ZXh0bGF5ZXJfVGV4dExheWVyIiwiX0xheWVyIiwiVGV4dExheWVyIiwiX3Jlc291cmNlVHlwZSIsIl90eXBlIiwiX2Zvcm1hdCIsImZvbnRGYW1pbHkiLCJfZm9udEZhbWlseSIsImZvbnRTaXplIiwiX2ZvbnRTaXplIiwiZm9udFdlaWdodCIsIl9mb250V2VpZ2h0IiwiZm9udFN0eWxlIiwiX2ZvbnRTdHlsZSIsInRleHREZWNvcmF0aW9uIiwiX3RleHREZWNvcmF0aW9uIiwidGV4dEFsaWduIiwiX3RleHRBbGlnbiIsInN0cm9rZSIsIl9zdHJva2UiLCJsZXR0ZXJTcGFjaW5nIiwiX2xldHRlclNwYWNpbmciLCJsaW5lU3BhY2luZyIsIl9saW5lU3BhY2luZyIsImZvbnRIaW50aW5nIiwiX2ZvbnRIaW50aW5nIiwiZm9udEFudGlhbGlhc2luZyIsIl9mb250QW50aWFsaWFzaW5nIiwidGV4dCIsIl90ZXh0IiwidGV4dFN0eWxlIiwiX3RleHRTdHlsZSIsImhhc1B1YmxpY0lkIiwiaGFzU3R5bGUiLCJyZSIsInJlcyIsInRleHRTb3VyY2UiLCJ0ZXh0U3R5bGVJZGVudGlmaWVyIiwiaW5kZXgiLCJ1bnNoaWZ0Iiwic3VidGl0bGVzbGF5ZXJfdHlwZW9mIiwic3VidGl0bGVzbGF5ZXJfZGVmaW5lUHJvcGVydGllcyIsInN1YnRpdGxlc2xheWVyX3RvUHJvcGVydHlLZXkiLCJzdWJ0aXRsZXNsYXllcl9jcmVhdGVDbGFzcyIsInN1YnRpdGxlc2xheWVyX3RvUHJpbWl0aXZlIiwic3VidGl0bGVzbGF5ZXJfY2xhc3NDYWxsQ2hlY2siLCJzdWJ0aXRsZXNsYXllcl9jYWxsU3VwZXIiLCJzdWJ0aXRsZXNsYXllcl9nZXRQcm90b3R5cGVPZiIsInN1YnRpdGxlc2xheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJzdWJ0aXRsZXNsYXllcl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJzdWJ0aXRsZXNsYXllcl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzdWJ0aXRsZXNsYXllcl9pbmhlcml0cyIsInN1YnRpdGxlc2xheWVyX3NldFByb3RvdHlwZU9mIiwiU3VidGl0bGVzTGF5ZXIiLCJfVGV4dExheWVyIiwiZmV0Y2hsYXllcl90eXBlb2YiLCJmZXRjaGxheWVyX2NsYXNzQ2FsbENoZWNrIiwiZmV0Y2hsYXllcl9kZWZpbmVQcm9wZXJ0aWVzIiwiZmV0Y2hsYXllcl90b1Byb3BlcnR5S2V5IiwiZmV0Y2hsYXllcl9jcmVhdGVDbGFzcyIsImZldGNobGF5ZXJfdG9QcmltaXRpdmUiLCJmZXRjaGxheWVyX2NhbGxTdXBlciIsImZldGNobGF5ZXJfZ2V0UHJvdG90eXBlT2YiLCJmZXRjaGxheWVyX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJmZXRjaGxheWVyX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsImZldGNobGF5ZXJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiZmV0Y2hsYXllcl9pbmhlcml0cyIsImZldGNobGF5ZXJfc2V0UHJvdG90eXBlT2YiLCJmZXRjaGxheWVyX0ZldGNoTGF5ZXIiLCJGZXRjaExheWVyIiwiX3VybCIsInBhcmFtZXRlcnNfY2FsbFN1cGVyIiwicGFyYW1ldGVyc19nZXRQcm90b3R5cGVPZiIsInBhcmFtZXRlcnNfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInBhcmFtZXRlcnNfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwicGFyYW1ldGVyc190eXBlb2YiLCJwYXJhbWV0ZXJzX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIl9nZXQiLCJyZWNlaXZlciIsImJhc2UiLCJfc3VwZXJQcm9wQmFzZSIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJwYXJhbWV0ZXJzX2luaGVyaXRzIiwicGFyYW1ldGVyc19zZXRQcm90b3R5cGVPZiIsInBhcmFtZXRlcnNfY2xhc3NDYWxsQ2hlY2siLCJwYXJhbWV0ZXJzX2RlZmluZVByb3BlcnRpZXMiLCJwYXJhbWV0ZXJzX3RvUHJvcGVydHlLZXkiLCJwYXJhbWV0ZXJzX2NyZWF0ZUNsYXNzIiwicGFyYW1ldGVyc190b1ByaW1pdGl2ZSIsInBhcmFtZXRlcnNfUGFyYW0iLCJQYXJhbSIsInNob3J0TmFtZSIsIm9yaWdWYWx1ZSIsInZhbGlkIiwibm9ybV9jb2xvciIsImJ1aWxkX2FycmF5IiwiYXJnIiwicHJvY2Vzc192aWRlb19wYXJhbXMiLCJwYXJhbSIsInZpZGVvIiwiY29kZWMiLCJwcm9maWxlIiwibGV2ZWwiLCJiX2ZyYW1lcyIsInBhcmFtZXRlcnNfQXJyYXlQYXJhbSIsIl9QYXJhbSIsIkFycmF5UGFyYW0iLCJzZXAiLCJhcnJheVZhbHVlIiwiZmxhdCIsIl90aGlzMiIsInBhcmFtZXRlcnNfVHJhbnNmb3JtYXRpb25QYXJhbSIsIl9QYXJhbTIiLCJUcmFuc2Zvcm1hdGlvblBhcmFtIiwiX3RoaXMzIiwiX3RoaXM0Iiwiam9pbmVkIiwib3JpZ1ZhbHVlMSIsIm51bWJlcl9wYXR0ZXJuIiwib2Zmc2V0X2FueV9wYXR0ZXJuIiwicGFyYW1ldGVyc19SYW5nZVBhcmFtIiwiX1BhcmFtMyIsIlJhbmdlUGFyYW0iLCJub3JtX3JhbmdlX3ZhbHVlIiwib2Zmc2V0IiwibW9kaWZpZXIiLCJwYXJhbWV0ZXJzX1Jhd1BhcmFtIiwiX1BhcmFtNCIsIlJhd1BhcmFtIiwicGFyYW1ldGVyc19MYXllclBhcmFtIiwiX1BhcmFtNSIsIkxheWVyUGFyYW0iLCJsYXllck9wdGlvbnMiLCJsYXllciIsInBhcmFtZXRlcnNfRXhwcmVzc2lvblBhcmFtIiwiX1BhcmFtNiIsIkV4cHJlc3Npb25QYXJhbSIsInRyYW5zZm9ybWF0aW9uX2NhbGxTdXBlciIsInRyYW5zZm9ybWF0aW9uX2dldFByb3RvdHlwZU9mIiwidHJhbnNmb3JtYXRpb25fcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInRyYW5zZm9ybWF0aW9uX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsInRyYW5zZm9ybWF0aW9uX3R5cGVvZiIsInRyYW5zZm9ybWF0aW9uX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInRyYW5zZm9ybWF0aW9uX2luaGVyaXRzIiwidHJhbnNmb3JtYXRpb25fc2V0UHJvdG90eXBlT2YiLCJ0cmFuc2Zvcm1hdGlvbl9zbGljZWRUb0FycmF5IiwidHJhbnNmb3JtYXRpb25fYXJyYXlXaXRoSG9sZXMiLCJ0cmFuc2Zvcm1hdGlvbl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsInRyYW5zZm9ybWF0aW9uX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwidHJhbnNmb3JtYXRpb25fbm9uSXRlcmFibGVSZXN0IiwidHJhbnNmb3JtYXRpb25fYXJyYXlMaWtlVG9BcnJheSIsInRyYW5zZm9ybWF0aW9uX2NsYXNzQ2FsbENoZWNrIiwidHJhbnNmb3JtYXRpb25fZGVmaW5lUHJvcGVydGllcyIsInRyYW5zZm9ybWF0aW9uX3RvUHJvcGVydHlLZXkiLCJ0cmFuc2Zvcm1hdGlvbl9jcmVhdGVDbGFzcyIsInRyYW5zZm9ybWF0aW9uX3RvUHJpbWl0aXZlIiwiYXNzaWduTm90TnVsbCIsInRyYW5zZm9ybWF0aW9uX1RyYW5zZm9ybWF0aW9uQmFzZSIsIlRyYW5zZm9ybWF0aW9uQmFzZSIsInRyYW5zIiwid2l0aENoYWluIiwib3B0Iiwib3RoZXJPcHRpb25zIiwiY2hhaW5lZCIsInRyIiwiZnJvbU9wdGlvbnMiLCJhYmJyIiwiZGVmYXVsdFZhbHVlIiwicmF3UGFyYW0iLCJsYXN0QXJnQ2FsbGJhY2siLCJyYW5nZVBhcmFtIiwiYXJyYXlQYXJhbSIsInRyYW5zZm9ybWF0aW9uUGFyYW0iLCJsYXllclBhcmFtIiwiZ2V0VmFsdWUiLCJyZW1vdmUiLCJ0ZW1wIiwiVkFSX05BTUVfUkUiLCJzb3J0IiwidG9QbGFpbk9iamVjdCIsImhhc2giLCJjaGFpbiIsIm5hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInJlc2V0VHJhbnNmb3JtYXRpb25zIiwiZnJvbVRyYW5zZm9ybWF0aW9uIiwib3RoZXIiLCJjYW1lbEtleSIsIl9sZW4yIiwidmFsdWVzIiwiX2tleTIiLCJ0cmFuc2Zvcm1hdGlvbl9UcmFuc2Zvcm1hdGlvbiIsIm1ldGhvZHMiLCJoYXNMYXllciIsImlmUGFyYW0iLCJqIiwicGFyYW1MaXN0IiwicmVmMSIsInJlZjIiLCJyZWYzIiwicmVmNCIsInJlc3VsdEFycmF5IiwidHJhbnNmb3JtYXRpb25MaXN0IiwidHJhbnNmb3JtYXRpb25TdHJpbmciLCJ2YXJzIiwicHJvY2Vzc1ZhciIsImxlbjEiLCJwYXJhbV9zZXBhcmF0b3IiLCJ0cmFuc19zZXBhcmF0b3IiLCJ0b0h0bWxBdHRyaWJ1dGVzIiwiYXR0ck5hbWUiLCJzbmFrZUNhc2VLZXkiLCJQQVJBTV9OQU1FUyIsInRvSHRtbCIsImxpc3ROYW1lcyIsImlzVmFsaWRQYXJhbU5hbWUiLCJpbmRleE9mIiwiYXJncyIsImNhbGxiYWNrIiwidmFyQXJyYXkiLCJfdmFyQXJyYXkkaiIsInByb2Nlc3NDdXN0b21GdW5jdGlvbiIsIl9yZWYiLCJmdW5jdGlvbl90eXBlIiwiX1RyYW5zZm9ybWF0aW9uQmFzZSIsIlRyYW5zZm9ybWF0aW9uIiwiYW5nbGUiLCJhdWRpb0NvZGVjIiwiYXVkaW9GcmVxdWVuY3kiLCJiaXRSYXRlIiwiYm9yZGVyIiwiY29sb3IiLCJjb2xvclNwYWNlIiwiY3VzdG9tRnVuY3Rpb24iLCJjdXN0b21QcmVGdW5jdGlvbiIsImRlZmF1bHRJbWFnZSIsImRlbGF5IiwiZGVuc2l0eSIsImRwciIsIl9lbHNlIiwiZW5kSWYiLCJlbmRPZmZzZXQiLCJmYWxsYmFja0NvbnRlbnQiLCJmZXRjaEZvcm1hdCIsImZsYWdzIiwiZnBzIiwiaHRtbEhlaWdodCIsImh0bWxXaWR0aCIsIl9pZiIsImlmVmFsIiwidHJJZiIsInRyUmVzdCIsImtleWZyYW1lSW50ZXJ2YWwiLCJvY3IiLCJlbmRfbyIsInN0YXJ0X28iLCJfcmVmMiIsIl9yZWYzIiwic3RhcnRPZmZzZXQiLCJvcGFjaXR5Iiwib3ZlcmxheSIsInBhZ2UiLCJwb3N0ZXIiLCJwcmVmaXgiLCJyYWRpdXMiLCJyYXdUcmFuc2Zvcm1hdGlvbiIsInNvdXJjZVR5cGVzIiwic291cmNlVHJhbnNmb3JtYXRpb24iLCJzdHJlYW1pbmdQcm9maWxlIiwidW5kZXJsYXkiLCJ2aWRlb0NvZGVjIiwidmlkZW9TYW1wbGluZyIsInpvb20iLCJodG1sdGFnX3R5cGVvZiIsImh0bWx0YWdfY2xhc3NDYWxsQ2hlY2siLCJodG1sdGFnX2RlZmluZVByb3BlcnRpZXMiLCJodG1sdGFnX3RvUHJvcGVydHlLZXkiLCJodG1sdGFnX2NyZWF0ZUNsYXNzIiwiaHRtbHRhZ190b1ByaW1pdGl2ZSIsImh0bWx0YWdfSHRtbFRhZyIsIkh0bWxUYWciLCJodG1sQXR0cnMiLCJhdHRycyIsInBhaXJzIiwiZXNjYXBlUXVvdGVzIiwiaHRtbHRhZ190b0F0dHJpYnV0ZSIsImdldE9wdGlvbnMiLCJnZXRPcHRpb24iLCJodG1sQXR0cmlidXRlcyIsInJlbW92ZUF0dHIiLCJjb250ZW50Iiwib3BlblRhZyIsInRhZyIsImNsb3NlVGFnIiwidG9ET00iLCJjcmVhdGVFbGVtZW50IiwiaXNSZXNwb25zaXZlIiwicmVzcG9uc2l2ZUNsYXNzIiwiZGF0YVNyYyIsIl9leGNsdWRlZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsImV4Y2x1ZGVkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzb3VyY2VTeW1ib2xLZXlzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJzb3VyY2VLZXlzIiwibWFrZVVybCIsImhvc3QiLCJwYXRobmFtZSIsImlzVXJsIiwiY2RuU3ViZG9tYWluTnVtYmVyIiwiaGFuZGxlU2lnbmF0dXJlIiwic2lnbmF0dXJlIiwiaXNGb3JtYXR0ZWQiLCJoYW5kbGVQcmVmaXgiLCJjbG91ZF9uYW1lIiwiY2RuUGFydCIsInN1YmRvbWFpbiIsInBhdGgiLCJwcml2YXRlX2NkbiIsImNkbl9zdWJkb21haW4iLCJzZWN1cmVfY2RuX3N1YmRvbWFpbiIsInNlY3VyZV9kaXN0cmlidXRpb24iLCJjbmFtZSIsImhhbmRsZVJlc291cmNlVHlwZSIsIl9yZWYkcmVzb3VyY2VfdHlwZSIsIl9yZWYkdHlwZSIsInVybF9zdWZmaXgiLCJ1c2Vfcm9vdF9wYXRoIiwic2hvcnRlbiIsImVuY29kZVB1YmxpY0lkIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZm9ybWF0UHVibGljSWQiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlcnJvciIsInRydXN0X3B1YmxpY19pZCIsInZhbGlkYXRlIiwiaGFuZGxlVmVyc2lvbiIsImlzRm9yY2VWZXJzaW9uIiwiZm9yY2VfdmVyc2lvbiIsImlzVmVyc2lvbkV4aXN0IiwidmVyc2lvbiIsImhhbmRsZVRyYW5zZm9ybWF0aW9uIiwicGxhY2Vob2xkZXJUcmFuc2Zvcm1hdGlvbnMiLCJibHVyIiwicHJlcGFyZVB1YmxpY0lkIiwidXJsU3RyaW5nIiwicHJlcGFyZU9wdGlvbnMiLCJ1cmxfdXJsIiwicmVzdWx0VXJsIiwic2RrQW5hbHl0aWNzU2lnbmF0dXJlIiwiYXBwZW5kZXIiLCJhdXRoX3Rva2VuIiwiX2FwcGVuZGVyIiwiZ2VuZXJhdGVCcmVha3BvaW50c19zbGljZWRUb0FycmF5IiwiZ2VuZXJhdGVCcmVha3BvaW50c19hcnJheVdpdGhIb2xlcyIsImdlbmVyYXRlQnJlYWtwb2ludHNfaXRlcmFibGVUb0FycmF5TGltaXQiLCJnZW5lcmF0ZUJyZWFrcG9pbnRzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiZ2VuZXJhdGVCcmVha3BvaW50c19ub25JdGVyYWJsZVJlc3QiLCJnZW5lcmF0ZUJyZWFrcG9pbnRzX2FycmF5TGlrZVRvQXJyYXkiLCJnZW5lcmF0ZUJyZWFrcG9pbnRzIiwic3Jjc2V0IiwiYnJlYWtwb2ludHMiLCJfbWFwIiwibWluX3dpZHRoIiwibWF4X3dpZHRoIiwibWF4X2ltYWdlcyIsIl9tYXAyIiwic29tZSIsInN0ZXBTaXplIiwiTWF0aCIsImNlaWwiLCJtYXgiLCJjdXJyZW50Iiwic3Jjc2V0VXRpbHNfaXNFbXB0eSIsInNjYWxlZFVybCIsInB1YmxpY19pZCIsImNvbmZpZ1BhcmFtcyIsInJhd190cmFuc2Zvcm1hdGlvbiIsImdldE9yR2VuZXJhdGVCcmVha3BvaW50cyIsImdlbmVyYXRlU3Jjc2V0QXR0cmlidXRlIiwiZ2VuZXJhdGVTaXplc0F0dHJpYnV0ZSIsImdlbmVyYXRlSW1hZ2VSZXNwb25zaXZlQXR0cmlidXRlcyIsInNyY3NldERhdGEiLCJyZXNwb25zaXZlQXR0cmlidXRlcyIsImdlbmVyYXRlU2l6ZXMiLCJzaXplcyIsImdlbmVyYXRlU3Jjc2V0Iiwic3Jjc2V0QXR0ciIsInNpemVzQXR0ciIsImdlbmVyYXRlTWVkaWFBdHRyIiwibWVkaWFRdWVyeSIsInNyY3NldFVybCIsImltYWdldGFnX3R5cGVvZiIsImltYWdldGFnX2NsYXNzQ2FsbENoZWNrIiwiaW1hZ2V0YWdfZGVmaW5lUHJvcGVydGllcyIsImltYWdldGFnX3RvUHJvcGVydHlLZXkiLCJpbWFnZXRhZ19jcmVhdGVDbGFzcyIsImltYWdldGFnX3RvUHJpbWl0aXZlIiwiaW1hZ2V0YWdfY2FsbFN1cGVyIiwiaW1hZ2V0YWdfZ2V0UHJvdG90eXBlT2YiLCJpbWFnZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiaW1hZ2V0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiaW1hZ2V0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiaW1hZ2V0YWdfZ2V0IiwiaW1hZ2V0YWdfc3VwZXJQcm9wQmFzZSIsImltYWdldGFnX2luaGVyaXRzIiwiaW1hZ2V0YWdfc2V0UHJvdG90eXBlT2YiLCJpbWFnZXRhZ19JbWFnZVRhZyIsIl9IdG1sVGFnIiwiSW1hZ2VUYWciLCJzcmNBdHRyaWJ1dGUiLCJzcmNzZXRQYXJhbSIsImNsaWVudF9oaW50cyIsInNvdXJjZXRhZ190eXBlb2YiLCJzb3VyY2V0YWdfY2xhc3NDYWxsQ2hlY2siLCJzb3VyY2V0YWdfZGVmaW5lUHJvcGVydGllcyIsInNvdXJjZXRhZ190b1Byb3BlcnR5S2V5Iiwic291cmNldGFnX2NyZWF0ZUNsYXNzIiwic291cmNldGFnX3RvUHJpbWl0aXZlIiwic291cmNldGFnX2NhbGxTdXBlciIsInNvdXJjZXRhZ19nZXRQcm90b3R5cGVPZiIsInNvdXJjZXRhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwic291cmNldGFnX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsInNvdXJjZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzb3VyY2V0YWdfZ2V0Iiwic291cmNldGFnX3N1cGVyUHJvcEJhc2UiLCJzb3VyY2V0YWdfaW5oZXJpdHMiLCJzb3VyY2V0YWdfc2V0UHJvdG90eXBlT2YiLCJzb3VyY2V0YWdfU291cmNlVGFnIiwiU291cmNlVGFnIiwibWVkaWEiLCJzb3VyY2V0YWciLCJwaWN0dXJldGFnX3R5cGVvZiIsInBpY3R1cmV0YWdfY2xhc3NDYWxsQ2hlY2siLCJwaWN0dXJldGFnX2RlZmluZVByb3BlcnRpZXMiLCJwaWN0dXJldGFnX3RvUHJvcGVydHlLZXkiLCJwaWN0dXJldGFnX2NyZWF0ZUNsYXNzIiwicGljdHVyZXRhZ190b1ByaW1pdGl2ZSIsInBpY3R1cmV0YWdfY2FsbFN1cGVyIiwicGljdHVyZXRhZ19nZXRQcm90b3R5cGVPZiIsInBpY3R1cmV0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInBpY3R1cmV0YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwicGljdHVyZXRhZ19hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJwaWN0dXJldGFnX2dldCIsInBpY3R1cmV0YWdfc3VwZXJQcm9wQmFzZSIsInBpY3R1cmV0YWdfaW5oZXJpdHMiLCJwaWN0dXJldGFnX3NldFByb3RvdHlwZU9mIiwicGljdHVyZXRhZ19QaWN0dXJlVGFnIiwiUGljdHVyZVRhZyIsIndpZHRoTGlzdCIsInZpZGVvdGFnX3R5cGVvZiIsInZpZGVvdGFnX2NsYXNzQ2FsbENoZWNrIiwidmlkZW90YWdfZGVmaW5lUHJvcGVydGllcyIsInZpZGVvdGFnX3RvUHJvcGVydHlLZXkiLCJ2aWRlb3RhZ19jcmVhdGVDbGFzcyIsInZpZGVvdGFnX3RvUHJpbWl0aXZlIiwidmlkZW90YWdfY2FsbFN1cGVyIiwidmlkZW90YWdfZ2V0UHJvdG90eXBlT2YiLCJ2aWRlb3RhZ19wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwidmlkZW90YWdfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwidmlkZW90YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwidmlkZW90YWdfZ2V0IiwidmlkZW90YWdfc3VwZXJQcm9wQmFzZSIsInZpZGVvdGFnX2luaGVyaXRzIiwidmlkZW90YWdfc2V0UHJvdG90eXBlT2YiLCJWSURFT19UQUdfUEFSQU1TIiwidmlkZW90YWdfREVGQVVMVF9WSURFT19TT1VSQ0VfVFlQRVMiLCJ2aWRlb3RhZ19ERUZBVUxUX1BPU1RFUl9PUFRJT05TIiwidmlkZW90YWdfVmlkZW9UYWciLCJWaWRlb1RhZyIsInNldFNvdXJjZVRyYW5zZm9ybWF0aW9uIiwic2V0U291cmNlVHlwZXMiLCJzZXRQb3N0ZXIiLCJzZXRGYWxsYmFja0NvbnRlbnQiLCJmYWxsYmFjayIsImlubmVyVGFncyIsInNyYyIsImNyZWF0ZVNvdXJjZVRhZyIsInNyY1R5cGUiLCJkZWZhdWx0T3B0aW9ucyIsImhhc1NvdXJjZVRhZ3MiLCJzb3VyY2VUeXBlIiwibWltZVR5cGUiLCJ2aWRlb1R5cGUiLCJjb2RlY3NTdHIiLCJjbGllbnRoaW50c21ldGF0YWdfdHlwZW9mIiwiY2xpZW50aGludHNtZXRhdGFnX2NsYXNzQ2FsbENoZWNrIiwiY2xpZW50aGludHNtZXRhdGFnX2RlZmluZVByb3BlcnRpZXMiLCJjbGllbnRoaW50c21ldGF0YWdfdG9Qcm9wZXJ0eUtleSIsImNsaWVudGhpbnRzbWV0YXRhZ19jcmVhdGVDbGFzcyIsImNsaWVudGhpbnRzbWV0YXRhZ190b1ByaW1pdGl2ZSIsImNsaWVudGhpbnRzbWV0YXRhZ19jYWxsU3VwZXIiLCJjbGllbnRoaW50c21ldGF0YWdfZ2V0UHJvdG90eXBlT2YiLCJjbGllbnRoaW50c21ldGF0YWdfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsImNsaWVudGhpbnRzbWV0YXRhZ19pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJjbGllbnRoaW50c21ldGF0YWdfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiY2xpZW50aGludHNtZXRhdGFnX2luaGVyaXRzIiwiY2xpZW50aGludHNtZXRhdGFnX3NldFByb3RvdHlwZU9mIiwiY2xpZW50aGludHNtZXRhdGFnX0NsaWVudEhpbnRzTWV0YVRhZyIsIkNsaWVudEhpbnRzTWV0YVRhZyIsIm5vcm1hbGl6ZVRvQXJyYXlfdG9Db25zdW1hYmxlQXJyYXkiLCJub3JtYWxpemVUb0FycmF5X2FycmF5V2l0aG91dEhvbGVzIiwibm9ybWFsaXplVG9BcnJheV9pdGVyYWJsZVRvQXJyYXkiLCJub3JtYWxpemVUb0FycmF5X3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5Iiwibm9ybWFsaXplVG9BcnJheV9ub25JdGVyYWJsZVNwcmVhZCIsIm5vcm1hbGl6ZVRvQXJyYXlfYXJyYXlMaWtlVG9BcnJheSIsIm5vcm1hbGl6ZVRvQXJyYXkiLCJlbGVtZW50cyIsIm1vdW50Q2xvdWRpbmFyeVZpZGVvVGFnIiwiaHRtbEVsQ29udGFpbmVyIiwiY2xJbnN0YW5jZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiaW5uZXJIVE1MIiwidmlkZW9UYWciLCJjbG91ZGluYXJ5VmlkZW9FbGVtZW50IiwicXVlcnlTZWxlY3RvciIsInRyYW5zcGFyZW50VmlkZW9fbW91bnRDbG91ZGluYXJ5VmlkZW9UYWciLCJhZGRGbGFnVG9PcHRpb25zIiwiZmxhZyIsImFkZEZsYWciLCJlbmZvcmNlT3B0aW9uc0ZvclRyYW5zcGFyZW50VmlkZW8iLCJhdXRvcGxheSIsIm11dGVkIiwiY29udHJvbHMiLCJtYXhfdGltZW91dF9tcyIsImV4dGVybmFsTGlicmFyaWVzIiwidHJhbnNwYXJlbnRWaWRlb19lbmZvcmNlT3B0aW9uc0ZvclRyYW5zcGFyZW50VmlkZW8iLCJsb2FkU2NyaXB0Iiwic2NyaXB0VVJMIiwiaXNBbHJlYWR5TG9hZGVkIiwic2NyaXB0VGFnIiwidGltZXJJRCIsInNldFRpbWVvdXQiLCJzdGF0dXMiLCJtZXNzYWdlIiwib25lcnJvciIsImNsZWFyVGltZW91dCIsIm9ubG9hZCIsImhlYWQiLCJhcHBlbmRDaGlsZCIsInhocl9sb2FkU2NyaXB0IiwicmVqZWN0T25UaW1lb3V0IiwibWF4VGltZW91dE1TIiwiZ2V0QmxvYkZyb21VUkwiLCJ1cmxUb0xvYWQiLCJmZXRjaEJsb2IiLCJmZXRjaCIsImxvYWRVcmxVc2luZ0ZldGNoIiwibG9hZFVybFVzaW5nWGhyIiwiYmxvYiIsInBheWxvYWQiLCJibG9iVVJMIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwicmVzcG9uc2UiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsInJlc3BvbnNlVHlwZSIsIm9wZW4iLCJzZW5kIiwieGhyX2dldEJsb2JGcm9tVVJMIiwiY3JlYXRlSGlkZGVuVmlkZW9UYWciLCJ2aWRlb09wdGlvbnMiLCJwbGF5c2lubGluZSIsImxvb3AiLCJ2aWRlb1VSTCIsInZpc2liaWxpdHkiLCJwb3NpdGlvbiIsInJldm9rZU9iamVjdFVSTCIsInRyYW5zcGFyZW50VmlkZW9fY3JlYXRlSGlkZGVuVmlkZW9UYWciLCJpbnN0YW50aWF0ZVNlZVRocnUiLCJ2aWRlb0VsZW1lbnQiLCJjdXN0b21DbGFzcyIsImF1dG9QbGF5IiwiX3dpbmRvdyIsInNlZVRocnVJbnN0YW5jZSIsInJlYWR5IiwiY2FudmFzRWxlbWVudCIsImdldENhbnZhcyIsInBsYXkiLCJ0cmFuc3BhcmVudFZpZGVvX2luc3RhbnRpYXRlU2VlVGhydSIsIm1vdW50U2VlVGhydUNhbnZhc1RhZyIsImVyciIsInRyYW5zcGFyZW50VmlkZW9fbW91bnRTZWVUaHJ1Q2FudmFzVGFnIiwiY2hlY2tTdXBwb3J0Rm9yVHJhbnNwYXJlbmN5IiwiY2FuUGxheSIsImNhblBsYXlUeXBlIiwidHJhbnNwYXJlbnRWaWRlb19jaGVja1N1cHBvcnRGb3JUcmFuc3BhcmVuY3kiLCJjbG91ZGluYXJ5X3R5cGVvZiIsImNsb3VkaW5hcnlfY2xhc3NDYWxsQ2hlY2siLCJjbG91ZGluYXJ5X2RlZmluZVByb3BlcnRpZXMiLCJjbG91ZGluYXJ5X3RvUHJvcGVydHlLZXkiLCJjbG91ZGluYXJ5X2NyZWF0ZUNsYXNzIiwiY2xvdWRpbmFyeV90b1ByaW1pdGl2ZSIsImFwcGx5QnJlYWtwb2ludHMiLCJjbG9zZXN0QWJvdmUiLCJkZWZhdWx0QnJlYWtwb2ludHMiLCJjbG91ZGluYXJ5X2ZpbmRDb250YWluZXJXaWR0aCIsImNsb3VkaW5hcnlfbWF4V2lkdGgiLCJ1cGRhdGVEcHIiLCJzdGVwcyIsInJlc2l6aW5nIiwiY2FsY19icmVha3BvaW50IiwiZmluZENvbnRhaW5lcldpZHRoIiwiY29udGFpbmVyV2lkdGgiLCJFbGVtZW50IiwiZGlzcGxheSIsInJvdW5kRHByIiwiZGV2aWNlX3BpeGVsX3JhdGlvIiwicmVxdWlyZWRXaWR0aCIsImltYWdlV2lkdGgiLCJjbG91ZGluYXJ5X0Nsb3VkaW5hcnkiLCJDbG91ZGluYXJ5IiwiZGV2aWNlUGl4ZWxSYXRpb0NhY2hlIiwicmVzcG9uc2l2ZUNvbmZpZyIsInJlc3BvbnNpdmVSZXNpemVJbml0aWFsaXplZCIsIm5ld0NvbmZpZyIsIm5ld1ZhbHVlIiwidmlkZW9fdXJsIiwidmlkZW9fdGh1bWJuYWlsX3VybCIsInRyYW5zZm9ybWF0aW9uX3N0cmluZyIsImltYWdlIiwiaW1nIiwiaW1hZ2VUYWciLCJjbG91ZGluYXJ5X3VwZGF0ZSIsInBpY3R1cmVUYWciLCJzb3VyY2VUYWciLCJ2aWRlb190aHVtYm5haWwiLCJmYWNlYm9va19wcm9maWxlX2ltYWdlIiwidHdpdHRlcl9wcm9maWxlX2ltYWdlIiwidHdpdHRlcl9uYW1lX3Byb2ZpbGVfaW1hZ2UiLCJncmF2YXRhcl9pbWFnZSIsImZldGNoX2ltYWdlIiwic3ByaXRlX2NzcyIsImJvb3RzdHJhcCIsInJlc3BvbnNpdmVSZXNpemUiLCJ0aW1lb3V0IiwicmVzcG9uc2l2ZV9yZXNpemUiLCJtYWtlUmVzcG9uc2l2ZSIsImRlYm91bmNlIiwicmVzZXQiLCJydW4iLCJ3YWl0Iiwid2FpdEZ1bmMiLCJyZXNwb25zaXZlX2RlYm91bmNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwb2ludCIsImNhbGNfc3RvcHBvaW50IiwiZGV2aWNlUGl4ZWxSYXRpbyIsImRwclN0cmluZyIsInByb2Nlc3NJbWFnZVRhZ3MiLCJub2RlcyIsImltYWdlcyIsIm5vZGUiLCJ0YWdOYW1lIiwiaW1nT3B0aW9ucyIsInNldFVybCIsInJlc3BvbnNpdmVfcHJlc2VydmVfaGVpZ2h0IiwiaXNMYXp5TG9hZGluZyIsImlzTGF6eUxvYWRTdXBwb3J0ZWQiLCJzZXRBdHRyaWJ1dGVJZkV4aXN0cyIsInRvQXR0cmlidXRlIiwiZnJvbUF0dHJpYnV0ZSIsImF0dHJpYnV0ZVZhbHVlIiwiaW5qZWN0VHJhbnNwYXJlbnRWaWRlb0VsZW1lbnQiLCJpc05hdGl2ZWx5VHJhbnNwYXJlbnQiLCJtb3VudFByb21pc2UiLCJjbG91ZGluYXJ5X2NvcmUiLCJVdGlsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cloudinary-core/cloudinary-core.js\n");

/***/ })

};
;