"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pvtsutils";
exports.ids = ["vendor-chunks/pvtsutils"];
exports.modules = {

/***/ "(action-browser)/./node_modules/pvtsutils/build/index.es.js":
/*!**************************************************!*\
  !*** ./node_modules/pvtsutils/build/index.es.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BufferSourceConverter: () => (/* binding */ BufferSourceConverter),\n/* harmony export */   Convert: () => (/* binding */ Convert),\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   combine: () => (/* binding */ combine),\n/* harmony export */   isEqual: () => (/* binding */ isEqual)\n/* harmony export */ });\n/*!\n * MIT License\n * \n * Copyright (c) 2017-2024 Peculiar Ventures, LLC\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n * \n */ const ARRAY_BUFFER_NAME = \"[object ArrayBuffer]\";\nclass BufferSourceConverter {\n    static isArrayBuffer(data) {\n        return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;\n    }\n    static toArrayBuffer(data) {\n        if (this.isArrayBuffer(data)) {\n            return data;\n        }\n        if (data.byteLength === data.buffer.byteLength) {\n            return data.buffer;\n        }\n        if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n            return data.buffer;\n        }\n        return this.toUint8Array(data.buffer).slice(data.byteOffset, data.byteOffset + data.byteLength).buffer;\n    }\n    static toUint8Array(data) {\n        return this.toView(data, Uint8Array);\n    }\n    static toView(data, type) {\n        if (data.constructor === type) {\n            return data;\n        }\n        if (this.isArrayBuffer(data)) {\n            return new type(data);\n        }\n        if (this.isArrayBufferView(data)) {\n            return new type(data.buffer, data.byteOffset, data.byteLength);\n        }\n        throw new TypeError(\"The provided value is not of type '(ArrayBuffer or ArrayBufferView)'\");\n    }\n    static isBufferSource(data) {\n        return this.isArrayBufferView(data) || this.isArrayBuffer(data);\n    }\n    static isArrayBufferView(data) {\n        return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);\n    }\n    static isEqual(a, b) {\n        const aView = BufferSourceConverter.toUint8Array(a);\n        const bView = BufferSourceConverter.toUint8Array(b);\n        if (aView.length !== bView.byteLength) {\n            return false;\n        }\n        for(let i = 0; i < aView.length; i++){\n            if (aView[i] !== bView[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static concat(...args) {\n        let buffers;\n        if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {\n            buffers = args[0];\n        } else if (Array.isArray(args[0]) && args[1] instanceof Function) {\n            buffers = args[0];\n        } else {\n            if (args[args.length - 1] instanceof Function) {\n                buffers = args.slice(0, args.length - 1);\n            } else {\n                buffers = args;\n            }\n        }\n        let size = 0;\n        for (const buffer of buffers){\n            size += buffer.byteLength;\n        }\n        const res = new Uint8Array(size);\n        let offset = 0;\n        for (const buffer of buffers){\n            const view = this.toUint8Array(buffer);\n            res.set(view, offset);\n            offset += view.length;\n        }\n        if (args[args.length - 1] instanceof Function) {\n            return this.toView(res, args[args.length - 1]);\n        }\n        return res.buffer;\n    }\n}\nconst STRING_TYPE = \"string\";\nconst HEX_REGEX = /^[0-9a-f\\s]+$/i;\nconst BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;\nconst BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;\nclass Utf8Converter {\n    static fromString(text) {\n        const s = unescape(encodeURIComponent(text));\n        const uintArray = new Uint8Array(s.length);\n        for(let i = 0; i < s.length; i++){\n            uintArray[i] = s.charCodeAt(i);\n        }\n        return uintArray.buffer;\n    }\n    static toString(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        let encodedString = \"\";\n        for(let i = 0; i < buf.length; i++){\n            encodedString += String.fromCharCode(buf[i]);\n        }\n        const decodedString = decodeURIComponent(escape(encodedString));\n        return decodedString;\n    }\n}\nclass Utf16Converter {\n    static toString(buffer, littleEndian = false) {\n        const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);\n        const dataView = new DataView(arrayBuffer);\n        let res = \"\";\n        for(let i = 0; i < arrayBuffer.byteLength; i += 2){\n            const code = dataView.getUint16(i, littleEndian);\n            res += String.fromCharCode(code);\n        }\n        return res;\n    }\n    static fromString(text, littleEndian = false) {\n        const res = new ArrayBuffer(text.length * 2);\n        const dataView = new DataView(res);\n        for(let i = 0; i < text.length; i++){\n            dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);\n        }\n        return res;\n    }\n}\nclass Convert {\n    static isHex(data) {\n        return typeof data === STRING_TYPE && HEX_REGEX.test(data);\n    }\n    static isBase64(data) {\n        return typeof data === STRING_TYPE && BASE64_REGEX.test(data);\n    }\n    static isBase64Url(data) {\n        return typeof data === STRING_TYPE && BASE64URL_REGEX.test(data);\n    }\n    static ToString(buffer, enc = \"utf8\") {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        switch(enc.toLowerCase()){\n            case \"utf8\":\n                return this.ToUtf8String(buf);\n            case \"binary\":\n                return this.ToBinary(buf);\n            case \"hex\":\n                return this.ToHex(buf);\n            case \"base64\":\n                return this.ToBase64(buf);\n            case \"base64url\":\n                return this.ToBase64Url(buf);\n            case \"utf16le\":\n                return Utf16Converter.toString(buf, true);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.toString(buf);\n            default:\n                throw new Error(`Unknown type of encoding '${enc}'`);\n        }\n    }\n    static FromString(str, enc = \"utf8\") {\n        if (!str) {\n            return new ArrayBuffer(0);\n        }\n        switch(enc.toLowerCase()){\n            case \"utf8\":\n                return this.FromUtf8String(str);\n            case \"binary\":\n                return this.FromBinary(str);\n            case \"hex\":\n                return this.FromHex(str);\n            case \"base64\":\n                return this.FromBase64(str);\n            case \"base64url\":\n                return this.FromBase64Url(str);\n            case \"utf16le\":\n                return Utf16Converter.fromString(str, true);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.fromString(str);\n            default:\n                throw new Error(`Unknown type of encoding '${enc}'`);\n        }\n    }\n    static ToBase64(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        if (typeof btoa !== \"undefined\") {\n            const binary = this.ToString(buf, \"binary\");\n            return btoa(binary);\n        } else {\n            return Buffer.from(buf).toString(\"base64\");\n        }\n    }\n    static FromBase64(base64) {\n        const formatted = this.formatString(base64);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isBase64(formatted)) {\n            throw new TypeError(\"Argument 'base64Text' is not Base64 encoded\");\n        }\n        if (typeof atob !== \"undefined\") {\n            return this.FromBinary(atob(formatted));\n        } else {\n            return new Uint8Array(Buffer.from(formatted, \"base64\")).buffer;\n        }\n    }\n    static FromBase64Url(base64url) {\n        const formatted = this.formatString(base64url);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isBase64Url(formatted)) {\n            throw new TypeError(\"Argument 'base64url' is not Base64Url encoded\");\n        }\n        return this.FromBase64(this.Base64Padding(formatted.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\")));\n    }\n    static ToBase64Url(data) {\n        return this.ToBase64(data).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/\\=/g, \"\");\n    }\n    static FromUtf8String(text, encoding = Convert.DEFAULT_UTF8_ENCODING) {\n        switch(encoding){\n            case \"ascii\":\n                return this.FromBinary(text);\n            case \"utf8\":\n                return Utf8Converter.fromString(text);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.fromString(text);\n            case \"utf16le\":\n            case \"usc2\":\n                return Utf16Converter.fromString(text, true);\n            default:\n                throw new Error(`Unknown type of encoding '${encoding}'`);\n        }\n    }\n    static ToUtf8String(buffer, encoding = Convert.DEFAULT_UTF8_ENCODING) {\n        switch(encoding){\n            case \"ascii\":\n                return this.ToBinary(buffer);\n            case \"utf8\":\n                return Utf8Converter.toString(buffer);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.toString(buffer);\n            case \"utf16le\":\n            case \"usc2\":\n                return Utf16Converter.toString(buffer, true);\n            default:\n                throw new Error(`Unknown type of encoding '${encoding}'`);\n        }\n    }\n    static FromBinary(text) {\n        const stringLength = text.length;\n        const resultView = new Uint8Array(stringLength);\n        for(let i = 0; i < stringLength; i++){\n            resultView[i] = text.charCodeAt(i);\n        }\n        return resultView.buffer;\n    }\n    static ToBinary(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        let res = \"\";\n        for(let i = 0; i < buf.length; i++){\n            res += String.fromCharCode(buf[i]);\n        }\n        return res;\n    }\n    static ToHex(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        let result = \"\";\n        const len = buf.length;\n        for(let i = 0; i < len; i++){\n            const byte = buf[i];\n            if (byte < 16) {\n                result += \"0\";\n            }\n            result += byte.toString(16);\n        }\n        return result;\n    }\n    static FromHex(hexString) {\n        let formatted = this.formatString(hexString);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isHex(formatted)) {\n            throw new TypeError(\"Argument 'hexString' is not HEX encoded\");\n        }\n        if (formatted.length % 2) {\n            formatted = `0${formatted}`;\n        }\n        const res = new Uint8Array(formatted.length / 2);\n        for(let i = 0; i < formatted.length; i = i + 2){\n            const c = formatted.slice(i, i + 2);\n            res[i / 2] = parseInt(c, 16);\n        }\n        return res.buffer;\n    }\n    static ToUtf16String(buffer, littleEndian = false) {\n        return Utf16Converter.toString(buffer, littleEndian);\n    }\n    static FromUtf16String(text, littleEndian = false) {\n        return Utf16Converter.fromString(text, littleEndian);\n    }\n    static Base64Padding(base64) {\n        const padCount = 4 - base64.length % 4;\n        if (padCount < 4) {\n            for(let i = 0; i < padCount; i++){\n                base64 += \"=\";\n            }\n        }\n        return base64;\n    }\n    static formatString(data) {\n        return (data === null || data === void 0 ? void 0 : data.replace(/[\\n\\r\\t ]/g, \"\")) || \"\";\n    }\n}\nConvert.DEFAULT_UTF8_ENCODING = \"utf8\";\nfunction assign(target, ...sources) {\n    const res = arguments[0];\n    for(let i = 1; i < arguments.length; i++){\n        const obj = arguments[i];\n        for(const prop in obj){\n            res[prop] = obj[prop];\n        }\n    }\n    return res;\n}\nfunction combine(...buf) {\n    const totalByteLength = buf.map((item)=>item.byteLength).reduce((prev, cur)=>prev + cur);\n    const res = new Uint8Array(totalByteLength);\n    let currentPos = 0;\n    buf.map((item)=>new Uint8Array(item)).forEach((arr)=>{\n        for (const item2 of arr){\n            res[currentPos++] = item2;\n        }\n    });\n    return res.buffer;\n}\nfunction isEqual(bytes1, bytes2) {\n    if (!(bytes1 && bytes2)) {\n        return false;\n    }\n    if (bytes1.byteLength !== bytes2.byteLength) {\n        return false;\n    }\n    const b1 = new Uint8Array(bytes1);\n    const b2 = new Uint8Array(bytes2);\n    for(let i = 0; i < bytes1.byteLength; i++){\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wdnRzdXRpbHMvYnVpbGQvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1QkMsR0FFRCxNQUFNQSxvQkFBb0I7QUFDMUIsTUFBTUM7SUFDRixPQUFPQyxjQUFjQyxJQUFJLEVBQUU7UUFDdkIsT0FBT0MsT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ0osVUFBVUg7SUFDcEQ7SUFDQSxPQUFPUSxjQUFjTCxJQUFJLEVBQUU7UUFDdkIsSUFBSSxJQUFJLENBQUNELGFBQWEsQ0FBQ0MsT0FBTztZQUMxQixPQUFPQTtRQUNYO1FBQ0EsSUFBSUEsS0FBS00sVUFBVSxLQUFLTixLQUFLTyxNQUFNLENBQUNELFVBQVUsRUFBRTtZQUM1QyxPQUFPTixLQUFLTyxNQUFNO1FBQ3RCO1FBQ0EsSUFBSVAsS0FBS1EsVUFBVSxLQUFLLEtBQUtSLEtBQUtNLFVBQVUsS0FBS04sS0FBS08sTUFBTSxDQUFDRCxVQUFVLEVBQUU7WUFDckUsT0FBT04sS0FBS08sTUFBTTtRQUN0QjtRQUNBLE9BQU8sSUFBSSxDQUFDRSxZQUFZLENBQUNULEtBQUtPLE1BQU0sRUFDL0JHLEtBQUssQ0FBQ1YsS0FBS1EsVUFBVSxFQUFFUixLQUFLUSxVQUFVLEdBQUdSLEtBQUtNLFVBQVUsRUFDeERDLE1BQU07SUFDZjtJQUNBLE9BQU9FLGFBQWFULElBQUksRUFBRTtRQUN0QixPQUFPLElBQUksQ0FBQ1csTUFBTSxDQUFDWCxNQUFNWTtJQUM3QjtJQUNBLE9BQU9ELE9BQU9YLElBQUksRUFBRWEsSUFBSSxFQUFFO1FBQ3RCLElBQUliLEtBQUtjLFdBQVcsS0FBS0QsTUFBTTtZQUMzQixPQUFPYjtRQUNYO1FBQ0EsSUFBSSxJQUFJLENBQUNELGFBQWEsQ0FBQ0MsT0FBTztZQUMxQixPQUFPLElBQUlhLEtBQUtiO1FBQ3BCO1FBQ0EsSUFBSSxJQUFJLENBQUNlLGlC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VSxFQUFFO1FBQ3pDLE9BQU87SUFDWDtJQUNBLE1BQU0ySCxLQUFLLElBQUlySCxXQUFXbUg7SUFDMUIsTUFBTUcsS0FBSyxJQUFJdEgsV0FBV29IO0lBQzFCLElBQUssSUFBSXRHLElBQUksR0FBR0EsSUFBSXFHLE9BQU96SCxVQUFVLEVBQUVvQixJQUFLO1FBQ3hDLElBQUl1RyxFQUFFLENBQUN2RyxFQUFFLEtBQUt3RyxFQUFFLENBQUN4RyxFQUFFLEVBQUU7WUFDakIsT0FBTztRQUNYO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFFb0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYWlnb254YW5oLy4vbm9kZV9tb2R1bGVzL3B2dHN1dGlscy9idWlsZC9pbmRleC5lcy5qcz80YTc0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTUlUIExpY2Vuc2VcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE3LTIwMjQgUGVjdWxpYXIgVmVudHVyZXMsIExMQ1xuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKiBcbiAqL1xuXG5jb25zdCBBUlJBWV9CVUZGRVJfTkFNRSA9IFwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIjtcbmNsYXNzIEJ1ZmZlclNvdXJjZUNvbnZlcnRlciB7XG4gICAgc3RhdGljIGlzQXJyYXlCdWZmZXIoZGF0YSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpID09PSBBUlJBWV9CVUZGRVJfTkFNRTtcbiAgICB9XG4gICAgc3RhdGljIHRvQXJyYXlCdWZmZXIoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5pc0FycmF5QnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5ieXRlTGVuZ3RoID09PSBkYXRhLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuYnl0ZU9mZnNldCA9PT0gMCAmJiBkYXRhLmJ5dGVMZW5ndGggPT09IGRhdGEuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50b1VpbnQ4QXJyYXkoZGF0YS5idWZmZXIpXG4gICAgICAgICAgICAuc2xpY2UoZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVPZmZzZXQgKyBkYXRhLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAuYnVmZmVyO1xuICAgIH1cbiAgICBzdGF0aWMgdG9VaW50OEFycmF5KGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9WaWV3KGRhdGEsIFVpbnQ4QXJyYXkpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9WaWV3KGRhdGEsIHR5cGUpIHtcbiAgICAgICAgaWYgKGRhdGEuY29uc3RydWN0b3IgPT09IHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXlCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdHlwZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0eXBlKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBwcm92aWRlZCB2YWx1ZSBpcyBub3Qgb2YgdHlwZSAnKEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldyknXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNCdWZmZXJTb3VyY2UoZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKVxuICAgICAgICAgICAgfHwgdGhpcy5pc0FycmF5QnVmZmVyKGRhdGEpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkge1xuICAgICAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpXG4gICAgICAgICAgICB8fCAoZGF0YSAmJiB0aGlzLmlzQXJyYXlCdWZmZXIoZGF0YS5idWZmZXIpKTtcbiAgICB9XG4gICAgc3RhdGljIGlzRXF1YWwoYSwgYikge1xuICAgICAgICBjb25zdCBhVmlldyA9IEJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoYSk7XG4gICAgICAgIGNvbnN0IGJWaWV3ID0gQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShiKTtcbiAgICAgICAgaWYgKGFWaWV3Lmxlbmd0aCAhPT0gYlZpZXcuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYVZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhVmlld1tpXSAhPT0gYlZpZXdbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHN0YXRpYyBjb25jYXQoLi4uYXJncykge1xuICAgICAgICBsZXQgYnVmZmVycztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkgJiYgIShhcmdzWzFdIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgICBidWZmZXJzID0gYXJnc1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pICYmIGFyZ3NbMV0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgYnVmZmVycyA9IGFyZ3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXJnc1thcmdzLmxlbmd0aCAtIDFdIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBidWZmZXJzID0gYXJncy5zbGljZSgwLCBhcmdzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmZmVycyA9IGFyZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiBidWZmZXJzKSB7XG4gICAgICAgICAgICBzaXplICs9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgYnVmZmVycykge1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IHRoaXMudG9VaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgICAgICByZXMuc2V0KHZpZXcsIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gdmlldy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3NbYXJncy5sZW5ndGggLSAxXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1ZpZXcocmVzLCBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXMuYnVmZmVyO1xuICAgIH1cbn1cblxuY29uc3QgU1RSSU5HX1RZUEUgPSBcInN0cmluZ1wiO1xuY29uc3QgSEVYX1JFR0VYID0gL15bMC05YS1mXFxzXSskL2k7XG5jb25zdCBCQVNFNjRfUkVHRVggPSAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC87XG5jb25zdCBCQVNFNjRVUkxfUkVHRVggPSAvXlthLXpBLVowLTktX10rJC87XG5jbGFzcyBVdGY4Q29udmVydGVyIHtcbiAgICBzdGF0aWMgZnJvbVN0cmluZyh0ZXh0KSB7XG4gICAgICAgIGNvbnN0IHMgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodGV4dCkpO1xuICAgICAgICBjb25zdCB1aW50QXJyYXkgPSBuZXcgVWludDhBcnJheShzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdWludEFycmF5W2ldID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1aW50QXJyYXkuYnVmZmVyO1xuICAgIH1cbiAgICBzdGF0aWMgdG9TdHJpbmcoYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgbGV0IGVuY29kZWRTdHJpbmcgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZW5jb2RlZFN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjb2RlZFN0cmluZyA9IGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoZW5jb2RlZFN0cmluZykpO1xuICAgICAgICByZXR1cm4gZGVjb2RlZFN0cmluZztcbiAgICB9XG59XG5jbGFzcyBVdGYxNkNvbnZlcnRlciB7XG4gICAgc3RhdGljIHRvU3RyaW5nKGJ1ZmZlciwgbGl0dGxlRW5kaWFuID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBCdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihidWZmZXIpO1xuICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgICAgIGxldCByZXMgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5QnVmZmVyLmJ5dGVMZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IGRhdGFWaWV3LmdldFVpbnQxNihpLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcodGV4dCwgbGl0dGxlRW5kaWFuID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IEFycmF5QnVmZmVyKHRleHQubGVuZ3RoICogMik7XG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHJlcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KGkgKiAyLCB0ZXh0LmNoYXJDb2RlQXQoaSksIGxpdHRsZUVuZGlhbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5jbGFzcyBDb252ZXJ0IHtcbiAgICBzdGF0aWMgaXNIZXgoZGF0YSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09IFNUUklOR19UWVBFXG4gICAgICAgICAgICAmJiBIRVhfUkVHRVgudGVzdChkYXRhKTtcbiAgICB9XG4gICAgc3RhdGljIGlzQmFzZTY0KGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSBTVFJJTkdfVFlQRVxuICAgICAgICAgICAgJiYgQkFTRTY0X1JFR0VYLnRlc3QoZGF0YSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0Jhc2U2NFVybChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gU1RSSU5HX1RZUEVcbiAgICAgICAgICAgICYmIEJBU0U2NFVSTF9SRUdFWC50ZXN0KGRhdGEpO1xuICAgIH1cbiAgICBzdGF0aWMgVG9TdHJpbmcoYnVmZmVyLCBlbmMgPSBcInV0ZjhcIikge1xuICAgICAgICBjb25zdCBidWYgPSBCdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIHN3aXRjaCAoZW5jLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ1dGY4XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuVG9VdGY4U3RyaW5nKGJ1Zik7XG4gICAgICAgICAgICBjYXNlIFwiYmluYXJ5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuVG9CaW5hcnkoYnVmKTtcbiAgICAgICAgICAgIGNhc2UgXCJoZXhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5Ub0hleChidWYpO1xuICAgICAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlRvQmFzZTY0KGJ1Zik7XG4gICAgICAgICAgICBjYXNlIFwiYmFzZTY0dXJsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuVG9CYXNlNjRVcmwoYnVmKTtcbiAgICAgICAgICAgIGNhc2UgXCJ1dGYxNmxlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0ZjE2Q29udmVydGVyLnRvU3RyaW5nKGJ1ZiwgdHJ1ZSk7XG4gICAgICAgICAgICBjYXNlIFwidXRmMTZcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ1dGYxNmJlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0ZjE2Q29udmVydGVyLnRvU3RyaW5nKGJ1Zik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0eXBlIG9mIGVuY29kaW5nICcke2VuY30nYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIEZyb21TdHJpbmcoc3RyLCBlbmMgPSBcInV0ZjhcIikge1xuICAgICAgICBpZiAoIXN0cikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGVuYy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwidXRmOFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkZyb21VdGY4U3RyaW5nKHN0cik7XG4gICAgICAgICAgICBjYXNlIFwiYmluYXJ5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuRnJvbUJpbmFyeShzdHIpO1xuICAgICAgICAgICAgY2FzZSBcImhleFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkZyb21IZXgoc3RyKTtcbiAgICAgICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5Gcm9tQmFzZTY0KHN0cik7XG4gICAgICAgICAgICBjYXNlIFwiYmFzZTY0dXJsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuRnJvbUJhc2U2NFVybChzdHIpO1xuICAgICAgICAgICAgY2FzZSBcInV0ZjE2bGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRmMTZDb252ZXJ0ZXIuZnJvbVN0cmluZyhzdHIsIHRydWUpO1xuICAgICAgICAgICAgY2FzZSBcInV0ZjE2XCI6XG4gICAgICAgICAgICBjYXNlIFwidXRmMTZiZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBVdGYxNkNvbnZlcnRlci5mcm9tU3RyaW5nKHN0cik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0eXBlIG9mIGVuY29kaW5nICcke2VuY30nYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIFRvQmFzZTY0KGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBidWYgPSBCdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGlmICh0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgY29uc3QgYmluYXJ5ID0gdGhpcy5Ub1N0cmluZyhidWYsIFwiYmluYXJ5XCIpO1xuICAgICAgICAgICAgcmV0dXJuIGJ0b2EoYmluYXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShidWYpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBGcm9tQmFzZTY0KGJhc2U2NCkge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWQgPSB0aGlzLmZvcm1hdFN0cmluZyhiYXNlNjQpO1xuICAgICAgICBpZiAoIWZvcm1hdHRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUNvbnZlcnQuaXNCYXNlNjQoZm9ybWF0dGVkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50ICdiYXNlNjRUZXh0JyBpcyBub3QgQmFzZTY0IGVuY29kZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhdG9iICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5Gcm9tQmluYXJ5KGF0b2IoZm9ybWF0dGVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmZyb20oZm9ybWF0dGVkLCBcImJhc2U2NFwiKSkuYnVmZmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBGcm9tQmFzZTY0VXJsKGJhc2U2NHVybCkge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWQgPSB0aGlzLmZvcm1hdFN0cmluZyhiYXNlNjR1cmwpO1xuICAgICAgICBpZiAoIWZvcm1hdHRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUNvbnZlcnQuaXNCYXNlNjRVcmwoZm9ybWF0dGVkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50ICdiYXNlNjR1cmwnIGlzIG5vdCBCYXNlNjRVcmwgZW5jb2RlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5Gcm9tQmFzZTY0KHRoaXMuQmFzZTY0UGFkZGluZyhmb3JtYXR0ZWQucmVwbGFjZSgvXFwtL2csIFwiK1wiKS5yZXBsYWNlKC9cXF8vZywgXCIvXCIpKSk7XG4gICAgfVxuICAgIHN0YXRpYyBUb0Jhc2U2NFVybChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLlRvQmFzZTY0KGRhdGEpLnJlcGxhY2UoL1xcKy9nLCBcIi1cIikucmVwbGFjZSgvXFwvL2csIFwiX1wiKS5yZXBsYWNlKC9cXD0vZywgXCJcIik7XG4gICAgfVxuICAgIHN0YXRpYyBGcm9tVXRmOFN0cmluZyh0ZXh0LCBlbmNvZGluZyA9IENvbnZlcnQuREVGQVVMVF9VVEY4X0VOQ09ESU5HKSB7XG4gICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhc2NpaVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkZyb21CaW5hcnkodGV4dCk7XG4gICAgICAgICAgICBjYXNlIFwidXRmOFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBVdGY4Q29udmVydGVyLmZyb21TdHJpbmcodGV4dCk7XG4gICAgICAgICAgICBjYXNlIFwidXRmMTZcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ1dGYxNmJlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0ZjE2Q29udmVydGVyLmZyb21TdHJpbmcodGV4dCk7XG4gICAgICAgICAgICBjYXNlIFwidXRmMTZsZVwiOlxuICAgICAgICAgICAgY2FzZSBcInVzYzJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRmMTZDb252ZXJ0ZXIuZnJvbVN0cmluZyh0ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHR5cGUgb2YgZW5jb2RpbmcgJyR7ZW5jb2Rpbmd9J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBUb1V0ZjhTdHJpbmcoYnVmZmVyLCBlbmNvZGluZyA9IENvbnZlcnQuREVGQVVMVF9VVEY4X0VOQ09ESU5HKSB7XG4gICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhc2NpaVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlRvQmluYXJ5KGJ1ZmZlcik7XG4gICAgICAgICAgICBjYXNlIFwidXRmOFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBVdGY4Q29udmVydGVyLnRvU3RyaW5nKGJ1ZmZlcik7XG4gICAgICAgICAgICBjYXNlIFwidXRmMTZcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ1dGYxNmJlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0ZjE2Q29udmVydGVyLnRvU3RyaW5nKGJ1ZmZlcik7XG4gICAgICAgICAgICBjYXNlIFwidXRmMTZsZVwiOlxuICAgICAgICAgICAgY2FzZSBcInVzYzJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRmMTZDb252ZXJ0ZXIudG9TdHJpbmcoYnVmZmVyLCB0cnVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHR5cGUgb2YgZW5jb2RpbmcgJyR7ZW5jb2Rpbmd9J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBGcm9tQmluYXJ5KHRleHQpIHtcbiAgICAgICAgY29uc3Qgc3RyaW5nTGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdFZpZXcgPSBuZXcgVWludDhBcnJheShzdHJpbmdMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRWaWV3W2ldID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRWaWV3LmJ1ZmZlcjtcbiAgICB9XG4gICAgc3RhdGljIFRvQmluYXJ5KGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBidWYgPSBCdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGxldCByZXMgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBzdGF0aWMgVG9IZXgoYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUgPSBidWZbaV07XG4gICAgICAgICAgICBpZiAoYnl0ZSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiMFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IGJ5dGUudG9TdHJpbmcoMTYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBGcm9tSGV4KGhleFN0cmluZykge1xuICAgICAgICBsZXQgZm9ybWF0dGVkID0gdGhpcy5mb3JtYXRTdHJpbmcoaGV4U3RyaW5nKTtcbiAgICAgICAgaWYgKCFmb3JtYXR0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFDb252ZXJ0LmlzSGV4KGZvcm1hdHRlZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCAnaGV4U3RyaW5nJyBpcyBub3QgSEVYIGVuY29kZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdHRlZC5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWQgPSBgMCR7Zm9ybWF0dGVkfWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZm9ybWF0dGVkLmxlbmd0aCAvIDIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdHRlZC5sZW5ndGg7IGkgPSBpICsgMikge1xuICAgICAgICAgICAgY29uc3QgYyA9IGZvcm1hdHRlZC5zbGljZShpLCBpICsgMik7XG4gICAgICAgICAgICByZXNbaSAvIDJdID0gcGFyc2VJbnQoYywgMTYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXMuYnVmZmVyO1xuICAgIH1cbiAgICBzdGF0aWMgVG9VdGYxNlN0cmluZyhidWZmZXIsIGxpdHRsZUVuZGlhbiA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBVdGYxNkNvbnZlcnRlci50b1N0cmluZyhidWZmZXIsIGxpdHRsZUVuZGlhbik7XG4gICAgfVxuICAgIHN0YXRpYyBGcm9tVXRmMTZTdHJpbmcodGV4dCwgbGl0dGxlRW5kaWFuID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIFV0ZjE2Q29udmVydGVyLmZyb21TdHJpbmcodGV4dCwgbGl0dGxlRW5kaWFuKTtcbiAgICB9XG4gICAgc3RhdGljIEJhc2U2NFBhZGRpbmcoYmFzZTY0KSB7XG4gICAgICAgIGNvbnN0IHBhZENvdW50ID0gNCAtIChiYXNlNjQubGVuZ3RoICUgNCk7XG4gICAgICAgIGlmIChwYWRDb3VudCA8IDQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGJhc2U2NCArPSBcIj1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZTY0O1xuICAgIH1cbiAgICBzdGF0aWMgZm9ybWF0U3RyaW5nKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEucmVwbGFjZSgvW1xcblxcclxcdCBdL2csIFwiXCIpKSB8fCBcIlwiO1xuICAgIH1cbn1cbkNvbnZlcnQuREVGQVVMVF9VVEY4X0VOQ09ESU5HID0gXCJ1dGY4XCI7XG5cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIC4uLnNvdXJjZXMpIHtcbiAgICBjb25zdCByZXMgPSBhcmd1bWVudHNbMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb2JqID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICByZXNbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbWJpbmUoLi4uYnVmKSB7XG4gICAgY29uc3QgdG90YWxCeXRlTGVuZ3RoID0gYnVmLm1hcCgoaXRlbSkgPT4gaXRlbS5ieXRlTGVuZ3RoKS5yZWR1Y2UoKHByZXYsIGN1cikgPT4gcHJldiArIGN1cik7XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxCeXRlTGVuZ3RoKTtcbiAgICBsZXQgY3VycmVudFBvcyA9IDA7XG4gICAgYnVmLm1hcCgoaXRlbSkgPT4gbmV3IFVpbnQ4QXJyYXkoaXRlbSkpLmZvckVhY2goKGFycikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0yIG9mIGFycikge1xuICAgICAgICAgICAgcmVzW2N1cnJlbnRQb3MrK10gPSBpdGVtMjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXMuYnVmZmVyO1xufVxuZnVuY3Rpb24gaXNFcXVhbChieXRlczEsIGJ5dGVzMikge1xuICAgIGlmICghKGJ5dGVzMSAmJiBieXRlczIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGJ5dGVzMS5ieXRlTGVuZ3RoICE9PSBieXRlczIuYnl0ZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGIxID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMxKTtcbiAgICBjb25zdCBiMiA9IG5ldyBVaW50OEFycmF5KGJ5dGVzMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlczEuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChiMVtpXSAhPT0gYjJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IHsgQnVmZmVyU291cmNlQ29udmVydGVyLCBDb252ZXJ0LCBhc3NpZ24sIGNvbWJpbmUsIGlzRXF1YWwgfTtcbiJdLCJuYW1lcyI6WyJBUlJBWV9CVUZGRVJfTkFNRSIsIkJ1ZmZlclNvdXJjZUNvbnZlcnRlciIsImlzQXJyYXlCdWZmZXIiLCJkYXRhIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwidG9BcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwidG9VaW50OEFycmF5Iiwic2xpY2UiLCJ0b1ZpZXciLCJVaW50OEFycmF5IiwidHlwZSIsImNvbnN0cnVjdG9yIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJUeXBlRXJyb3IiLCJpc0J1ZmZlclNvdXJjZSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiaXNFcXVhbCIsImEiLCJiIiwiYVZpZXciLCJiVmlldyIsImxlbmd0aCIsImkiLCJjb25jYXQiLCJhcmdzIiwiYnVmZmVycyIsIkFycmF5IiwiaXNBcnJheSIsIkZ1bmN0aW9uIiwic2l6ZSIsInJlcyIsIm9mZnNldCIsInZpZXciLCJzZXQiLCJTVFJJTkdfVFlQRSIsIkhFWF9SRUdFWCIsIkJBU0U2NF9SRUdFWCIsIkJBU0U2NFVSTF9SRUdFWCIsIlV0ZjhDb252ZXJ0ZXIiLCJmcm9tU3RyaW5nIiwidGV4dCIsInMiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsInVpbnRBcnJheSIsImNoYXJDb2RlQXQiLCJidWYiLCJlbmNvZGVkU3RyaW5nIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZGVjb2RlZFN0cmluZyIsImRlY29kZVVSSUNvbXBvbmVudCIsImVzY2FwZSIsIlV0ZjE2Q29udmVydGVyIiwibGl0dGxlRW5kaWFuIiwiYXJyYXlCdWZmZXIiLCJkYXRhVmlldyIsIkRhdGFWaWV3IiwiY29kZSIsImdldFVpbnQxNiIsInNldFVpbnQxNiIsIkNvbnZlcnQiLCJpc0hleCIsInRlc3QiLCJpc0Jhc2U2NCIsImlzQmFzZTY0VXJsIiwiVG9TdHJpbmciLCJlbmMiLCJ0b0xvd2VyQ2FzZSIsIlRvVXRmOFN0cmluZyIsIlRvQmluYXJ5IiwiVG9IZXgiLCJUb0Jhc2U2NCIsIlRvQmFzZTY0VXJsIiwiRXJyb3IiLCJGcm9tU3RyaW5nIiwic3RyIiwiRnJvbVV0ZjhTdHJpbmciLCJGcm9tQmluYXJ5IiwiRnJvbUhleCIsIkZyb21CYXNlNjQiLCJGcm9tQmFzZTY0VXJsIiwiYnRvYSIsImJpbmFyeSIsIkJ1ZmZlciIsImZyb20iLCJiYXNlNjQiLCJmb3JtYXR0ZWQiLCJmb3JtYXRTdHJpbmciLCJhdG9iIiwiYmFzZTY0dXJsIiwiQmFzZTY0UGFkZGluZyIsInJlcGxhY2UiLCJlbmNvZGluZyIsIkRFRkFVTFRfVVRGOF9FTkNPRElORyIsInN0cmluZ0xlbmd0aCIsInJlc3VsdFZpZXciLCJyZXN1bHQiLCJsZW4iLCJieXRlIiwiaGV4U3RyaW5nIiwiYyIsInBhcnNlSW50IiwiVG9VdGYxNlN0cmluZyIsIkZyb21VdGYxNlN0cmluZyIsInBhZENvdW50IiwiYXNzaWduIiwidGFyZ2V0Iiwic291cmNlcyIsImFyZ3VtZW50cyIsIm9iaiIsInByb3AiLCJjb21iaW5lIiwidG90YWxCeXRlTGVuZ3RoIiwibWFwIiwiaXRlbSIsInJlZHVjZSIsInByZXYiLCJjdXIiLCJjdXJyZW50UG9zIiwiZm9yRWFjaCIsImFyciIsIml0ZW0yIiwiYnl0ZXMxIiwiYnl0ZXMyIiwiYjEiLCJiMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/pvtsutils/build/index.es.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pvtsutils/build/index.es.js":
/*!**************************************************!*\
  !*** ./node_modules/pvtsutils/build/index.es.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BufferSourceConverter: () => (/* binding */ BufferSourceConverter),\n/* harmony export */   Convert: () => (/* binding */ Convert),\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   combine: () => (/* binding */ combine),\n/* harmony export */   isEqual: () => (/* binding */ isEqual)\n/* harmony export */ });\n/*!\n * MIT License\n * \n * Copyright (c) 2017-2024 Peculiar Ventures, LLC\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n * \n */ const ARRAY_BUFFER_NAME = \"[object ArrayBuffer]\";\nclass BufferSourceConverter {\n    static isArrayBuffer(data) {\n        return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;\n    }\n    static toArrayBuffer(data) {\n        if (this.isArrayBuffer(data)) {\n            return data;\n        }\n        if (data.byteLength === data.buffer.byteLength) {\n            return data.buffer;\n        }\n        if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n            return data.buffer;\n        }\n        return this.toUint8Array(data.buffer).slice(data.byteOffset, data.byteOffset + data.byteLength).buffer;\n    }\n    static toUint8Array(data) {\n        return this.toView(data, Uint8Array);\n    }\n    static toView(data, type) {\n        if (data.constructor === type) {\n            return data;\n        }\n        if (this.isArrayBuffer(data)) {\n            return new type(data);\n        }\n        if (this.isArrayBufferView(data)) {\n            return new type(data.buffer, data.byteOffset, data.byteLength);\n        }\n        throw new TypeError(\"The provided value is not of type '(ArrayBuffer or ArrayBufferView)'\");\n    }\n    static isBufferSource(data) {\n        return this.isArrayBufferView(data) || this.isArrayBuffer(data);\n    }\n    static isArrayBufferView(data) {\n        return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);\n    }\n    static isEqual(a, b) {\n        const aView = BufferSourceConverter.toUint8Array(a);\n        const bView = BufferSourceConverter.toUint8Array(b);\n        if (aView.length !== bView.byteLength) {\n            return false;\n        }\n        for(let i = 0; i < aView.length; i++){\n            if (aView[i] !== bView[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static concat(...args) {\n        let buffers;\n        if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {\n            buffers = args[0];\n        } else if (Array.isArray(args[0]) && args[1] instanceof Function) {\n            buffers = args[0];\n        } else {\n            if (args[args.length - 1] instanceof Function) {\n                buffers = args.slice(0, args.length - 1);\n            } else {\n                buffers = args;\n            }\n        }\n        let size = 0;\n        for (const buffer of buffers){\n            size += buffer.byteLength;\n        }\n        const res = new Uint8Array(size);\n        let offset = 0;\n        for (const buffer of buffers){\n            const view = this.toUint8Array(buffer);\n            res.set(view, offset);\n            offset += view.length;\n        }\n        if (args[args.length - 1] instanceof Function) {\n            return this.toView(res, args[args.length - 1]);\n        }\n        return res.buffer;\n    }\n}\nconst STRING_TYPE = \"string\";\nconst HEX_REGEX = /^[0-9a-f\\s]+$/i;\nconst BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;\nconst BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;\nclass Utf8Converter {\n    static fromString(text) {\n        const s = unescape(encodeURIComponent(text));\n        const uintArray = new Uint8Array(s.length);\n        for(let i = 0; i < s.length; i++){\n            uintArray[i] = s.charCodeAt(i);\n        }\n        return uintArray.buffer;\n    }\n    static toString(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        let encodedString = \"\";\n        for(let i = 0; i < buf.length; i++){\n            encodedString += String.fromCharCode(buf[i]);\n        }\n        const decodedString = decodeURIComponent(escape(encodedString));\n        return decodedString;\n    }\n}\nclass Utf16Converter {\n    static toString(buffer, littleEndian = false) {\n        const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);\n        const dataView = new DataView(arrayBuffer);\n        let res = \"\";\n        for(let i = 0; i < arrayBuffer.byteLength; i += 2){\n            const code = dataView.getUint16(i, littleEndian);\n            res += String.fromCharCode(code);\n        }\n        return res;\n    }\n    static fromString(text, littleEndian = false) {\n        const res = new ArrayBuffer(text.length * 2);\n        const dataView = new DataView(res);\n        for(let i = 0; i < text.length; i++){\n            dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);\n        }\n        return res;\n    }\n}\nclass Convert {\n    static isHex(data) {\n        return typeof data === STRING_TYPE && HEX_REGEX.test(data);\n    }\n    static isBase64(data) {\n        return typeof data === STRING_TYPE && BASE64_REGEX.test(data);\n    }\n    static isBase64Url(data) {\n        return typeof data === STRING_TYPE && BASE64URL_REGEX.test(data);\n    }\n    static ToString(buffer, enc = \"utf8\") {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        switch(enc.toLowerCase()){\n            case \"utf8\":\n                return this.ToUtf8String(buf);\n            case \"binary\":\n                return this.ToBinary(buf);\n            case \"hex\":\n                return this.ToHex(buf);\n            case \"base64\":\n                return this.ToBase64(buf);\n            case \"base64url\":\n                return this.ToBase64Url(buf);\n            case \"utf16le\":\n                return Utf16Converter.toString(buf, true);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.toString(buf);\n            default:\n                throw new Error(`Unknown type of encoding '${enc}'`);\n        }\n    }\n    static FromString(str, enc = \"utf8\") {\n        if (!str) {\n            return new ArrayBuffer(0);\n        }\n        switch(enc.toLowerCase()){\n            case \"utf8\":\n                return this.FromUtf8String(str);\n            case \"binary\":\n                return this.FromBinary(str);\n            case \"hex\":\n                return this.FromHex(str);\n            case \"base64\":\n                return this.FromBase64(str);\n            case \"base64url\":\n                return this.FromBase64Url(str);\n            case \"utf16le\":\n                return Utf16Converter.fromString(str, true);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.fromString(str);\n            default:\n                throw new Error(`Unknown type of encoding '${enc}'`);\n        }\n    }\n    static ToBase64(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        if (typeof btoa !== \"undefined\") {\n            const binary = this.ToString(buf, \"binary\");\n            return btoa(binary);\n        } else {\n            return Buffer.from(buf).toString(\"base64\");\n        }\n    }\n    static FromBase64(base64) {\n        const formatted = this.formatString(base64);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isBase64(formatted)) {\n            throw new TypeError(\"Argument 'base64Text' is not Base64 encoded\");\n        }\n        if (typeof atob !== \"undefined\") {\n            return this.FromBinary(atob(formatted));\n        } else {\n            return new Uint8Array(Buffer.from(formatted, \"base64\")).buffer;\n        }\n    }\n    static FromBase64Url(base64url) {\n        const formatted = this.formatString(base64url);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isBase64Url(formatted)) {\n            throw new TypeError(\"Argument 'base64url' is not Base64Url encoded\");\n        }\n        return this.FromBase64(this.Base64Padding(formatted.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\")));\n    }\n    static ToBase64Url(data) {\n        return this.ToBase64(data).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/\\=/g, \"\");\n    }\n    static FromUtf8String(text, encoding = Convert.DEFAULT_UTF8_ENCODING) {\n        switch(encoding){\n            case \"ascii\":\n                return this.FromBinary(text);\n            case \"utf8\":\n                return Utf8Converter.fromString(text);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.fromString(text);\n            case \"utf16le\":\n            case \"usc2\":\n                return Utf16Converter.fromString(text, true);\n            default:\n                throw new Error(`Unknown type of encoding '${encoding}'`);\n        }\n    }\n    static ToUtf8String(buffer, encoding = Convert.DEFAULT_UTF8_ENCODING) {\n        switch(encoding){\n            case \"ascii\":\n                return this.ToBinary(buffer);\n            case \"utf8\":\n                return Utf8Converter.toString(buffer);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.toString(buffer);\n            case \"utf16le\":\n            case \"usc2\":\n                return Utf16Converter.toString(buffer, true);\n            default:\n                throw new Error(`Unknown type of encoding '${encoding}'`);\n        }\n    }\n    static FromBinary(text) {\n        const stringLength = text.length;\n        const resultView = new Uint8Array(stringLength);\n        for(let i = 0; i < stringLength; i++){\n            resultView[i] = text.charCodeAt(i);\n        }\n        return resultView.buffer;\n    }\n    static ToBinary(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        let res = \"\";\n        for(let i = 0; i < buf.length; i++){\n            res += String.fromCharCode(buf[i]);\n        }\n        return res;\n    }\n    static ToHex(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        let result = \"\";\n        const len = buf.length;\n        for(let i = 0; i < len; i++){\n            const byte = buf[i];\n            if (byte < 16) {\n                result += \"0\";\n            }\n            result += byte.toString(16);\n        }\n        return result;\n    }\n    static FromHex(hexString) {\n        let formatted = this.formatString(hexString);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isHex(formatted)) {\n            throw new TypeError(\"Argument 'hexString' is not HEX encoded\");\n        }\n        if (formatted.length % 2) {\n            formatted = `0${formatted}`;\n        }\n        const res = new Uint8Array(formatted.length / 2);\n        for(let i = 0; i < formatted.length; i = i + 2){\n            const c = formatted.slice(i, i + 2);\n            res[i / 2] = parseInt(c, 16);\n        }\n        return res.buffer;\n    }\n    static ToUtf16String(buffer, littleEndian = false) {\n        return Utf16Converter.toString(buffer, littleEndian);\n    }\n    static FromUtf16String(text, littleEndian = false) {\n        return Utf16Converter.fromString(text, littleEndian);\n    }\n    static Base64Padding(base64) {\n        const padCount = 4 - base64.length % 4;\n        if (padCount < 4) {\n            for(let i = 0; i < padCount; i++){\n                base64 += \"=\";\n            }\n        }\n        return base64;\n    }\n    static formatString(data) {\n        return (data === null || data === void 0 ? void 0 : data.replace(/[\\n\\r\\t ]/g, \"\")) || \"\";\n    }\n}\nConvert.DEFAULT_UTF8_ENCODING = \"utf8\";\nfunction assign(target, ...sources) {\n    const res = arguments[0];\n    for(let i = 1; i < arguments.length; i++){\n        const obj = arguments[i];\n        for(const prop in obj){\n            res[prop] = obj[prop];\n        }\n    }\n    return res;\n}\nfunction combine(...buf) {\n    const totalByteLength = buf.map((item)=>item.byteLength).reduce((prev, cur)=>prev + cur);\n    const res = new Uint8Array(totalByteLength);\n    let currentPos = 0;\n    buf.map((item)=>new Uint8Array(item)).forEach((arr)=>{\n        for (const item2 of arr){\n            res[currentPos++] = item2;\n        }\n    });\n    return res.buffer;\n}\nfunction isEqual(bytes1, bytes2) {\n    if (!(bytes1 && bytes2)) {\n        return false;\n    }\n    if (bytes1.byteLength !== bytes2.byteLength) {\n        return false;\n    }\n    const b1 = new Uint8Array(bytes1);\n    const b2 = new Uint8Array(bytes2);\n    for(let i = 0; i < bytes1.byteLength; i++){\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcHZ0c3V0aWxzL2J1aWxkL2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBdUJDLEdBRUQsTUFBTUEsb0JBQW9CO0FBQzFCLE1BQU1DO0lBQ0YsT0FBT0MsY0FBY0MsSUFBSSxFQUFFO1FBQ3ZCLE9BQU9DLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNKLFVBQVVIO0lBQ3BEO0lBQ0EsT0FBT1EsY0FBY0wsSUFBSSxFQUFFO1FBQ3ZCLElBQUksSUFBSSxDQUFDRCxhQUFhLENBQUNDLE9BQU87WUFDMUIsT0FBT0E7UUFDWDtRQUNBLElBQUlBLEtBQUtNLFVBQVUsS0FBS04sS0FBS08sTUFBTSxDQUFDRCxVQUFVLEVBQUU7WUFDNUMsT0FBT04sS0FBS08sTUFBTTtRQUN0QjtRQUNBLElBQUlQLEtBQUtRLFVBQVUsS0FBSyxLQUFLUixLQUFLTSxVQUFVLEtBQUtOLEtBQUtPLE1BQU0sQ0FBQ0QsVUFBVSxFQUFFO1lBQ3JFLE9BQU9OLEtBQUtPLE1BQU07UUFDdEI7UUFDQSxPQUFPLElBQUksQ0FBQ0UsWUFBWSxDQUFDVCxLQUFLTyxNQUFNLEVBQy9CRyxLQUFLLENBQUNWLEtBQUtRLFVBQVUsRUFBRVIsS0FBS1EsVUFBVSxHQUFHUixLQUFLTSxVQUFVLEVBQ3hEQyxNQUFNO0lBQ2Y7SUFDQSxPQUFPRSxhQUFhVCxJQUFJLEVBQUU7UUFDdEIsT0FBTyxJQUFJLENBQUNXLE1BQU0sQ0FBQ1gsTUFBTVk7SUFDN0I7SUFDQSxPQUFPRCxPQUFPWCxJQUFJLEVBQUVhLElBQUksRUFBRTtRQUN0QixJQUFJYixLQUFLYyxXQUFXLEtBQUtELE1BQU07WUFDM0IsT0FBT2I7UUFDWDtRQUNBLElBQUksSUFBSSxDQUFDRCxhQUFhLENBQUNDLE9BQU87WUFDMUIsT0FBTyxJQUFJYSxLQUFLYjtRQUNwQjtRQUNBLElBQUksSUFBSSxDQUFDZSxpQkFBaUIsQ0FBQ2Ys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QyxPQUFPO0lBQ1g7SUFDQSxNQUFNMkgsS0FBSyxJQUFJckgsV0FBV21IO0lBQzFCLE1BQU1HLEtBQUssSUFBSXRILFdBQVdvSDtJQUMxQixJQUFLLElBQUl0RyxJQUFJLEdBQUdBLElBQUlxRyxPQUFPekgsVUFBVSxFQUFFb0IsSUFBSztRQUN4QyxJQUFJdUcsRUFBRSxDQUFDdkcsRUFBRSxLQUFLd0csRUFBRSxDQUFDeEcsRUFBRSxFQUFFO1lBQ2pCLE9BQU87UUFDWDtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBRW9FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2FpZ29ueGFuaC8uL25vZGVfbW9kdWxlcy9wdnRzdXRpbHMvYnVpbGQvaW5kZXguZXMuanM/NGE3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1JVCBMaWNlbnNlXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNy0yMDI0IFBlY3VsaWFyIFZlbnR1cmVzLCBMTENcbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICogXG4gKi9cblxuY29uc3QgQVJSQVlfQlVGRkVSX05BTUUgPSBcIltvYmplY3QgQXJyYXlCdWZmZXJdXCI7XG5jbGFzcyBCdWZmZXJTb3VyY2VDb252ZXJ0ZXIge1xuICAgIHN0YXRpYyBpc0FycmF5QnVmZmVyKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gQVJSQVlfQlVGRkVSX05BTUU7XG4gICAgfVxuICAgIHN0YXRpYyB0b0FycmF5QnVmZmVyKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheUJ1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuYnl0ZUxlbmd0aCA9PT0gZGF0YS5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmJ5dGVPZmZzZXQgPT09IDAgJiYgZGF0YS5ieXRlTGVuZ3RoID09PSBkYXRhLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudG9VaW50OEFycmF5KGRhdGEuYnVmZmVyKVxuICAgICAgICAgICAgLnNsaWNlKGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlT2Zmc2V0ICsgZGF0YS5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgLmJ1ZmZlcjtcbiAgICB9XG4gICAgc3RhdGljIHRvVWludDhBcnJheShkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvVmlldyhkYXRhLCBVaW50OEFycmF5KTtcbiAgICB9XG4gICAgc3RhdGljIHRvVmlldyhkYXRhLCB0eXBlKSB7XG4gICAgICAgIGlmIChkYXRhLmNvbnN0cnVjdG9yID09PSB0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0FycmF5QnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHR5cGUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdHlwZShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgcHJvdmlkZWQgdmFsdWUgaXMgbm90IG9mIHR5cGUgJyhBcnJheUJ1ZmZlciBvciBBcnJheUJ1ZmZlclZpZXcpJ1wiKTtcbiAgICB9XG4gICAgc3RhdGljIGlzQnVmZmVyU291cmNlKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSlcbiAgICAgICAgICAgIHx8IHRoaXMuaXNBcnJheUJ1ZmZlcihkYXRhKTtcbiAgICB9XG4gICAgc3RhdGljIGlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKVxuICAgICAgICAgICAgfHwgKGRhdGEgJiYgdGhpcy5pc0FycmF5QnVmZmVyKGRhdGEuYnVmZmVyKSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0VxdWFsKGEsIGIpIHtcbiAgICAgICAgY29uc3QgYVZpZXcgPSBCdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGEpO1xuICAgICAgICBjb25zdCBiVmlldyA9IEJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoYik7XG4gICAgICAgIGlmIChhVmlldy5sZW5ndGggIT09IGJWaWV3LmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFWaWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYVZpZXdbaV0gIT09IGJWaWV3W2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzdGF0aWMgY29uY2F0KC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IGJ1ZmZlcnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pICYmICEoYXJnc1sxXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgICAgICAgYnVmZmVycyA9IGFyZ3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSAmJiBhcmdzWzFdIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGJ1ZmZlcnMgPSBhcmdzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFyZ3NbYXJncy5sZW5ndGggLSAxXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVycyA9IGFyZ3Muc2xpY2UoMCwgYXJncy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcnMgPSBhcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgYnVmZmVycykge1xuICAgICAgICAgICAgc2l6ZSArPSBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIGJ1ZmZlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLnRvVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICAgICAgcmVzLnNldCh2aWV3LCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHZpZXcubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9WaWV3KHJlcywgYXJnc1thcmdzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzLmJ1ZmZlcjtcbiAgICB9XG59XG5cbmNvbnN0IFNUUklOR19UWVBFID0gXCJzdHJpbmdcIjtcbmNvbnN0IEhFWF9SRUdFWCA9IC9eWzAtOWEtZlxcc10rJC9pO1xuY29uc3QgQkFTRTY0X1JFR0VYID0gL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvO1xuY29uc3QgQkFTRTY0VVJMX1JFR0VYID0gL15bYS16QS1aMC05LV9dKyQvO1xuY2xhc3MgVXRmOENvbnZlcnRlciB7XG4gICAgc3RhdGljIGZyb21TdHJpbmcodGV4dCkge1xuICAgICAgICBjb25zdCBzID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHRleHQpKTtcbiAgICAgICAgY29uc3QgdWludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkocy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHVpbnRBcnJheVtpXSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdWludEFycmF5LmJ1ZmZlcjtcbiAgICB9XG4gICAgc3RhdGljIHRvU3RyaW5nKGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBidWYgPSBCdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGxldCBlbmNvZGVkU3RyaW5nID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGVuY29kZWRTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlY29kZWRTdHJpbmcgPSBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKGVuY29kZWRTdHJpbmcpKTtcbiAgICAgICAgcmV0dXJuIGRlY29kZWRTdHJpbmc7XG4gICAgfVxufVxuY2xhc3MgVXRmMTZDb252ZXJ0ZXIge1xuICAgIHN0YXRpYyB0b1N0cmluZyhidWZmZXIsIGxpdHRsZUVuZGlhbiA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoYnVmZmVyKTtcbiAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICAgICAgICBsZXQgcmVzID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBkYXRhVmlldy5nZXRVaW50MTYoaSwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHRleHQsIGxpdHRsZUVuZGlhbiA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBBcnJheUJ1ZmZlcih0ZXh0Lmxlbmd0aCAqIDIpO1xuICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhyZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihpICogMiwgdGV4dC5jaGFyQ29kZUF0KGkpLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuY2xhc3MgQ29udmVydCB7XG4gICAgc3RhdGljIGlzSGV4KGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSBTVFJJTkdfVFlQRVxuICAgICAgICAgICAgJiYgSEVYX1JFR0VYLnRlc3QoZGF0YSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0Jhc2U2NChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gU1RSSU5HX1RZUEVcbiAgICAgICAgICAgICYmIEJBU0U2NF9SRUdFWC50ZXN0KGRhdGEpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNCYXNlNjRVcmwoZGF0YSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09IFNUUklOR19UWVBFXG4gICAgICAgICAgICAmJiBCQVNFNjRVUkxfUkVHRVgudGVzdChkYXRhKTtcbiAgICB9XG4gICAgc3RhdGljIFRvU3RyaW5nKGJ1ZmZlciwgZW5jID0gXCJ1dGY4XCIpIHtcbiAgICAgICAgY29uc3QgYnVmID0gQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICBzd2l0Y2ggKGVuYy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwidXRmOFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlRvVXRmOFN0cmluZyhidWYpO1xuICAgICAgICAgICAgY2FzZSBcImJpbmFyeVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlRvQmluYXJ5KGJ1Zik7XG4gICAgICAgICAgICBjYXNlIFwiaGV4XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuVG9IZXgoYnVmKTtcbiAgICAgICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5Ub0Jhc2U2NChidWYpO1xuICAgICAgICAgICAgY2FzZSBcImJhc2U2NHVybFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlRvQmFzZTY0VXJsKGJ1Zik7XG4gICAgICAgICAgICBjYXNlIFwidXRmMTZsZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBVdGYxNkNvbnZlcnRlci50b1N0cmluZyhidWYsIHRydWUpO1xuICAgICAgICAgICAgY2FzZSBcInV0ZjE2XCI6XG4gICAgICAgICAgICBjYXNlIFwidXRmMTZiZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBVdGYxNkNvbnZlcnRlci50b1N0cmluZyhidWYpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdHlwZSBvZiBlbmNvZGluZyAnJHtlbmN9J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBGcm9tU3RyaW5nKHN0ciwgZW5jID0gXCJ1dGY4XCIpIHtcbiAgICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChlbmMudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcInV0ZjhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5Gcm9tVXRmOFN0cmluZyhzdHIpO1xuICAgICAgICAgICAgY2FzZSBcImJpbmFyeVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkZyb21CaW5hcnkoc3RyKTtcbiAgICAgICAgICAgIGNhc2UgXCJoZXhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5Gcm9tSGV4KHN0cik7XG4gICAgICAgICAgICBjYXNlIFwiYmFzZTY0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuRnJvbUJhc2U2NChzdHIpO1xuICAgICAgICAgICAgY2FzZSBcImJhc2U2NHVybFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkZyb21CYXNlNjRVcmwoc3RyKTtcbiAgICAgICAgICAgIGNhc2UgXCJ1dGYxNmxlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0ZjE2Q29udmVydGVyLmZyb21TdHJpbmcoc3RyLCB0cnVlKTtcbiAgICAgICAgICAgIGNhc2UgXCJ1dGYxNlwiOlxuICAgICAgICAgICAgY2FzZSBcInV0ZjE2YmVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRmMTZDb252ZXJ0ZXIuZnJvbVN0cmluZyhzdHIpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdHlwZSBvZiBlbmNvZGluZyAnJHtlbmN9J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBUb0Jhc2U2NChidWZmZXIpIHtcbiAgICAgICAgY29uc3QgYnVmID0gQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICBpZiAodHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpbmFyeSA9IHRoaXMuVG9TdHJpbmcoYnVmLCBcImJpbmFyeVwiKTtcbiAgICAgICAgICAgIHJldHVybiBidG9hKGJpbmFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYnVmKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgRnJvbUJhc2U2NChiYXNlNjQpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkID0gdGhpcy5mb3JtYXRTdHJpbmcoYmFzZTY0KTtcbiAgICAgICAgaWYgKCFmb3JtYXR0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFDb252ZXJ0LmlzQmFzZTY0KGZvcm1hdHRlZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCAnYmFzZTY0VGV4dCcgaXMgbm90IEJhc2U2NCBlbmNvZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXRvYiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRnJvbUJpbmFyeShhdG9iKGZvcm1hdHRlZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKGZvcm1hdHRlZCwgXCJiYXNlNjRcIikpLmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgRnJvbUJhc2U2NFVybChiYXNlNjR1cmwpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkID0gdGhpcy5mb3JtYXRTdHJpbmcoYmFzZTY0dXJsKTtcbiAgICAgICAgaWYgKCFmb3JtYXR0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFDb252ZXJ0LmlzQmFzZTY0VXJsKGZvcm1hdHRlZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCAnYmFzZTY0dXJsJyBpcyBub3QgQmFzZTY0VXJsIGVuY29kZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuRnJvbUJhc2U2NCh0aGlzLkJhc2U2NFBhZGRpbmcoZm9ybWF0dGVkLnJlcGxhY2UoL1xcLS9nLCBcIitcIikucmVwbGFjZSgvXFxfL2csIFwiL1wiKSkpO1xuICAgIH1cbiAgICBzdGF0aWMgVG9CYXNlNjRVcmwoZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5Ub0Jhc2U2NChkYXRhKS5yZXBsYWNlKC9cXCsvZywgXCItXCIpLnJlcGxhY2UoL1xcLy9nLCBcIl9cIikucmVwbGFjZSgvXFw9L2csIFwiXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgRnJvbVV0ZjhTdHJpbmcodGV4dCwgZW5jb2RpbmcgPSBDb252ZXJ0LkRFRkFVTFRfVVRGOF9FTkNPRElORykge1xuICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICAgICAgICBjYXNlIFwiYXNjaWlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5Gcm9tQmluYXJ5KHRleHQpO1xuICAgICAgICAgICAgY2FzZSBcInV0ZjhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRmOENvbnZlcnRlci5mcm9tU3RyaW5nKHRleHQpO1xuICAgICAgICAgICAgY2FzZSBcInV0ZjE2XCI6XG4gICAgICAgICAgICBjYXNlIFwidXRmMTZiZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBVdGYxNkNvbnZlcnRlci5mcm9tU3RyaW5nKHRleHQpO1xuICAgICAgICAgICAgY2FzZSBcInV0ZjE2bGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ1c2MyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0ZjE2Q29udmVydGVyLmZyb21TdHJpbmcodGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0eXBlIG9mIGVuY29kaW5nICcke2VuY29kaW5nfSdgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgVG9VdGY4U3RyaW5nKGJ1ZmZlciwgZW5jb2RpbmcgPSBDb252ZXJ0LkRFRkFVTFRfVVRGOF9FTkNPRElORykge1xuICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICAgICAgICBjYXNlIFwiYXNjaWlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5Ub0JpbmFyeShidWZmZXIpO1xuICAgICAgICAgICAgY2FzZSBcInV0ZjhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRmOENvbnZlcnRlci50b1N0cmluZyhidWZmZXIpO1xuICAgICAgICAgICAgY2FzZSBcInV0ZjE2XCI6XG4gICAgICAgICAgICBjYXNlIFwidXRmMTZiZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBVdGYxNkNvbnZlcnRlci50b1N0cmluZyhidWZmZXIpO1xuICAgICAgICAgICAgY2FzZSBcInV0ZjE2bGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ1c2MyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0ZjE2Q29udmVydGVyLnRvU3RyaW5nKGJ1ZmZlciwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0eXBlIG9mIGVuY29kaW5nICcke2VuY29kaW5nfSdgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgRnJvbUJpbmFyeSh0ZXh0KSB7XG4gICAgICAgIGNvbnN0IHN0cmluZ0xlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoc3RyaW5nTGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0Vmlld1tpXSA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0Vmlldy5idWZmZXI7XG4gICAgfVxuICAgIHN0YXRpYyBUb0JpbmFyeShidWZmZXIpIHtcbiAgICAgICAgY29uc3QgYnVmID0gQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICBsZXQgcmVzID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgc3RhdGljIFRvSGV4KGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBidWYgPSBCdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBjb25zdCBsZW4gPSBidWYubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlID0gYnVmW2ldO1xuICAgICAgICAgICAgaWYgKGJ5dGUgPCAxNikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIjBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSBieXRlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgRnJvbUhleChoZXhTdHJpbmcpIHtcbiAgICAgICAgbGV0IGZvcm1hdHRlZCA9IHRoaXMuZm9ybWF0U3RyaW5nKGhleFN0cmluZyk7XG4gICAgICAgIGlmICghZm9ybWF0dGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQ29udmVydC5pc0hleChmb3JtYXR0ZWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgJ2hleFN0cmluZycgaXMgbm90IEhFWCBlbmNvZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXR0ZWQubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgZm9ybWF0dGVkID0gYDAke2Zvcm1hdHRlZH1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGZvcm1hdHRlZC5sZW5ndGggLyAyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXR0ZWQubGVuZ3RoOyBpID0gaSArIDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBmb3JtYXR0ZWQuc2xpY2UoaSwgaSArIDIpO1xuICAgICAgICAgICAgcmVzW2kgLyAyXSA9IHBhcnNlSW50KGMsIDE2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzLmJ1ZmZlcjtcbiAgICB9XG4gICAgc3RhdGljIFRvVXRmMTZTdHJpbmcoYnVmZmVyLCBsaXR0bGVFbmRpYW4gPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gVXRmMTZDb252ZXJ0ZXIudG9TdHJpbmcoYnVmZmVyLCBsaXR0bGVFbmRpYW4pO1xuICAgIH1cbiAgICBzdGF0aWMgRnJvbVV0ZjE2U3RyaW5nKHRleHQsIGxpdHRsZUVuZGlhbiA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBVdGYxNkNvbnZlcnRlci5mcm9tU3RyaW5nKHRleHQsIGxpdHRsZUVuZGlhbik7XG4gICAgfVxuICAgIHN0YXRpYyBCYXNlNjRQYWRkaW5nKGJhc2U2NCkge1xuICAgICAgICBjb25zdCBwYWRDb3VudCA9IDQgLSAoYmFzZTY0Lmxlbmd0aCAlIDQpO1xuICAgICAgICBpZiAocGFkQ291bnQgPCA0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBiYXNlNjQgKz0gXCI9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U2NDtcbiAgICB9XG4gICAgc3RhdGljIGZvcm1hdFN0cmluZyhkYXRhKSB7XG4gICAgICAgIHJldHVybiAoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnJlcGxhY2UoL1tcXG5cXHJcXHQgXS9nLCBcIlwiKSkgfHwgXCJcIjtcbiAgICB9XG59XG5Db252ZXJ0LkRFRkFVTFRfVVRGOF9FTkNPRElORyA9IFwidXRmOFwiO1xuXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCAuLi5zb3VyY2VzKSB7XG4gICAgY29uc3QgcmVzID0gYXJndW1lbnRzWzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgcmVzW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjb21iaW5lKC4uLmJ1Zikge1xuICAgIGNvbnN0IHRvdGFsQnl0ZUxlbmd0aCA9IGJ1Zi5tYXAoKGl0ZW0pID0+IGl0ZW0uYnl0ZUxlbmd0aCkucmVkdWNlKChwcmV2LCBjdXIpID0+IHByZXYgKyBjdXIpO1xuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsQnl0ZUxlbmd0aCk7XG4gICAgbGV0IGN1cnJlbnRQb3MgPSAwO1xuICAgIGJ1Zi5tYXAoKGl0ZW0pID0+IG5ldyBVaW50OEFycmF5KGl0ZW0pKS5mb3JFYWNoKChhcnIpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtMiBvZiBhcnIpIHtcbiAgICAgICAgICAgIHJlc1tjdXJyZW50UG9zKytdID0gaXRlbTI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzLmJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIGlzRXF1YWwoYnl0ZXMxLCBieXRlczIpIHtcbiAgICBpZiAoIShieXRlczEgJiYgYnl0ZXMyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChieXRlczEuYnl0ZUxlbmd0aCAhPT0gYnl0ZXMyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBiMSA9IG5ldyBVaW50OEFycmF5KGJ5dGVzMSk7XG4gICAgY29uc3QgYjIgPSBuZXcgVWludDhBcnJheShieXRlczIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMxLmJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYjFbaV0gIT09IGIyW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCB7IEJ1ZmZlclNvdXJjZUNvbnZlcnRlciwgQ29udmVydCwgYXNzaWduLCBjb21iaW5lLCBpc0VxdWFsIH07XG4iXSwibmFtZXMiOlsiQVJSQVlfQlVGRkVSX05BTUUiLCJCdWZmZXJTb3VyY2VDb252ZXJ0ZXIiLCJpc0FycmF5QnVmZmVyIiwiZGF0YSIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsInRvQXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsInRvVWludDhBcnJheSIsInNsaWNlIiwidG9WaWV3IiwiVWludDhBcnJheSIsInR5cGUiLCJjb25zdHJ1Y3RvciIsImlzQXJyYXlCdWZmZXJWaWV3IiwiVHlwZUVycm9yIiwiaXNCdWZmZXJTb3VyY2UiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImlzRXF1YWwiLCJhIiwiYiIsImFWaWV3IiwiYlZpZXciLCJsZW5ndGgiLCJpIiwiY29uY2F0IiwiYXJncyIsImJ1ZmZlcnMiLCJBcnJheSIsImlzQXJyYXkiLCJGdW5jdGlvbiIsInNpemUiLCJyZXMiLCJvZmZzZXQiLCJ2aWV3Iiwic2V0IiwiU1RSSU5HX1RZUEUiLCJIRVhfUkVHRVgiLCJCQVNFNjRfUkVHRVgiLCJCQVNFNjRVUkxfUkVHRVgiLCJVdGY4Q29udmVydGVyIiwiZnJvbVN0cmluZyIsInRleHQiLCJzIiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJ1aW50QXJyYXkiLCJjaGFyQ29kZUF0IiwiYnVmIiwiZW5jb2RlZFN0cmluZyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImRlY29kZWRTdHJpbmciLCJkZWNvZGVVUklDb21wb25lbnQiLCJlc2NhcGUiLCJVdGYxNkNvbnZlcnRlciIsImxpdHRsZUVuZGlhbiIsImFycmF5QnVmZmVyIiwiZGF0YVZpZXciLCJEYXRhVmlldyIsImNvZGUiLCJnZXRVaW50MTYiLCJzZXRVaW50MTYiLCJDb252ZXJ0IiwiaXNIZXgiLCJ0ZXN0IiwiaXNCYXNlNjQiLCJpc0Jhc2U2NFVybCIsIlRvU3RyaW5nIiwiZW5jIiwidG9Mb3dlckNhc2UiLCJUb1V0ZjhTdHJpbmciLCJUb0JpbmFyeSIsIlRvSGV4IiwiVG9CYXNlNjQiLCJUb0Jhc2U2NFVybCIsIkVycm9yIiwiRnJvbVN0cmluZyIsInN0ciIsIkZyb21VdGY4U3RyaW5nIiwiRnJvbUJpbmFyeSIsIkZyb21IZXgiLCJGcm9tQmFzZTY0IiwiRnJvbUJhc2U2NFVybCIsImJ0b2EiLCJiaW5hcnkiLCJCdWZmZXIiLCJmcm9tIiwiYmFzZTY0IiwiZm9ybWF0dGVkIiwiZm9ybWF0U3RyaW5nIiwiYXRvYiIsImJhc2U2NHVybCIsIkJhc2U2NFBhZGRpbmciLCJyZXBsYWNlIiwiZW5jb2RpbmciLCJERUZBVUxUX1VURjhfRU5DT0RJTkciLCJzdHJpbmdMZW5ndGgiLCJyZXN1bHRWaWV3IiwicmVzdWx0IiwibGVuIiwiYnl0ZSIsImhleFN0cmluZyIsImMiLCJwYXJzZUludCIsIlRvVXRmMTZTdHJpbmciLCJGcm9tVXRmMTZTdHJpbmciLCJwYWRDb3VudCIsImFzc2lnbiIsInRhcmdldCIsInNvdXJjZXMiLCJhcmd1bWVudHMiLCJvYmoiLCJwcm9wIiwiY29tYmluZSIsInRvdGFsQnl0ZUxlbmd0aCIsIm1hcCIsIml0ZW0iLCJyZWR1Y2UiLCJwcmV2IiwiY3VyIiwiY3VycmVudFBvcyIsImZvckVhY2giLCJhcnIiLCJpdGVtMiIsImJ5dGVzMSIsImJ5dGVzMiIsImIxIiwiYjIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pvtsutils/build/index.es.js\n");

/***/ })

};
;